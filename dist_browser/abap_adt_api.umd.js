(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define([], factory);
	else if(typeof exports === 'object')
		exports["abap_adt_api"] = factory();
	else
		root["abap_adt_api"] = factory();
})(this, () => {
return /******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./build/AdtClient.js":
/*!****************************!*\
  !*** ./build/AdtClient.js ***!
  \****************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ADTClient = exports.createSSLConfig = void 0;
const AdtException_1 = __webpack_require__(/*! ./AdtException */ "./build/AdtException.js");
const AdtHTTP_1 = __webpack_require__(/*! ./AdtHTTP */ "./build/AdtHTTP.js");
const api_1 = __webpack_require__(/*! ./api */ "./build/api/index.js");
const utilities_1 = __webpack_require__(/*! ./utilities */ "./build/utilities.js");
const https_1 = __importDefault(__webpack_require__(/*! https */ "./build/browser/node_https.js"));
function createSSLConfig(allowUnauthorized, ca) {
    const httpsAgent = new https_1.default.Agent({
        keepAlive: true,
        ca,
        rejectUnauthorized: !allowUnauthorized // disable CA checks?
    });
    return { httpsAgent };
}
exports.createSSLConfig = createSSLConfig;
class ADTClient {
    get httpClient() {
        return this.h;
    }
    static mainInclude(object, withDefault = true) {
        // packages don't really have any include
        if ((0, api_1.isPackageType)(object.metaData["adtcore:type"]))
            return object.objectUrl;
        if ((0, api_1.isClassStructure)(object)) {
            const mainInclude = object.includes.find(x => x["class:includeType"] === "main");
            const mainLink = mainInclude &&
                (mainInclude.links.find(x => x.type === "text/plain") ||
                    mainInclude.links.find(x => !x.type)); // CDS have no type for the plain text link...
            if (mainLink)
                return (0, utilities_1.followUrl)(object.objectUrl, mainLink.href);
        }
        else {
            const source = object.metaData["abapsource:sourceUri"];
            if (source)
                return (0, utilities_1.followUrl)(object.objectUrl, source);
            const mainLink = object.links.find(x => x.type === "text/plain");
            if (mainLink)
                return (0, utilities_1.followUrl)(object.objectUrl, mainLink.href);
        }
        return withDefault
            ? (0, utilities_1.followUrl)(object.objectUrl, "/source/main")
            : object.objectUrl;
    }
    static classIncludes(clas) {
        const includes = new Map();
        for (const i of clas.includes) {
            const mainLink = i.links.find(x => x.type === "text/plain");
            includes.set(i["class:includeType"], (0, utilities_1.followUrl)(clas.objectUrl, mainLink.href));
        }
        return includes;
    }
    get id() {
        return this.h.id;
    }
    /**
     * Create an ADT client
     *
     * @argument baseUrlOrClient  Base url, i.e. http://vhcalnplci.local:8000
     * @argument username SAP logon user
     * @argument password Password
     * @argument client   Login client (optional)
     * @argument language Language key (optional)
     */
    constructor(baseUrlOrClient, username, password, client = "", language = "", options = {}) {
        this.wrapFetcher = fetcher => {
            let fetchBearer;
            if (this.fetcher)
                return this.fetcher;
            this.fetcher = () => {
                fetchBearer = fetchBearer || fetcher();
                return fetchBearer;
            };
            return this.fetcher;
        };
        this.hasTransportConfig = async () => {
            const collection = await this.findCollectionByUrl("/sap/bc/adt/cts/transportrequests/searchconfiguration/configurations");
            return !!collection;
        };
        this.isProposalMessage = api_1.isProposalMessage;
        if (((0, utilities_1.isString)(baseUrlOrClient) && username && !password))
            throw (0, AdtException_1.adtException)("Invalid ADTClient configuration: url, login and password are required");
        if (username == null)
            username = "";
        if (password == null)
            password = "";
        if (typeof password !== "string")
            password = this.wrapFetcher(password);
        this.options = {
            baseUrlOrClient: baseUrlOrClient,
            username,
            password,
            client,
            language,
            options
        };
        this.h = this.createHttp();
    }
    createHttp() {
        const o = this.options;
        return new AdtHTTP_1.AdtHTTP(o.baseUrlOrClient, o.username, o.password, o.client, o.language, o.options);
    }
    get pIsClone() {
        return this.h.isClone;
    }
    set pIsClone(isClone) {
        this.h.isClone = isClone;
    }
    get statelessClone() {
        if (this.pIsClone)
            return this;
        if (!this.pClone) {
            const pw = this.fetcher || this.password;
            if (!pw)
                throw (0, AdtException_1.adtException)("Not logged in");
            this.pClone = new ADTClient(this.baseUrl, this.username, pw, this.client, this.language, this.options.options);
            this.pClone.pIsClone = true;
        }
        return this.pClone;
    }
    get stateful() {
        return this.h.stateful;
    }
    set stateful(stateful) {
        if (this.pIsClone)
            throw (0, AdtException_1.adtException)("Stateful sessions not allowed in stateless clones");
        this.h.stateful = stateful;
    }
    get loggedin() {
        return this.h.loggedin;
    }
    get isStateful() {
        return this.h.isStateful;
    }
    get csrfToken() {
        return this.h.csrfToken;
    }
    get baseUrl() {
        return this.h.baseURL;
    }
    get client() {
        return this.h.client;
    }
    get language() {
        return this.h.language;
    }
    get username() {
        return this.h.username;
    }
    get password() {
        return this.h.password;
    }
    /**
     * Logs on an ADT server. parameters provided on creation
     */
    login() {
        // if loggedoff create a new client
        if (!this.h.username)
            this.h = this.createHttp();
        return this.h.login();
    }
    /**
     * Logs out current user, clearing cookies
     * NOTE: you won't be able to login again with this client
     *
     * @memberof ADTClient
     */
    logout() {
        return this.h.logout();
    }
    dropSession() {
        return this.h.dropSession();
    }
    get sessionID() {
        const cookies = this.h.ascookies() || "";
        const sc = cookies.split(";").find(c => !!c.match(/SAP_SESSIONID/));
        return sc ? sc.split("=") : "";
    }
    nodeContents(
    // tslint:disable: variable-name
    parent_type, parent_name, user_name, parent_tech_name, rebuild_tree, parentnodes) {
        return (0, api_1.nodeContents)(this.h, parent_type, parent_name, user_name, parent_tech_name, rebuild_tree, parentnodes);
    }
    async reentranceTicket() {
        const response = await this.h.request("/sap/bc/adt/security/reentranceticket");
        return "" + response.body || "";
    }
    transportInfo(objSourceUrl, devClass, operation = "I") {
        return (0, api_1.transportInfo)(this.h, objSourceUrl, devClass, operation);
    }
    createTransport(objSourceUrl, REQUEST_TEXT, DEVCLASS, transportLayer) {
        return (0, api_1.createTransport)(this.h, objSourceUrl, REQUEST_TEXT, DEVCLASS, "I", transportLayer);
    }
    objectStructure(objectUrl, version) {
        return (0, api_1.objectStructure)(this.h, objectUrl, version);
    }
    activate(objectNameOrObjects, objectUrlOrPreauditReq = true, mainInclude, preauditRequested = true) {
        if ((0, utilities_1.isString)(objectNameOrObjects))
            return (0, api_1.activate)(this.h, objectNameOrObjects, objectUrlOrPreauditReq, // validated downstream
            mainInclude, preauditRequested);
        else
            return (0, api_1.activate)(this.h, objectNameOrObjects, objectUrlOrPreauditReq // validated downstream
            );
    }
    inactiveObjects() {
        return (0, api_1.inactiveObjects)(this.h);
    }
    mainPrograms(includeUrl) {
        return (0, api_1.mainPrograms)(this.h, includeUrl);
    }
    lock(objectUrl, accessMode = "MODIFY") {
        return (0, api_1.lock)(this.h, objectUrl, accessMode);
    }
    unLock(objectUrl, lockHandle) {
        return (0, api_1.unLock)(this.h, objectUrl, lockHandle);
    }
    /**
     * Retrieves a resource content (i.e. a program's source code)
     *
     * @param objectSourceUrl Resource URL
     * @param gitUser Username, only used for abapGit objects
     * @param gitPassword password, only used for abapGit objects
     */
    getObjectSource(objectSourceUrl, options) {
        return (0, api_1.getObjectSource)(this.h, objectSourceUrl, options);
    }
    setObjectSource(objectSourceUrl, source, lockHandle, transport) {
        return (0, api_1.setObjectSource)(this.h, objectSourceUrl, source, lockHandle, transport);
    }
    /**
     * Search object by name pattern
     *
     * @param {string} query     case sensitive in older systems, no wildcard added
     * @param {string} [objType] if passed, only the first part is used i.e. PROG rather than PROG/P
     * @param {number} [max=100] max number of results
     * @returns
     * @memberof ADTClient
     */
    searchObject(query, objType, max = 100) {
        return (0, api_1.searchObject)(this.h, query, objType, max);
    }
    findObjectPath(objectUrl) {
        return (0, api_1.findObjectPath)(this.h, objectUrl);
    }
    validateNewObject(options) {
        return (0, api_1.validateNewObject)(this.h, options);
    }
    createObject(optionsOrType, name, parentName, description, parentPath, responsible = "", transport = "") {
        if ((0, api_1.isCreatableTypeId)(optionsOrType)) {
            if (!name || !parentName || !parentPath || !description)
                throw (0, AdtException_1.adtException)("");
            return (0, api_1.createObject)(this.h, {
                description,
                name,
                objtype: optionsOrType,
                parentName,
                parentPath,
                responsible,
                transport
            });
        }
        else
            return (0, api_1.createObject)(this.h, optionsOrType);
    }
    async featureDetails(title) {
        if (!this.discovery)
            this.discovery = await this.adtDiscovery();
        return this.discovery.find(d => d.title === title);
    }
    async collectionFeatureDetails(url) {
        if (!this.discovery)
            this.discovery = await this.adtDiscovery();
        return this.discovery.find(f => f.collection.find(c => c.templateLinks.find(l => l.template === url)));
    }
    async findCollectionByUrl(url) {
        if (!this.discovery)
            this.discovery = await this.adtDiscovery();
        for (const discoveryResult of this.discovery) {
            const collection = discoveryResult.collection.find(c => c.href === url);
            if (collection)
                return { discoveryResult, collection };
        }
    }
    createTestInclude(clas, lockHandle, transport = "") {
        return (0, api_1.createTestInclude)(this.h, clas, lockHandle, transport);
    }
    objectRegistrationInfo(objectUrl) {
        return (0, api_1.objectRegistrationInfo)(this.h, objectUrl);
    }
    deleteObject(objectUrl, lockHandle, transport) {
        return (0, api_1.deleteObject)(this.h, objectUrl, lockHandle, transport);
    }
    loadTypes() {
        return (0, api_1.loadTypes)(this.h);
    }
    adtDiscovery() {
        return (0, api_1.adtDiscovery)(this.h);
    }
    adtCoreDiscovery() {
        return (0, api_1.adtCoreDiscovery)(this.h);
    }
    adtCompatibiliyGraph() {
        return (0, api_1.adtCompatibilityGraph)(this.h);
    }
    syntaxCheckTypes() {
        return (0, api_1.syntaxCheckTypes)(this.h);
    }
    syntaxCheck(url, mainUrl, content, mainProgram = "", version = "active") {
        if (url.match(/^\/sap\/bc\/adt\/((ddic\/ddlx?)|(acm\/dcl))\/sources\//))
            return (0, api_1.syntaxCheckCDS)(this.h, url, mainUrl, content);
        else {
            if (!mainUrl || !content)
                throw (0, AdtException_1.adtException)("mainUrl and content are required for syntax check");
            return (0, api_1.syntaxCheck)(this.h, url, mainUrl, content, mainProgram, version);
        }
    }
    codeCompletion(sourceUrl, source, line, column) {
        return (0, api_1.codeCompletion)(this.h, sourceUrl, source, line, column);
    }
    codeCompletionFull(sourceUrl, source, line, column, patternKey) {
        return (0, api_1.codeCompletionFull)(this.h, sourceUrl, source, line, column, patternKey);
    }
    async runClass(className) {
        const response = await this.h.request("/sap/bc/adt/oo/classrun/" + className.toUpperCase(), {
            method: "POST"
        });
        return "" + response.body;
    }
    /**
     * Read code completion elements
     * Will fail on older systems where this returns HTML fragments rather than XML
     *
     * @param {string} sourceUrl
     * @param {string} source
     * @param {number} line
     * @param {number} column
     * @returns
     * @memberof ADTClient
     */
    codeCompletionElement(sourceUrl, source, line, column) {
        return (0, api_1.codeCompletionElement)(this.h, sourceUrl, source, line, column);
    }
    findDefinition(url, source, line, startCol, endCol, implementation = false, mainProgram = "") {
        return (0, api_1.findDefinition)(this.h, url, source, line, startCol, endCol, implementation, mainProgram);
    }
    usageReferences(url, line, column) {
        return (0, api_1.usageReferences)(this.h, url, line, column);
    }
    usageReferenceSnippets(references) {
        return (0, api_1.usageReferenceSnippets)(this.h, references);
    }
    fixProposals(url, source, line, column) {
        return (0, api_1.fixProposals)(this.h, url, source, line, column);
    }
    fixEdits(proposal, source) {
        return (0, api_1.fixEdits)(this.h, proposal, source);
    }
    unitTestRun(url, flags = api_1.DefaultUnitTestRunFlags) {
        return (0, api_1.runUnitTest)(this.h, url, flags);
    }
    unitTestEvaluation(clas, flags = api_1.DefaultUnitTestRunFlags) {
        return (0, api_1.unitTestEvaluation)(this.h, clas, flags);
    }
    unitTestOccurrenceMarkers(url, source) {
        return (0, api_1.unitTestOccurrenceMarkers)(this.h, url, source);
    }
    classComponents(url) {
        return (0, api_1.classComponents)(this.h, url);
    }
    fragmentMappings(url, type, name) {
        return (0, api_1.fragmentMappings)(this.h, url, type, name);
    }
    objectTypes() {
        return (0, api_1.objectTypes)(this.h);
    }
    prettyPrinterSetting() {
        return (0, api_1.prettyPrinterSetting)(this.h);
    }
    setPrettyPrinterSetting(indent, style) {
        return (0, api_1.setPrettyPrinterSetting)(this.h, indent, style);
    }
    prettyPrinter(source) {
        return (0, api_1.prettyPrinter)(this.h, source);
    }
    typeHierarchy(url, body, line, offset, superTypes = false) {
        return (0, api_1.typeHierarchy)(this.h, url, body, line, offset, superTypes);
    }
    transportConfigurations() {
        return (0, api_1.transportConfigurations)(this.h);
    }
    getTransportConfiguration(url) {
        return (0, api_1.getTransportConfiguration)(this.h, url);
    }
    setTransportsConfig(uri, etag, config) {
        return (0, api_1.setTransportsConfig)(this.h, uri, etag, config);
    }
    createTransportsConfig() {
        return (0, api_1.createTransportsConfig)(this.h);
    }
    userTransports(user, targets = true) {
        return (0, api_1.userTransports)(this.h, user, targets);
    }
    transportsByConfig(configUri, targets = true) {
        return (0, api_1.transportsByConfig)(this.h, configUri, targets);
    }
    transportDelete(transportNumber) {
        return (0, api_1.transportDelete)(this.h, transportNumber);
    }
    transportRelease(transportNumber, ignoreLocks = false, IgnoreATC = false) {
        return (0, api_1.transportRelease)(this.h, transportNumber, ignoreLocks, IgnoreATC);
    }
    transportSetOwner(transportNumber, targetuser) {
        return (0, api_1.transportSetOwner)(this.h, transportNumber, targetuser);
    }
    transportAddUser(transportNumber, user) {
        return (0, api_1.transportAddUser)(this.h, transportNumber, user);
    }
    systemUsers() {
        return (0, api_1.systemUsers)(this.h);
    }
    transportReference(pgmid, obj_wbtype, obj_name, tr_number = "") {
        return (0, api_1.transportReference)(this.h, pgmid, obj_wbtype, obj_name, tr_number);
    }
    revisions(objectUrl, clsInclude) {
        return (0, api_1.revisions)(this.h, objectUrl, clsInclude);
    }
    abapDocumentation(objectUri, body, line, column, language = "EN") {
        return (0, api_1.abapDocumentation)(this.h, objectUri, body, line, column, language);
    }
    packageSearchHelp(type, name = "*") {
        return (0, api_1.packageSearchHelp)(this.h, type, name);
    }
    gitRepos() {
        return (0, api_1.gitRepos)(this.h);
    }
    gitExternalRepoInfo(repourl, user = "", password = "") {
        return (0, api_1.externalRepoInfo)(this.h, repourl, user, password);
    }
    gitCreateRepo(packageName, repourl, branch = "refs/heads/master", transport = "", user = "", password = "") {
        return (0, api_1.createRepo)(this.h, packageName, repourl, branch, transport, user, password);
    }
    gitPullRepo(repoId, branch = "refs/heads/master", transport = "", user = "", password = "") {
        return (0, api_1.pullRepo)(this.h, repoId, branch, transport, user, password);
    }
    gitUnlinkRepo(repoId) {
        return (0, api_1.unlinkRepo)(this.h, repoId);
    }
    stageRepo(repo, user = "", password = "") {
        return (0, api_1.stageRepo)(this.h, repo, user, password);
    }
    pushRepo(repo, staging, user = "", password = "") {
        return (0, api_1.pushRepo)(this.h, repo, staging, user, password);
    }
    checkRepo(repo, user = "", password = "") {
        return (0, api_1.checkRepo)(this.h, repo, user, password);
    }
    /**
     * @deprecated since 1.2.1, duplicate of gitExternalRepoInfo
     */
    remoteRepoInfo(repo, user = "", password = "") {
        return (0, api_1.remoteRepoInfo)(this.h, repo, user, password);
    }
    switchRepoBranch(repo, branch, create = false, user = "", password = "") {
        return (0, api_1.switchRepoBranch)(this.h, repo, branch, create, user, password);
    }
    annotationDefinitions() {
        return (0, api_1.annotationDefinitions)(this.h);
    }
    ddicElement(path, getTargetForAssociation = false, getExtensionViews = true, getSecondaryObjects = true) {
        return (0, api_1.ddicElement)(this.h, path, getTargetForAssociation, getExtensionViews, getSecondaryObjects);
    }
    ddicRepositoryAccess(path) {
        return (0, api_1.ddicRepositoryAccess)(this.h, path);
    }
    publishServiceBinding(name, version) {
        return (0, api_1.publishServiceBinding)(this.h, name, version);
    }
    unPublishServiceBinding(name, version) {
        return (0, api_1.unpublishServiceBinding)(this.h, name, version);
    }
    /** Reads table data - usually returns one line more than requested */
    tableContents(ddicEntityName, rowNumber = 100, decode = true, sqlQuery = "") {
        return (0, api_1.tableContents)(this.h, ddicEntityName, rowNumber, decode, sqlQuery);
    }
    /** Runs a given SQL query on the target */
    runQuery(sqlQuery, rowNumber = 100, decode = true) {
        return (0, api_1.runQuery)(this.h, sqlQuery, rowNumber, decode);
    }
    bindingDetails(binding, index = 0) {
        return (0, api_1.bindingDetails)(this.h, binding, index);
    }
    feeds() {
        return (0, api_1.feeds)(this.h);
    }
    dumps(query) {
        return (0, api_1.dumps)(this.h, query);
    }
    debuggerListeners(debuggingMode, terminalId, ideId, user, checkConflict = true) {
        return (0, api_1.debuggerListeners)(this.h, debuggingMode, terminalId, ideId, user, checkConflict);
    }
    debuggerListen(debuggingMode, terminalId, ideId, user, checkConflict = true, isNotifiedOnConflict = true) {
        return (0, api_1.debuggerListen)(this.h, debuggingMode, terminalId, ideId, user, checkConflict, isNotifiedOnConflict);
    }
    debuggerDeleteListener(debuggingMode, terminalId, ideId, user) {
        return (0, api_1.debuggerDeleteListener)(this.h, debuggingMode, terminalId, ideId, user);
    }
    debuggerSetBreakpoints(debuggingMode, terminalId, ideId, clientId, breakpoints, user, scope = "external", systemDebugging = false, deactivated = false, syncScupeUrl = "") {
        return (0, api_1.debuggerSetBreakpoints)(this.h, debuggingMode, terminalId, ideId, clientId, breakpoints, user, scope, systemDebugging, deactivated, syncScupeUrl);
    }
    debuggerDeleteBreakpoints(breakpoint, debuggingMode, terminalId, ideId, requestUser, scope = "external") {
        return (0, api_1.debuggerDeleteBreakpoints)(this.h, breakpoint, debuggingMode, terminalId, ideId, requestUser, scope);
    }
    debuggerAttach(debuggingMode, debuggeeId, user, dynproDebugging = false) {
        return (0, api_1.debuggerAttach)(this.h, debuggingMode, debuggeeId, user, dynproDebugging);
    }
    debuggerSaveSettings(settings) {
        return (0, api_1.debuggerSaveSettings)(this.h, settings);
    }
    async debuggerStackTrace(semanticURIs = true) {
        const stack = await this.collectionFeatureDetails("/sap/bc/adt/debugger/stack");
        if (stack)
            return (0, api_1.debuggerStack)(this.h, semanticURIs);
        else
            return (0, api_1.simpleDebuggerStack)(this.h, semanticURIs);
    }
    debuggerVariables(parents) {
        return (0, api_1.debuggerVariables)(this.h, parents);
    }
    debuggerChildVariables(parent = ["@DATAAGING", "@ROOT"]) {
        return (0, api_1.debuggerChildVariables)(this.h, parent);
    }
    debuggerStep(steptype, url) {
        return (0, api_1.debuggerStep)(this.h, steptype, url);
    }
    /**
     * Go to stack entry
     *
     * @param urlOrPosition The stack entry stackUri in newer systems, the stack id in older ones that return a DebugStackSimple
     */
    debuggerGoToStack(urlOrPosition) {
        if ((0, utilities_1.isString)(urlOrPosition))
            return (0, api_1.debuggerGoToStack)(this.h, urlOrPosition);
        else
            return (0, api_1.debuggerGoToStackOld)(this.h, urlOrPosition);
    }
    debuggerSetVariableValue(variableName, value) {
        return (0, api_1.debuggerSetVariableValue)(this.h, variableName, value);
    }
    renameEvaluate(uri, line, startColumn, endColumn) {
        return (0, api_1.renameEvaluate)(this.h, uri, line, startColumn, endColumn);
    }
    renamePreview(renameRefactoring, transport = "") {
        return (0, api_1.renamePreview)(this.h, renameRefactoring, transport);
    }
    renameExecute(refactoring) {
        return (0, api_1.renameExecute)(this.h, refactoring);
    }
    atcCustomizing() {
        return (0, api_1.atcCustomizing)(this.h);
    }
    atcCheckVariant(variant) {
        return (0, api_1.atcCheckVariant)(this.h, variant);
    }
    createAtcRun(variant, mainUrl, maxResults = 100) {
        return (0, api_1.createAtcRun)(this.h, variant, mainUrl, maxResults);
    }
    atcWorklists(runResultId, timestamp, usedObjectSet, includeExempted = false) {
        return (0, api_1.atcWorklists)(this.h, runResultId, timestamp, usedObjectSet, includeExempted);
    }
    atcUsers() {
        return (0, api_1.atcUsers)(this.h);
    }
    atcExemptProposal(markerId) {
        return (0, api_1.atcExemptProposal)(this.h, markerId);
    }
    atcRequestExemption(proposal) {
        return (0, api_1.atcRequestExemption)(this.h, proposal);
    }
    atcContactUri(findingUri) {
        return (0, api_1.atcContactUri)(this.h, findingUri);
    }
    atcChangeContact(itemUri, userId) {
        return (0, api_1.atcChangeContact)(this.h, itemUri, userId);
    }
    tracesList(user) {
        return (0, api_1.tracesList)(this.h, user || this.username);
    }
    tracesListRequests(user) {
        return (0, api_1.tracesListRequests)(this.h, user || this.username);
    }
    tracesHitList(id, withSystemEvents = false) {
        return (0, api_1.tracesHitList)(this.h, id, withSystemEvents);
    }
    tracesDbAccess(id, withSystemEvents = false) {
        return (0, api_1.tracesDbAccess)(this.h, id, withSystemEvents);
    }
    tracesStatements(id, options = {}) {
        return (0, api_1.tracesStatements)(this.h, id, options);
    }
    tracesSetParameters(parameters) {
        return (0, api_1.tracesSetParameters)(this.h, parameters);
    }
    tracesCreateConfiguration(config) {
        return (0, api_1.tracesCreateConfiguration)(this.h, config);
    }
    tracesDeleteConfiguration(id) {
        return (0, api_1.tracesDeleteConfiguration)(this.h, id);
    }
    tracesDelete(id) {
        return (0, api_1.tracesDelete)(this.h, id);
    }
    extractMethodEvaluate(uri, range) {
        return (0, api_1.extractMethodEvaluate)(this.h, uri, range);
    }
    extractMethodPreview(proposal) {
        return (0, api_1.extractMethodPreview)(this.h, proposal);
    }
    extractMethodExecute(refactoring) {
        return (0, api_1.extractMethodExecute)(this.h, refactoring);
    }
}
exports.ADTClient = ADTClient;


/***/ }),

/***/ "./build/AdtException.js":
/*!*******************************!*\
  !*** ./build/AdtException.js ***!
  \*******************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.isErrorMessageType = exports.validateParseResult = exports.ValidateStateful = exports.ValidateObjectUrl = exports.adtException = exports.fromException = exports.fromError = exports.fromResponse = exports.isLoginError = exports.isAdtException = exports.isHttpError = exports.isCsrfError = exports.isAdtError = exports.AdtErrorException = exports.SAPRC = void 0;
const utilities_1 = __webpack_require__(/*! ./utilities */ "./build/utilities.js");
const axios_1 = __importDefault(__webpack_require__(/*! axios */ "./build/build/axios.js"));
const These_1 = __webpack_require__(/*! fp-ts/lib/These */ "./node_modules/fp-ts/lib/These.js");
const io_ts_reporters_1 = __importDefault(__webpack_require__(/*! io-ts-reporters */ "./node_modules/io-ts-reporters/target/src/index.js"));
const ADTEXTYPEID = Symbol.for("ADT EXCEPTION");
const CSRFEXTYPEID = Symbol.for("BAD CSRF");
const HTTPEXTYPEID = Symbol.for("HTTP EXCEPTION");
var SAPRC;
(function (SAPRC) {
    SAPRC["Success"] = "S";
    SAPRC["Info"] = "I";
    SAPRC["Warning"] = "W";
    SAPRC["Error"] = "E";
    SAPRC["CriticalError"] = "A";
    SAPRC["Exception"] = "X";
})(SAPRC = exports.SAPRC || (exports.SAPRC = {}));
const isResponse = (r) => (0, utilities_1.isObject)(r) && !!(r === null || r === void 0 ? void 0 : r.status) && (0, utilities_1.isString)(r === null || r === void 0 ? void 0 : r.statusText);
class AdtErrorException extends Error {
    get typeID() {
        return ADTEXTYPEID;
    }
    static create(errOrResponse, properties, type, message, parent, namespace, localizedMessage, response) {
        if (!(0, utilities_1.isNumber)(errOrResponse)) {
            return this.create(errOrResponse.status, properties, "", errOrResponse.statusText || "Unknown error in adt client", undefined, undefined, undefined, errOrResponse);
        }
        else {
            return new AdtErrorException(errOrResponse, properties, type, message, parent, namespace, localizedMessage, response);
        }
    }
    constructor(err, properties, type, message, parent, namespace, localizedMessage, response) {
        super();
        this.err = err;
        this.properties = properties;
        this.type = type;
        this.message = message;
        this.parent = parent;
        this.namespace = namespace;
        this.localizedMessage = localizedMessage;
        this.response = response;
    }
}
exports.AdtErrorException = AdtErrorException;
// tslint:disable-next-line:max-classes-per-file
class AdtCsrfException extends Error {
    get typeID() {
        return CSRFEXTYPEID;
    }
    constructor(message, parent) {
        super();
        this.message = message;
        this.parent = parent;
    }
}
// tslint:disable-next-line:max-classes-per-file
class AdtHttpException extends Error {
    get typeID() {
        return HTTPEXTYPEID;
    }
    get code() {
        const p = this.parent;
        return (p.response && p.response.status) || 0;
    }
    get message() {
        return this.parent.message;
    }
    get name() {
        return this.parent.name;
    }
    constructor(parent) {
        super();
        this.parent = parent;
    }
}
function isAdtError(e) {
    return (e === null || e === void 0 ? void 0 : e.typeID) === ADTEXTYPEID;
}
exports.isAdtError = isAdtError;
function isCsrfError(e) {
    return (e === null || e === void 0 ? void 0 : e.typeID) === CSRFEXTYPEID;
}
exports.isCsrfError = isCsrfError;
function isHttpError(e) {
    return (e === null || e === void 0 ? void 0 : e.typeID) === HTTPEXTYPEID;
}
exports.isHttpError = isHttpError;
function isAdtException(e) {
    return isAdtError(e) || isCsrfError(e) || isHttpError(e);
}
exports.isAdtException = isAdtException;
const isLoginError = (adtErr) => (isHttpError(adtErr) && adtErr.code === 401) || isCsrfError(adtErr);
exports.isLoginError = isLoginError;
const simpleError = (response) => adtException(`Error ${response.status}:${response.statusText}`, response.status);
const isCsrfException = (r) => (r.status === 403 && r.headers["x-csrf-token"] === "Required") ||
    (r.status === 400 && r.statusText === "Session timed out"); // hack to get login refresh to work on expired sessions
const fromResponse = (data, response) => {
    if (!data)
        return simpleError(response);
    if (data.match(/CSRF/))
        return new AdtCsrfException(data);
    const raw = (0, utilities_1.fullParse)(data);
    const root = raw["exc:exception"];
    if (!root && response.status === 401)
        return simpleError(response);
    const getf = (base, idx) => (base ? base[idx] : "");
    const properties = {};
    (0, utilities_1.xmlArray)(root, "properties", "entry").forEach((p) => {
        properties[p["@_key"]] = `${p["#text"]}`
            .replace(/^\s+/, "")
            .replace(/\s+$/, "");
    });
    return new AdtErrorException(response.status, properties, root.type["@_id"], root.message["#text"], undefined, getf(root.namespace, "@_id"), getf(root.localizedMessage, "#text"));
};
exports.fromResponse = fromResponse;
const axiosErrorBody = (e) => { var _a; return ((_a = e.response) === null || _a === void 0 ? void 0 : _a.data) ? `${e.response.data}` : ""; };
const fromError = (error) => {
    try {
        if (isAdtError(error))
            return error;
        if (axios_1.default.isAxiosError(error) && error.response) {
            if (error.status === 401)
                return new AdtHttpException(error);
            return (0, exports.fromResponse)(axiosErrorBody(error), error.response);
        }
        if ((0, utilities_1.isObject)(error) && "message" in error && (0, utilities_1.isString)(error === null || error === void 0 ? void 0 : error.message))
            return new AdtErrorException(500, {}, "", error.message);
    }
    catch (error) { }
    return AdtErrorException.create(500, {}, "Unknown error", `${error}`); // hopefully will never happen
};
exports.fromError = fromError;
function fromExceptionOrResponse_int(errOrResp, config) {
    try {
        if (isResponse(errOrResp))
            return (0, exports.fromResponse)(errOrResp.body, errOrResp);
        else
            return (0, exports.fromError)(errOrResp);
    }
    catch (e) {
        return isResponse(errOrResp)
            ? AdtErrorException.create(errOrResp, {})
            : (0, exports.fromError)(e);
    }
}
function fromException(errOrResp, config) {
    if (isAdtException(errOrResp))
        return errOrResp;
    if (!isResponse(errOrResp) &&
        (!(0, utilities_1.isNativeError)(errOrResp) ||
            ((0, utilities_1.isNativeError)(errOrResp) && !axios_1.default.isAxiosError(errOrResp))))
        return AdtErrorException.create(500, {}, "Unknown error", `${errOrResp}`); // hopefully will never happen
    return fromExceptionOrResponse_int(errOrResp, config);
}
exports.fromException = fromException;
function adtException(message, number = 0) {
    return new AdtErrorException(number, {}, "", message);
}
exports.adtException = adtException;
function ValidateObjectUrl(url) {
    if (url.match(/^\/sap\/bc\/adt\/[a-z]+\/[a-zA-Z%\$]?[\w%]+/))
        return; // valid
    throw new AdtErrorException(0, {}, "BADOBJECTURL", "Invalid Object URL:" + url);
}
exports.ValidateObjectUrl = ValidateObjectUrl;
function ValidateStateful(h) {
    if (h.isStateful)
        return;
    throw new AdtErrorException(0, {}, "STATELESS", "This operation can only be performed in stateful mode");
}
exports.ValidateStateful = ValidateStateful;
const validateParseResult = (parseResult) => {
    if ((0, These_1.isLeft)(parseResult)) {
        const messages = io_ts_reporters_1.default.report(parseResult);
        throw adtException(messages.slice(0, 3).join("\n"));
    }
    return parseResult.right;
};
exports.validateParseResult = validateParseResult;
const isErrorMessageType = (x) => !!`${x}`.match(/^[EAX]$/i);
exports.isErrorMessageType = isErrorMessageType;


/***/ }),

/***/ "./build/AdtHTTP.js":
/*!**************************!*\
  !*** ./build/AdtHTTP.js ***!
  \**************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.AdtHTTP = exports.AxiosHttpClient = exports.session_types = void 0;
const axios_1 = __importStar(__webpack_require__(/*! axios */ "./build/build/axios.js"));
const AdtException_1 = __webpack_require__(/*! ./AdtException */ "./build/AdtException.js");
const _1 = __webpack_require__(/*! . */ "./build/index.js");
const requestLogger_1 = __webpack_require__(/*! ./requestLogger */ "./build/requestLogger.js");
const utilities_1 = __webpack_require__(/*! ./utilities */ "./build/utilities.js");
const FETCH_CSRF_TOKEN = "fetch";
const CSRF_TOKEN_HEADER = "x-csrf-token";
const SESSION_HEADER = "X-sap-adt-sessiontype";
const runningInNode = typeof process !== "undefined" &&
    process.versions != null &&
    process.versions.node != null;
let lastClientId = 0;
var session_types;
(function (session_types) {
    session_types["stateful"] = "stateful";
    session_types["stateless"] = "stateless";
    session_types["keep"] = "";
})(session_types = exports.session_types || (exports.session_types = {}));
const toAxiosConfig = (options) => {
    const config = {
        method: options.method || "GET",
        url: options.url,
        headers: options.headers || {},
        params: options.qs,
        httpsAgent: options.httpsAgent,
        timeout: options.timeout,
        auth: options.auth,
        data: options.body,
        adtRequestNumber: options.adtRequestNumber,
        adtStartTime: options.adtStartTime
    };
    return config;
};
let adtRequestNumber = 0;
const convertheaders = (raw) => {
    if (raw instanceof axios_1.AxiosHeaders)
        return raw;
    const headers = new axios_1.AxiosHeaders();
    for (const k in Object.keys(raw))
        headers.set(k, raw[k]);
    return headers;
};
class AxiosHttpClient {
    constructor(baseURL, config) {
        this.baseURL = baseURL;
        const conf = toAxiosConfig({ ...config });
        this.axios = axios_1.default.create({ ...conf, baseURL });
    }
    async request(options) {
        try {
            const config = toAxiosConfig(options);
            const { data, headers, ...rest } = await this.axios.request(config);
            const body = data ? ((0, utilities_1.isString)(data) ? data : `${data}`) : "";
            return { body, headers: convertheaders(headers), ...rest };
        }
        catch (error) {
            throw (0, _1.fromError)(error);
        }
    }
}
exports.AxiosHttpClient = AxiosHttpClient;
class AdtHTTP {
    get isStateful() {
        return (this.stateful === session_types.stateful ||
            (this.stateful === session_types.keep &&
                this.currentSession === session_types.stateful));
    }
    get stateful() {
        return this._stateful;
    }
    set stateful(value) {
        this._stateful = value;
        if (value !== session_types.keep)
            this.currentSession = value;
    }
    get csrfToken() {
        return this.commonHeaders[CSRF_TOKEN_HEADER] || FETCH_CSRF_TOKEN;
    }
    set csrfToken(token) {
        this.commonHeaders[CSRF_TOKEN_HEADER] = token;
    }
    get loggedin() {
        return this.csrfToken !== FETCH_CSRF_TOKEN;
    }
    constructor(baseURLOrClient, username, password, client, language, config) {
        this.username = username;
        this.client = client;
        this.language = language;
        this.isClone = false;
        this.currentSession = session_types.stateless;
        this._stateful = session_types.stateless;
        this.needKeepalive = false;
        this.cookie = new Map();
        this.keep_session = async () => {
            if (this.needKeepalive && this.loggedin)
                await this._request("/sap/bc/adt/compatibility/graph", {}).catch(() => { });
            this.needKeepalive = true;
        };
        if ((0, utilities_1.isString)(baseURLOrClient) && username && !password)
            throw (0, _1.adtException)("Invalid ADTClient configuration: url, login and password are required");
        this.baseURL = (0, utilities_1.isString)(baseURLOrClient) ? baseURLOrClient : "";
        this.id = lastClientId++;
        if ((0, utilities_1.isString)(password))
            this.password = password;
        else
            this.getToken = password;
        this.commonHeaders = {
            ...config === null || config === void 0 ? void 0 : config.headers,
            Accept: "*/*",
            "Cache-Control": "no-cache",
            [CSRF_TOKEN_HEADER]: FETCH_CSRF_TOKEN
        };
        this.httpclient = (0, utilities_1.isString)(baseURLOrClient)
            ? new AxiosHttpClient(baseURLOrClient, config)
            : baseURLOrClient;
        this.debugCallback = config === null || config === void 0 ? void 0 : config.debugCallback;
        if (config === null || config === void 0 ? void 0 : config.keepAlive)
            this.keepAlive = setInterval(() => this.keep_session(), 120000);
    }
    async login() {
        if (this.loginPromise)
            return this.loginPromise;
        this.cookie.clear();
        // oauth
        if (this.getToken && !this.bearer) {
            await this.getToken().then(bearer => (this.bearer = bearer));
        }
        else
            this.auth = {
                username: this.username || "",
                password: this.password || ""
            };
        const qs = {};
        if (this.client)
            qs["sap-client"] = this.client;
        if (this.language)
            qs["sap-language"] = this.language;
        this.csrfToken = FETCH_CSRF_TOKEN;
        try {
            this.loginPromise = this._request("/sap/bc/adt/compatibility/graph", {
                qs
            });
            await this.loginPromise;
        }
        finally {
            this.loginPromise = undefined;
        }
    }
    ascookies() {
        return [...this.cookie.values()].join("; ");
    }
    async logout() {
        this.stateful = session_types.stateless;
        await this._request("/sap/public/bc/icf/logoff", {});
        // prevent autologin
        this.auth = undefined;
        this.bearer = undefined;
        // new cookie jar
        this.cookie.clear();
        // clear token
        this.csrfToken = FETCH_CSRF_TOKEN;
    }
    async dropSession() {
        this.stateful = session_types.stateless;
        await this._request("/sap/bc/adt/compatibility/graph", {});
    }
    async request(url, config) {
        let autologin = false;
        try {
            if (!this.loggedin) {
                autologin = true;
                await this.login();
            }
            return await this._request(url, config || {});
        }
        catch (e) {
            const adtErr = (0, AdtException_1.fromException)(e, config);
            // if the logon ticket expired try to logon again, unless in stateful mode
            // or already tried a login
            if ((0, _1.isLoginError)(adtErr) && !autologin && !this.isStateful) {
                try {
                    this.csrfToken = FETCH_CSRF_TOKEN;
                    await this.login();
                    return await this._request(url, config || {});
                }
                catch (e2) {
                    throw (0, AdtException_1.fromException)(e2, config);
                }
            }
            else
                throw adtErr;
        }
    }
    updateCookies(response) {
        if (runningInNode) {
            const cookies = response.headers["set-cookie"] || [];
            cookies.forEach(cookie => {
                const cleaned = cookie
                    .replace(/path=\/,/g, "")
                    .replace(/path=\//g, "")
                    .split(";")[0];
                const [key] = cookie.split("=", 1);
                this.cookie.set(key, cleaned);
            });
        }
    }
    logResponse(exceptionOrResponse, options) {
        if (!this.debugCallback)
            return;
        if ((0, _1.isAdtException)(exceptionOrResponse))
            (0, requestLogger_1.logError)(this.id, exceptionOrResponse, this.debugCallback, options);
        else
            (0, requestLogger_1.logResponse)(this.id, exceptionOrResponse, options, this.debugCallback);
    }
    /**
     * HTTP request without automated login / retry
     *
     * @param url URL suffix
     * @param options request options
     */
    async _request(url, options) {
        this.needKeepalive = false;
        const headers = { ...this.commonHeaders, ...options.headers };
        headers[SESSION_HEADER] = this.stateful;
        if (!headers["Cookie"] && runningInNode)
            headers["Cookie"] = this.ascookies();
        adtRequestNumber++;
        const adtStartTime = new Date();
        const config = {
            ...options,
            auth: this.auth,
            headers,
            adtStartTime,
            adtRequestNumber,
            url
        };
        try {
            if (this.getToken && !this.bearer)
                this.bearer = await this.getToken();
            if (this.bearer)
                headers.Authorization = `bearer ${this.bearer}`;
            const response = await this.httpclient.request(config);
            this.updateCookies(response);
            if (response.status >= 400)
                throw (0, AdtException_1.fromException)(response, config);
            if (this.csrfToken === FETCH_CSRF_TOKEN &&
                (0, utilities_1.isString)(response.headers[CSRF_TOKEN_HEADER]))
                this.csrfToken = response.headers[CSRF_TOKEN_HEADER];
            this.logResponse(response, config);
            return response;
        }
        catch (error) {
            const exc = (0, AdtException_1.fromException)(error, config);
            this.logResponse(exc, config);
            throw exc;
        }
    }
}
exports.AdtHTTP = AdtHTTP;


/***/ }),

/***/ "./build/api/abapgit.js":
/*!******************************!*\
  !*** ./build/api/abapgit.js ***!
  \******************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.switchRepoBranch = exports.remoteRepoInfo = exports.stageRepo = exports.pushRepo = exports.checkRepo = exports.unlinkRepo = exports.pullRepo = exports.createRepo = exports.externalRepoInfo = exports.gitRepos = void 0;
const utilities_1 = __webpack_require__(/*! ../utilities */ "./build/utilities.js");
const AdtException_1 = __webpack_require__(/*! ../AdtException */ "./build/AdtException.js");
const parseDate = (d) => {
    const match = d.match(/(\d\d\d\d)(\d\d)(\d\d)(\d\d)(\d\d)(\d\d)/);
    if (!match)
        return new Date(); // wrong but valid
    const [Y, M, D, h, m, s] = match.slice(1);
    return new Date(Date.UTC((0, utilities_1.toInt)(Y), (0, utilities_1.toInt)(M) - 1, (0, utilities_1.toInt)(D), (0, utilities_1.toInt)(h), (0, utilities_1.toInt)(m), (0, utilities_1.toInt)(s)));
};
async function gitRepos(h) {
    const headers = { Accept: "application/abapgit.adt.repos.v2+xml" };
    const response = await h.request(`/sap/bc/adt/abapgit/repos`, { headers });
    const raw = (0, utilities_1.parse)(response.body, {
        ignoreAttributes: false,
        parseAttributeValue: false,
        parseTagValue: false,
        removeNSPrefix: true
    });
    return (0, utilities_1.xmlArray)(raw, "repositories", "repository").map((x) => {
        const { key, package: sapPackage, url, status, status_text, } = x;
        // tslint:disable: variable-name
        const branch_name = x.branch_name || x.branchName || "";
        const created_by = x.created_by || x.createdBy || "";
        const created_at = x.created_at || x.createdAt || "";
        const created_email = x.created_email || x.createdEmail || "";
        const deserialized_by = x.deserialized_by || x.deserializedBy || "";
        const deserialized_email = x.deserialized_email || x.deserializedEmail || "";
        const deserialized_at = x.deserialized_at || x.deserializedAt || "";
        const links = (0, utilities_1.xmlArray)(x, "link").map(utilities_1.xmlNodeAttr);
        const repo = {
            key,
            sapPackage,
            url,
            branch_name,
            created_by,
            created_at: parseDate(created_at),
            created_email,
            deserialized_by,
            deserialized_email,
            deserialized_at: deserialized_at && parseDate(deserialized_at),
            status,
            status_text,
            links,
        };
        return repo;
    });
}
exports.gitRepos = gitRepos;
async function externalRepoInfo(h, repourl, user = "", password = "") {
    const headers = {
        "Content-Type": "application/abapgit.adt.repo.info.ext.request.v2+xml",
        Accept: "application/abapgit.adt.repo.info.ext.response.v2+xml",
    };
    const body = `<?xml version="1.0" ?>
  <abapgitexternalrepo:externalRepoInfoRequest xmlns:abapgitexternalrepo="http://www.sap.com/adt/abapgit/externalRepo">
    <abapgitexternalrepo:url>${repourl}</abapgitexternalrepo:url>
    <abapgitexternalrepo:user>${user}</abapgitexternalrepo:user>
    <abapgitexternalrepo:password>${password}</abapgitexternalrepo:password>
  </abapgitexternalrepo:externalRepoInfoRequest>`;
    const response = await h.request(`/sap/bc/adt/abapgit/externalrepoinfo`, {
        method: "POST",
        body,
        headers,
    });
    const raw = (0, utilities_1.fullParse)(response.body, { removeNSPrefix: true });
    // tslint:disable-next-line: variable-name
    const access_mode = (0, utilities_1.xmlNode)(raw, "externalRepoInfo", "accessMode");
    const branches = (0, utilities_1.xmlArray)(raw, "externalRepoInfo", "branch").map((branch) => ({
        name: branch.name,
        type: branch.type,
        sha1: branch.sha1,
        display_name: branch.displayName,
        is_head: (0, utilities_1.boolFromAbap)(branch && branch.is_head),
    }));
    return { access_mode, branches };
}
exports.externalRepoInfo = externalRepoInfo;
const parseObjects = (body) => {
    const raw = (0, utilities_1.fullParse)(body);
    return (0, utilities_1.xmlArray)(raw, "objects", "object").map((r) => {
        const { type, name, package: pkg, status, msgType, msgText, } = r;
        const obj = {
            obj_type: type,
            obj_name: name,
            package: pkg,
            obj_status: status,
            msg_type: msgType,
            msg_text: msgText,
        };
    });
};
async function createRepo(h, packageName, repourl, branch = "refs/heads/master", transport = "", user = "", password = "") {
    const headers = {
        "Content-Type": "application/abapgit.adt.repo.v3+xml",
    };
    const body = `<?xml version="1.0" ?>
  <abapgitrepo:repository xmlns:abapgitrepo="http://www.sap.com/adt/abapgit/repositories">
    <abapgitrepo:package>${packageName}</abapgitrepo:package>
    <abapgitrepo:url>${repourl}</abapgitrepo:url>
    <abapgitrepo:branchName>${branch}</abapgitrepo:branchName>
    <abapgitrepo:transportRequest>${transport}</abapgitrepo:transportRequest>
    <abapgitrepo:remoteUser>${user}</abapgitrepo:remoteUser>
    <abapgitrepo:remotePassword>${password}</abapgitrepo:remotePassword>
  </abapgitrepo:repository>`;
    const response = await h.request(`/sap/bc/adt/abapgit/repos`, {
        method: "POST",
        body,
        headers, // encodeEntity?
    });
    return parseObjects(response.body);
}
exports.createRepo = createRepo;
async function pullRepo(h, repoId, branch = "refs/heads/master", transport = "", user = "", password = "") {
    const headers = {
        "Content-Type": "application/abapgit.adt.repo.v3+xml",
    };
    branch = `<abapgitrepo:branchName>${branch}</abapgitrepo:branchName>`;
    transport = transport
        ? `<abapgitrepo:transportRequest>${transport}</abapgitrepo:transportRequest>`
        : "";
    user = user ? `<abapgitrepo:remoteUser>${user}</abapgitrepo:remoteUser>` : "";
    password = password ? `<abapgitrepo:remotePassword>${password}</abapgitrepo:remotePassword>` : "";
    const body = `<?xml version="1.0" ?><abapgitrepo:repository xmlns:abapgitrepo="http://www.sap.com/adt/abapgit/repositories">
    ${branch}${transport}${user}${password}</abapgitrepo:repository>`;
    const response = await h.request(`/sap/bc/adt/abapgit/repos/${repoId}/pull`, {
        method: "POST",
        body,
        headers,
    });
    return parseObjects(response.body);
}
exports.pullRepo = pullRepo;
async function unlinkRepo(h, repoId) {
    const headers = {
        "Content-Type": "application/abapgit.adt.repo.v3+xml",
    };
    await h.request(`/sap/bc/adt/abapgit/repos/${repoId}`, {
        method: "DELETE",
        headers,
    });
}
exports.unlinkRepo = unlinkRepo;
const deserializeStaging = (body) => {
    const raw = (0, utilities_1.xmlNode)((0, utilities_1.fullParse)(body), "abapgitstaging:abapgitstaging");
    const parsefile = (x) => ({
        ...(0, utilities_1.stripNs)((0, utilities_1.xmlNodeAttr)(x)),
        links: (0, utilities_1.xmlArray)(x, "atom:link")
            .map(utilities_1.xmlNodeAttr)
            .map(utilities_1.stripNs)
            .map((l) => ({ ...l, href: l.href })),
    });
    const parseObject = (x) => {
        const attrs = (0, utilities_1.stripNs)((0, utilities_1.xmlNodeAttr)(x));
        const abapGitFiles = (0, utilities_1.xmlArray)(x, "abapgitstaging:abapgitfile").map(parsefile);
        return { ...attrs, abapGitFiles };
    };
    const unstaged = (0, utilities_1.xmlArray)(raw, "abapgitstaging:unstaged_objects", "abapgitstaging:abapgitobject").map(parseObject);
    const staged = (0, utilities_1.xmlArray)(raw, "abapgitstaging:staged_objects", "abapgitstaging:abapgitobject").map(parseObject);
    const ignored = (0, utilities_1.xmlArray)(raw, "abapgitstaging:ignored_objects", "abapgitstaging:abapgitobject").map(parseObject);
    const commentNode = (0, utilities_1.xmlNode)(raw, "abapgitstaging:abapgit_comment");
    const extractUser = (p) => (0, utilities_1.stripNs)((0, utilities_1.xmlNodeAttr)((0, utilities_1.xmlNode)(commentNode, p)));
    const comment = commentNode["@_abapgitstaging:comment"] || "";
    const author = extractUser("abapgitstaging:author");
    const committer = extractUser("abapgitstaging:author");
    const result = {
        staged,
        unstaged,
        ignored,
        comment,
        author,
        committer,
    };
    return result;
};
const serializeStaging = (s) => {
    const formatFile = (f) => {
        const { links, ...rest } = f;
        return `  <abapgitstaging:abapgitfile ${(0, utilities_1.toXmlAttributes)(rest, "abapgitstaging")}>${links
            .map((l) => ({ ...l, href: (0, utilities_1.encodeEntity)(l.href) }))
            .map((l) => `<atom:link ${(0, utilities_1.toXmlAttributes)(l, "")}/>`)
            .join("")}
  </abapgitstaging:abapgitfile>`;
    };
    const formatObject = (obj) => {
        const { abapGitFiles, wbkey, ...rest } = obj;
        return `<abapgitstaging:abapgitobject ${(0, utilities_1.toXmlAttributes)(rest, "adtcore")} abapgitstaging:wbkey="${obj.wbkey}">
    ${obj.abapGitFiles.map(formatFile).join("")}
 </abapgitstaging:abapgitobject>`;
    };
    const formatObjects = (objects, root) => {
        if (!objects.length)
            return `<${root}/>`;
        return `<${root}>${objects.map(formatObject).join("")}</${root}>`;
    };
    const unstaged = formatObjects(s.unstaged, "abapgitstaging:unstaged_objects");
    const staged = formatObjects(s.staged, "abapgitstaging:staged_objects");
    const ignored = formatObjects(s.ignored, "abapgitstaging:ignored_objects");
    const comment = `<abapgitstaging:abapgit_comment abapgitstaging:comment="${s.comment}">
  <abapgitstaging:author abapgitstaging:name="${s.author.name}" abapgitstaging:email="${s.author.email}"/>
  <abapgitstaging:committer abapgitstaging:name="${s.committer.name}" abapgitstaging:email="${s.committer.email}"/>
</abapgitstaging:abapgit_comment>
`;
    return `<?xml version="1.0" encoding="UTF-8"?>
  <abapgitstaging:abapgitstaging xmlns:abapgitstaging="http://www.sap.com/adt/abapgit/staging"
         xmlns:adtcore="http://www.sap.com/adt/core"
         xmlns:atom="http://www.w3.org/2005/Atom">
  ${unstaged}
  ${staged}
  ${ignored}
  ${comment}
  </abapgitstaging:abapgitstaging>`;
};
async function checkRepo(h, repo, user = "", password = "") {
    const clink = repo.links.find((l) => l.type === "check_link");
    if (!(clink === null || clink === void 0 ? void 0 : clink.href))
        throw (0, AdtException_1.adtException)("Check link not found");
    const headers = {
        Accept: "text/plain",
    };
    if (user)
        headers.Username = user;
    if (password)
        headers.Password = (0, utilities_1.btoa)(password);
    await h.request(clink.href, { method: "POST", headers });
}
exports.checkRepo = checkRepo;
async function pushRepo(h, repo, staging, user = "", password = "") {
    const link = repo.links.find((l) => l.type === "push_link");
    if (!(link === null || link === void 0 ? void 0 : link.href))
        throw (0, AdtException_1.adtException)("Push link not found");
    const headers = {
        Accept: "application/abapgit.adt.repo.stage.v1+xml",
    };
    headers["Content-Type"] = headers.Accept;
    if (user)
        headers.Username = user;
    if (password)
        headers.Password = (0, utilities_1.btoa)(password);
    const body = serializeStaging(staging);
    await h.request(link.href, { method: "POST", headers, body });
}
exports.pushRepo = pushRepo;
async function stageRepo(h, repo, user = "", password = "") {
    const link = repo.links.find((l) => l.type === "stage_link");
    if (!(link === null || link === void 0 ? void 0 : link.href))
        throw (0, AdtException_1.adtException)("Stage link not found");
    const headers = {
        "Content-Type": "application/abapgit.adt.repo.stage.v1+xml",
    };
    if (user)
        headers.Username = user;
    if (password)
        headers.Password = (0, utilities_1.btoa)(password);
    const resp = await h.request(link.href, { headers });
    return deserializeStaging(resp.body);
}
exports.stageRepo = stageRepo;
/**
 * @deprecated since 1.2.1, duplicate of externalRepoInfo
 */
async function remoteRepoInfo(h, repo, user = "", password = "") {
    var _a;
    const headers = {
        "Content-Type": "application/abapgit.adt.repo.info.ext.request.v1+xml",
        Accept: "application/abapgit.adt.repo.info.ext.response.v1+xml",
    };
    const body = `<?xml version="1.0" encoding="UTF-8"?>
<repository_ext>
<url>${repo.url}</url>
<user>${user}</user>
<password>${password}</password>
</repository_ext>`;
    const resp = await h.request("/sap/bc/adt/abapgit/externalrepoinfo", {
        headers,
        body,
        method: "POST",
    });
    const raw = (_a = (0, utilities_1.parse)(resp.body)) === null || _a === void 0 ? void 0 : _a.repository_external;
    const { access_mode, branches } = raw;
    return {
        access_mode,
        branches: (0, utilities_1.xmlArray)(branches, "branch"),
    };
}
exports.remoteRepoInfo = remoteRepoInfo;
async function switchRepoBranch(h, repo, branch, create = false, user = "", password = "") {
    const headers = {};
    if (user)
        headers.Username = user;
    if (password)
        headers.Password = (0, utilities_1.btoa)(password);
    await h.request(`/sap/bc/adt/abapgit/repos/${repo.key}/branches/${encodeURIComponent(branch)}?create=${create}`, {
        headers,
        method: "POST",
    });
}
exports.switchRepoBranch = switchRepoBranch;


/***/ }),

/***/ "./build/api/activate.js":
/*!*******************************!*\
  !*** ./build/api/activate.js ***!
  \*******************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.inactiveObjects = exports.inactiveObjectsInResults = exports.mainPrograms = exports.activate = void 0;
const AdtException_1 = __webpack_require__(/*! ../AdtException */ "./build/AdtException.js");
const utilities_1 = __webpack_require__(/*! ../utilities */ "./build/utilities.js");
function toElement(source) {
    if (!source || !source["ioc:ref"])
        return undefined;
    return {
        deleted: source["@_ioc:deleted"],
        user: source["@_ioc:user"],
        ...(0, utilities_1.xmlNodeAttr)(source["ioc:ref"])
    };
}
function parseInactive(raw) {
    return (0, utilities_1.xmlArray)(raw, "ioc:inactiveObjects", "ioc:entry").map((obj) => {
        return {
            object: toElement((0, utilities_1.xmlNode)(obj, "ioc:object")),
            transport: toElement((0, utilities_1.xmlNode)(obj, "ioc:transport"))
        };
    });
}
async function activate(h, objectNameOrObjects, objectUrlOrPreauditReq = true, mainInclude, preauditRequested = true) {
    let objects = [];
    let incl = "";
    if ((0, utilities_1.isString)(objectNameOrObjects)) {
        if (!(0, utilities_1.isString)(objectUrlOrPreauditReq))
            throw (0, AdtException_1.adtException)("Invalid parameters, objectUrl should be  a string");
        (0, AdtException_1.ValidateObjectUrl)(objectUrlOrPreauditReq || "");
        if (mainInclude)
            incl = `?context=${encodeURIComponent(mainInclude)}`;
        objects.push(`<adtcore:objectReference adtcore:uri="${objectUrlOrPreauditReq}${incl}" adtcore:name="${objectNameOrObjects}"/>`);
    }
    else {
        let inactives;
        if ((0, utilities_1.isString)(objectUrlOrPreauditReq))
            throw (0, AdtException_1.adtException)("Invalid parameters, preauditRequested should be a boolean");
        preauditRequested = objectUrlOrPreauditReq;
        if ((0, utilities_1.isArray)(objectNameOrObjects)) {
            inactives = objectNameOrObjects;
        }
        else
            inactives = [objectNameOrObjects];
        inactives.forEach(i => (0, AdtException_1.ValidateObjectUrl)(i["adtcore:uri"]));
        objects = inactives.map(i => `<adtcore:objectReference adtcore:uri="${i["adtcore:uri"]}" adtcore:type="${i["adtcore:type"]}" adtcore:parentUri="${i["adtcore:parentUri"]}" adtcore:name="${i["adtcore:name"]}"/>`);
    }
    const qs = { method: "activate", preauditRequested };
    const body = `<?xml version="1.0" encoding="UTF-8"?>` +
        `<adtcore:objectReferences xmlns:adtcore="http://www.sap.com/adt/core">` +
        objects.join(`\n`) +
        `</adtcore:objectReferences>`;
    const response = await h.request("/sap/bc/adt/activation", {
        body,
        method: "POST",
        qs
    });
    let messages = [];
    let success = true;
    let inactive = [];
    if (response.body) {
        const raw = (0, utilities_1.fullParse)(response.body);
        inactive = parseInactive(raw);
        messages = (0, utilities_1.xmlArray)(raw, "chkl:messages", "msg").map((m) => {
            const message = (0, utilities_1.xmlNodeAttr)(m);
            message.shortText = (m.shortText && m.shortText.txt) || "Syntax error";
            return message;
        });
        if (inactive.length > 0)
            success = false;
        else
            messages.some(m => {
                if (m.type.match(/[EAX]/))
                    success = false;
                return !success;
            });
    }
    return { messages, success, inactive };
}
exports.activate = activate;
async function mainPrograms(h, IncludeUrl) {
    (0, AdtException_1.ValidateObjectUrl)(IncludeUrl);
    const response = await h.request(`${IncludeUrl}/mainprograms`);
    const parsed = (0, utilities_1.fullParse)(response.body);
    const includes = (0, utilities_1.xmlArray)(parsed["adtcore:objectReferences"], "adtcore:objectReference").map(utilities_1.xmlNodeAttr);
    return includes;
}
exports.mainPrograms = mainPrograms;
function inactiveObjectsInResults(results) {
    const obj = results.inactive.filter(x => x.object).map(x => x.object);
    return obj.map(o => {
        const { user, deleted, ...rest } = o;
        return rest;
    });
}
exports.inactiveObjectsInResults = inactiveObjectsInResults;
async function inactiveObjects(h) {
    const headers = {
        Accept: "application/vnd.sap.adt.inactivectsobjects.v1+xml, application/xml;q=0.8"
    };
    const response = await h.request("/sap/bc/adt/activation/inactiveobjects", {
        headers
    });
    return parseInactive((0, utilities_1.fullParse)(response.body));
}
exports.inactiveObjects = inactiveObjects;


/***/ }),

/***/ "./build/api/atc.js":
/*!**************************!*\
  !*** ./build/api/atc.js ***!
  \**************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.atcChangeContact = exports.atcContactUri = exports.atcRequestExemption = exports.atcExemptProposal = exports.atcUsers = exports.atcWorklists = exports.createAtcRun = exports.atcCheckVariant = exports.atcCustomizing = exports.isProposalMessage = void 0;
const utilities_1 = __webpack_require__(/*! ../utilities */ "./build/utilities.js");
const t = __importStar(__webpack_require__(/*! io-ts */ "./node_modules/io-ts/es6/index.js"));
const __1 = __webpack_require__(/*! .. */ "./build/index.js");
const urlparser_1 = __webpack_require__(/*! ./urlparser */ "./build/api/urlparser.js");
const exemptionKind = t.union([
    t.literal("A"),
    t.literal("I"),
    t.literal(""),
    t.string
]); // SATC_AC_RSLT_XMPT_KIND Atc based/Inline/none
const proposalFinding = (0, utilities_1.mixed)({
    uri: t.string,
    type: t.string,
    name: t.string,
    location: t.string,
    processor: t.string,
    lastChangedBy: t.string,
    priority: t.number,
    checkId: t.string,
    checkTitle: t.string,
    messageId: t.string,
    messageTitle: t.string,
    exemptionApproval: t.string,
    exemptionKind,
    checksum: t.number,
    quickfixInfo: t.string
}, {
    quickfixes: t.partial({
        automatic: t.boolean,
        manual: t.boolean,
        pseudo: t.boolean
    })
});
const restriction = t.type({
    enabled: t.boolean,
    singlefinding: t.boolean,
    rangeOfFindings: t.type({
        enabled: t.boolean,
        restrictByObject: t.type({
            object: t.boolean,
            package: t.boolean,
            subobject: t.boolean,
            target: t.union([
                t.literal("subobject"),
                t.literal("object"),
                t.literal("package"),
                t.literal("")
            ])
        }),
        restrictByCheck: t.type({
            check: t.boolean,
            message: t.boolean,
            target: t.union([t.literal("message"), t.literal("check"), t.literal("")])
        })
    })
});
const atcProposal = (0, utilities_1.mixed)({
    finding: t.union([proposalFinding, t.string]),
    package: t.string,
    subObject: t.string,
    subObjectType: t.string,
    subObjectTypeDescr: t.string,
    objectTypeDescr: t.string,
    approver: t.string,
    reason: t.union([t.literal("FPOS"), t.literal("OTHR"), t.literal("")]),
    justification: t.string,
    notify: t.union([
        t.literal("never"),
        t.literal("on_rejection"),
        t.literal("always")
    ]),
    restriction: restriction
}, {
    apprIsArea: t.string,
    checkClass: t.string,
    validUntil: t.string
});
const atcProposalMessage = t.type({
    type: t.string,
    message: t.string
});
const atcRunResultInfo = t.type({
    type: t.string,
    description: t.string
});
const atcRunResult = t.type({
    id: t.string,
    timestamp: t.number,
    infos: t.array(atcRunResultInfo)
});
const atcExcemption = t.type({
    id: t.string,
    justificationMandatory: t.boolean,
    title: t.string
});
const atcProperty = t.type({
    name: t.string,
    value: t.union([t.boolean, t.string])
});
const atcCustomizingi = t.type({
    properties: t.array(atcProperty),
    excemptions: t.array(atcExcemption)
});
const objectSet = t.type({
    name: t.string,
    title: t.string,
    kind: t.string
});
const link = t.type({
    href: t.string,
    rel: t.string,
    type: t.string
});
const finding = t.type({
    uri: t.string,
    location: urlparser_1.uriParts,
    priority: t.number,
    checkId: t.string,
    checkTitle: t.string,
    messageId: t.string,
    messageTitle: t.string,
    exemptionApproval: t.string,
    exemptionKind,
    quickfixInfo: (0, utilities_1.orUndefined)(t.string),
    link: link
});
const object = t.type({
    uri: t.string,
    type: t.string,
    name: t.string,
    packageName: t.string,
    author: t.string,
    objectTypeId: (0, utilities_1.orUndefined)(t.string),
    findings: t.array(finding)
});
const atcWorklist = t.type({
    id: t.string,
    timestamp: t.number,
    usedObjectSet: t.string,
    objectSetIsComplete: t.boolean,
    objectSets: t.array(objectSet),
    objects: t.array(object)
});
const atcUser = t.type({
    id: t.string,
    title: t.string
});
exports.isProposalMessage = atcProposalMessage.is;
async function atcCustomizing(h) {
    const headers = {
        Accept: "application/xml, application/vnd.sap.atc.customizing-v1+xml"
    };
    const response = await h.request("/sap/bc/adt/atc/customizing", { headers });
    const raw = (0, utilities_1.fullParse)(response.body, {
        removeNSPrefix: true,
        parseTagValue: false
    });
    const properties = (0, utilities_1.xmlArray)(raw, "customizing", "properties", "property").map(utilities_1.xmlNodeAttr);
    const excemptions = (0, utilities_1.xmlArray)(raw, "customizing", "exemption", "reasons", "reason").map(utilities_1.xmlNodeAttr);
    const retval = { properties, excemptions };
    return (0, __1.validateParseResult)(atcCustomizingi.decode(retval));
}
exports.atcCustomizing = atcCustomizing;
async function atcCheckVariant(h, variant) {
    const headers = { Accept: "text/plain" };
    const response = await h.request(`/sap/bc/adt/atc/worklists?checkVariant=${variant}`, { method: "POST", headers });
    return response.body;
}
exports.atcCheckVariant = atcCheckVariant;
async function createAtcRun(h, variant, mainUrl, maxResults = 100) {
    const body = `<?xml version="1.0" encoding="UTF-8"?>
<atc:run maximumVerdicts="${maxResults}" xmlns:atc="http://www.sap.com/adt/atc">
	<objectSets xmlns:adtcore="http://www.sap.com/adt/core">
		<objectSet kind="inclusive">
			<adtcore:objectReferences>
				<adtcore:objectReference adtcore:uri="${mainUrl}"/>
			</adtcore:objectReferences>
		</objectSet>
	</objectSets>
</atc:run>`;
    const headers = {
        Accept: "application/xml",
        "Content-Type": "application/xml"
    };
    const response = await h.request(`/sap/bc/adt/atc/runs?worklistId=${variant}`, { method: "POST", headers, body });
    const raw = (0, utilities_1.fullParse)(response.body, {
        removeNSPrefix: true,
        parseTagValue: false
    });
    const id = (0, utilities_1.xmlNode)(raw, "worklistRun", "worklistId");
    const ts = (0, utilities_1.xmlNode)(raw, "worklistRun", "worklistTimestamp");
    const infos = (0, utilities_1.xmlArray)(raw, "worklistRun", "infos", "info");
    const retval = { id, timestamp: new Date(ts).getTime() / 1000, infos };
    return (0, __1.validateParseResult)(atcRunResult.decode(retval));
}
exports.createAtcRun = createAtcRun;
async function atcWorklists(h, runResultId, timestamp, usedObjectSet, includeExemptedFindings = false) {
    const headers = { Accept: "application/atc.worklist.v1+xml" };
    const qs = { timestamp, usedObjectSet, includeExemptedFindings };
    const response = await h.request(`/sap/bc/adt/atc/worklists/${runResultId}`, {
        headers,
        qs
    });
    const raw = (0, utilities_1.fullParse)(response.body, {
        removeNSPrefix: true,
        parseTagValue: false,
        numberParseOptions: utilities_1.numberParseOptions
    });
    const root = (0, utilities_1.xmlNode)(raw, "worklist");
    const attrs = (0, utilities_1.xmlNodeAttr)(root);
    const objectSets = (0, utilities_1.xmlArray)(root, "objectSets", "objectSet").map(utilities_1.xmlNodeAttr);
    const objects = (0, utilities_1.xmlArray)(root, "objects", "object").map(o => {
        const oa = (0, utilities_1.xmlNodeAttr)(o);
        const findings = (0, utilities_1.xmlArray)(o, "findings", "finding").map(f => {
            const fa = (0, utilities_1.xmlNodeAttr)(f);
            const priority = (0, utilities_1.toInt)(fa.priority);
            const link = (0, utilities_1.xmlNodeAttr)((0, utilities_1.xmlNode)(f, "link"));
            const location = (0, urlparser_1.parseUri)(fa.location);
            const messageTitle = fa.messageTitle;
            const checkTitle = fa.checkTitle;
            return {
                ...fa,
                priority,
                messageTitle,
                checkTitle,
                location,
                messageId: `${fa.messageId}`,
                link
            };
        });
        return { ...oa, findings };
    });
    const ts = new Date(attrs.timestamp).getTime() / 1000;
    const result = { ...attrs, timestamp: ts, objectSets, objects };
    return (0, __1.validateParseResult)(atcWorklist.decode(result));
}
exports.atcWorklists = atcWorklists;
async function atcUsers(h) {
    const headers = { Accept: "application/atom+xml;type=feed" };
    const response = await h.request(`/sap/bc/adt/system/users`, { headers });
    const raw = (0, utilities_1.fullParse)(response.body, {
        removeNSPrefix: true,
        parseTagValue: false,
        parseAttributeValue: false
    });
    const users = (0, utilities_1.xmlArray)(raw, "feed", "entry");
    return (0, __1.validateParseResult)(t.array(atcUser).decode(users));
}
exports.atcUsers = atcUsers;
async function atcExemptProposal(h, markerId) {
    const headers = {
        Accept: "application/atc.xmpt.v1+xml, application/atc.xmptapp.v1+xml"
    };
    const qs = { markerId };
    const response = await h.request(`/sap/bc/adt/atc/exemptions/apply`, {
        headers,
        qs
    });
    const raw = (0, utilities_1.fullParse)(response.body, {
        removeNSPrefix: true,
        parseTagValue: false,
        parseAttributeValue: false
    });
    const root = (0, utilities_1.xmlNode)(raw, "exemptionApply", "exemptionProposal");
    const { message, type } = (0, utilities_1.xmlNode)(raw, "exemptionApply", "status") || {};
    if ((0, __1.isErrorMessageType)(type))
        throw (0, __1.adtException)(message);
    if (message && type)
        return (0, __1.validateParseResult)(atcProposalMessage.decode({ message, type }));
    const finding = (0, utilities_1.isString)(root.finding)
        ? root.finding
        : (0, utilities_1.xmlNodeAttr)((0, utilities_1.xmlNode)(root, "finding"));
    if (!(0, utilities_1.isString)(finding)) {
        finding.priority = (0, utilities_1.toInt)(finding.priority);
        finding.checksum = (0, utilities_1.toInt)(finding.checksum);
        const qf = (0, utilities_1.xmlNodeAttr)((0, utilities_1.xmlNode)(root, "finding", "quickfixes"));
        finding.quickfixes = {
            automatic: qf.automatic === "true",
            manual: qf.manual === "true",
            pseudo: qf.pseudo === "true"
        };
    }
    const { package: pa, subObject, subObjectType, subObjectTypeDescr, objectTypeDescr, approver, reason, justification, notify, apprIsArea, checkClass, validUntil } = root;
    const { thisFinding, rangeOfFindings } = (0, utilities_1.xmlNode)(root, "restriction");
    const { restrictByObject, restrictByCheck } = rangeOfFindings;
    const result = {
        finding,
        package: pa,
        subObject,
        subObjectType,
        subObjectTypeDescr,
        objectTypeDescr,
        approver,
        reason,
        justification,
        notify,
        apprIsArea,
        checkClass,
        validUntil,
        restriction: {
            enabled: thisFinding["@_enabled"] === "true",
            singlefinding: thisFinding["#text"] === "true",
            rangeOfFindings: {
                enabled: rangeOfFindings["@_enabled"] === "true",
                restrictByObject: {
                    object: restrictByObject["@_object"] === "true",
                    package: restrictByObject["@_package"] === "true",
                    subobject: restrictByObject["@_subobject"] === "true",
                    target: restrictByObject["#text"] || ""
                },
                restrictByCheck: {
                    check: restrictByCheck["@_check"] === "true",
                    message: restrictByCheck["@_message"] === "true",
                    target: restrictByCheck["#text"] || ""
                }
            }
        }
    };
    return (0, __1.validateParseResult)(atcProposal.decode(result));
}
exports.atcExemptProposal = atcExemptProposal;
async function atcRequestExemption(h, proposal) {
    const headers = {
        "Content-Type": "application/atc.xmptprop.v1+xml",
        Accept: "application/atc.xmpt.v1+xml, application/atc.xmptprop.v1+xml"
    };
    const { finding, restriction: { rangeOfFindings: { restrictByCheck, restrictByObject } }, restriction } = proposal;
    const qs = { markerId: (0, utilities_1.isString)(finding) ? finding : finding.quickfixInfo };
    const findingXml = (0, utilities_1.isString)(finding)
        ? `<atcexmpt:finding>${finding}</atcexmpt:finding>`
        : `<atcfinding:finding adtcore:name="${finding.name}" adtcore:type="${finding.type}" adtcore:uri="${finding.uri}" 
    atcfinding:checkId="${finding.checkId}" atcfinding:checksum="${finding.checksum}" atcfinding:checkTitle="${(0, utilities_1.encodeEntity)(finding.checkTitle)}" 
    atcfinding:exemptionApproval="${finding.exemptionApproval}" atcfinding:exemptionKind="${finding.exemptionKind}" 
    atcfinding:lastChangedBy="${finding.lastChangedBy}" 
    atcfinding:location="${finding.location}" atcfinding:messageId="${finding.messageId}" atcfinding:messageTitle="${(0, utilities_1.encodeEntity)(finding.messageTitle)}" 
    atcfinding:priority="${finding.priority}" atcfinding:processor="${finding.processor}" atcfinding:quickfixInfo="${finding.quickfixInfo}">
      <atcfinding:quickfixes atcfinding:automatic="false" atcfinding:manual="false" atcfinding:pseudo="false" />
    </atcfinding:finding>`;
    const body = `<?xml version="1.0" encoding="ASCII"?>
    <atcexmpt:exemptionProposal xmlns:adtcore="http://www.sap.com/adt/core" xmlns:atcexmpt="http://www.sap.com/adt/atc/exemption" xmlns:atcfinding="http://www.sap.com/adt/atc/finding">
      ${findingXml}
      <atcexmpt:package>${proposal.package}</atcexmpt:package>
      <atcexmpt:subObject>${proposal.subObject}</atcexmpt:subObject>
      <atcexmpt:subObjectType>${proposal.subObjectType}</atcexmpt:subObjectType>
      <atcexmpt:subObjectTypeDescr>${proposal.subObjectTypeDescr}</atcexmpt:subObjectTypeDescr>
      <atcexmpt:objectTypeDescr>${proposal.objectTypeDescr}</atcexmpt:objectTypeDescr>
      <atcexmpt:restriction>
        <atcexmpt:thisFinding enabled="${restriction.enabled}">${restriction.singlefinding}</atcexmpt:thisFinding>
        <atcexmpt:rangeOfFindings enabled="${restriction.rangeOfFindings.enabled}">
          <atcexmpt:restrictByObject object="${restrictByObject.object}" package="${restrictByObject.package}" subobject="${restrictByObject.subobject}">
          ${restrictByObject.target}</atcexmpt:restrictByObject>
          <atcexmpt:restrictByCheck check="${restrictByCheck.check}" message="${restrictByCheck.message}">
          ${restrictByCheck.target}</atcexmpt:restrictByCheck>
        </atcexmpt:rangeOfFindings>
      </atcexmpt:restriction>
      <atcexmpt:approver>${proposal.approver}</atcexmpt:approver>
      <atcexmpt:reason>${proposal.reason}</atcexmpt:reason>
      <atcexmpt:justification>${(0, utilities_1.encodeEntity)(proposal.justification)}</atcexmpt:justification>
      <atcexmpt:notify>${proposal.notify}</atcexmpt:notify>
      <atcexmpt:apprIsArea>${proposal.apprIsArea || ""}</atcexmpt:apprIsArea>
      <atcexmpt:checkClass>${proposal.checkClass || ""}</atcexmpt:checkClass>
      <atcexmpt:validUntil>${proposal.validUntil || ""}</atcexmpt:validUntil>
      </atcexmpt:exemptionProposal>`;
    const response = await h.request(`/sap/bc/adt/atc/exemptions/apply`, {
        headers,
        body,
        qs,
        method: "POST"
    });
    const raw = (0, utilities_1.fullParse)(response.body, {
        removeNSPrefix: true,
        parseTagValue: false,
        parseAttributeValue: false
    });
    const result = (0, __1.validateParseResult)(atcProposalMessage.decode(raw === null || raw === void 0 ? void 0 : raw.status));
    if ((0, __1.isErrorMessageType)(result.type))
        throw (0, __1.adtException)(result.message);
    return (0, __1.validateParseResult)(atcProposalMessage.decode(result));
}
exports.atcRequestExemption = atcRequestExemption;
async function atcContactUri(h, findingUri) {
    const headers = {
        "Content-Type": "application/vnd.sap.adt.atc.findingreferences.v1+xml",
        Accept: "application/vnd.sap.adt.atc.items.v1+xml"
    };
    const qs = { step: "proposal" };
    const body = `<?xml version="1.0" encoding="ASCII"?>
    <atcfinding:findingReferences xmlns:adtcore="http://www.sap.com/adt/core" xmlns:atcfinding="http://www.sap.com/adt/atc/finding">
      <atcfinding:findingReference adtcore:uri="${findingUri}"/>
    </atcfinding:findingReferences>`;
    const response = await h.request(`/sap/bc/adt/atc/items`, {
        headers,
        body,
        method: "POST",
        qs
    });
    const raw = (0, utilities_1.fullParse)(response.body, {
        removeNSPrefix: true,
        parseTagValue: false,
        parseAttributeValue: false
    });
    const { uri } = (0, utilities_1.xmlNodeAttr)((0, utilities_1.xmlNode)(raw, "items", "item"));
    return (0, __1.validateParseResult)(t.string.decode(uri));
}
exports.atcContactUri = atcContactUri;
async function atcChangeContact(h, itemUri, userId) {
    const headers = { "Content-Type": "application/vnd.sap.adt.atc.items.v1+xml" };
    const body = `<?xml version="1.0" encoding="ASCII"?>
    <atcfinding:items xmlns:adtcore="http://www.sap.com/adt/core" xmlns:atcfinding="http://www.sap.com/adt/atc/finding">
      <atcfinding:item adtcore:uri="${itemUri}" atcfinding:processor="${userId}" atcfinding:status="2"/>
    </atcfinding:items>`;
    await h.request(`/sap/bc/adt/atc/items`, { headers, body, method: "PUT" });
}
exports.atcChangeContact = atcChangeContact;


/***/ }),

/***/ "./build/api/cds.js":
/*!**************************!*\
  !*** ./build/api/cds.js ***!
  \**************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.unpublishServiceBinding = exports.publishServiceBinding = exports.ddicRepositoryAccess = exports.ddicElement = exports.annotationDefinitions = exports.syntaxCheckCDS = void 0;
const utilities_1 = __webpack_require__(/*! ../utilities */ "./build/utilities.js");
const syntax_1 = __webpack_require__(/*! ./syntax */ "./build/api/syntax.js");
async function syntaxCheckCDS(h, url, mainUrl, content) {
    const artifacts = mainUrl && content
        ? `<chkrun:artifacts>
  <chkrun:artifact chkrun:contentType="text/plain; charset=utf-8" chkrun:uri="${mainUrl}">
      <chkrun:content>${(0, utilities_1.btoa)(content)}</chkrun:content>
  </chkrun:artifact>
</chkrun:artifacts>`
        : "";
    const response = await h.request("/sap/bc/adt/checkruns?reporters=abapCheckRun", {
        method: "POST",
        headers: {
            "Content-Type": "application/vnd.sap.adt.checkobjects+xml",
            Accept: "application/vnd.sap.adt.checkmessages+xml"
        },
        body: `<?xml version="1.0" encoding="UTF-8"?>
<chkrun:checkObjectList xmlns:adtcore="http://www.sap.com/adt/core" xmlns:chkrun="http://www.sap.com/adt/checkrun">
  <chkrun:checkObject adtcore:uri="${url}" chkrun:version="active">${artifacts}</chkrun:checkObject>
</chkrun:checkObjectList>`
    });
    const raw = (0, utilities_1.fullParse)(response.body);
    return (0, syntax_1.parseCheckResults)(raw);
}
exports.syntaxCheckCDS = syntaxCheckCDS;
async function annotationDefinitions(h) {
    const headers = {
        Accept: "application/vnd.sap.adt.cds.annotation.definitions.v1+xml, application/vnd.sap.adt.cds.annotation.definitions.v2+xml"
    };
    const response = await h.request("/sap/bc/adt/ddic/cds/annotation/definitions", { headers });
    const raw = (0, utilities_1.fullParse)(response.body);
    return (0, utilities_1.xmlNode)(raw, "cds:annotation", "cds:definitions");
}
exports.annotationDefinitions = annotationDefinitions;
function parseDDICProps(raw) {
    const converted = (0, utilities_1.xmlArray)(raw, "abapsource:entry").reduce((prev, cur) => {
        const key = cur["@_abapsource:key"];
        const value = cur["#text"];
        prev[key] = value;
        return prev;
    }, {});
    const { ddicIsKey, ddicDataElement, ddicDataType, ddicLength, ddicDecimals, ddicHeading, ddicLabelShort, ddicLabelMedium, ddicLabelLong, ddicHeadingLength, ddicLabelShortLength, ddicLabelMediumLength, ddicLabelLongLength, parentName, ...rawanno } = converted;
    const elementProps = (ddicDataType || ddicDataType === "") && {
        ddicIsKey: !!ddicIsKey,
        ddicDataElement,
        ddicDataType,
        ddicLength,
        ddicDecimals,
        ddicHeading,
        ddicLabelShort,
        ddicLabelMedium,
        ddicLabelLong,
        ddicHeadingLength,
        ddicLabelShortLength,
        ddicLabelMediumLength,
        ddicLabelLongLength,
        parentName
    };
    const annotations = [];
    // tslint:disable-next-line: forin
    for (const key in rawanno) {
        const match = key.match(/annotation(Key|Value).([0-9]+)/);
        if (match && match.groups) {
            const mtype = match.groups[1];
            const idx = (0, utilities_1.toInt)(match.groups[2]);
            const anno = annotations[idx] || { key: "", value: "" };
            if (mtype === "Key")
                anno.key = rawanno[key];
            else
                anno.value = rawanno[key];
            annotations[idx] = anno;
        }
    }
    return {
        elementProps,
        annotations
    };
}
function parseDdicElement(raw) {
    const type = raw["@_adtcore:type"];
    const name = raw["@_adtcore:name"];
    const properties = parseDDICProps(raw["abapsource:properties"]);
    const children = (0, utilities_1.xmlArray)(raw, "abapsource:elementInfo").map(parseDdicElement);
    return { type, name, properties, children };
}
async function ddicElement(h, path, getTargetForAssociation = false, getExtensionViews = true, getSecondaryObjects = true) {
    const headers = { Accept: "application/vnd.sap.adt.elementinfo+xml" };
    const qs = (0, utilities_1.formatQS)({
        getTargetForAssociation,
        getExtensionViews,
        getSecondaryObjects,
        path
    });
    const uri = `/sap/bc/adt/ddic/ddl/elementinfo?${qs}`;
    const response = await h.request(uri, { headers });
    const raw = (0, utilities_1.fullParse)(response.body);
    return parseDdicElement(raw["abapsource:elementInfo"]);
}
exports.ddicElement = ddicElement;
async function ddicRepositoryAccess(h, path) {
    const headers = { Accept: "application/*" };
    const qs = (0, utilities_1.isArray)(path)
        ? (0, utilities_1.formatQS)({ requestScope: "all", path })
        : `datasource=${encodeURIComponent(path)}`;
    const url = `/sap/bc/adt/ddic/ddl/ddicrepositoryaccess?${qs}`;
    const response = await h.request(url, { headers });
    const raw = (0, utilities_1.fullParse)(response.body);
    const records = raw["adtcore:objectReferences"]
        ? (0, utilities_1.xmlArray)(raw, "adtcore:objectReferences", "adtcore:objectReference")
        : (0, utilities_1.xmlArray)(raw, "ddl:ddlObjectReferences", "ddl:ddlObjectReference");
    return records.map(r => {
        const attr = (0, utilities_1.xmlNodeAttr)(r);
        return {
            uri: attr["adtcore:uri"] || "",
            type: attr["adtcore:type"] || "",
            name: attr["adtcore:name"] || "",
            path: attr["ddl:path"] || ""
        };
    });
}
exports.ddicRepositoryAccess = ddicRepositoryAccess;
async function publishUnpublishServiceBinding(h, base, name, version) {
    const headers = { Accept: "application/*" };
    const qs = `servicename=${encodeURIComponent(name)}&serviceversion=${version}`;
    const url = `/sap/bc/adt/businessservices/odatav2/${base}?${qs}`;
    const body = `<adtcore:objectReferences xmlns:adtcore="http://www.sap.com/adt/core">
  <adtcore:objectReference adtcore:name="${name}"/>
  </adtcore:objectReferences>`;
    const response = await h.request(url, { headers, method: "POST", body });
    const raw = (0, utilities_1.fullParse)(response.body);
    const data = (0, utilities_1.xmlNode)(raw, "asx:abap/asx:values/DATA");
    const severity = (0, utilities_1.xmlNode)(data, "SEVERITY");
    const shortText = (0, utilities_1.xmlNode)(data, "SHORT_TEXT");
    const longText = (0, utilities_1.xmlNode)(data, "LONG_TEXT");
    return { severity, shortText, longText };
}
async function publishServiceBinding(h, name, version) {
    return publishUnpublishServiceBinding(h, "publishjobs", name, version);
}
exports.publishServiceBinding = publishServiceBinding;
async function unpublishServiceBinding(h, name, version) {
    return publishUnpublishServiceBinding(h, "unpublishjobs", name, version);
}
exports.unpublishServiceBinding = unpublishServiceBinding;


/***/ }),

/***/ "./build/api/debugger.js":
/*!*******************************!*\
  !*** ./build/api/debugger.js ***!
  \*******************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.debuggerSetVariableValue = exports.debuggerGoToStackOld = exports.debuggerGoToStack = exports.debuggerStep = exports.debuggerVariables = exports.debuggerChildVariables = exports.simpleDebuggerStack = exports.debuggerStack = exports.debuggerSaveSettings = exports.debuggerAttach = exports.debuggerDeleteBreakpoints = exports.debuggerSetBreakpoints = exports.isDebuggerBreakpoint = exports.debuggerDeleteListener = exports.debuggerListen = exports.debuggerListeners = exports.isDebuggee = exports.isDebugListenerError = exports.debugMetaIsComplex = void 0;
const __1 = __webpack_require__(/*! .. */ "./build/index.js");
const utilities_1 = __webpack_require__(/*! ../utilities */ "./build/utilities.js");
const urlparser_1 = __webpack_require__(/*! ./urlparser */ "./build/api/urlparser.js");
const debugMetaIsComplex = (m) => !["simple", "string", "boxedcomp", "anonymcomp", "unknown"].find(e => e === m);
exports.debugMetaIsComplex = debugMetaIsComplex;
const parseStep = (body) => {
    var _a;
    const raw = (0, utilities_1.fullParse)(body, { removeNSPrefix: true });
    checkException(raw);
    const attrs = (0, utilities_1.xmlNodeAttr)(raw.step);
    const settings = (0, utilities_1.xmlNodeAttr)((_a = raw === null || raw === void 0 ? void 0 : raw.step) === null || _a === void 0 ? void 0 : _a.settings);
    const actions = (0, utilities_1.xmlArray)(raw, "step", "actions", "action").map(utilities_1.xmlNodeAttr);
    return { ...attrs, actions, settings };
};
const convertVariable = (v) => ({
    ...v, TABLE_LINES: (0, utilities_1.toInt)(v.TABLE_LINES),
    LENGTH: (0, utilities_1.toInt)(v.LENGTH),
    INHERITANCE_LEVEL: (0, utilities_1.toInt)(v.INHERITANCE_LEVEL),
    VALUE: v.VALUE,
    ID: v.ID,
    NAME: v.NAME
});
const parseVariables = (body) => {
    const raw = (0, utilities_1.fullParse)(body, { removeNSPrefix: true, parseTagValue: false, numberParseOptions: utilities_1.numberParseOptions });
    const variables = (0, utilities_1.xmlArray)(raw, "abap", "values", "DATA", "STPDA_ADT_VARIABLE")
        .map(convertVariable);
    return variables;
};
const parseChildVariables = (body) => {
    const raw = (0, utilities_1.fullParse)(body, { removeNSPrefix: true, parseTagValue: false, numberParseOptions: utilities_1.numberParseOptions });
    const hierarchies = (0, utilities_1.xmlArray)(raw, "abap", "values", "DATA", "HIERARCHIES", "STPDA_ADT_VARIABLE_HIERARCHY");
    const variables = (0, utilities_1.xmlArray)(raw, "abap", "values", "DATA", "VARIABLES", "STPDA_ADT_VARIABLE")
        .map(convertVariable);
    return { hierarchies, variables };
};
const parseStack = (body) => {
    const raw = (0, utilities_1.fullParse)(body, { removeNSPrefix: true });
    const stack = (0, utilities_1.xmlArray)(raw, "stack", "stackEntry")
        .map(utilities_1.xmlNodeAttr)
        .map(x => ({ ...x, uri: (0, urlparser_1.parseUri)(x.uri) }));
    const attrs = (0, utilities_1.xmlNodeAttr)(raw.stack);
    return { ...attrs, stack };
};
const parseDebugSettings = (body) => {
    const raw = (0, utilities_1.fullParse)(body, { removeNSPrefix: true });
    return (0, utilities_1.xmlNodeAttr)(raw.settings);
};
const parseAttach = (body) => {
    const raw = (0, utilities_1.fullParse)(body, { removeNSPrefix: true });
    const attrs = (0, utilities_1.xmlNodeAttr)(raw.attach);
    const reachedBreakpoints = (0, utilities_1.xmlArray)(raw, "attach", "reachedBreakpoints", "breakpoint").map(utilities_1.xmlNodeAttr);
    const actions = (0, utilities_1.xmlArray)(raw, "attach", "actions", "action").map(utilities_1.xmlNodeAttr);
    return { ...attrs, actions, reachedBreakpoints };
};
const parseBreakpoints = (body) => {
    const raw = (0, utilities_1.fullParse)(body, { removeNSPrefix: true });
    return (0, utilities_1.xmlArray)(raw, "breakpoints", "breakpoint")
        .map(utilities_1.xmlNodeAttr)
        .map(x => {
        if (x.uri)
            return { ...x, uri: (0, urlparser_1.parseUri)(x.uri) };
        return x;
    });
};
const parseDebugError = (raw) => {
    if (raw.exception) {
        const { namespace: { "@_id": namespace }, type: { "@_id": type }, localizedMessage, message } = raw.exception;
        const parseMessage = (m) => ({ text: m["#text"], lang: m["@_lang"] });
        const entries = {};
        for (const ex of (0, utilities_1.xmlArray)(raw.exception, "properties", "entry"))
            entries[ex["@_key"]] = ex["#text"];
        return {
            ...entries,
            namespace,
            type,
            message: parseMessage(message),
            localizedMessage: parseMessage(localizedMessage)
        };
    }
};
const checkException = (raw) => {
    const e = parseDebugError(raw);
    if (e) {
        const err = new Error(e.message.text);
        err.extra = e;
        throw err;
    }
};
const isDebugListenerError = (e) => !!e && "conflictText" in e && "com.sap.adt.communicationFramework.subType" in e;
exports.isDebugListenerError = isDebugListenerError;
const isDebuggee = (d) => !!d && !["CLIENT", "DEBUGGEE_ID", "TERMINAL_ID", "IDE_ID", "DEBUGGEE_USER"].find(f => !(f in d));
exports.isDebuggee = isDebuggee;
const parseDebugListeners = (body) => {
    if (!body)
        return;
    const raw = (0, utilities_1.fullParse)(body, { removeNSPrefix: true });
    const err = parseDebugError(raw);
    if (err)
        return err;
    const debug = (0, utilities_1.xmlNode)(raw, "abap", "values", "DATA", "STPDA_DEBUGGEE");
    return { ...debug, URI: (0, urlparser_1.parseUri)(debug.URI) };
};
async function debuggerListeners(h, debuggingMode, terminalId, ideId, requestUser, checkConflict = true) {
    const qs = {
        debuggingMode,
        requestUser,
        terminalId,
        ideId,
        checkConflict
    };
    const response = await h.request("/sap/bc/adt/debugger/listeners", { qs });
    if (!response.body)
        return;
    const raw = (0, utilities_1.fullParse)(response.body, { removeNSPrefix: true });
    return parseDebugError(raw);
}
exports.debuggerListeners = debuggerListeners;
async function debuggerListen(h, debuggingMode, terminalId, ideId, requestUser, checkConflict = true, isNotifiedOnConflict = true) {
    const qs = {
        debuggingMode,
        requestUser,
        terminalId,
        ideId,
        checkConflict,
        isNotifiedOnConflict
    };
    const response = await h.request("/sap/bc/adt/debugger/listeners", {
        method: "POST",
        timeout: 360000000,
        qs
    });
    return parseDebugListeners(response.body);
}
exports.debuggerListen = debuggerListen;
async function debuggerDeleteListener(h, debuggingMode, terminalId, ideId, requestUser) {
    const qs = {
        debuggingMode,
        requestUser,
        terminalId,
        ideId,
        checkConflict: false,
        notifyConflict: true
    };
    await h.request("/sap/bc/adt/debugger/listeners", { method: "DELETE", qs });
}
exports.debuggerDeleteListener = debuggerDeleteListener;
const formatBreakpoint = (clientId) => (b) => {
    if ((0, utilities_1.isString)(b))
        return `<breakpoint xmlns:adtcore="http://www.sap.com/adt/core" kind="line" clientId="${clientId}" skipCount="0" adtcore:uri="${b}"/>`;
    const uri = `adtcore:uri="${b.uri.uri}#start=${b.uri.range.start.line}"`;
    const condition = b.condition ? `condition="${b.condition}"` : ``;
    return `<breakpoint xmlns:adtcore="http://www.sap.com/adt/core" kind="${b.kind}" clientId="${b.clientId}" skipCount="0" ${uri} ${condition}/>`;
};
const isDebuggerBreakpoint = (x) => "uri" in x;
exports.isDebuggerBreakpoint = isDebuggerBreakpoint;
async function debuggerSetBreakpoints(h, debuggingMode, terminalId, ideId, clientId, breakpoints, requestUser, scope = "external", systemDebugging = false, deactivated = false, syncScopeUri = "") {
    const syncScope = syncScopeUri ?
        `<syncScope mode="partial"><adtcore:objectReference xmlns:adtcore="http://www.sap.com/adt/core" adtcore:uri="${syncScopeUri}"/></syncScope>`
        : `<syncScope mode="full"></syncScope>`;
    const body = `<?xml version="1.0" encoding="UTF-8"?>
    <dbg:breakpoints scope="${scope}" debuggingMode="${debuggingMode}" requestUser="${requestUser}" 
        terminalId="${terminalId}" ideId="${ideId}" systemDebugging="${systemDebugging}" deactivated="${deactivated}"
        xmlns:dbg="http://www.sap.com/adt/debugger">
        ${syncScope}
        ${breakpoints.map(formatBreakpoint(clientId)).join("")}
    </dbg:breakpoints>`;
    const headers = {
        "Content-Type": "application/xml",
        Accept: "application/xml"
    };
    const response = await h.request("/sap/bc/adt/debugger/breakpoints", {
        method: "POST",
        headers,
        body
    });
    return parseBreakpoints(response.body);
}
exports.debuggerSetBreakpoints = debuggerSetBreakpoints;
async function debuggerDeleteBreakpoints(h, breakpoint, debuggingMode, terminalId, ideId, requestUser, scope = "external") {
    const headers = { Accept: "application/xml" };
    const qs = { scope, debuggingMode, requestUser, terminalId, ideId };
    await h.request(`/sap/bc/adt/debugger/breakpoints/${encodeURIComponent(breakpoint.id)}`, {
        method: "DELETE",
        headers,
        qs
    });
}
exports.debuggerDeleteBreakpoints = debuggerDeleteBreakpoints;
async function debuggerAttach(h, debuggingMode, debuggeeId, requestUser = "", dynproDebugging = true) {
    const headers = {
        Accept: "application/xml"
    };
    const qs = {
        method: "attach",
        debuggeeId,
        dynproDebugging,
        debuggingMode,
        requestUser
    };
    const response = await h.request("/sap/bc/adt/debugger", {
        method: "POST",
        headers,
        qs
    });
    return parseAttach(response.body);
}
exports.debuggerAttach = debuggerAttach;
async function debuggerSaveSettings(h, settings) {
    const headers = {
        "Content-Type": "application/xml",
        Accept: "application/xml"
    };
    const { systemDebugging = false, createExceptionObject = false, backgroundRFC = false, sharedObjectDebugging = false, showDataAging = true, updateDebugging = false } = settings;
    const body = `<?xml version="1.0" encoding="UTF-8"?>
    <dbg:settings xmlns:dbg="http://www.sap.com/adt/debugger" 
    systemDebugging="${systemDebugging}" createExceptionObject="${createExceptionObject}" 
    backgroundRFC="${backgroundRFC}" sharedObjectDebugging="${sharedObjectDebugging}" 
    showDataAging="${showDataAging}" updateDebugging="${updateDebugging}">
    </dbg:settings>`;
    const qs = { method: "setDebuggerSettings" };
    const response = await h.request("/sap/bc/adt/debugger", {
        method: "POST",
        headers,
        body,
        qs
    });
    return parseDebugSettings(response.body);
}
exports.debuggerSaveSettings = debuggerSaveSettings;
async function debuggerStack(h, semanticURIs = true) {
    const headers = { Accept: "application/xml" };
    const qs = { method: "getStack", emode: "_", semanticURIs };
    const response = await h.request("/sap/bc/adt/debugger/stack", {
        headers,
        qs
    });
    return parseStack(response.body);
}
exports.debuggerStack = debuggerStack;
async function simpleDebuggerStack(h, semanticURIs = true) {
    const headers = { Accept: "application/xml" };
    const qs = { method: "getStack", emode: "_", semanticURIs };
    const response = await h.request("/sap/bc/adt/debugger", { headers, method: "POST", qs });
    return parseStack(response.body);
}
exports.simpleDebuggerStack = simpleDebuggerStack;
async function debuggerChildVariables(h, parents = ["@ROOT", "@DATAAGING"]) {
    const headers = {
        Accept: "application/vnd.sap.as+xml;charset=UTF-8;dataname=com.sap.adt.debugger.ChildVariables",
        "Content-Type": "application/vnd.sap.as+xml; charset=UTF-8; dataname=com.sap.adt.debugger.ChildVariables"
    };
    const hierarchies = parents.map(p => `<STPDA_ADT_VARIABLE_HIERARCHY><PARENT_ID>${(0, utilities_1.encodeEntity)(p)}</PARENT_ID></STPDA_ADT_VARIABLE_HIERARCHY>`);
    const body = `<?xml version="1.0" encoding="UTF-8" ?><asx:abap version="1.0" xmlns:asx="http://www.sap.com/abapxml"><asx:values><DATA>
    <HIERARCHIES>${hierarchies.join("")}</HIERARCHIES>
    </DATA></asx:values></asx:abap>`;
    const qs = { method: "getChildVariables" };
    const response = await h.request("/sap/bc/adt/debugger", { method: "POST", headers, qs, body });
    return parseChildVariables(response.body);
}
exports.debuggerChildVariables = debuggerChildVariables;
async function debuggerVariables(h, parents) {
    const headers = {
        Accept: "application/vnd.sap.as+xml;charset=UTF-8;dataname=com.sap.adt.debugger.Variables",
        "Content-Type": "application/vnd.sap.as+xml; charset=UTF-8; dataname=com.sap.adt.debugger.Variables"
    };
    const mainBody = parents.map(p => `<STPDA_ADT_VARIABLE><ID>${(0, utilities_1.encodeEntity)(p)}</ID></STPDA_ADT_VARIABLE>`).join("");
    const body = `<?xml version="1.0" encoding="UTF-8" ?><asx:abap xmlns:asx="http://www.sap.com/abapxml" version="1.0"><asx:values>
    <DATA>${mainBody}</DATA></asx:values></asx:abap>`;
    const qs = { method: "getVariables" };
    const response = await h.request("/sap/bc/adt/debugger", { method: "POST", headers, qs, body });
    return parseVariables(response.body);
}
exports.debuggerVariables = debuggerVariables;
async function debuggerStep(h, method, uri) {
    const headers = { Accept: "application/xml" };
    const response = await h.request("/sap/bc/adt/debugger", { method: "POST", headers, qs: { method, uri } });
    return parseStep(response.body);
}
exports.debuggerStep = debuggerStep;
async function debuggerGoToStack(h, stackUri) {
    if (!stackUri.match(/^\/sap\/bc\/adt\/debugger\/stack\/type\/[\w]+\/position\/\d+$/))
        throw (0, __1.adtException)(`Invalid stack URL: ${stackUri}`);
    await h.request(stackUri, { method: "PUT" });
}
exports.debuggerGoToStack = debuggerGoToStack;
async function debuggerGoToStackOld(h, position) {
    const qs = { method: "setStackPosition", position };
    await h.request(`/sap/bc/adt/debugger`, { method: "POST", qs });
}
exports.debuggerGoToStackOld = debuggerGoToStackOld;
async function debuggerSetVariableValue(h, variableName, value) {
    const qs = { variableName };
    const resp = await h.request(`/sap/bc/adt/debugger?method=setVariableValue`, { method: "POST", qs, body: value });
    return resp.body;
}
exports.debuggerSetVariableValue = debuggerSetVariableValue;


/***/ }),

/***/ "./build/api/delete.js":
/*!*****************************!*\
  !*** ./build/api/delete.js ***!
  \*****************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.deleteObject = exports.objectRegistrationInfo = void 0;
const AdtException_1 = __webpack_require__(/*! ../AdtException */ "./build/AdtException.js");
const utilities_1 = __webpack_require__(/*! ../utilities */ "./build/utilities.js");
async function objectRegistrationInfo(h, objectUrl) {
    (0, AdtException_1.ValidateObjectUrl)(objectUrl);
    const response = await h.request("/sap/bc/adt/sscr/registration/objects", {
        qs: { uri: objectUrl }
    });
    const raw = (0, utilities_1.fullParse)(response.body)["reg:objectRegistrationResponse"];
    return {
        developer: (0, utilities_1.xmlNodeAttr)(raw["reg:developer"]),
        object: (0, utilities_1.xmlNodeAttr)(raw["reg:object"]),
        ...(0, utilities_1.xmlNodeAttr)(raw)
    };
}
exports.objectRegistrationInfo = objectRegistrationInfo;
async function deleteObject(h, objectUrl, lockHandle, transport) {
    (0, AdtException_1.ValidateObjectUrl)(objectUrl);
    (0, AdtException_1.ValidateStateful)(h);
    const qs = { lockHandle };
    if (transport)
        qs.corrNr = transport;
    const method = "DELETE";
    // no return value, will throw on failure
    await h.request(objectUrl, { method, qs });
}
exports.deleteObject = deleteObject;


/***/ }),

/***/ "./build/api/discovery.js":
/*!********************************!*\
  !*** ./build/api/discovery.js ***!
  \********************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.objectTypes = exports.adtCompatibilityGraph = exports.adtCoreDiscovery = exports.adtDiscovery = void 0;
const utilities_1 = __webpack_require__(/*! ../utilities */ "./build/utilities.js");
async function adtDiscovery(h) {
    const response = await h.request("/sap/bc/adt/discovery");
    const ret = (0, utilities_1.fullParse)(response.body);
    const objects = (0, utilities_1.xmlArray)(ret, "app:service", "app:workspace").map((o) => {
        return {
            collection: (0, utilities_1.xmlArray)(o, "app:collection").map((c) => {
                return {
                    href: c["@_href"],
                    templateLinks: (0, utilities_1.xmlArray)(c, "adtcomp:templateLinks", "adtcomp:templateLink").map(utilities_1.xmlNodeAttr),
                    title: c["atom:title"]
                };
            }),
            title: o["atom:title"]
        };
    });
    return objects;
}
exports.adtDiscovery = adtDiscovery;
async function adtCoreDiscovery(h) {
    const response = await h.request("/sap/bc/adt/core/discovery");
    const ret = (0, utilities_1.fullParse)(response.body);
    const workspaces = (0, utilities_1.xmlArray)(ret, "app:service", "app:workspace").filter((w) => w["app:collection"]);
    return workspaces.map((w) => {
        const collection = w["app:collection"];
        return {
            collection: {
                category: collection["atom:category"]["@_term"],
                href: collection["@_href"],
                title: collection["atom:title"]
            },
            title: w["atom:title"]
        };
    });
}
exports.adtCoreDiscovery = adtCoreDiscovery;
async function adtCompatibilityGraph(h) {
    const response = await h.request("/sap/bc/adt/compatibility/graph");
    const ret = (0, utilities_1.fullParse)(response.body);
    const edges = (0, utilities_1.xmlArray)(ret, "compatibility:graph", "edges", "edge").map((e) => {
        return {
            sourceNode: (0, utilities_1.xmlNodeAttr)(e.sourceNode),
            targetNode: (0, utilities_1.xmlNodeAttr)(e.targetNode)
        };
    });
    const nodes = (0, utilities_1.xmlArray)(ret, "compatibility:graph", "nodes", "node").map(utilities_1.xmlNodeAttr);
    return { edges, nodes };
}
exports.adtCompatibilityGraph = adtCompatibilityGraph;
async function objectTypes(h) {
    const qs = { maxItemCount: 999, name: "*", data: "usedByProvider" };
    const response = await h.request("/sap/bc/adt/repository/informationsystem/objecttypes", { qs });
    const ret = (0, utilities_1.parse)(response.body);
    const types = (0, utilities_1.xmlArray)(ret, "nameditem:namedItemList", "nameditem:namedItem")
        .map((n) => {
        const data = n["nameditem:data"] || "";
        const fields = data.split(";").reduce((acc, cur) => {
            const parts = cur.split(":", 2);
            acc[parts[0]] = parts[1] || "";
            return acc;
        }, {});
        let o;
        if (fields.type && fields.usedBy)
            o = {
                name: n["nameditem:name"],
                description: n["nameditem:description"],
                type: fields.type,
                usedBy: fields.usedBy.split(",")
            };
        return o;
    })
        .filter(x => x);
    return types;
}
exports.objectTypes = objectTypes;


/***/ }),

/***/ "./build/api/feeds.js":
/*!****************************!*\
  !*** ./build/api/feeds.js ***!
  \****************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.dumps = exports.feeds = void 0;
const utilities_1 = __webpack_require__(/*! ../utilities */ "./build/utilities.js");
const parseFeeds = (body) => {
    const raw = (0, utilities_1.fullParse)(body, { removeNSPrefix: true });
    const parseDt = (dt) => {
        const { "@_id": id, label = "" } = dt;
        const operators = (0, utilities_1.xmlArray)(dt, "operators", "operator");
        return { id, label, operators: operators.map((o) => o["@_id"]) };
    };
    const parseAttribute = (at) => {
        var _a;
        const dataType = (_a = at.dataType) === null || _a === void 0 ? void 0 : _a["@_id"];
        return { ...parseDt(at), dataType };
    };
    const parseOperators = (op) => ({ ...(0, utilities_1.xmlNodeAttr)(op), label: op.label });
    const feeds = (0, utilities_1.xmlArray)(raw, "feed", "entry").map((f) => {
        var _a, _b;
        const author = (0, utilities_1.xmlNode)(f, "author", "name");
        const { href, type: accept } = (0, utilities_1.xmlNodeAttr)(f["link"]);
        const { published, summary, title, updated } = f;
        const ed = f.extendedData;
        const refresh = (0, utilities_1.xmlNodeAttr)((_a = ed === null || ed === void 0 ? void 0 : ed.refresh) === null || _a === void 0 ? void 0 : _a.interval);
        const paging = (_b = ed === null || ed === void 0 ? void 0 : ed.paging) === null || _b === void 0 ? void 0 : _b['@_size'];
        const { queryIsObligatory, queryDepth } = ed;
        const operators = (0, utilities_1.xmlArray)(ed, "operators", "operator").map(parseOperators);
        const dataTypes = (0, utilities_1.xmlArray)(ed, "dataTypes", "dataType").map(parseDt);
        const attributes = (0, utilities_1.xmlArray)(ed, "attributes", "attribute").map(parseAttribute);
        const queryVariants = (0, utilities_1.xmlArray)(ed, "queryVariants", "queryVariant").map(utilities_1.xmlNodeAttr);
        return {
            author, href, published: (0, utilities_1.parseJsonDate)(published), summary, title, updated: (0, utilities_1.parseJsonDate)(updated), accept, refresh, paging,
            operators, dataTypes, attributes,
            queryIsObligatory, queryDepth, queryVariants
        };
    });
    return feeds;
};
const parseDumps = (body) => {
    var _a;
    const raw = (_a = (0, utilities_1.fullParse)(body, { removeNSPrefix: true })) === null || _a === void 0 ? void 0 : _a.feed;
    const { href } = (0, utilities_1.xmlNodeAttr)(raw === null || raw === void 0 ? void 0 : raw.link);
    const { title, updated } = raw;
    const dumps = (0, utilities_1.xmlArray)(raw, "entry").map((e) => {
        const { category, id, author: { name: author }, summary: { "#text": text, "@_type": type } } = e;
        const links = (0, utilities_1.xmlArray)(e, "link").map(utilities_1.xmlNodeAttr);
        return { categories: category.map(utilities_1.xmlNodeAttr), links, id, author, text: text, type };
    });
    return { href, title, updated: (0, utilities_1.parseJsonDate)(updated), dumps };
};
async function feeds(h) {
    const headers = { Accept: "application/atom+xml;type=feed" };
    const response = await h.request("/sap/bc/adt/feeds", { method: "GET", headers });
    return parseFeeds(response.body);
}
exports.feeds = feeds;
async function dumps(h, query = "") {
    const headers = { Accept: "application/atom+xml;type=feed" };
    const qs = {};
    if (query)
        qs["$query"] = query;
    const response = await h.request("/sap/bc/adt/runtime/dumps", { method: "GET", qs, headers });
    return parseDumps(response.body);
}
exports.dumps = dumps;


/***/ }),

/***/ "./build/api/index.js":
/*!****************************!*\
  !*** ./build/api/index.js ***!
  \****************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
__exportStar(__webpack_require__(/*! ./atc */ "./build/api/atc.js"), exports);
__exportStar(__webpack_require__(/*! ./cds */ "./build/api/cds.js"), exports);
__exportStar(__webpack_require__(/*! ./delete */ "./build/api/delete.js"), exports);
__exportStar(__webpack_require__(/*! ./discovery */ "./build/api/discovery.js"), exports);
__exportStar(__webpack_require__(/*! ./nodeContents */ "./build/api/nodeContents.js"), exports);
__exportStar(__webpack_require__(/*! ./transports */ "./build/api/transports.js"), exports);
__exportStar(__webpack_require__(/*! ./objectcreator */ "./build/api/objectcreator.js"), exports);
__exportStar(__webpack_require__(/*! ./objectstructure */ "./build/api/objectstructure.js"), exports);
__exportStar(__webpack_require__(/*! ./activate */ "./build/api/activate.js"), exports);
__exportStar(__webpack_require__(/*! ./objectcontents */ "./build/api/objectcontents.js"), exports);
__exportStar(__webpack_require__(/*! ./revisions */ "./build/api/revisions.js"), exports);
__exportStar(__webpack_require__(/*! ./refactor */ "./build/api/refactor.js"), exports);
__exportStar(__webpack_require__(/*! ./search */ "./build/api/search.js"), exports);
__exportStar(__webpack_require__(/*! ./syntax */ "./build/api/syntax.js"), exports);
__exportStar(__webpack_require__(/*! ./unittest */ "./build/api/unittest.js"), exports);
__exportStar(__webpack_require__(/*! ./urlparser */ "./build/api/urlparser.js"), exports);
__exportStar(__webpack_require__(/*! ./abapgit */ "./build/api/abapgit.js"), exports);
__exportStar(__webpack_require__(/*! ./tablecontents */ "./build/api/tablecontents.js"), exports);
__exportStar(__webpack_require__(/*! ./feeds */ "./build/api/feeds.js"), exports);
__exportStar(__webpack_require__(/*! ./debugger */ "./build/api/debugger.js"), exports);
__exportStar(__webpack_require__(/*! ./traces */ "./build/api/traces.js"), exports);


/***/ }),

/***/ "./build/api/nodeContents.js":
/*!***********************************!*\
  !*** ./build/api/nodeContents.js ***!
  \***********************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.nodeContents = exports.isNodeParent = void 0;
const utilities_1 = __webpack_require__(/*! ../utilities */ "./build/utilities.js");
function isNodeParent(t) {
    return t === "DEVC/K" || t === "PROG/P" || t === "FUGR/F" || t === "PROG/PI";
}
exports.isNodeParent = isNodeParent;
const decodeComponents = (keys) => (x) => {
    if ((0, utilities_1.isObject)(x)) {
        const o = keys.reduce((acc, key) => {
            const v = x[key] || "";
            return (0, utilities_1.isString)(v) ? { ...acc, [key]: v } : acc;
        }, {});
        return { ...x, ...o };
    }
    return x;
};
const parsePackageResponse = (data) => {
    let nodes = [];
    let categories = [];
    let objectTypes = [];
    if (data) {
        const xml = (0, utilities_1.parse)(data);
        const root = xml["asx:abap"]["asx:values"].DATA;
        nodes = (0, utilities_1.xmlArray)(root, "TREE_CONTENT", "SEU_ADT_REPOSITORY_OBJ_NODE");
        for (const node of nodes) {
            if (!(0, utilities_1.isString)(node.OBJECT_NAME)) {
                node.OBJECT_NAME = (node.OBJECT_NAME || "").toString();
                node.TECH_NAME = (node.TECH_NAME || "").toString();
            }
            node.DESCRIPTION = node.DESCRIPTION || "";
        }
        categories = (0, utilities_1.xmlArray)(root, "CATEGORIES", "SEU_ADT_OBJECT_CATEGORY_INFO");
        objectTypes = (0, utilities_1.xmlArray)(root, "OBJECT_TYPES", "SEU_ADT_OBJECT_TYPE_INFO")
            .map(decodeComponents(["OBJECT_TYPE_LABEL"]))
            .map(ot => {
            const o = ot;
            return o.OBJECT_TYPE_LABEL === "<no type text>" &&
                o.OBJECT_TYPE === "FUGR/I"
                ? { ...o, OBJECT_TYPE_LABEL: "Includes" }
                : o;
        });
    }
    return {
        categories,
        nodes,
        objectTypes
    };
};
// tslint:disable: variable-name
async function nodeContents(h, parent_type, parent_name, user_name, parent_tech_name, rebuild_tree, parentnodes) {
    const qs = {
        parent_type,
        withShortDescriptions: true
    };
    const options = { method: "POST", qs };
    if (parent_name)
        qs.parent_name = parent_name;
    if (parent_tech_name)
        qs.parent_tech_name = parent_tech_name;
    if (user_name)
        qs.user_name = user_name;
    if (rebuild_tree)
        qs.rebuild_tree = "X";
    if (parentnodes === null || parentnodes === void 0 ? void 0 : parentnodes.length)
        options.body = `<?xml version="1.0" encoding="UTF-8" ?><asx:abap version="1.0" xmlns:asx="http://www.sap.com/abapxml">
<asx:values><DATA>
${parentnodes
            .map(n => `<TV_NODEKEY>${n.toString().padStart(6, "0")}</TV_NODEKEY>`)
            .join("")}
<TV_NODEKEY>000000</TV_NODEKEY>
</DATA></asx:values></asx:abap>
`;
    const response = await h.request("/sap/bc/adt/repository/nodestructure", options);
    return parsePackageResponse(response.body);
}
exports.nodeContents = nodeContents;


/***/ }),

/***/ "./build/api/objectcontents.js":
/*!*************************************!*\
  !*** ./build/api/objectcontents.js ***!
  \*************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.unLock = exports.lock = exports.setObjectSource = exports.getObjectSource = void 0;
const AdtException_1 = __webpack_require__(/*! ../AdtException */ "./build/AdtException.js");
const utilities_1 = __webpack_require__(/*! ../utilities */ "./build/utilities.js");
async function getObjectSource(h, objectSourceUrl, options) {
    (0, AdtException_1.ValidateObjectUrl)(objectSourceUrl);
    const config = {};
    const { gitPassword, gitUser, version } = options || {};
    if (gitUser || gitPassword) {
        config.headers = {};
        if (gitUser)
            config.headers.Username = gitUser;
        if (gitPassword)
            config.headers.Password = (0, utilities_1.btoa)(gitPassword);
    }
    if (version)
        config.qs = { version };
    const response = await h.request(objectSourceUrl, config);
    return response.body;
}
exports.getObjectSource = getObjectSource;
async function setObjectSource(h, objectSourceUrl, source, lockHandle, transport) {
    (0, AdtException_1.ValidateObjectUrl)(objectSourceUrl);
    (0, AdtException_1.ValidateStateful)(h);
    const qs = { lockHandle };
    const ctype = source.match(/^<\?xml\s/i)
        ? "application/*"
        : "text/plain; charset=utf-8";
    if (transport)
        qs.corrNr = transport;
    await h.request(objectSourceUrl, {
        body: source,
        headers: { "content-type": ctype },
        method: "PUT",
        qs
    });
}
exports.setObjectSource = setObjectSource;
async function lock(h, objectUrl, accessMode = "MODIFY") {
    (0, AdtException_1.ValidateObjectUrl)(objectUrl);
    (0, AdtException_1.ValidateStateful)(h);
    const qs = { _action: "LOCK", accessMode };
    const response = await h.request(objectUrl, {
        headers: {
            Accept: "application/*,application/vnd.sap.as+xml;charset=UTF-8;dataname=com.sap.adt.lock.result"
        },
        method: "POST",
        qs
    });
    const raw = (0, utilities_1.parse)(response.body);
    const locks = (0, utilities_1.xmlArray)(raw, "asx:abap", "asx:values", "DATA");
    return locks[0];
}
exports.lock = lock;
async function unLock(h, objectUrl, lockHandle) {
    (0, AdtException_1.ValidateObjectUrl)(objectUrl);
    const qs = {
        _action: "UNLOCK",
        lockHandle: encodeURIComponent(lockHandle)
    };
    const response = await h.request(objectUrl, {
        method: "POST",
        qs
    });
    return response.body;
}
exports.unLock = unLock;


/***/ }),

/***/ "./build/api/objectcreator.js":
/*!************************************!*\
  !*** ./build/api/objectcreator.js ***!
  \************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.parentTypeId = exports.isCreatableTypeId = exports.isNonGroupType = exports.CreatableTypes = exports.isPackageType = exports.isGroupType = exports.createTestInclude = exports.createObject = exports.validateNewObject = exports.objectPath = exports.loadTypes = exports.isBindingOptions = exports.isPackageOptions = exports.hasPackageOptions = exports.BindinTypes = void 0;
const sprintf_js_1 = __webpack_require__(/*! sprintf-js */ "./node_modules/sprintf-js/src/sprintf.js");
const AdtException_1 = __webpack_require__(/*! ../AdtException */ "./build/AdtException.js");
const utilities_1 = __webpack_require__(/*! ../utilities */ "./build/utilities.js");
exports.BindinTypes = [
    { description: "Odata V2 - Web API", bindingtype: "ODATA", category: "0" },
    { description: "Odata V2 - UI", bindingtype: "ODATA", category: "1" }
];
const hasPackageOptions = (o) => !!(o === null || o === void 0 ? void 0 : o.swcomp);
exports.hasPackageOptions = hasPackageOptions;
const isPackageOptions = (o) => (o === null || o === void 0 ? void 0 : o.objtype) === "DEVC/K" && (0, exports.hasPackageOptions)(o);
exports.isPackageOptions = isPackageOptions;
const isBindingOptions = (o) => (o === null || o === void 0 ? void 0 : o.objtype) === "SRVB/SVB" &&
    !!(o === null || o === void 0 ? void 0 : o.service) &&
    !!(o === null || o === void 0 ? void 0 : o.bindingtype);
exports.isBindingOptions = isBindingOptions;
const xmlEntry = (value, key) => value ? `<${key}>${(0, utilities_1.encodeEntity)(value)}</${key}>}` : `<${key}/>`;
const xmlAttribute = (value, key) => value ? `${key}="${(0, utilities_1.encodeEntity)(value)}"` : ``;
function createBodyPackage(options) {
    const responsible = `adtcore:responsible="${options.responsible}"`;
    const compname = xmlAttribute(options.swcomp, `pak:name`);
    const description = xmlAttribute(options.description, "adtcore:description");
    const superp = xmlAttribute(options.parentName, "adtcore:name");
    const pkgname = xmlAttribute(options.name, "adtcore:name");
    const pkgtype = xmlAttribute(options.packagetype, "pak:packageType");
    return `<?xml version="1.0" encoding="UTF-8"?>
<pak:package xmlns:pak="http://www.sap.com/adt/packages"
xmlns:adtcore="http://www.sap.com/adt/core" ${description}
${pkgname} adtcore:type="DEVC/K" adtcore:version="active" ${responsible}>
<adtcore:packageRef  adtcore:name="YMU_RAP"/>
<pak:attributes ${pkgtype}/>
<pak:superPackage ${superp}/>
<pak:applicationComponent/>
<pak:transport>
 <pak:softwareComponent ${compname}/>
 <pak:transportLayer pak:name="${(0, utilities_1.encodeEntity)(options.transportLayer)}"/>
</pak:transport>
<pak:translation/>
<pak:useAccesses/>
<pak:packageInterfaces/>
<pak:subPackages/>
</pak:package>`;
}
function createBodyFunc(options, type) {
    const responsible = `adtcore:responsible="${options.responsible}"`;
    return `<?xml version="1.0" encoding="UTF-8"?>
  <${type.rootName} ${type.nameSpace} 
  xmlns:adtcore="http://www.sap.com/adt/core"
  adtcore:description="${(0, utilities_1.encodeEntity)(options.description)}"
  adtcore:name="${options.name}" adtcore:type="${options.objtype}">
  <adtcore:containerRef adtcore:name="${options.parentName}" 
    adtcore:type="FUGR/F"
    adtcore:uri="${options.parentPath}" />
</${type.rootName}>`;
}
function createBodySimple(options, type, body = "") {
    const responsible = `adtcore:responsible="${options.responsible}"`;
    body = body || `<adtcore:packageRef adtcore:name="${options.parentName}"/>`;
    return `<?xml version="1.0" encoding="UTF-8"?>
        <${type.rootName} ${type.nameSpace}
          xmlns:adtcore="http://www.sap.com/adt/core"
          adtcore:description="${(0, utilities_1.encodeEntity)(options.description)}"
          adtcore:name="${options.name}" adtcore:type="${options.objtype}"
          ${responsible} ${type.extra || ""}>
          ${body}
        </${type.rootName}>`;
}
function createBodyBinding(options, type) {
    const body = `<adtcore:packageRef adtcore:name="${options.parentName}"/>
      <srvb:services srvb:name="${options.name}">
          <srvb:content srvb:version="0001">
              <srvb:serviceDefinition adtcore:name="${options.service}"/>
          </srvb:content>
      </srvb:services>
      <srvb:binding srvb:category="0" srvb:type="${options.bindingtype}" srvb:version="V2">
          <srvb:implementation adtcore:name=""/>
      </srvb:binding>`;
    return createBodySimple(options, type, body);
}
function createBody(options, type) {
    switch (type.typeId) {
        case "DEVC/K":
            if ((0, exports.isPackageOptions)(options))
                return createBodyPackage(options);
            throw (0, AdtException_1.adtException)("Can't create a Package with incomplete data");
        case "FUGR/FF":
        case "FUGR/I":
            return createBodyFunc(options, type);
        case "SRVB/SVB":
            if ((0, exports.isBindingOptions)(options))
                return createBodyBinding(options, type);
            throw (0, AdtException_1.adtException)("Can't create service binding with incomplete data");
        default:
            return createBodySimple(options, type);
    }
}
async function loadTypes(h) {
    const response = await h.request("/sap/bc/adt/repository/typestructure", {
        method: "POST"
    });
    const raw = (0, utilities_1.fullParse)(response.body);
    return (0, utilities_1.xmlArray)(raw, "asx:abap", "asx:values", "DATA", "SEU_ADT_OBJECT_TYPE_DESCRIPTOR").map((x) => {
        return { ...x, CAPABILITIES: (0, utilities_1.xmlArray)(x, "CAPABILITIES", "SEU_ACTION") };
    });
}
exports.loadTypes = loadTypes;
function objectPath(typeIdOrObjectOptions, name, parentName) {
    if (!(0, utilities_1.isString)(typeIdOrObjectOptions))
        return objectPath(typeIdOrObjectOptions.objtype, typeIdOrObjectOptions.name, typeIdOrObjectOptions.parentName);
    const encodedname = encodeURIComponent(name || "");
    const ot = exports.CreatableTypes.get(typeIdOrObjectOptions);
    if (!ot)
        return "";
    return ("/sap/bc/adt/" +
        (0, sprintf_js_1.sprintf)(ot.creationPath, encodeURIComponent(parentName || "")) +
        "/" +
        encodedname);
}
exports.objectPath = objectPath;
async function validateNewObject(h, options) {
    const ot = exports.CreatableTypes.get(options.objtype);
    if (!ot)
        throw (0, AdtException_1.adtException)("Unsupported object type");
    if (!ot.validationPath)
        throw (0, AdtException_1.adtException)(`Validation not supported for object ${ot} ${options.objname}`);
    const response = await h.request("/sap/bc/adt/" + ot.validationPath, {
        method: "POST",
        qs: options
    });
    const raw = (0, utilities_1.fullParse)(response.body);
    const results = (0, utilities_1.xmlArray)(raw, "asx:abap", "asx:values", "DATA");
    const record = (results && results[0]) || {};
    const { SEVERITY, SHORT_TEXT, CHECK_RESULT } = record;
    if (SEVERITY === "ERROR")
        throw (0, AdtException_1.adtException)(record.SHORT_TEXT);
    return {
        SEVERITY,
        SHORT_TEXT,
        success: !!CHECK_RESULT || !!SEVERITY
    };
}
exports.validateNewObject = validateNewObject;
async function createObject(h, options) {
    const ot = exports.CreatableTypes.get(options.objtype);
    if (!ot)
        throw (0, AdtException_1.adtException)("Unsupported object type");
    const url = "/sap/bc/adt/" +
        (0, sprintf_js_1.sprintf)(ot.creationPath, encodeURIComponent(options.parentName.toLowerCase()));
    options.responsible = (options.responsible || h.username).toUpperCase();
    const body = createBody(options, ot);
    const qs = {};
    if (options.transport)
        qs.corrNr = options.transport;
    // will raise exceptions on failure
    await h.request(url, {
        body,
        headers: { "Content-Type": "application/*" },
        method: "POST",
        qs
    });
}
exports.createObject = createObject;
async function createTestInclude(h, clas, lockHandle, corrNr) {
    const body = `<?xml version="1.0" encoding="UTF-8"?><class:abapClassInclude
  xmlns:class="http://www.sap.com/adt/oo/classes" xmlns:adtcore="http://www.sap.com/adt/core"
  adtcore:name="dummy" class:includeType="testclasses"/>`;
    await h.request(`/sap/bc/adt/oo/classes/${encodeURIComponent(clas)}/includes`, {
        body,
        headers: { "Content-Type": "application/*" },
        method: "POST",
        qs: { lockHandle, corrNr }
    });
}
exports.createTestInclude = createTestInclude;
function isGroupType(type) {
    return type === "FUGR/FF" || type === "FUGR/I";
}
exports.isGroupType = isGroupType;
function isPackageType(type) {
    return type === "DEVC/K";
}
exports.isPackageType = isPackageType;
exports.CreatableTypes = new Map();
function isNonGroupType(type) {
    return exports.CreatableTypes.has(type) && !isGroupType(type);
}
exports.isNonGroupType = isNonGroupType;
function isCreatableTypeId(type) {
    return isGroupType(type) || isNonGroupType(type);
}
exports.isCreatableTypeId = isCreatableTypeId;
function parentTypeId(type) {
    return isGroupType(type) ? "FUGR/F" : "DEVC/K";
}
exports.parentTypeId = parentTypeId;
const ctypes = [
    {
        creationPath: "programs/programs",
        label: "Program",
        nameSpace: 'xmlns:program="http://www.sap.com/adt/programs/programs"',
        rootName: "program:abapProgram",
        typeId: "PROG/P",
        validationPath: "programs/validation",
        maxLen: 30
    },
    {
        creationPath: "oo/classes",
        label: "Class",
        nameSpace: 'xmlns:class="http://www.sap.com/adt/oo/classes"',
        rootName: "class:abapClass",
        typeId: "CLAS/OC",
        validationPath: "oo/validation/objectname",
        maxLen: 30
    },
    {
        creationPath: "oo/interfaces",
        label: "Interface",
        nameSpace: 'xmlns:intf="http://www.sap.com/adt/oo/interfaces"',
        rootName: "intf:abapInterface",
        typeId: "INTF/OI",
        validationPath: "oo/validation/objectname",
        maxLen: 30
    },
    {
        creationPath: "programs/includes",
        label: "Include",
        nameSpace: 'xmlns:include="http://www.sap.com/adt/programs/includes"',
        rootName: "include:abapInclude",
        typeId: "PROG/I",
        validationPath: "includes/validation",
        maxLen: 30
    },
    {
        creationPath: "functions/groups",
        label: "Function Group",
        nameSpace: 'xmlns:group="http://www.sap.com/adt/functions/groups"',
        rootName: "group:abapFunctionGroup",
        typeId: "FUGR/F",
        validationPath: "functions/validation",
        maxLen: 26
    },
    {
        creationPath: "functions/groups/%s/fmodules",
        label: "Function module",
        nameSpace: 'xmlns:fmodule="http://www.sap.com/adt/functions/fmodules"',
        rootName: "fmodule:abapFunctionModule",
        typeId: "FUGR/FF",
        validationPath: "functions/validation",
        maxLen: 30
    },
    {
        creationPath: "functions/groups/%s/includes",
        label: "Function group include",
        nameSpace: 'xmlns:finclude="http://www.sap.com/adt/functions/fincludes"',
        rootName: "finclude:abapFunctionGroupInclude",
        typeId: "FUGR/I",
        validationPath: "functions/validation",
        maxLen: 3
    },
    {
        creationPath: "ddic/ddl/sources",
        label: "CDS Data Definitions",
        nameSpace: 'xmlns:ddl="http://www.sap.com/adt/ddic/ddlsources"',
        rootName: "ddl:ddlSource",
        typeId: "DDLS/DF",
        validationPath: "ddic/ddl/validation",
        maxLen: 30
    },
    {
        creationPath: "acm/dcl/sources",
        label: "CDS Access Control",
        nameSpace: 'xmlns:dcl="http://www.sap.com/adt/acm/dclsources"',
        rootName: "dcl:dclSource",
        typeId: "DCLS/DL",
        validationPath: "acm/dcl/validation",
        maxLen: 30
    },
    {
        creationPath: "ddic/ddlx/sources",
        label: "CDS metadata extensions",
        nameSpace: 'xmlns:ddlx="http://www.sap.com/adt/ddic/ddlxsources"',
        rootName: "ddlx:ddlxSource",
        typeId: "DDLX/EX",
        validationPath: "ddic/ddlx/sources/validation",
        maxLen: 30
    },
    {
        creationPath: "ddic/ddla/sources",
        label: "CDS Annotation definitions",
        nameSpace: 'xmlns:ddla="http://www.sap.com/adt/ddic/ddlasources"',
        rootName: "ddla:ddlaSource",
        typeId: "DDLA/ADF",
        validationPath: "ddic/ddla/sources/validation",
        maxLen: 30
    },
    {
        creationPath: "packages",
        label: "Package",
        nameSpace: 'xmlns:pak="http://www.sap.com/adt/packages"',
        rootName: "pak:package",
        typeId: "DEVC/K",
        validationPath: "packages/validation",
        maxLen: 30
    },
    {
        creationPath: "ddic/tables",
        label: "Table",
        nameSpace: 'xmlns:blue="http://www.sap.com/wbobj/blue"',
        rootName: "blue:blueSource",
        typeId: "TABL/DT",
        validationPath: "ddic/tables/validation",
        maxLen: 16
    },
    {
        creationPath: "ddic/srvd/sources",
        label: "Service definition",
        nameSpace: 'xmlns:srvd="http://www.sap.com/adt/ddic/srvdsources"',
        rootName: "srvd:srvdSource",
        typeId: "SRVD/SRV",
        validationPath: "ddic/srvd/sources/validation",
        extra: `srvd:srvdSourceType="S"`,
        maxLen: 30
    },
    {
        creationPath: "aps/iam/auth",
        rootName: "auth:auth",
        nameSpace: 'xmlns:auth="http://www.sap.com/iam/auth"',
        label: "Authorization field",
        typeId: "AUTH",
        validationPath: "aps/iam/auth/validation",
        maxLen: 10
    },
    {
        creationPath: "aps/iam/suso",
        validationPath: "aps/iam/suso/validation",
        rootName: "susob:suso",
        nameSpace: `xmlns:susob="http://www.sap.com/iam/suso"`,
        label: "Authorization object",
        typeId: "SUSO/B",
        maxLen: 10
    },
    {
        creationPath: "ddic/dataelements",
        validationPath: "ddic/dataelements/validation",
        rootName: "blue:wbobj",
        nameSpace: 'xmlns:blue="http://www.sap.com/wbobj/dictionary/dtel"',
        label: "Data Element",
        typeId: "DTEL/DE",
        maxLen: 30
    },
    {
        creationPath: "businessservices/bindings",
        validationPath: "businessservices/bindings/validation",
        rootName: "srvb:serviceBinding",
        nameSpace: 'xmlns:srvb="http://www.sap.com/adt/ddic/ServiceBindings"',
        label: "Service binding",
        typeId: "SRVB/SVB",
        maxLen: 26
    },
    {
        creationPath: "messageclass",
        validationPath: "messageclass/validation",
        rootName: "mc:messageClass",
        nameSpace: `xmlns:mc="http://www.sap.com/adt/MessageClass"`,
        label: "Message class",
        typeId: "MSAG/N",
        maxLen: 20
    }
];
ctypes.forEach(v => exports.CreatableTypes.set(v.typeId, v));


/***/ }),

/***/ "./build/api/objectstructure.js":
/*!**************************************!*\
  !*** ./build/api/objectstructure.js ***!
  \**************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.objectStructure = exports.isClassStructure = exports.isClassMetaData = void 0;
const AdtException_1 = __webpack_require__(/*! ../AdtException */ "./build/AdtException.js");
const utilities_1 = __webpack_require__(/*! ../utilities */ "./build/utilities.js");
function isClassMetaData(meta) {
    return meta["class:visibility"] !== undefined;
}
exports.isClassMetaData = isClassMetaData;
function isClassStructure(struc) {
    return isClassMetaData(struc.metaData);
}
exports.isClassStructure = isClassStructure;
const convertIncludes = (i) => {
    const imeta = (0, utilities_1.xmlNodeAttr)(i);
    const links = i["atom:link"].map(utilities_1.xmlNodeAttr);
    return { ...imeta, links };
};
async function objectStructure(h, objectUrl, version) {
    (0, AdtException_1.ValidateObjectUrl)(objectUrl);
    const qs = version ? { version } : {};
    const response = await h.request(objectUrl, { qs });
    const res = (0, utilities_1.fullParse)(response.body);
    // return type depends on object type, but always have a single root
    const root = (0, utilities_1.xmlRoot)(res);
    const attr = (0, utilities_1.xmlNodeAttr)(root);
    attr["adtcore:changedAt"] = Date.parse(attr["adtcore:changedAt"]) || 0;
    attr["adtcore:createdAt"] = Date.parse(attr["adtcore:createdAt"]) || 0;
    const links = (0, utilities_1.xmlArray)(root, "atom:link").map(utilities_1.xmlNodeAttr);
    const metaData = attr;
    if (isClassMetaData(metaData)) {
        const includes = (0, utilities_1.xmlArray)(root, "class:include").map(convertIncludes);
        return { objectUrl, metaData, includes, links };
    }
    return { objectUrl, metaData, links };
}
exports.objectStructure = objectStructure;


/***/ }),

/***/ "./build/api/refactor.js":
/*!*******************************!*\
  !*** ./build/api/refactor.js ***!
  \*******************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.extractMethodExecute = exports.extractMethodPreview = exports.extractMethodEvaluate = exports.renameExecute = exports.renamePreview = exports.renameEvaluate = exports.fixEdits = exports.fixProposals = void 0;
const html_entities_1 = __webpack_require__(/*! html-entities */ "./node_modules/html-entities/dist/commonjs/index.js");
const _1 = __webpack_require__(/*! . */ "./build/api/index.js");
const AdtException_1 = __webpack_require__(/*! ../AdtException */ "./build/AdtException.js");
const utilities_1 = __webpack_require__(/*! ../utilities */ "./build/utilities.js");
const urlparser_1 = __webpack_require__(/*! ./urlparser */ "./build/api/urlparser.js");
async function fixProposals(h, uri, body, line, column) {
    const qs = { uri: `${uri}#start=${line},${column}` };
    const headers = { "Content-Type": "application/*", Accept: "application/*" };
    const response = await h.request("/sap/bc/adt/quickfixes/evaluation", {
        method: "POST",
        qs,
        headers,
        body
    });
    const raw = (0, utilities_1.fullParse)(response.body, { processEntities: false });
    const rawResults = (0, utilities_1.xmlArray)(raw, "qf:evaluationResults", "evaluationResult");
    return rawResults.map(x => {
        const attrs = (0, utilities_1.xmlNodeAttr)((0, utilities_1.xmlNode)(x, "adtcore:objectReference"));
        const userContent = (0, html_entities_1.decode)((0, utilities_1.xmlNode)(x, "userContent") || "");
        return {
            ...attrs,
            "adtcore:name": attrs["adtcore:name"],
            "adtcore:description": attrs["adtcore:description"],
            uri,
            line,
            column,
            userContent
        };
    });
}
exports.fixProposals = fixProposals;
async function fixEdits(h, proposal, source) {
    if (!proposal["adtcore:uri"].match(/\/sap\/bc\/adt\/quickfixes/))
        throw (0, AdtException_1.adtException)("Invalid fix proposal");
    const body = `<?xml version="1.0" encoding="UTF-8"?>
  <quickfixes:proposalRequest xmlns:quickfixes="http://www.sap.com/adt/quickfixes"
     xmlns:adtcore="http://www.sap.com/adt/core">
    <input>
      <content>${(0, utilities_1.encodeEntity)(source)}</content>
      <adtcore:objectReference adtcore:uri="${proposal.uri}#start=${proposal.line},${proposal.column}"/>
    </input>
    <userContent>${(0, utilities_1.encodeEntity)(proposal.userContent)}</userContent>
  </quickfixes:proposalRequest>`;
    const headers = { "Content-Type": "application/*", Accept: "application/*" };
    const response = await h.request(proposal["adtcore:uri"], {
        method: "POST",
        headers,
        body
    });
    const raw = (0, utilities_1.fullParse)(response.body);
    const parseDelta = (d) => {
        const attr = (0, utilities_1.xmlNodeAttr)((0, utilities_1.xmlNode)(d, "adtcore:objectReference"));
        const content = d.content;
        const { uri, range } = (0, urlparser_1.parseUri)(attr["adtcore:uri"]);
        return {
            uri,
            range,
            name: attr["adtcore:name"],
            type: attr["adtcore:type"],
            content
        };
    };
    const deltas = (0, utilities_1.xmlArray)(raw, "qf:proposalResult", "deltas", "unit").map(parseDelta);
    return deltas;
}
exports.fixEdits = fixEdits;
const parseGeneric = (generic) => {
    const affectedObjects = (0, utilities_1.xmlArray)(generic, "affectedObjects", "affectedObject").map(o => {
        const { uri, type, name, parentUri } = (0, utilities_1.xmlNodeAttr)(o);
        const textReplaceDeltas = (0, utilities_1.xmlArray)(o, "textReplaceDeltas", "textReplaceDelta").map(z => {
            return {
                rangeFragment: (0, urlparser_1.parseUri)((0, utilities_1.xmlNode)(z, "rangeFragment")).range,
                contentOld: (0, utilities_1.xmlNode)(z, "contentOld"),
                contentNew: (0, utilities_1.xmlNode)(z, "contentNew")
            };
        });
        return {
            uri,
            type,
            name,
            parentUri,
            userContent: o.userContent,
            textReplaceDeltas
        };
    });
    const { ignoreSyntaxErrorsAllowed, ignoreSyntaxErrors, transport, userContent = "", adtObjectUri = "", title } = generic;
    return {
        title,
        ignoreSyntaxErrorsAllowed,
        ignoreSyntaxErrors,
        transport,
        adtObjectUri: (0, urlparser_1.parseUri)(adtObjectUri),
        userContent: (0, html_entities_1.decode)(userContent),
        affectedObjects
    };
};
function parseRenameRefactoring(body) {
    const raw = (0, utilities_1.fullParse)(body, { removeNSPrefix: true });
    const root = (0, utilities_1.xmlNode)(raw, "renameRefactoring");
    const { ignoreSyntaxErrorsAllowed, ignoreSyntaxErrors, transport, adtObjectUri, affectedObjects, userContent } = parseGeneric((0, utilities_1.xmlNode)(root || raw, "genericRefactoring")); // depending on the caller the generic refactoring might be wrapped or not
    return {
        oldName: (0, utilities_1.xmlNode)(root, "oldName") || "",
        newName: (0, utilities_1.xmlNode)(root, "newName") || "",
        adtObjectUri,
        ignoreSyntaxErrorsAllowed: !!ignoreSyntaxErrorsAllowed,
        ignoreSyntaxErrors: !!ignoreSyntaxErrors,
        transport,
        affectedObjects,
        userContent: userContent
    };
}
async function renameEvaluate(h, uri, line, startColumn, endColumn) {
    const qs = {
        step: `evaluate`,
        rel: `http://www.sap.com/adt/relations/refactoring/rename`,
        uri: `${uri}#start=${line},${startColumn};end=${line},${endColumn}`
    };
    const headers = { "Content-Type": "application/*", Accept: "application/*" };
    const response = await h.request("/sap/bc/adt/refactorings", {
        method: "POST",
        qs: qs,
        headers: headers
    });
    return parseRenameRefactoring(response.body);
}
exports.renameEvaluate = renameEvaluate;
const serializeAffectedObject = (o) => {
    const pu = o.parentUri ? `adtcore:parentUri="${o.parentUri}"` : "";
    return `<generic:affectedObject adtcore:name="${o.name}" ${pu} adtcore:type="${o.type}" adtcore:uri="${o.uri}">
        <generic:textReplaceDeltas>
          ${o.textReplaceDeltas
        .map(y => {
        return `<generic:textReplaceDelta>
            <generic:rangeFragment>${(0, _1.rangeToString)(y.rangeFragment)}</generic:rangeFragment>
            <generic:contentOld>${(0, utilities_1.encodeEntity)(y.contentOld)}</generic:contentOld>
            <generic:contentNew>${(0, utilities_1.encodeEntity)(y.contentNew)}</generic:contentNew>
          </generic:textReplaceDelta>`;
    })
        .join("")}
          </generic:textReplaceDeltas>
        <generic:userContent>${o.userContent}</generic:userContent>
      </generic:affectedObject>`;
};
const serializeGenericRefactoring = (g) => {
    return `<?xml version="1.0" encoding="utf-8"?>
<generic:genericRefactoring xmlns:adtcore="http://www.sap.com/adt/core" xmlns:generic="http://www.sap.com/adt/refactoring/genericrefactoring">
  <generic:title>${g.title}</generic:title>
  <generic:adtObjectUri>${(0, urlparser_1.uriPartsToString)(g.adtObjectUri)}</generic:adtObjectUri>
  <generic:affectedObjects>
  ${g.affectedObjects.map(serializeAffectedObject).join("\n")}
  </generic:affectedObjects>
  <generic:transport>${g.transport}</generic:transport>
  <generic:ignoreSyntaxErrorsAllowed>${g.ignoreSyntaxErrorsAllowed}</generic:ignoreSyntaxErrorsAllowed>
  <generic:ignoreSyntaxErrors>${g.ignoreSyntaxErrors}</generic:ignoreSyntaxErrors>
  <generic:userContent/>
</generic:genericRefactoring>`;
};
const srializeRefactoring = (renameRefactoring, wrapped, transport = "") => {
    const start = wrapped
        ? `<rename:renameRefactoring xmlns:adtcore="http://www.sap.com/adt/core" xmlns:generic="http://www.sap.com/adt/refactoring/genericrefactoring" 
  xmlns:rename="http://www.sap.com/adt/refactoring/renamerefactoring">
  <rename:oldName>${renameRefactoring.oldName}</rename:oldName>
  <rename:newName>${renameRefactoring.newName}</rename:newName>`
        : "";
    const end = wrapped ? `<rename:userContent/></rename:renameRefactoring>` : "";
    const genns = wrapped
        ? ""
        : ` xmlns:generic="http://www.sap.com/adt/refactoring/genericrefactoring" xmlns:adtcore="http://www.sap.com/adt/core"`;
    const addAffectedObjects = (affectedObject) => affectedObject.map(serializeAffectedObject);
    const bodyXml = `<?xml version="1.0" encoding="ASCII"?>
  ${start}
    <generic:genericRefactoring ${genns}>
      <generic:title>Rename Field</generic:title>
      <generic:adtObjectUri>${renameRefactoring.adtObjectUri.uri}${(0, _1.rangeToString)(renameRefactoring.adtObjectUri.range)}</generic:adtObjectUri>
      <generic:affectedObjects>
        ${addAffectedObjects(renameRefactoring.affectedObjects).join("")}
      </generic:affectedObjects>
      <generic:transport>${renameRefactoring.transport || transport}</generic:transport>
      <generic:ignoreSyntaxErrorsAllowed>${renameRefactoring.ignoreSyntaxErrorsAllowed}</generic:ignoreSyntaxErrorsAllowed>
      <generic:ignoreSyntaxErrors>${renameRefactoring.ignoreSyntaxErrors}</generic:ignoreSyntaxErrors>
      <generic:userContent/>
    </generic:genericRefactoring>
    ${end}`;
    return bodyXml;
};
const extractMethodBody = (proposal) => {
    const parameters = proposal.parameters
        .map(p => `<extractmethod:parameter>
      <extractmethod:id>${(0, utilities_1.encodeEntity)(p.id)}</extractmethod:id>
      <extractmethod:name>${p.name}</extractmethod:name>
      <extractmethod:direction>${p.direction}</extractmethod:direction>
      <extractmethod:byValue>${p.byValue}</extractmethod:byValue>
      <extractmethod:typeType>${p.typeType}</extractmethod:typeType>
      <extractmethod:type>${p.type}</extractmethod:type>
      <extractmethod:userContent>${(0, utilities_1.encodeEntity)(p.userContent)}</extractmethod:userContent>
    </extractmethod:parameter>`)
        .join("\n");
    const exceptions = proposal.exceptions
        .map(e => `<extractmethod:exception>
      <extractmethod:name>${e.name}</extractmethod:name>
      <extractmethod:resumable>${e.resumable}</extractmethod:resumable>
      <extractmethod:userContent>${e.userContent}</extractmethod:userContent>
    </extractmethod:exception>`)
        .join("\n");
    const exc = exceptions.length
        ? `<extractmethod:exceptions>${exceptions}</extractmethod:exceptions>  `
        : `<extractmethod:exceptions/>`;
    const gr = proposal.genericRefactoring;
    const affected = gr.affectedObjects
        .map(o => {
        const deltas = o.textReplaceDeltas.length === 0
            ? undefined
            : o.textReplaceDeltas
                .map(d => `<generic:textReplaceDelta> <generic:rangeFragment>${d.rangeFragment}</generic:rangeFragment> <generic:contentOld>${(0, utilities_1.encodeEntity)(d.contentOld)}</generic:contentOld> <generic:contentNew>${(0, utilities_1.encodeEntity)(d.contentNew)}</generic:contentNew> </generic:textReplaceDelta>`)
                .join("\n");
        const delta = deltas
            ? `<generic:textReplaceDeltas>${deltas}</generic:textReplaceDeltas>`
            : ``;
        return `<generic:affectedObject adtcore:name="${o.name}" adtcore:parentUri="${o.parentUri}" adtcore:type="${o.type}" adtcore:uri="${o.uri}">
        <generic:userContent>${o.userContent}</generic:userContent>
        ${delta}
      </generic:affectedObject>`;
    })
        .join("\n");
    return `<?xml version="1.0" encoding="ASCII"?>
<extractmethod:extractMethodRefactoring xmlns:adtcore="http://www.sap.com/adt/core" xmlns:extractmethod="http://www.sap.com/adt/refactoring/extractmethodrefactoring" xmlns:generic="http://www.sap.com/adt/refactoring/genericrefactoring">
  <extractmethod:name>${proposal.name}</extractmethod:name>
  <extractmethod:isStatic>${proposal.isStatic}</extractmethod:isStatic>
  <extractmethod:visibility>${proposal.visibility}</extractmethod:visibility>
  <extractmethod:classBasedExceptions>${proposal.classBasedExceptions}</extractmethod:classBasedExceptions>
  <extractmethod:parameters>
  ${parameters}
  </extractmethod:parameters>
  ${exc}
  <extractmethod:content>${(0, utilities_1.encodeEntity)(proposal.content)}</extractmethod:content>
  <generic:genericRefactoring>
    <generic:title>${gr.title}</generic:title>
    <generic:adtObjectUri>${(0, urlparser_1.uriPartsToString)(gr.adtObjectUri)}</generic:adtObjectUri>
    <generic:affectedObjects>
    ${affected}
    </generic:affectedObjects>
    <generic:transport>${gr.transport}</generic:transport>
    <generic:ignoreSyntaxErrorsAllowed>${gr.ignoreSyntaxErrorsAllowed}</generic:ignoreSyntaxErrorsAllowed>
    <generic:ignoreSyntaxErrors>${gr.ignoreSyntaxErrors}</generic:ignoreSyntaxErrors>
    <generic:userContent>${gr.userContent}</generic:userContent>
  </generic:genericRefactoring>
  <extractmethod:className>ZAPIADT_TESTCASE_CLASS1${proposal}</extractmethod:className>
  <extractmethod:isEventAllowed>${proposal.isEventAllowed}</extractmethod:isEventAllowed>
  <extractmethod:isEvent>${proposal.isEvent}</extractmethod:isEvent>
  <extractmethod:userContent>${(0, utilities_1.encodeEntity)(proposal.userContent)}</extractmethod:userContent>
  <extractmethod:isForTesting>${proposal.isForTesting}</extractmethod:isForTesting>
</extractmethod:extractMethodRefactoring>`;
};
const parseExtractMethodEval = (body) => {
    const root = (0, utilities_1.fullParse)(body, {
        removeNSPrefix: true
    }).extractMethodRefactoring;
    const parameters = (0, utilities_1.xmlArray)(root, "parameters", "parameter");
    const exceptions = (0, utilities_1.xmlArray)(root, "exceptions", "exception");
    const { name, isStatic, visibility, classBasedExceptions, content, className, isEventAllowed, isEvent, userContent } = root;
    const genericRefactoring = parseGeneric(root.genericRefactoring);
    const resp = {
        name,
        isStatic,
        visibility,
        classBasedExceptions,
        genericRefactoring,
        content,
        className,
        isForTesting: false,
        isEventAllowed,
        isEvent,
        userContent: (0, html_entities_1.decode)(userContent),
        parameters,
        exceptions
    };
    return resp;
};
async function renamePreview(h, renameRefactoring, transport) {
    const qs = {
        step: `preview`,
        rel: `http://www.sap.com/adt/relations/refactoring/rename`
    };
    const bodyXml = srializeRefactoring(renameRefactoring, true, transport);
    const headers = { "Content-Type": "application/*", Accept: "application/*" };
    const response = await h.request("/sap/bc/adt/refactorings", {
        method: "POST",
        qs: qs,
        body: bodyXml,
        headers: headers
    });
    const parsed = parseRenameRefactoring(response.body);
    return { ...parsed, transport: parsed.transport || transport };
}
exports.renamePreview = renamePreview;
async function renameExecute(h, rename) {
    const qs = {
        step: `execute`
    };
    const headers = { "Content-Type": "application/*", Accept: "application/*" };
    const body = srializeRefactoring(rename, false);
    const response = await h.request("/sap/bc/adt/refactorings", {
        method: "POST",
        qs: qs,
        body,
        headers: headers
    });
    const result = parseRenameRefactoring(response.body);
    return { ...result, transport: result.transport || rename.transport };
}
exports.renameExecute = renameExecute;
async function extractMethodEvaluate(h, uri, range) {
    const qs = {
        step: `evaluate`,
        rel: `http://www.sap.com/adt/relations/refactoring/extractmethod`,
        uri: `${uri}#start=${range.start.line},${range.start.column};end=${range.end.line},${range.end.column}`
    };
    const headers = { "Content-Type": "application/*", Accept: "application/*" };
    const opts = { method: "POST", qs, headers };
    const response = await h.request("/sap/bc/adt/refactorings", opts);
    return parseExtractMethodEval(response.body);
}
exports.extractMethodEvaluate = extractMethodEvaluate;
async function extractMethodPreview(h, proposal) {
    const body = extractMethodBody(proposal);
    const qs = {
        step: `preview`,
        rel: `http://www.sap.com/adt/relations/refactoring/extractmethod`
    };
    const headers = { "Content-Type": "application/*", Accept: "application/*" };
    const opts = { method: "POST", qs, headers, body };
    const response = await h.request("/sap/bc/adt/refactorings", opts);
    const raw = (0, utilities_1.fullParse)(response.body, {
        removeNSPrefix: true
    }).genericRefactoring;
    return parseGeneric(raw);
}
exports.extractMethodPreview = extractMethodPreview;
async function extractMethodExecute(h, refactoring) {
    const body = serializeGenericRefactoring(refactoring);
    const qs = { step: `execute` };
    const headers = { "Content-Type": "application/*", Accept: "application/*" };
    const opts = { method: "POST", qs, headers, body };
    const response = await h.request("/sap/bc/adt/refactorings", opts);
    const raw = (0, utilities_1.fullParse)(response.body, {
        removeNSPrefix: true
    }).genericRefactoring;
    return parseGeneric(raw);
}
exports.extractMethodExecute = extractMethodExecute;


/***/ }),

/***/ "./build/api/revisions.js":
/*!********************************!*\
  !*** ./build/api/revisions.js ***!
  \********************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.revisions = exports.getRevisionLink = void 0;
const AdtException_1 = __webpack_require__(/*! ../AdtException */ "./build/AdtException.js");
const utilities_1 = __webpack_require__(/*! ../utilities */ "./build/utilities.js");
const objectstructure_1 = __webpack_require__(/*! ./objectstructure */ "./build/api/objectstructure.js");
function extractRevisionLink(links) {
    return links.find(l => l.rel === "http://www.sap.com/adt/relations/versions");
}
function getRevisionLink(struct, includeName) {
    let link;
    if ((0, objectstructure_1.isClassStructure)(struct)) {
        const iname = includeName || "main";
        const include = struct.includes.find(i => i["class:includeType"] === iname);
        if (include)
            link = extractRevisionLink(include.links);
    }
    else {
        link = extractRevisionLink(struct.links);
    }
    if (link)
        return (0, utilities_1.followUrl)(struct.objectUrl, link.href);
    return "";
}
exports.getRevisionLink = getRevisionLink;
const extractVersion = (entry) => {
    const ADTTYPE = "application/vnd.sap.adt.transportrequests.v1+xml";
    const base = (0, utilities_1.xmlNode)(entry, "atom:link");
    if (Array.isArray(base)) {
        const vlink = base.find(l => l["@_type"] === ADTTYPE) || base[0];
        return (0, utilities_1.xmlNode)(vlink, "@_adtcore:name") || "";
    }
    else
        return (0, utilities_1.xmlNode)(base, "@_adtcore:name") || "";
};
async function revisions(h, objectUrl, includeName) {
    const str = (0, utilities_1.isString)(objectUrl)
        ? await (0, objectstructure_1.objectStructure)(h, objectUrl)
        : objectUrl;
    const name = str.metaData["adtcore:name"];
    const revisionUrl = getRevisionLink(str, includeName);
    if (!revisionUrl)
        throw (0, AdtException_1.adtException)(`Revision URL not found for object ${name}`);
    const headers = { Accept: "application/atom+xml;type=feed" };
    const response = await h.request(revisionUrl, {
        method: "GET",
        headers
    });
    const raw = (0, utilities_1.fullParse)(response.body);
    const versions = (0, utilities_1.xmlArray)(raw, "atom:feed", "atom:entry").map((entry) => {
        const uri = (0, utilities_1.xmlNode)(entry, "atom:content", "@_src") || "";
        const version = extractVersion(entry);
        const versionTitle = (0, utilities_1.xmlNode)(entry, "atom:title") || "";
        const date = (0, utilities_1.xmlNode)(entry, "atom:updated") || "";
        const author = (0, utilities_1.xmlNode)(entry, "atom:author", "atom:name");
        const r = { uri, version, versionTitle, date, author };
        return r;
    });
    return versions;
}
exports.revisions = revisions;


/***/ }),

/***/ "./build/api/search.js":
/*!*****************************!*\
  !*** ./build/api/search.js ***!
  \*****************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.packageSearchHelp = exports.abapDocumentation = exports.findObjectPath = exports.searchObject = void 0;
const AdtException_1 = __webpack_require__(/*! ../AdtException */ "./build/AdtException.js");
const utilities_1 = __webpack_require__(/*! ../utilities */ "./build/utilities.js");
async function searchObject(h, query, objType, maxResults = 100) {
    const qs = { operation: "quickSearch", query, maxResults };
    if (objType)
        qs.objectType = objType.replace(/\/.*$/, "");
    const response = await h.request(`/sap/bc/adt/repository/informationsystem/search`, { qs, headers: { Accept: "application/*" } });
    const raw = (0, utilities_1.fullParse)(response.body);
    return (0, utilities_1.xmlArray)(raw, "adtcore:objectReferences", "adtcore:objectReference").map((sr) => {
        const result = (0, utilities_1.xmlNodeAttr)(sr);
        // older systems return things like "ZREPORT (PROGRAM)"...
        const r = result["adtcore:name"].match(/([^\s]*)\s*\((.*)\)/);
        if (r) {
            result["adtcore:name"] = r[1];
            if (!result["adtcore:description"])
                result["adtcore:description"] = r[2];
        }
        return result;
    });
}
exports.searchObject = searchObject;
async function findObjectPath(h, objectUrl) {
    (0, AdtException_1.ValidateObjectUrl)(objectUrl);
    const qs = { uri: objectUrl };
    const response = await h.request(`/sap/bc/adt/repository/nodepath`, {
        method: "POST",
        qs
    });
    const raw = (0, utilities_1.fullParse)(response.body);
    return (0, utilities_1.xmlArray)(raw, "projectexplorer:nodepath", "projectexplorer:objectLinkReferences", "objectLinkReference").map(utilities_1.xmlNodeAttr);
}
exports.findObjectPath = findObjectPath;
async function abapDocumentation(h, objectUri, body, line, column, language = "EN") {
    (0, AdtException_1.ValidateObjectUrl)(objectUri);
    const headers = {
        "Content-Type": "text/plain",
        Accept: "application/vnd.sap.adt.docu.v1+html,text/html"
    };
    const uri = `${objectUri}#start=${line},${column}`;
    const qs = { uri, language, format: "eclipse" };
    const response = await h.request(`/sap/bc/adt/docu/abap/langu`, {
        method: "POST",
        qs,
        headers,
        body
    });
    return response.body;
}
exports.abapDocumentation = abapDocumentation;
async function packageSearchHelp(h, type, name = "*") {
    const headers = { Accept: "application/*" };
    const qs = { name };
    const uri = `/sap/bc/adt/packages/valuehelps/${type}`;
    const response = await h.request(uri, { qs, headers });
    const raw = (0, utilities_1.fullParse)(response.body);
    return (0, utilities_1.xmlArray)(raw, "nameditem:namedItemList", "nameditem:namedItem").map((item) => {
        return {
            name: item["nameditem:name"],
            description: item["nameditem:description"],
            data: item["nameditem:data"]
        };
    });
}
exports.packageSearchHelp = packageSearchHelp;


/***/ }),

/***/ "./build/api/syntax.js":
/*!*****************************!*\
  !*** ./build/api/syntax.js ***!
  \*****************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.typeHierarchy = exports.prettyPrinter = exports.setPrettyPrinterSetting = exports.prettyPrinterSetting = exports.fragmentMappings = exports.classComponents = exports.usageReferenceSnippets = exports.usageReferences = exports.findDefinition = exports.codeCompletionElement = exports.codeCompletionFull = exports.codeCompletion = exports.syntaxCheck = exports.parseCheckResults = exports.syntaxCheckTypes = void 0;
const AdtException_1 = __webpack_require__(/*! ../AdtException */ "./build/AdtException.js");
const utilities_1 = __webpack_require__(/*! ../utilities */ "./build/utilities.js");
async function syntaxCheckTypes(h) {
    const response = await h.request("/sap/bc/adt/checkruns/reporters");
    const raw = (0, utilities_1.fullParse)(response.body);
    const reporters = (0, utilities_1.xmlArray)(raw, "chkrun:checkReporters", "chkrun:reporter").reduce((acc, cur) => {
        acc.set(cur["@_chkrun:name"], (0, utilities_1.xmlArray)(cur, "chkrun:supportedType"));
        return acc;
    }, new Map());
    return reporters;
}
exports.syntaxCheckTypes = syntaxCheckTypes;
function parseCheckResults(raw) {
    const messages = [];
    (0, utilities_1.xmlArray)(raw, "chkrun:checkRunReports", "chkrun:checkReport", "chkrun:checkMessageList", "chkrun:checkMessage").forEach((m) => {
        const rawUri = m["@_chkrun:uri"] || "";
        let message = {
            uri: rawUri,
            line: 0,
            offset: 0,
            severity: m["@_chkrun:type"],
            text: m["@_chkrun:shortText"]
        };
        const matches = rawUri.match(/([^#]+)#start=([\d]+),([\d]+)/);
        if (matches) {
            const [uri, line, offset] = matches.slice(1);
            message = { ...message, uri, line: (0, utilities_1.toInt)(line), offset: (0, utilities_1.toInt)(offset) };
        }
        messages.push(message);
    });
    return messages;
}
exports.parseCheckResults = parseCheckResults;
async function syntaxCheck(h, inclUrl, sourceUrl, content, mainProgram = "", version = "active") {
    const source = mainProgram
        ? `${sourceUrl}?context=${encodeURIComponent(mainProgram)}`
        : sourceUrl;
    const body = `<?xml version="1.0" encoding="UTF-8"?>
  <chkrun:checkObjectList xmlns:chkrun="http://www.sap.com/adt/checkrun" xmlns:adtcore="http://www.sap.com/adt/core">
  <chkrun:checkObject adtcore:uri="${source}" chkrun:version="${version}">
    <chkrun:artifacts>
      <chkrun:artifact chkrun:contentType="text/plain; charset=utf-8" chkrun:uri="${inclUrl}">
        <chkrun:content>${(0, utilities_1.btoa)(content)}</chkrun:content>
      </chkrun:artifact>
    </chkrun:artifacts>
  </chkrun:checkObject>
</chkrun:checkObjectList>`;
    const headers = {
        // Accept: "application/vnd.sap.adt.checkmessages+xml",
        // "Content-Type": "application/vnd.sap.adt.checkobjects+xml"
        "Content-Type": "application/*"
    };
    const response = await h.request("/sap/bc/adt/checkruns?reporters=abapCheckRun", { method: "POST", headers, body });
    const raw = (0, utilities_1.fullParse)(response.body);
    return parseCheckResults(raw);
}
exports.syntaxCheck = syntaxCheck;
async function codeCompletion(h, url, body, line, offset) {
    const uri = `${url}#start=${line},${offset}`;
    const qs = { uri, signalCompleteness: true };
    const headers = { "Content-Type": "application/*" };
    const response = await h.request("/sap/bc/adt/abapsource/codecompletion/proposal", { method: "POST", qs, headers, body });
    const raw = (0, utilities_1.parse)(response.body);
    const proposals = (0, utilities_1.xmlArray)(raw, "asx:abap", "asx:values", "DATA", "SCC_COMPLETION")
        .filter((p) => p.IDENTIFIER && p.IDENTIFIER !== "@end")
        .map((p) => ({
        ...p,
        IDENTIFIER: p.IDENTIFIER
    }));
    return proposals;
}
exports.codeCompletion = codeCompletion;
async function codeCompletionFull(h, url, body, line, offset, patternKey) {
    const uri = `${url}#start=${line},${offset}`;
    const qs = { uri, patternKey };
    const headers = { "Content-Type": "application/*" };
    const response = await h.request("/sap/bc/adt/abapsource/codecompletion/insertion", { method: "POST", qs, headers, body });
    return response.body;
}
exports.codeCompletionFull = codeCompletionFull;
function extractDocLink(raw) {
    const link = (0, utilities_1.xmlNode)(raw, "abapsource:elementInfo", "atom:link", "@_href") || "";
    return link.replace(/\w+:\/\/[^\/]*/, "");
}
async function codeCompletionElement(h, url, body, line, offset) {
    const qs = { uri: `${url}#start=${line},${offset}` };
    const headers = { "Content-Type": "text/plain", Accept: "application/*" };
    const response = await h.request("/sap/bc/adt/abapsource/codecompletion/elementinfo", { method: "POST", qs, headers, body });
    const raw = (0, utilities_1.fullParse)(response.body);
    if (!(0, utilities_1.xmlNode)(raw, "abapsource:elementInfo"))
        return response.body;
    const elinfo = (0, utilities_1.xmlNodeAttr)((0, utilities_1.xmlNode)(raw, "abapsource:elementInfo"));
    const doc = (0, utilities_1.xmlNode)(raw, "abapsource:elementInfo", "abapsource:documentation", "#text") || "";
    const href = extractDocLink(raw);
    const components = (0, utilities_1.xmlArray)(raw, "abapsource:elementInfo", "abapsource:elementInfo").map((c) => {
        return {
            ...(0, utilities_1.xmlNodeAttr)(c),
            entries: (0, utilities_1.xmlArray)(c, "abapsource:properties", "abapsource:entry").map((e) => {
                return {
                    value: e["#text"],
                    key: e["@_abapsource:key"]
                };
            })
        };
    });
    return {
        name: elinfo["adtcore:name"],
        type: elinfo["adtcore:type"],
        doc,
        href,
        components
    };
}
exports.codeCompletionElement = codeCompletionElement;
async function findDefinition(h, url, body, line, firstof, lastof, implementation, mainProgram) {
    const ctx = mainProgram ? `?context=${encodeURIComponent(mainProgram)}` : "";
    const qs = {
        uri: `${url}${ctx}#start=${line},${firstof};end=${line},${lastof}`,
        filter: implementation ? "implementation" : "definition"
    };
    const headers = { "Content-Type": "text/plain", Accept: "application/*" };
    const response = await h.request("/sap/bc/adt/navigation/target", {
        method: "POST",
        qs,
        headers,
        body
    });
    const raw = (0, utilities_1.fullParse)(response.body);
    const rawLink = (0, utilities_1.xmlNode)(raw, "adtcore:objectReference", "@_adtcore:uri") || "";
    const match = rawLink.match(/([^#]+)#start=(\d+),(\d+)/);
    return {
        url: (match && match[1]) || rawLink,
        line: (0, utilities_1.toInt)(match && match[2]),
        column: (0, utilities_1.toInt)(match && match[3])
    };
}
exports.findDefinition = findDefinition;
async function usageReferences(h, url, line, column) {
    const headers = { "Content-Type": "application/*", Accept: "application/*" };
    const uri = line && column ? `${url}#start=${line},${column}` : url;
    const qs = { uri };
    const body = `<?xml version="1.0" encoding="ASCII"?>
  <usagereferences:usageReferenceRequest xmlns:usagereferences="http://www.sap.com/adt/ris/usageReferences">
    <usagereferences:affectedObjects/>
  </usagereferences:usageReferenceRequest>`;
    const response = await h.request("/sap/bc/adt/repository/informationsystem/usageReferences", {
        method: "POST",
        qs,
        headers,
        body
    });
    const raw = (0, utilities_1.fullParse)(response.body);
    const rawreferences = (0, utilities_1.xmlArray)(raw, "usageReferences:usageReferenceResult", "usageReferences:referencedObjects", "usageReferences:referencedObject");
    const references = rawreferences.map((r) => {
        const reference = {
            ...(0, utilities_1.xmlNodeAttr)(r),
            ...(0, utilities_1.xmlNodeAttr)((0, utilities_1.xmlNode)(r, "usageReferences:adtObject") || {}),
            packageRef: (0, utilities_1.xmlNodeAttr)((0, utilities_1.xmlNode)(r, "usageReferences:adtObject", "adtcore:packageRef") || {}),
            objectIdentifier: r.objectIdentifier || ""
        };
        // older systems hide the type in the URI
        if (!reference["adtcore:type"]) {
            const uriParts = splitReferenceUri(reference.uri, "");
            reference["adtcore:type"] = uriParts.type;
        }
        return reference;
    });
    return references;
}
exports.usageReferences = usageReferences;
function splitReferenceUri(url, matches) {
    const [uri, context, hash] = (0, utilities_1.parts)(url, /([^#\?]*)(?:\?context=([^#]*))?(?:#(.*))/);
    const uparts = { uri, context };
    if (hash) {
        hash.split(";").forEach(p => {
            const [name, value] = p.split("=");
            if (name === "start" || name === "end") {
                const [line, column] = value.split(",");
                if (line)
                    uparts[name] = { line: (0, utilities_1.toInt)(line), column: (0, utilities_1.toInt)(column) };
            }
            else if (name === "type" || name === "name")
                uparts[name] = decodeURIComponent(value);
        });
    }
    const [start, end] = (0, utilities_1.parts)(matches, /(\d+)-(\d+)/);
    if (!uparts.start)
        uparts.start = { line: 0, column: (0, utilities_1.toInt)(start) };
    if (!uparts.start.column)
        uparts.start.column = (0, utilities_1.toInt)(start);
    if (!uparts.end)
        uparts.end = {
            line: uparts.start.line,
            column: (0, utilities_1.toInt)(end) || uparts.start.column
        };
    return uparts;
}
async function usageReferenceSnippets(h, references) {
    const headers = { "Content-Type": "application/*", Accept: "application/*" };
    const refNodes = references
        .filter(r => r.objectIdentifier)
        .reduce((last, current) => `${last}<usagereferences:objectIdentifier optional="false">${current.objectIdentifier}</usagereferences:objectIdentifier>`, "");
    const body = `<?xml version="1.0" encoding="UTF-8"?>
  <usagereferences:usageSnippetRequest xmlns:usagereferences="http://www.sap.com/adt/ris/usageReferences">
  <usagereferences:objectIdentifiers>
  ${refNodes}
  </usagereferences:objectIdentifiers>
  <usagereferences:affectedObjects/>
</usagereferences:usageSnippetRequest>`;
    const response = await h.request("/sap/bc/adt/repository/informationsystem/usageSnippets", {
        method: "POST",
        headers,
        body
    });
    const raw = (0, utilities_1.fullParse)(response.body);
    const snippetReferences = (0, utilities_1.xmlArray)(raw, "usageReferences:usageSnippetResult", "usageReferences:codeSnippetObjects", "usageReferences:codeSnippetObject").map((o) => {
        const snippets = (0, utilities_1.xmlArray)(o, "usageReferences:codeSnippets", "usageReferences:codeSnippet").map((s) => {
            const parms = (0, utilities_1.xmlNodeAttr)(s);
            const uri = splitReferenceUri(parms.uri, parms.matches);
            return {
                uri,
                matches: parms.matches,
                content: s.content,
                description: s.description
            };
        });
        return { objectIdentifier: o.objectIdentifier, snippets };
    });
    return snippetReferences;
}
exports.usageReferenceSnippets = usageReferenceSnippets;
const parseElement = (e) => {
    const attrs = (0, utilities_1.xmlNodeAttr)(e);
    const links = (0, utilities_1.xmlArray)(e, "atom:link").map(utilities_1.xmlNodeAttr);
    const components = (0, utilities_1.xmlArray)(e, "abapsource:objectStructureElement").map(parseElement);
    return { ...attrs, links, components };
};
async function classComponents(h, url) {
    (0, AdtException_1.ValidateObjectUrl)(url);
    const uri = `${url}/objectstructure`;
    const qs = { version: "active", withShortDescriptions: true };
    const headers = { "Content-Type": "application/*" };
    const response = await h.request(uri, { qs, headers });
    const raw = (0, utilities_1.fullParse)(response.body);
    const header = parseElement((0, utilities_1.xmlNode)(raw, "abapsource:objectStructureElement"));
    return header;
}
exports.classComponents = classComponents;
async function fragmentMappings(h, url, type, name) {
    (0, AdtException_1.ValidateObjectUrl)(url);
    const qs = { uri: `${url}#type=${type};name=${name}` };
    const headers = { "Content-Type": "application/*" };
    const response = await h.request("/sap/bc/adt/urifragmentmappings", {
        qs,
        headers
    });
    const [sourceUrl, line, column] = (0, utilities_1.parts)(response.body, /([^#]*)#start=([\d]+),([\d]+)/);
    if (!column)
        throw (0, AdtException_1.adtException)("Fragment not found");
    const location = {
        uri: sourceUrl,
        line: (0, utilities_1.toInt)(line),
        column: (0, utilities_1.toInt)(column)
    };
    return location;
}
exports.fragmentMappings = fragmentMappings;
async function prettyPrinterSetting(h) {
    const response = await h.request("/sap/bc/adt/abapsource/prettyprinter/settings");
    const raw = (0, utilities_1.fullParse)(response.body);
    const settings = (0, utilities_1.xmlNodeAttr)(raw["abapformatter:PrettyPrinterSettings"]);
    return settings;
}
exports.prettyPrinterSetting = prettyPrinterSetting;
async function setPrettyPrinterSetting(h, indent, style) {
    const headers = { "Content-Type": "application/*" };
    const body = `<?xml version="1.0" encoding="UTF-8"?><prettyprintersettings:PrettyPrinterSettings
xmlns:prettyprintersettings="http://www.sap.com/adt/prettyprintersettings"
prettyprintersettings:indentation="${indent}" prettyprintersettings:style="${style}"/>`;
    const response = await h.request("/sap/bc/adt/abapsource/prettyprinter/settings", { method: "PUT", headers, body });
    return response.body || "";
}
exports.setPrettyPrinterSetting = setPrettyPrinterSetting;
async function prettyPrinter(h, body) {
    const headers = { "Content-Type": "text/plain", Accept: "text/plain" };
    const response = await h.request("/sap/bc/adt/abapsource/prettyprinter", {
        method: "POST",
        headers,
        body
    });
    return (response.body || body).toString();
}
exports.prettyPrinter = prettyPrinter;
async function typeHierarchy(h, url, body, line, offset, superTypes = false) {
    const qs = {
        uri: `${url}#start=${line},${offset}`,
        type: superTypes ? "superTypes" : "subTypes"
    };
    const headers = { "Content-Type": "text/plain", Accept: "application/*" };
    const response = await h.request("/sap/bc/adt/abapsource/typehierarchy", {
        method: "POST",
        qs,
        headers,
        body
    });
    const raw = (0, utilities_1.fullParse)(response.body);
    const hierarchy = (0, utilities_1.xmlArray)(raw, "hierarchy:info", "entries", "entry").map(he => {
        const rawh = (0, utilities_1.xmlNodeAttr)(he);
        const [uri, srcline, character] = (0, utilities_1.parts)(rawh["adtcore:uri"], /([^#]+)(?:#start=(\d+)(?:,(\d+))?)?/);
        const node = {
            hasDefOrImpl: rawh.hasDefOrImpl,
            uri,
            line: (0, utilities_1.toInt)(srcline),
            character: (0, utilities_1.toInt)(character),
            type: rawh["adtcore:type"] || "",
            name: rawh["adtcore:name"] || "",
            parentUri: rawh["adtcore:parentUri"] || "",
            description: rawh["adtcore:description"] || ""
        };
        return node;
    });
    return hierarchy;
}
exports.typeHierarchy = typeHierarchy;


/***/ }),

/***/ "./build/api/tablecontents.js":
/*!************************************!*\
  !*** ./build/api/tablecontents.js ***!
  \************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.bindingDetails = exports.runQuery = exports.tableContents = exports.servicePreviewUrl = exports.parseBindingDetails = exports.parseQueryResponse = exports.decodeQueryResult = exports.extractBindingLinks = exports.parseServiceBinding = exports.TypeKinds = void 0;
const AdtException_1 = __webpack_require__(/*! ../AdtException */ "./build/AdtException.js");
const utilities_1 = __webpack_require__(/*! ../utilities */ "./build/utilities.js");
var TypeKinds;
(function (TypeKinds) {
    TypeKinds["ANY"] = "~";
    TypeKinds["CHAR"] = "C";
    TypeKinds["CLASS"] = "*";
    TypeKinds["CLIKE"] = "&";
    TypeKinds["CSEQUENCE"] = "?";
    TypeKinds["DATA"] = "#";
    TypeKinds["DATE"] = "D";
    TypeKinds["DECFLOAT"] = "/";
    TypeKinds["DECFLOAT16"] = "a";
    TypeKinds["DECFLOAT34"] = "e";
    TypeKinds["DREF"] = "l";
    TypeKinds["FLOAT"] = "F";
    TypeKinds["HEX"] = "X";
    TypeKinds["INT"] = "I";
    TypeKinds["INT1"] = "b";
    TypeKinds["INT8"] = "8";
    TypeKinds["INT2"] = "s";
    TypeKinds["INTF"] = "+";
    TypeKinds["IREF"] = "m";
    TypeKinds["NUM"] = "N";
    TypeKinds["NUMERIC"] = "%";
    TypeKinds["OREF"] = "r";
    TypeKinds["PACKED"] = "P";
    TypeKinds["SIMPLE"] = "$";
    TypeKinds["STRING"] = "g";
    TypeKinds["STRUCT1"] = "u";
    TypeKinds["STRUCT2"] = "v";
    TypeKinds["TABLE"] = "h";
    TypeKinds["TIME"] = "T";
    TypeKinds["W"] = "w";
    TypeKinds["XSEQUENCE"] = "!";
    TypeKinds["XSTRING"] = "y";
    TypeKinds["BREF"] = "j";
})(TypeKinds = exports.TypeKinds || (exports.TypeKinds = {}));
const parseServiceBinding = (xml) => {
    const s = (0, utilities_1.fullParse)(xml, { removeNSPrefix: true, parseAttributeValue: false });
    const attrs = (0, utilities_1.xmlNodeAttr)(s.serviceBinding);
    for (const key of ["releaseSupported", "published", "repair", "bindingCreated"])
        attrs[key] = !`${attrs[key]}`.match(/false/i);
    const packageRef = (0, utilities_1.xmlNodeAttr)(s.serviceBinding.packageRef);
    const links = s.serviceBinding.link.map(utilities_1.xmlNodeAttr);
    const parseService = (name) => (service) => {
        const { "@_version": version, "@_releaseState": releaseState } = service;
        const serviceDefinition = (0, utilities_1.xmlNodeAttr)(service.serviceDefinition);
        return { name, version, releaseState, serviceDefinition };
    };
    const { "@_name": serviceName } = (0, utilities_1.xmlNode)(s, "serviceBinding", "services");
    const services = (0, utilities_1.xmlArray)(s, "serviceBinding", "services", "content").map(parseService(serviceName));
    const parseBinding = (b) => ({ ...(0, utilities_1.xmlNodeAttr)(b), implementation: { ...(0, utilities_1.xmlNodeAttr)(b.implementation) } });
    const binding = parseBinding(s.serviceBinding.binding);
    return { ...attrs, packageRef, links, services, binding };
};
exports.parseServiceBinding = parseServiceBinding;
const extractBindingLinks = (binding) => {
    var _a;
    const url = (_a = binding.links.find(l => l.rel === "http://www.sap.com/categories/odatav2")) === null || _a === void 0 ? void 0 : _a.href;
    if (!url)
        return [];
    return binding.services.map(service => {
        const { name: servicename, version: serviceversion, serviceDefinition: { name: srvdname } } = service;
        const query = { servicename, serviceversion, srvdname };
        return { service, query, url };
    });
};
exports.extractBindingLinks = extractBindingLinks;
const decodeSapDate = (raw) => new Date(`${raw.substr(0, 4)}-${raw.substr(4, 2)}-${raw.substr(6, 2)}`);
const parseValue = (type, raw) => {
    switch (type) {
        case TypeKinds.DATE:
            return decodeSapDate(raw);
        case TypeKinds.DECFLOAT:
        case TypeKinds.DECFLOAT16:
        case TypeKinds.DECFLOAT34:
        case TypeKinds.FLOAT:
        case TypeKinds.NUM:
        case TypeKinds.NUMERIC:
        case TypeKinds.PACKED:
            return parseFloat(raw);
        case TypeKinds.INT:
        case TypeKinds.INT1:
        case TypeKinds.INT8:
        case TypeKinds.INT2:
            return parseInt(raw, 10);
        case TypeKinds.TIME:
            return raw; // converting to date doesn't sound like a great idea
        default:
            return raw;
    }
};
const decodeQueryResult = (original) => {
    const { columns } = original;
    const types = new Map();
    for (const c of columns)
        types.set(c.name, c.type);
    const values = original.values.map(l => {
        const decoded = (k) => parseValue(types.get(k), l[k]);
        return Object.keys(l).reduce((o, k) => { o[k] = decoded(k); return o; }, {});
    });
    return { columns, values };
};
exports.decodeQueryResult = decodeQueryResult;
const parseColumn = (raw) => {
    const { "@_name": name = "", "@_type": type = "", "@_description": description, "@_keyAttribute": keyAttribute = false, "@_colType": colType, "@_isKeyFigure": isKeyFigure = false, "@_length": length = 0, } = raw.metadata;
    const values = (0, utilities_1.xmlArray)(raw, "dataSet", "data");
    const meta = { name, type, description, keyAttribute, colType, isKeyFigure, length };
    return { values, meta };
};
function parseQueryResponse(body) {
    const raw = (0, utilities_1.fullParse)(body, { removeNSPrefix: true, parseTagValue: false });
    const fields = (0, utilities_1.xmlArray)(raw, "tableData", "columns").map(parseColumn);
    const columns = fields.map(c => c.meta);
    const longest = fields.map(f => f.values).reduce((m, l) => l.length > m.length ? l : m, []);
    const row = (_, i) => fields.reduce((r, f) => {
        return { ...r, [f.meta.name]: f.values[i] };
    }, {});
    const values = longest.map(row);
    return { columns, values };
}
exports.parseQueryResponse = parseQueryResponse;
const parseBindingDetails = (xml) => {
    var _a;
    const s = (0, utilities_1.fullParse)(xml, { removeNSPrefix: true, parseAttributeValue: false });
    const link = (0, utilities_1.xmlNodeAttr)((_a = s === null || s === void 0 ? void 0 : s.serviceList) === null || _a === void 0 ? void 0 : _a.link);
    const parseCollection = (c) => {
        const name = c["@_name"];
        const navigation = (0, utilities_1.xmlArray)(c, "navigation").map(utilities_1.xmlNodeAttr);
        return { name, navigation };
    };
    const parseService = (s) => {
        const base = (0, utilities_1.xmlNodeAttr)(s);
        const serviceInformation = (0, utilities_1.xmlNodeAttr)(s.serviceInformation);
        serviceInformation.collection = (0, utilities_1.xmlArray)(s, "serviceInformation", "collection").map(parseCollection);
        return ({ ...base, serviceInformation });
    };
    const services = (0, utilities_1.xmlArray)(s, "serviceList", "services").map(parseService);
    return { link, services };
};
exports.parseBindingDetails = parseBindingDetails;
const servicePreviewUrl = (service, collectionName) => {
    const { serviceId, serviceInformation: { collection, url, name, version } } = service;
    const annotation = `${name.substr(0, 28)}_VAN`;
    const baseUrl = url.replace(/(https?:\/\/[^\/]+).*/, "$1");
    const cn = collection.find(c => c.name === collectionName);
    if (!cn)
        return;
    const encrypt = (s) => s.split("").map(c => String.fromCharCode(c.charCodeAt(0) + 20)).join("");
    const names = cn.navigation.map(n => n.name).join("@@");
    const targets = cn.navigation.map(n => n.target).join("@@");
    const rawparm = [serviceId, cn.name, names, targets, annotation, version].join("##");
    return `${baseUrl}/sap/bc/adt/businessservices/odatav2/feap?feapParams=${encodeURIComponent(encrypt(rawparm))}`;
};
exports.servicePreviewUrl = servicePreviewUrl;
async function tableContents(h, ddicEntityName, rowNumber = 100, decode = true, sqlQuery = "") {
    const qs = { rowNumber, ddicEntityName };
    const response = await h.request(`/sap/bc/adt/datapreview/ddic`, { qs, headers: { Accept: "application/*" }, method: "POST", body: sqlQuery });
    const queryResult = parseQueryResponse(response.body);
    if (decode)
        return (0, exports.decodeQueryResult)(queryResult);
    return queryResult;
}
exports.tableContents = tableContents;
async function runQuery(h, sqlQuery, rowNumber = 100, decode = true) {
    const qs = { rowNumber };
    const response = await h.request(`/sap/bc/adt/datapreview/freestyle`, { qs, headers: { Accept: "application/*" }, method: "POST", body: sqlQuery });
    const queryResult = parseQueryResponse(response.body);
    if (decode)
        return (0, exports.decodeQueryResult)(queryResult);
    return queryResult;
}
exports.runQuery = runQuery;
async function bindingDetails(h, binding, index = 0) {
    const queries = (0, exports.extractBindingLinks)(binding);
    const { query: qs, url } = queries[index];
    if (!qs || !url)
        throw (0, AdtException_1.adtException)("Binding not found");
    const response = await h.request(url, { qs, headers: { Accept: "application/*" }, method: "GET" });
    return (0, exports.parseBindingDetails)(response.body);
}
exports.bindingDetails = bindingDetails;


/***/ }),

/***/ "./build/api/traces.js":
/*!*****************************!*\
  !*** ./build/api/traces.js ***!
  \*****************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.tracesDelete = exports.tracesDeleteConfiguration = exports.tracesCreateConfiguration = exports.tracesSetParameters = exports.tracesStatements = exports.tracesDbAccess = exports.tracesHitList = exports.tracesListRequests = exports.tracesList = exports.traceProcessObjects = void 0;
const tracetypes_1 = __webpack_require__(/*! ./tracetypes */ "./build/api/tracetypes.js");
const __1 = __webpack_require__(/*! .. */ "./build/index.js");
var tracetypes_2 = __webpack_require__(/*! ./tracetypes */ "./build/api/tracetypes.js");
Object.defineProperty(exports, "traceProcessObjects", ({ enumerable: true, get: function () { return tracetypes_2.traceProcessObjects; } }));
const tracesList = async (h, user) => {
    const qs = { user: user.toUpperCase() };
    const response = await h.request(`/sap/bc/adt/runtime/traces/abaptraces`, {
        qs
    });
    return (0, tracetypes_1.parseTraceResults)(response.body);
};
exports.tracesList = tracesList;
const tracesListRequests = async (h, user) => {
    const qs = { user: user.toUpperCase() };
    const response = await h.request(`/sap/bc/adt/runtime/traces/abaptraces/requests`, { qs });
    return (0, tracetypes_1.parseTraceRequestList)(response.body);
};
exports.tracesListRequests = tracesListRequests;
const traceId = (id) => id.startsWith("/sap/bc/adt/runtime/traces/abaptraces/")
    ? id
    : `/sap/bc/adt/runtime/traces/abaptraces/${id}`;
const tracesHitList = async (h, id, withSystemEvents = false) => {
    const opts = { qs: { withSystemEvents } };
    const response = await h.request(`${traceId(id)}/hitlist`, opts);
    return (0, tracetypes_1.parseTraceHitList)(response.body);
};
exports.tracesHitList = tracesHitList;
const tracesDbAccess = async (h, id, withSystemEvents = false) => {
    const opts = { qs: { withSystemEvents } };
    const response = await h.request(`${traceId(id)}/dbAccesses`, opts);
    return (0, tracetypes_1.parseTraceDbAccess)(response.body);
};
exports.tracesDbAccess = tracesDbAccess;
const tracesStatements = async (h, id, options = {}) => {
    const headers = {
        Accept: "application/vnd.sap.adt.runtime.traces.abaptraces.aggcalltree+xml, application/xml"
    };
    const opts = { qs: options, headers };
    const response = await h.request(`${traceId(id)}/statements`, opts);
    return (0, tracetypes_1.parseTraceStatements)(response.body);
};
exports.tracesStatements = tracesStatements;
const tracesSetParameters = async (h, parameters) => {
    const headers = { "Content-Type": "application/xml" };
    const body = `<?xml version="1.0" encoding="UTF-8"?>
  <trc:parameters xmlns:trc="http://www.sap.com/adt/runtime/traces/abaptraces">
      <trc:allMiscAbapStatements value="${parameters.allMiscAbapStatements}"></trc:allMiscAbapStatements>
      <trc:allProceduralUnits value="${parameters.allProceduralUnits}"></trc:allProceduralUnits>
      <trc:allInternalTableEvents value="${parameters.allInternalTableEvents}"></trc:allInternalTableEvents>
      <trc:allDynproEvents value="${parameters.allDynproEvents}"></trc:allDynproEvents>
      <trc:description value="${parameters.description}"></trc:description>
      <trc:aggregate value="${parameters.aggregate}"></trc:aggregate>
      <trc:explicitOnOff value="${parameters.explicitOnOff}"></trc:explicitOnOff>
      <trc:withRfcTracing value="${parameters.withRfcTracing}"></trc:withRfcTracing>
      <trc:allSystemKernelEvents value="${parameters.allSystemKernelEvents}"></trc:allSystemKernelEvents>
      <trc:sqlTrace value="${parameters.sqlTrace}"></trc:sqlTrace>
      <trc:allDbEvents value="${parameters.allDbEvents}"></trc:allDbEvents>
      <trc:maxSizeForTraceFile value="${parameters.maxSizeForTraceFile}"></trc:maxSizeForTraceFile>
      <trc:maxTimeForTracing value="${parameters.maxTimeForTracing}"></trc:maxTimeForTracing>
  </trc:parameters>`;
    const opts = { headers, method: "POST", body };
    const response = await h.request(`/sap/bc/adt/runtime/traces/abaptraces/parameters`, opts);
    const uri = response.headers["location"];
    if (!uri)
        throw (0, __1.adtException)("trace configuration not set");
    return uri;
};
exports.tracesSetParameters = tracesSetParameters;
const tracesCreateConfiguration = async (h, config) => {
    if (!tracetypes_1.traceProcessObjects[config.processType].includes(config.objectType))
        throw (0, __1.adtException)(`Invalid process type ${config.processType} or object type ${config.objectType}`);
    const qs = {
        ...config,
        server: config.server || "*",
        processType: tracetypes_1.traceProcessTypeUris[config.processType],
        objectType: tracetypes_1.traceObjectTypeUris[config.objectType]
    };
    const opts = { method: "POST", qs };
    const response = await h.request(`/sap/bc/adt/runtime/traces/abaptraces/requests`, opts);
    return (0, tracetypes_1.parseTraceRequestList)(response.body);
};
exports.tracesCreateConfiguration = tracesCreateConfiguration;
const tracesDeleteConfiguration = async (h, id) => {
    const prefix = `/sap/bc/adt/runtime/traces/abaptraces/requests`;
    const url = id.startsWith(prefix) ? id : `${prefix}/${id}`;
    await h.request(url, { method: "DELETE" });
};
exports.tracesDeleteConfiguration = tracesDeleteConfiguration;
const tracesDelete = async (h, id) => {
    const prefix = `/sap/bc/adt/runtime/traces/abaptraces/`;
    const url = id.startsWith(prefix) ? id : `${prefix}/${id}`;
    await h.request(url, { method: "DELETE" });
};
exports.tracesDelete = tracesDelete;


/***/ }),

/***/ "./build/api/tracetypes.js":
/*!*********************************!*\
  !*** ./build/api/tracetypes.js ***!
  \*********************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.parseTraceRequestList = exports.parseTraceStatements = exports.parseTraceDbAccess = exports.parseTraceHitList = exports.parseTraceResults = exports.traceProcessObjects = exports.traceObjectTypeUris = exports.traceProcessTypeUris = void 0;
const t = __importStar(__webpack_require__(/*! io-ts */ "./node_modules/io-ts/es6/index.js"));
const utilities_1 = __webpack_require__(/*! ../utilities */ "./build/utilities.js");
const AdtException_1 = __webpack_require__(/*! ../AdtException */ "./build/AdtException.js");
const contributorClass = t.type({ name: t.string });
const link = t.type({
    "@_href": t.string,
    "@_rel": t.string,
    "@_type": t.string,
    "@_title": t.string
});
// A	Active
// R	Read Only
// E	Error
// S	SizeLim
// T	TimeLim
// C	Close Error
const state = t.type({ "@_value": t.string, "@_text": t.string });
const extendedData = t.type({
    host: t.string,
    size: t.number,
    runtime: t.number,
    runtimeABAP: t.number,
    runtimeSystem: t.number,
    runtimeDatabase: t.number,
    expiration: t.string,
    system: t.string,
    client: t.number,
    isAggregated: t.boolean,
    aggregationKind: (0, utilities_1.orUndefined)(t.string),
    objectName: t.string,
    state: state
});
const entryAuthor = t.type({ name: t.string, uri: t.string });
const entry = t.type({
    author: entryAuthor,
    content: t.type({
        "@_type": t.string,
        "@_src": t.string
    }),
    id: t.string,
    link: (0, utilities_1.xmlArrayType)(link),
    published: t.string,
    title: t.string,
    updated: t.string,
    extendedData: extendedData,
    "@_lang": t.string
});
const feed = t.type({
    author: contributorClass,
    contributor: contributorClass,
    title: t.string,
    updated: t.string,
    entry: (0, utilities_1.xmlArrayType)(entry)
});
const traceResults = t.type({ feed: feed });
const time = t.type({
    "@_time": t.number,
    "@_percentage": t.number
});
const baseLink = t.type({
    "@_rel": t.string,
    "@_href": t.string
});
const calledProgram = t.type({ "@_context": t.string });
const callingProgram = (0, utilities_1.mixed)({
    "@_context": t.string,
    "@_byteCodeOffset": t.number
}, {
    "@_uri": t.string,
    "@_type": t.string,
    "@_name": t.string,
    "@_packageName": t.string,
    "@_objectReferenceQuery": t.string
});
const hlentry = (0, utilities_1.mixed)({
    calledProgram: calledProgram,
    grossTime: time,
    traceEventNetTime: time,
    proceduralNetTime: time,
    "@_topDownIndex": t.number,
    "@_index": t.number,
    "@_hitCount": t.number,
    "@_recursionDepth": t.number,
    "@_description": t.string
}, {
    callingProgram: callingProgram,
    "@_stackCount": t.number,
    "@_proceduralEntryAnchor": t.number,
    "@_dbAccessAnchor": t.number
});
const Hitlist = t.type({
    link: baseLink,
    entry: (0, utilities_1.xmlArrayType)(hlentry)
});
const HitListResponse = t.type({ hitlist: Hitlist });
///
const accessTime = t.type({
    "@_total": t.number,
    "@_applicationServer": t.number,
    "@_database": t.number,
    "@_ratioOfTraceTotal": t.number
});
const dBAccess = (0, utilities_1.mixed)({
    accessTime: accessTime,
    "@_index": t.number,
    "@_tableName": t.string,
    "@_statement": t.string,
    "@_type": t.union([
        t.literal("EXEC SQL"),
        t.literal("OpenSQL"),
        t.literal("")
    ]),
    "@_totalCount": t.number,
    "@_bufferedCount": t.number
}, {
    callingProgram: callingProgram
});
const dBAccesses = t.type({
    link: baseLink,
    dbAccess: (0, utilities_1.xmlArrayType)(dBAccess),
    tables: t.union([
        t.type({
            table: (0, utilities_1.xmlArrayType)(t.type({
                "@_name": t.string,
                "@_type": t.string,
                "@_description": t.string,
                "@_bufferMode": t.string,
                "@_storageType": t.string,
                "@_package": t.string
            }))
        }),
        t.literal("")
    ]),
    "@_totalDbTime": t.number
});
const traceDBAccesResponse = t.type({ dbAccesses: dBAccesses });
///
const statement = (0, utilities_1.mixed)({
    callingProgram: callingProgram,
    grossTime: time,
    traceEventNetTime: time,
    proceduralNetTime: time,
    "@_index": t.number,
    "@_id": t.number,
    "@_description": t.string,
    "@_hitCount": t.number,
    "@_hasDetailSubnodes": t.boolean,
    "@_hasProcedureLikeSubnodes": t.boolean,
    "@_callerId": t.number,
    "@_callLevel": t.number,
    "@_subnodeCount": t.number,
    "@_directSubnodeCount": t.number,
    "@_directSubnodeCountProcedureLike": t.number,
    "@_hitlistAnchor": t.number
}, {
    "@_isProcedureLike": t.boolean,
    "@_isProceduralUnit": t.boolean,
    "@_isAutoDrillDowned": t.boolean,
    "@_calltreeAnchor": t.number,
    "@_moduleHitlistAnchor": t.number
});
const traceStatementResponse = t.type({
    statements: t.type({
        link: baseLink,
        statement: (0, utilities_1.xmlArrayType)(statement),
        "@_withDetails": t.boolean,
        "@_withSysEvents": t.boolean,
        "@_count": t.union([t.number, t.string])
    })
});
///
const author = t.type({
    name: t.string,
    uri: t.string,
    "@_role": t.string
});
const client = t.partial({
    "#text": (0, utilities_1.orUndefined)(t.number),
    "@_role": t.string
});
const executions = t.type({
    "@_maximal": t.number,
    "@_completed": t.number
});
const rawProcessTypes = t.union([
    t.literal("/sap/bc/adt/runtime/traces/abaptraces/processtypes/any"),
    t.literal("/sap/bc/adt/runtime/traces/abaptraces/processtypes/http"),
    t.literal("/sap/bc/adt/runtime/traces/abaptraces/processtypes/dialog"),
    t.literal("/sap/bc/adt/runtime/traces/abaptraces/processtypes/batch"),
    t.literal("/sap/bc/adt/runtime/traces/abaptraces/processtypes/rfc"),
    t.literal("/sap/bc/adt/runtime/traces/abaptraces/processtypes/sharedobjectsarea")
]);
const rawObjectTypes = t.union([
    t.literal("/sap/bc/adt/runtime/traces/abaptraces/objecttypes/any"),
    t.literal("/sap/bc/adt/runtime/traces/abaptraces/objecttypes/url"),
    t.literal("/sap/bc/adt/runtime/traces/abaptraces/objecttypes/transaction"),
    t.literal("/sap/bc/adt/runtime/traces/abaptraces/objecttypes/report"),
    t.literal("/sap/bc/adt/runtime/traces/abaptraces/objecttypes/functionmodule"),
    t.literal("/sap/bc/adt/runtime/traces/abaptraces/objecttypes/sharedobjectarea")
]);
const traceListextendedData = t.type({
    host: t.string,
    requestIndex: t.number,
    client: (0, utilities_1.xmlArrayType)(client),
    description: t.string,
    isAggregated: t.boolean,
    expires: t.string,
    processType: t.type({ "@_processTypeId": rawProcessTypes }),
    object: t.type({ "@_objectTypeId": rawObjectTypes }),
    executions: executions
});
const traceListEntry = (0, utilities_1.mixed)({
    id: t.string,
    author: (0, utilities_1.xmlArrayType)(author),
    content: t.type({
        "@_type": t.string,
        "@_src": t.string
    }),
    published: t.string,
    title: t.string,
    updated: t.string,
    extendedData: traceListextendedData,
    "@_lang": t.string
}, {
    link: (0, utilities_1.xmlArrayType)(link)
});
const tlFeed = t.type({
    contributor: t.type({
        name: t.string,
        "@_role": t.string
    }),
    title: t.string,
    updated: t.string,
    entry: (0, utilities_1.xmlArrayType)(traceListEntry)
});
const tracesListRequest = t.type({ feed: tlFeed });
exports.traceProcessTypeUris = {
    ANY: "/sap/bc/adt/runtime/traces/abaptraces/processtypes/any",
    HTTP: "/sap/bc/adt/runtime/traces/abaptraces/processtypes/http",
    DIALOG: "/sap/bc/adt/runtime/traces/abaptraces/processtypes/dialog",
    BATCH: "/sap/bc/adt/runtime/traces/abaptraces/processtypes/batch",
    RFC: "/sap/bc/adt/runtime/traces/abaptraces/processtypes/rfc",
    SHARED_OBJECTS_AREA: "/sap/bc/adt/runtime/traces/abaptraces/processtypes/sharedobjectsarea"
};
exports.traceObjectTypeUris = {
    ANY: "/sap/bc/adt/runtime/traces/abaptraces/objecttypes/any",
    URL: "/sap/bc/adt/runtime/traces/abaptraces/objecttypes/url",
    TRANSACTION: "/sap/bc/adt/runtime/traces/abaptraces/objecttypes/transaction",
    REPORT: "/sap/bc/adt/runtime/traces/abaptraces/objecttypes/report",
    FUNCTION_MODULE: "/sap/bc/adt/runtime/traces/abaptraces/objecttypes/functionmodule",
    SHARED_OBJECTS_AREA: "/sap/bc/adt/runtime/traces/abaptraces/objecttypes/sharedobjectarea"
};
const decodeObjectType = (x) => {
    switch (x) {
        case "/sap/bc/adt/runtime/traces/abaptraces/objecttypes/any":
            return "ANY";
        case "/sap/bc/adt/runtime/traces/abaptraces/objecttypes/url":
            return "URL";
        case "/sap/bc/adt/runtime/traces/abaptraces/objecttypes/transaction":
            return "TRANSACTION";
        case "/sap/bc/adt/runtime/traces/abaptraces/objecttypes/report":
            return "REPORT";
        case "/sap/bc/adt/runtime/traces/abaptraces/objecttypes/functionmodule":
            return "FUNCTION_MODULE";
        case "/sap/bc/adt/runtime/traces/abaptraces/objecttypes/sharedobjectarea":
            return "SHARED_OBJECTS_AREA";
        default:
            return "ANY";
    }
};
const decodeProcessType = (x) => {
    switch (x) {
        case "/sap/bc/adt/runtime/traces/abaptraces/processtypes/any":
            return "ANY";
        case "/sap/bc/adt/runtime/traces/abaptraces/processtypes/http":
            return "HTTP";
        case "/sap/bc/adt/runtime/traces/abaptraces/processtypes/dialog":
            return "DIALOG";
        case "/sap/bc/adt/runtime/traces/abaptraces/processtypes/batch":
            return "BATCH";
        case "/sap/bc/adt/runtime/traces/abaptraces/processtypes/rfc":
            return "RFC";
        case "/sap/bc/adt/runtime/traces/abaptraces/processtypes/sharedobjectsarea":
            return "SHARED_OBJECTS_AREA";
        default:
            return "ANY";
    }
};
exports.traceProcessObjects = {
    ANY: [
        "FUNCTION_MODULE",
        "URL",
        "TRANSACTION",
        "REPORT",
        "SHARED_OBJECTS_AREA",
        "ANY"
    ],
    HTTP: ["URL"],
    DIALOG: ["TRANSACTION", "REPORT"],
    BATCH: ["REPORT"],
    RFC: ["FUNCTION_MODULE"],
    SHARED_OBJECTS_AREA: ["SHARED_OBJECTS_AREA"]
};
const parseRawTrace = (x) => (0, AdtException_1.validateParseResult)(traceResults.decode(x)).feed;
const parseTraceResults = (xml) => {
    const raw = parseRawTrace((0, utilities_1.fullParse)(xml, { removeNSPrefix: true }));
    const runs = (0, utilities_1.extractXmlArray)(raw.entry).map(l => {
        const links = (0, utilities_1.extractXmlArray)(l.link).map(utilities_1.typedNodeAttr);
        const { id, author: { name: author, uri: authorUri }, content: { "@_type": type, "@_src": src }, "@_lang": lang, title } = l;
        const published = new Date(l.published);
        const updated = new Date(l.updated);
        const extendedData = {
            ...l.extendedData,
            expiration: new Date(l.extendedData.expiration),
            state: (0, utilities_1.typedNodeAttr)(l.extendedData.state)
        };
        // @ts-ignore
        delete extendedData["#text"];
        return {
            id,
            author,
            title,
            published,
            updated,
            authorUri,
            type,
            src,
            lang,
            extendedData,
            links
        };
    });
    const { author: { name: author }, contributor: { name: contributor }, title } = raw;
    const updated = new Date((0, utilities_1.xmlNode)(raw, "updated"));
    return { author, contributor, title, updated, runs };
};
exports.parseTraceResults = parseTraceResults;
const parseTraceHitList = (xml) => {
    const raw = (0, AdtException_1.validateParseResult)(HitListResponse.decode((0, utilities_1.fullParse)(xml, { removeNSPrefix: true }))).hitlist;
    const parentLink = raw.link["@_href"];
    const entries = (0, utilities_1.extractXmlArray)(raw.entry).map(e => {
        var _a;
        const callingProgram = e.callingProgram
            ? (0, utilities_1.typedNodeAttr)(e.callingProgram)
            : undefined;
        const calledProgram = (_a = e.calledProgram) === null || _a === void 0 ? void 0 : _a["@_context"];
        const grossTime = (0, utilities_1.typedNodeAttr)(e.grossTime);
        const traceEventNetTime = (0, utilities_1.typedNodeAttr)(e.traceEventNetTime);
        const proceduralNetTime = (0, utilities_1.typedNodeAttr)(e.proceduralNetTime);
        return {
            ...(0, utilities_1.typedNodeAttr)(e),
            callingProgram,
            calledProgram,
            grossTime,
            traceEventNetTime,
            proceduralNetTime
        };
    });
    return { parentLink, entries };
};
exports.parseTraceHitList = parseTraceHitList;
const parseTraceDbAccess = (xml) => {
    const toParse = (0, utilities_1.fullParse)(xml, { removeNSPrefix: true });
    const parsed = traceDBAccesResponse.decode(toParse);
    const raw = (0, AdtException_1.validateParseResult)(parsed).dbAccesses;
    const parentLink = raw.link["@_href"];
    const dbaccesses = (0, utilities_1.extractXmlArray)(raw.dbAccess).map(a => {
        const callingProgram = a.callingProgram && (0, utilities_1.typedNodeAttr)(a.callingProgram);
        const accessTime = (0, utilities_1.typedNodeAttr)(a.accessTime);
        return { ...(0, utilities_1.typedNodeAttr)(a), accessTime, callingProgram };
    });
    const tables = raw.tables === ""
        ? []
        : (0, utilities_1.extractXmlArray)(raw.tables.table).map(utilities_1.typedNodeAttr);
    return { parentLink, dbaccesses, tables };
};
exports.parseTraceDbAccess = parseTraceDbAccess;
const parseCount = (count) => {
    if ((0, utilities_1.isNumber)(count))
        return count;
    const [base, exp] = count.split("E").map(utilities_1.toInt);
    if (exp)
        return base * 10 ** exp;
    return base;
};
const parseTraceStatements = (xml) => {
    const raw = (0, AdtException_1.validateParseResult)(traceStatementResponse.decode((0, utilities_1.fullParse)(xml, { removeNSPrefix: true }))).statements;
    const parentLink = raw.link["@_href"];
    const statements = (0, utilities_1.extractXmlArray)(raw.statement).map(s => {
        const callingProgram = (0, utilities_1.typedNodeAttr)(s.callingProgram);
        const grossTime = (0, utilities_1.typedNodeAttr)(s.grossTime);
        const proceduralNetTime = (0, utilities_1.typedNodeAttr)(s.proceduralNetTime);
        const traceEventNetTime = (0, utilities_1.typedNodeAttr)(s.traceEventNetTime);
        return {
            ...(0, utilities_1.typedNodeAttr)(s),
            callingProgram,
            grossTime,
            traceEventNetTime,
            proceduralNetTime
        };
    });
    const count = parseCount(raw["@_count"]);
    return { ...(0, utilities_1.typedNodeAttr)(raw), count, parentLink, statements };
};
exports.parseTraceStatements = parseTraceStatements;
const parseTraceRequestList = (xml) => {
    const raw = tracesListRequest.decode((0, utilities_1.fullParse)(xml, { removeNSPrefix: true }));
    const parsed = (0, AdtException_1.validateParseResult)(raw).feed;
    const { contributor: { name: contributorName, "@_role": contributorRole }, title } = parsed;
    const requests = (0, utilities_1.extractXmlArray)(parsed.entry).map(e => {
        const { id, "@_lang": lang, title } = e;
        const published = new Date(e.published);
        const updated = new Date(e.updated);
        const links = (0, utilities_1.extractXmlArray)(e.link).map(utilities_1.typedNodeAttr);
        const authors = (0, utilities_1.extractXmlArray)(e.author).map(({ name, uri, "@_role": role }) => ({ name, role, uri }));
        const { "@_src": contentSrc, "@_type": contentType } = e.content;
        const { description, executions, isAggregated, host, requestIndex } = e.extendedData;
        const expires = new Date(e.extendedData.expires);
        const processType = decodeProcessType(e.extendedData.processType["@_processTypeId"]);
        const objectType = decodeObjectType(e.extendedData.object["@_objectTypeId"]);
        const clients = (0, utilities_1.extractXmlArray)(e.extendedData.client).map(({ "#text": id = 0, "@_role": role = "" }) => ({ id, role }));
        const extendedData = {
            description,
            executions: (0, utilities_1.typedNodeAttr)(executions),
            isAggregated,
            host,
            expires,
            processType,
            objectType,
            requestIndex,
            clients
        };
        return {
            id,
            lang,
            title,
            published,
            updated,
            links,
            authors,
            contentSrc,
            contentType,
            extendedData
        };
    });
    return { title, contributorName, contributorRole, requests };
};
exports.parseTraceRequestList = parseTraceRequestList;


/***/ }),

/***/ "./build/api/transports.js":
/*!*********************************!*\
  !*** ./build/api/transports.js ***!
  \*********************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getTransportConfiguration = exports.transportConfigurations = exports.transportReference = exports.systemUsers = exports.transportAddUser = exports.transportSetOwner = exports.transportRelease = exports.transportDelete = exports.setTransportsConfig = exports.createTransportsConfig = exports.transportsByConfig = exports.userTransports = exports.createTransport = exports.transportInfo = exports.TransportDateFilter = void 0;
const AdtException_1 = __webpack_require__(/*! ../AdtException */ "./build/AdtException.js");
const utilities_1 = __webpack_require__(/*! ../utilities */ "./build/utilities.js");
var TransportDateFilter;
(function (TransportDateFilter) {
    TransportDateFilter[TransportDateFilter["SinceYesterday"] = 0] = "SinceYesterday";
    TransportDateFilter[TransportDateFilter["SincleTwoWeeks"] = 1] = "SincleTwoWeeks";
    TransportDateFilter[TransportDateFilter["SinceFourWeeks"] = 2] = "SinceFourWeeks";
    TransportDateFilter[TransportDateFilter["DateRange"] = 3] = "DateRange";
})(TransportDateFilter = exports.TransportDateFilter || (exports.TransportDateFilter = {}));
function extractLocks(raw) {
    const lock = raw && raw.CTS_OBJECT_LOCK;
    if (!lock)
        return;
    try {
        const holder = lock.LOCK_HOLDER;
        const TASKS = (0, utilities_1.xmlArray)(holder, "TASK_HEADERS").map((x) => x.CTS_TASK_HEADER);
        return {
            HEADER: holder.REQ_HEADER,
            OBJECT_KEY: (0, utilities_1.xmlNode)(lock, "OBJECT_KEY"),
            TASKS
        };
    }
    catch (_a) {
        return;
    }
}
function extractTransports(raw) {
    return (0, utilities_1.xmlArray)(raw, "CTS_REQUEST").map((x) => x.REQ_HEADER);
}
async function transportInfo(h, URI, DEVCLASS = "", OPERATION = "I") {
    (0, AdtException_1.ValidateObjectUrl)(URI);
    const body = (0, utilities_1.JSON2AbapXML)({
        DEVCLASS,
        OPERATION,
        URI
    });
    const headers = {
        Accept: "application/vnd.sap.as+xml;charset=UTF-8;dataname=com.sap.adt.transport.service.checkData",
        "Content-Type": "application/vnd.sap.as+xml; charset=UTF-8; dataname=com.sap.adt.transport.service.checkData"
    };
    const response = await h.request("/sap/bc/adt/cts/transportchecks", {
        body,
        method: "POST",
        headers
    });
    // return parsePackageResponse(response.body)
    // tslint:disable-next-line: prefer-const
    let { REQUESTS, LOCKS, MESSAGES, ...header } = (0, utilities_1.parse)(response.body)["asx:abap"]["asx:values"].DATA;
    if (MESSAGES) {
        MESSAGES = (0, utilities_1.xmlArray)(MESSAGES, "CTS_MESSAGE").map((m) => {
            // tslint:disable-next-line: prefer-const
            let { VARIABLES, ...rest } = m;
            VARIABLES =
                (VARIABLES && (0, utilities_1.xmlArray)(m, "VARIABLES", "CTS_VARIABLE")).map((v) => v.VARIABLE) || [];
            return { VARIABLES, ...rest };
        });
        MESSAGES.filter((m) => m.SEVERITY.match(/[EAX]/)).some((e) => {
            throw (0, AdtException_1.adtException)(e.TEXT);
        });
    }
    const TRANSPORTS = extractTransports(REQUESTS);
    return { ...header, LOCKS: extractLocks(LOCKS), TRANSPORTS };
}
exports.transportInfo = transportInfo;
async function createTransport(h, REF, REQUEST_TEXT, DEVCLASS, OPERATION = "I", transportLayer = "") {
    var _a;
    (0, AdtException_1.ValidateObjectUrl)(REF);
    const body = (0, utilities_1.JSON2AbapXML)({ DEVCLASS, REQUEST_TEXT, REF, OPERATION });
    const qs = transportLayer ? { transportLayer } : {};
    const response = await h.request("/sap/bc/adt/cts/transports", {
        body,
        qs,
        headers: {
            Accept: "text/plain",
            "Content-Type": "application/vnd.sap.as+xml; charset=UTF-8; dataname=com.sap.adt.CreateCorrectionRequest"
        },
        method: "POST"
    });
    const transport = (_a = response.body) === null || _a === void 0 ? void 0 : _a.split("/").pop();
    return transport || "";
}
exports.createTransport = createTransport;
const parseTask = (t) => {
    const task = {
        ...(0, utilities_1.xmlNodeAttr)(t),
        links: (0, utilities_1.xmlArray)(t, "atom:link").map(utilities_1.xmlNodeAttr),
        objects: (0, utilities_1.xmlArray)(t, "tm:abap_object").map(utilities_1.xmlNodeAttr)
    };
    if (task["tm:desc"])
        task["tm:desc"] = task["tm:desc"];
    return task;
};
const parseRequest = (r) => {
    const request = {
        ...parseTask(r),
        tasks: (0, utilities_1.xmlArray)(r, "tm:task").map(parseTask)
    };
    return request;
};
const parseTargets = (s) => ({
    ...(0, utilities_1.xmlNodeAttr)(s),
    modifiable: (0, utilities_1.xmlArray)(s, "tm:modifiable", "tm:request").map(parseRequest),
    released: (0, utilities_1.xmlArray)(s, "tm:released", "tm:request").map(parseRequest)
});
async function userTransports(h, user, targets = true) {
    const response = await h.request("/sap/bc/adt/cts/transportrequests", {
        qs: { user, targets }
    });
    const raw = (0, utilities_1.fullParse)(response.body);
    const workbench = (0, utilities_1.xmlArray)(raw, "tm:root", "tm:workbench", "tm:target").map(parseTargets);
    const customizing = (0, utilities_1.xmlArray)(raw, "tm:root", "tm:customizing", "tm:target").map(parseTargets);
    const retval = { workbench, customizing };
    return retval;
}
exports.userTransports = userTransports;
async function transportsByConfig(h, configUri, targets = true) {
    const response = await h.request("/sap/bc/adt/cts/transportrequests", {
        qs: { configUri, targets }
    });
    const raw = (0, utilities_1.fullParse)(response.body);
    const workbench = (0, utilities_1.xmlArray)(raw, "tm:root", "tm:workbench", "tm:target").map(parseTargets);
    const customizing = (0, utilities_1.xmlArray)(raw, "tm:root", "tm:customizing", "tm:target").map(parseTargets);
    const retval = { workbench, customizing };
    return retval;
}
exports.transportsByConfig = transportsByConfig;
const serializeTransportConfig = (cfg) => {
    const w = (k, v) => `<configuration:property key="${k}">${v}</configuration:property>`;
    const p = (v, k) => w(k, v[k]);
    const td = (d) => `${(0, utilities_1.toSapDate)(new Date(d))}`;
    const datelimit = cfg.DateFilter === TransportDateFilter.DateRange
        ? `${w("FromDate", td(cfg.FromDate))}${w("ToDate", td(cfg.ToDate))}`
        : "";
    return "".concat(`<configuration:configuration xmlns:configuration="http://www.sap.com/adt/configuration"> <configuration:properties>`, p(cfg, "WorkbenchRequests"), p(cfg, "CustomizingRequests"), p(cfg, "TransportOfCopies"), p(cfg, "DateFilter"), p(cfg, "Modifiable"), p(cfg, "Released"), p(cfg, "User"), datelimit, `</configuration:properties> </configuration:configuration>`);
};
async function createTransportsConfig(h) {
    const headers = { Accept: "application/vnd.sap.adt.configuration.v1+xml" };
    const uri = "/sap/bc/adt/cts/transportrequests/searchconfiguration/configurations";
    const response = await h.request(uri, { method: "POST", headers });
    return parseTransportConfig(response.body);
}
exports.createTransportsConfig = createTransportsConfig;
async function setTransportsConfig(h, uri, etag, config) {
    const body = serializeTransportConfig(config);
    const headers = {
        Accept: "application/vnd.sap.adt.configuration.v1+xml",
        "Content-Type": "application/vnd.sap.adt.configuration.v1+xml",
        "If-Match": etag
    };
    const response = await h.request(uri, { method: "PUT", headers, body });
    return parseTransportConfig(response.body);
}
exports.setTransportsConfig = setTransportsConfig;
function validateTransport(transportNumber) {
    if (transportNumber.length !== 10 || !transportNumber.match(/^[a-z]\w\wk/i))
        (0, AdtException_1.adtException)("Invalid transport number:" + transportNumber);
}
async function transportDelete(h, transportNumber) {
    validateTransport(transportNumber);
    await h.request("/sap/bc/adt/cts/transportrequests/" + transportNumber, {
        method: "DELETE",
        headers: { Accept: "application/*" }
    });
}
exports.transportDelete = transportDelete;
async function transportRelease(h, transportNumber, ignoreLocks = false, IgnoreATC = false) {
    validateTransport(transportNumber);
    const action = IgnoreATC
        ? "relObjigchkatc"
        : ignoreLocks
            ? "relwithignlock"
            : "newreleasejobs";
    const response = await h.request(`/sap/bc/adt/cts/transportrequests/${transportNumber}/${action}`, {
        method: "POST",
        headers: { Accept: "application/*" }
    });
    const raw = (0, utilities_1.fullParse)(response.body);
    const reports = (0, utilities_1.xmlArray)(raw, "tm:root", "tm:releasereports", "chkrun:checkReport").map((r) => {
        return {
            ...(0, utilities_1.xmlNodeAttr)(r),
            messages: (0, utilities_1.xmlArray)(r, "chkrun:checkMessageList", "chkrun:checkMessage").map(utilities_1.xmlNodeAttr)
        };
    });
    return reports;
}
exports.transportRelease = transportRelease;
async function transportSetOwner(h, transportNumber, targetuser) {
    validateTransport(transportNumber);
    const body = `<?xml version="1.0" encoding="ASCII"?><tm:root xmlns:tm="http://www.sap.com/cts/adt/tm" tm:number="${transportNumber}" tm:targetuser="${targetuser}" tm:useraction="changeowner"/>`;
    const response = await h.request("/sap/bc/adt/cts/transportrequests/" + transportNumber, {
        method: "PUT",
        headers: { Accept: "application/*" },
        qs: { targetuser },
        body
    });
    const raw = (0, utilities_1.fullParse)(response.body);
    return (0, utilities_1.xmlNodeAttr)((0, utilities_1.xmlNode)(raw, "tm:root"));
}
exports.transportSetOwner = transportSetOwner;
async function transportAddUser(h, transportNumber, user) {
    validateTransport(transportNumber);
    const body = `<?xml version="1.0" encoding="ASCII"?>
  <tm:root xmlns:tm="http://www.sap.com/cts/adt/tm" tm:number="${transportNumber}"
  tm:targetuser="${user}" tm:useraction="newtask"/>`;
    const response = await h.request("/sap/bc/adt/cts/transportrequests/" + transportNumber + "/tasks", {
        method: "POST",
        body,
        headers: { Accept: "application/*", "Content-Type": "text/plain" }
    });
    const raw = (0, utilities_1.fullParse)(response.body);
    return (0, utilities_1.xmlNodeAttr)((0, utilities_1.xmlNode)(raw, "tm:root"));
}
exports.transportAddUser = transportAddUser;
async function systemUsers(h) {
    const response = await h.request("/sap/bc/adt/system/users", {
        headers: { Accept: "application/atom+xml;type=feed" }
    });
    const raw = (0, utilities_1.parse)(response.body);
    return (0, utilities_1.xmlArray)(raw, "atom:feed", "atom:entry").map((r) => ({ id: r["atom:id"], title: r["atom:title"] }));
}
exports.systemUsers = systemUsers;
// tslint:disable: variable-name
async function transportReference(h, pgmid, obj_wbtype, obj_name, tr_number = "") {
    const response = await h.request("/sap/bc/adt/cts/transportrequests/reference", {
        headers: { Accept: "application/*" },
        qs: { obj_name, obj_wbtype, pgmid, tr_number }
    });
    const raw = (0, utilities_1.fullParse)(response.body);
    const link = (0, utilities_1.xmlNodeAttr)((0, utilities_1.xmlNode)(raw, "tm:root", "atom:link"));
    return link.href;
}
exports.transportReference = transportReference;
const parseTransportConfigItemList = (body) => {
    const raw = (0, utilities_1.fullParse)(body, { parseAttributeValue: false });
    return (0, utilities_1.xmlArray)(raw, "configurations:configurations", "configuration:configuration").map((conf) => {
        const { "atom:link": { "@_href": link, "@_etag": etag }, ...rest } = conf;
        const { createdAt, changedAt, ...attrs } = (0, utilities_1.xmlNodeAttr)(rest);
        const item = {
            ...attrs,
            link,
            etag,
            createdAt: Date.parse(createdAt),
            changedAt: Date.parse(changedAt)
        };
        return item;
    });
};
async function transportConfigurations(h) {
    const headers = { Accept: "application/vnd.sap.adt.configurations.v1+xml" };
    const url = "/sap/bc/adt/cts/transportrequests/searchconfiguration/configurations";
    const response = await h.request(url, { headers });
    return parseTransportConfigItemList(response.body);
}
exports.transportConfigurations = transportConfigurations;
const parseTransportConfig = (r) => {
    const raw = (0, utilities_1.fullParse)(r, { parseAttributeValue: false });
    const props = (0, utilities_1.xmlArray)(raw, "configuration:configuration", "configuration:properties", "configuration:property").map((p) => {
        return { key: p["@_key"], value: p["#text"] };
    });
    const cfg = {};
    for (const { key, value } of props)
        cfg[key] = value;
    const WorkbenchRequests = cfg.WorkbenchRequests;
    const TransportOfCopies = cfg.TransportOfCopies;
    const Released = cfg.Released;
    const User = cfg.User;
    const CustomizingRequests = cfg.CustomizingRequests;
    const FromDate = cfg.FromDate && (0, utilities_1.parseSapDate)(`${cfg.FromDate}`);
    const ToDate = cfg.ToDate && (0, utilities_1.parseSapDate)(`${cfg.ToDate}`);
    const DateFilter = cfg.DateFilter;
    const Modifiable = cfg.Modifiable;
    return {
        WorkbenchRequests,
        TransportOfCopies,
        Released,
        User,
        CustomizingRequests,
        FromDate,
        ToDate,
        DateFilter,
        Modifiable
    };
};
async function getTransportConfiguration(h, url) {
    const headers = { Accept: "application/vnd.sap.adt.configuration.v1+xml" };
    const response = await h.request(url, { headers });
    return parseTransportConfig(response.body);
}
exports.getTransportConfiguration = getTransportConfiguration;


/***/ }),

/***/ "./build/api/unittest.js":
/*!*******************************!*\
  !*** ./build/api/unittest.js ***!
  \*******************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.unitTestOccurrenceMarkers = exports.unitTestEvaluation = exports.runUnitTest = exports.DefaultUnitTestRunFlags = exports.UnitTestSeverity = exports.UnitTestAlertKind = void 0;
const t = __importStar(__webpack_require__(/*! io-ts */ "./node_modules/io-ts/es6/index.js"));
const __1 = __webpack_require__(/*! .. */ "./build/index.js");
const utilities_1 = __webpack_require__(/*! ../utilities */ "./build/utilities.js");
const urlparser_1 = __webpack_require__(/*! ./urlparser */ "./build/api/urlparser.js");
var UnitTestAlertKind;
(function (UnitTestAlertKind) {
    UnitTestAlertKind["exception"] = "exception";
    UnitTestAlertKind["failedAssertion"] = "failedAssertion";
    UnitTestAlertKind["warning"] = "warning";
})(UnitTestAlertKind = exports.UnitTestAlertKind || (exports.UnitTestAlertKind = {}));
var UnitTestSeverity;
(function (UnitTestSeverity) {
    UnitTestSeverity["critical"] = "critical";
    UnitTestSeverity["fatal"] = "fatal";
    UnitTestSeverity["tolerable"] = "tolerable";
    UnitTestSeverity["tolerant"] = "tolerant";
})(UnitTestSeverity = exports.UnitTestSeverity || (exports.UnitTestSeverity = {}));
const markerCodec = t.type({
    kind: t.string,
    keepsResult: t.boolean,
    location: urlparser_1.uriParts
});
const parseDetail = (alert) => (0, utilities_1.xmlArray)(alert, "details", "detail").reduce((result, d) => {
    const main = (d && d["@_text"]) || "";
    const children = (0, utilities_1.xmlArray)(d, "details", "detail")
        .map((dd) => (dd && `\n\t${dd["@_text"]}`) || "")
        .join("");
    return main ? [...result, main + children] : result;
}, []);
const parseStack = (alert) => (0, utilities_1.xmlArray)(alert, "stack", "stackEntry").map(x => {
    const entry = (0, utilities_1.xmlNodeAttr)(x);
    entry["adtcore:description"] = entry["adtcore:description"];
    return entry;
});
const parseAlert = (alert) => ({
    ...(0, utilities_1.xmlNodeAttr)(alert),
    details: parseDetail(alert),
    stack: parseStack(alert),
    title: (alert === null || alert === void 0 ? void 0 : alert.title) || ""
});
const parseMethod = (method) => ({
    ...(0, utilities_1.xmlNodeAttr)(method),
    alerts: (0, utilities_1.xmlArray)(method, "alerts", "alert").map(parseAlert)
});
exports.DefaultUnitTestRunFlags = {
    harmless: true,
    dangerous: false,
    critical: false,
    short: true,
    medium: false,
    long: false
};
async function runUnitTest(h, url, flags = exports.DefaultUnitTestRunFlags) {
    const headers = { "Content-Type": "application/*", Accept: "application/*" };
    const body = `<?xml version="1.0" encoding="UTF-8"?>
  <aunit:runConfiguration xmlns:aunit="http://www.sap.com/adt/aunit">
  <external>
    <coverage active="false"/>
  </external>
  <options>
    <uriType value="semantic"/>
    <testDeterminationStrategy sameProgram="true" assignedTests="false"/>
    <testRiskLevels harmless="${flags.harmless}" dangerous="${flags.dangerous}" critical="${flags.critical}"/>
    <testDurations short="${flags.short}" medium="${flags.medium}" long="${flags.long}"/>
    <withNavigationUri enabled="true"/>    
  </options>
  <adtcore:objectSets xmlns:adtcore="http://www.sap.com/adt/core">
    <objectSet kind="inclusive">
      <adtcore:objectReferences>
        <adtcore:objectReference adtcore:uri="${url}"/>
      </adtcore:objectReferences>
    </objectSet>
  </adtcore:objectSets>
</aunit:runConfiguration>`;
    const response = await h.request("/sap/bc/adt/abapunit/testruns", {
        method: "POST",
        headers,
        body
    });
    const raw = (0, utilities_1.fullParse)(response.body);
    const classes = (0, utilities_1.xmlFlatArray)(raw, "aunit:runResult", "program", "testClasses", "testClass").map(c => {
        return {
            ...(0, utilities_1.xmlNodeAttr)(c),
            alerts: (0, utilities_1.xmlArray)(c, "alerts", "alert").map(parseAlert),
            testmethods: (0, utilities_1.xmlFlatArray)(c, "testMethods", "testMethod").map(parseMethod)
        };
    });
    return classes;
}
exports.runUnitTest = runUnitTest;
async function unitTestEvaluation(h, clas, flags = exports.DefaultUnitTestRunFlags) {
    const headers = { "Content-Type": "application/*l", Accept: "application/*" };
    const references = clas.testmethods
        .map(m => `<adtcore:objectReference adtcore:uri="${m["adtcore:uri"]}" />`)
        .join("\n");
    const body = `<?xml version="1.0" encoding="UTF-8"?>
  <aunit:runConfiguration xmlns:aunit="http://www.sap.com/adt/aunit">
      <options>
          <uriType value="${clas.uriType}"></uriType>
          <testDeterminationStrategy sameProgram="true" assignedTests="false"></testDeterminationStrategy>
          <testRiskLevels harmless="${flags.harmless}" dangerous="${flags.dangerous}" critical="${flags.critical}"/>
          <testDurations short="${flags.short}" medium="${flags.medium}" long="${flags.long}"/>      
          <withNavigationUri enabled="true"></withNavigationUri>
      </options>
      <adtcore:objectSets xmlns:adtcore="http://www.sap.com/adt/core">
          <objectSet kind="inclusive">
              <adtcore:objectReferences>
              ${references}
              </adtcore:objectReferences>
          </objectSet>
      </adtcore:objectSets>
  </aunit:runConfiguration>`;
    const response = await h.request("/sap/bc/adt/abapunit/testruns/evaluation", {
        method: "POST",
        headers,
        body
    });
    const raw = (0, utilities_1.fullParse)(response.body);
    return (0, utilities_1.xmlArray)(raw, "aunit:runResult", "program", "testClasses", "testClass", "testMethods", "testMethod").map(parseMethod);
}
exports.unitTestEvaluation = unitTestEvaluation;
async function unitTestOccurrenceMarkers(h, uri, source) {
    const headers = { "Content-Type": "text/plain", Accept: "application/*" };
    const response = await h.request("/sap/bc/adt/abapsource/occurencemarkers", {
        method: "POST",
        headers,
        body: source,
        qs: { uri }
    });
    const raw = (0, utilities_1.fullParse)(response.body, { removeNSPrefix: true });
    const markers = (0, utilities_1.xmlArray)(raw, "occurrenceInfo", "occurrences", "occurrence").map(o => {
        const { kind, keepsResult } = (0, utilities_1.xmlNodeAttr)(o);
        const { uri } = (0, utilities_1.xmlNodeAttr)(o === null || o === void 0 ? void 0 : o.objectReference);
        return { kind, keepsResult, location: (0, urlparser_1.parseUri)(uri) };
    });
    return (0, __1.validateParseResult)(t.array(markerCodec).decode(markers));
}
exports.unitTestOccurrenceMarkers = unitTestOccurrenceMarkers;


/***/ }),

/***/ "./build/api/urlparser.js":
/*!********************************!*\
  !*** ./build/api/urlparser.js ***!
  \********************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.parseUri = exports.uriPartsToString = exports.rangeToString = exports.uriParts = void 0;
const utilities_1 = __webpack_require__(/*! ../utilities */ "./build/utilities.js");
const t = __importStar(__webpack_require__(/*! io-ts */ "./node_modules/io-ts/es6/index.js"));
const location = t.type({
    line: t.number,
    column: t.number
});
const range = t.type({
    start: location,
    end: location
});
exports.uriParts = t.type({
    uri: t.string,
    query: t.union([t.undefined, t.record(t.string, t.string)]),
    range: range,
    hashparms: t.union([t.undefined, t.record(t.string, t.string)]),
});
const rangeToString = (range) => `#start=${range.start.line},${range.start.column};end=${range.end.line},${range.end.column}`;
exports.rangeToString = rangeToString;
const serializeKv = (r) => {
    const rec = r || {};
    return Object.keys(rec).map(k => `${encodeURIComponent(k)}=${encodeURIComponent(rec[k])}`);
};
const isNullRange = (r) => r.start.line === 0 && r.start.column === 0 && r.end.line === 0 && r.end.column === 0;
const uriPartsToString = (parts) => {
    const range = isNullRange(parts.range) ? "" : (0, exports.rangeToString)(parts.range);
    const parms = serializeKv(parts.hashparms).join(";");
    const query = serializeKv(parts.query).join("&");
    const hash = `${range ? range : ""}${parms ? `${range ? ";" : "#"}${parms}` : ``}`;
    return `${parts.uri}${query ? `?${query}` : ``}${hash}`;
};
exports.uriPartsToString = uriPartsToString;
function parseUri(sourceuri) {
    const [uri, qs, hash] = (0, utilities_1.parts)(sourceuri, /([^\?#]*)(?:\?([^#]*))?(?:#(.*))?/);
    //
    const query = (qs || "").split(/&/).reduce((acc, cur) => {
        const [key, val] = cur.split("=");
        if (key)
            acc[decodeURIComponent(key)] = decodeURIComponent(val);
        return acc;
    }, {});
    const { start, end, ...hashparms } = (hash || "")
        .split(/;/)
        .reduce((acc, cur) => {
        const [key, val] = cur.split("=");
        if (key)
            acc[decodeURIComponent(key)] = decodeURIComponent(val);
        return acc;
    }, {});
    const parsePos = (x) => {
        const [line, column] = x ? x.split(",").map(utilities_1.toInt) : [0, 0];
        return { line: line || 0, column: column || 0 };
    };
    const st = parsePos(start);
    const range = {
        start: st,
        end: end ? parsePos(end) : st
    };
    return { range, uri, query, hashparms };
}
exports.parseUri = parseUri;


/***/ }),

/***/ "./build/browser/node_https.js":
/*!*************************************!*\
  !*** ./build/browser/node_https.js ***!
  \*************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Agent = void 0;
class Agent {
    constructor(opts) {
        //opts.ca
        //opts.keepAlive
        //opts.rejectUnauthorized
    }
}
exports.Agent = Agent;
const https = { Agent: Agent };
exports["default"] = https;


/***/ }),

/***/ "./build/build/axios.js":
/*!******************************!*\
  !*** ./build/build/axios.js ***!
  \******************************/
/***/ ((module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
console.log(axios);
module.exports = axios;


/***/ }),

/***/ "./build/index.js":
/*!************************!*\
  !*** ./build/index.js ***!
  \************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.traceProcessObjects = exports.servicePreviewUrl = exports.parseServiceBinding = exports.parentTypeId = exports.objectPath = exports.isDebuggerBreakpoint = exports.isDebuggee = exports.isDebugListenerError = exports.isPackageType = exports.isPackageOptions = exports.isNonGroupType = exports.isNodeParent = exports.isGroupType = exports.isCreatableTypeId = exports.isClassStructure = exports.isClassMetaData = exports.isBindingOptions = exports.inactiveObjectsInResults = exports.hasPackageOptions = exports.debugMetaIsComplex = exports.uriPartsToString = exports.UnitTestSeverity = exports.UnitTestAlertKind = exports.TypeKinds = exports.TransportDateFilter = exports.CreatableTypes = exports.BindinTypes = exports.session_types = void 0;
var AdtHTTP_1 = __webpack_require__(/*! ./AdtHTTP */ "./build/AdtHTTP.js");
Object.defineProperty(exports, "session_types", ({ enumerable: true, get: function () { return AdtHTTP_1.session_types; } }));
__exportStar(__webpack_require__(/*! ./AdtClient */ "./build/AdtClient.js"), exports);
__exportStar(__webpack_require__(/*! ./AdtException */ "./build/AdtException.js"), exports);
var api_1 = __webpack_require__(/*! ./api */ "./build/api/index.js");
Object.defineProperty(exports, "BindinTypes", ({ enumerable: true, get: function () { return api_1.BindinTypes; } }));
Object.defineProperty(exports, "CreatableTypes", ({ enumerable: true, get: function () { return api_1.CreatableTypes; } }));
Object.defineProperty(exports, "TransportDateFilter", ({ enumerable: true, get: function () { return api_1.TransportDateFilter; } }));
Object.defineProperty(exports, "TypeKinds", ({ enumerable: true, get: function () { return api_1.TypeKinds; } }));
Object.defineProperty(exports, "UnitTestAlertKind", ({ enumerable: true, get: function () { return api_1.UnitTestAlertKind; } }));
Object.defineProperty(exports, "UnitTestSeverity", ({ enumerable: true, get: function () { return api_1.UnitTestSeverity; } }));
Object.defineProperty(exports, "uriPartsToString", ({ enumerable: true, get: function () { return api_1.uriPartsToString; } }));
Object.defineProperty(exports, "debugMetaIsComplex", ({ enumerable: true, get: function () { return api_1.debugMetaIsComplex; } }));
Object.defineProperty(exports, "hasPackageOptions", ({ enumerable: true, get: function () { return api_1.hasPackageOptions; } }));
Object.defineProperty(exports, "inactiveObjectsInResults", ({ enumerable: true, get: function () { return api_1.inactiveObjectsInResults; } }));
Object.defineProperty(exports, "isBindingOptions", ({ enumerable: true, get: function () { return api_1.isBindingOptions; } }));
Object.defineProperty(exports, "isClassMetaData", ({ enumerable: true, get: function () { return api_1.isClassMetaData; } }));
Object.defineProperty(exports, "isClassStructure", ({ enumerable: true, get: function () { return api_1.isClassStructure; } }));
Object.defineProperty(exports, "isCreatableTypeId", ({ enumerable: true, get: function () { return api_1.isCreatableTypeId; } }));
Object.defineProperty(exports, "isGroupType", ({ enumerable: true, get: function () { return api_1.isGroupType; } }));
Object.defineProperty(exports, "isNodeParent", ({ enumerable: true, get: function () { return api_1.isNodeParent; } }));
Object.defineProperty(exports, "isNonGroupType", ({ enumerable: true, get: function () { return api_1.isNonGroupType; } }));
Object.defineProperty(exports, "isPackageOptions", ({ enumerable: true, get: function () { return api_1.isPackageOptions; } }));
Object.defineProperty(exports, "isPackageType", ({ enumerable: true, get: function () { return api_1.isPackageType; } }));
Object.defineProperty(exports, "isDebugListenerError", ({ enumerable: true, get: function () { return api_1.isDebugListenerError; } }));
Object.defineProperty(exports, "isDebuggee", ({ enumerable: true, get: function () { return api_1.isDebuggee; } }));
Object.defineProperty(exports, "isDebuggerBreakpoint", ({ enumerable: true, get: function () { return api_1.isDebuggerBreakpoint; } }));
Object.defineProperty(exports, "objectPath", ({ enumerable: true, get: function () { return api_1.objectPath; } }));
Object.defineProperty(exports, "parentTypeId", ({ enumerable: true, get: function () { return api_1.parentTypeId; } }));
Object.defineProperty(exports, "parseServiceBinding", ({ enumerable: true, get: function () { return api_1.parseServiceBinding; } }));
Object.defineProperty(exports, "servicePreviewUrl", ({ enumerable: true, get: function () { return api_1.servicePreviewUrl; } }));
Object.defineProperty(exports, "traceProcessObjects", ({ enumerable: true, get: function () { return api_1.traceProcessObjects; } }));


/***/ }),

/***/ "./build/requestLogger.js":
/*!********************************!*\
  !*** ./build/requestLogger.js ***!
  \********************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.logResponse = exports.logError = void 0;
const axios_1 = __importDefault(__webpack_require__(/*! axios */ "./build/build/axios.js"));
const _1 = __webpack_require__(/*! . */ "./build/index.js");
const utilities_1 = __webpack_require__(/*! ./utilities */ "./build/utilities.js");
const getLoggingData = (config) => {
    if (!(0, utilities_1.isObject)(config))
        return { id: -1, startTime: new Date(), duration: 0 };
    const id = (0, utilities_1.isNumber)(config === null || config === void 0 ? void 0 : config.adtRequestNumber) ? config.adtRequestNumber : -1;
    const startTime = (config === null || config === void 0 ? void 0 : config.adtStartTime) instanceof Date ? config.adtStartTime : new Date();
    return {
        id,
        startTime,
        duration: new Date().getTime() - startTime.getTime()
    };
};
const createLogData = (request, response, clientId, config, error) => {
    var _a;
    const { id, duration, startTime } = getLoggingData(config);
    const stateful = ((_a = request.headers) === null || _a === void 0 ? void 0 : _a["X-sap-adt-sessiontype"]) === _1.session_types.stateful;
    return { id, request, response, startTime, duration, stateful, clientId };
};
const convertRequest = (original) => {
    if (!(0, utilities_1.isObject)(original))
        return { headers: {}, method: "", uri: "", params: {} };
    const { headers, data, method, uri, params } = original;
    return {
        method: method || "GET",
        uri: (0, utilities_1.isString)(uri) ? uri : "",
        params: (0, utilities_1.isObject)(params) ? { ...params } : {},
        headers: (0, utilities_1.isObject)(headers) ? { ...headers } : {},
        body: (0, utilities_1.isString)(data) || (0, utilities_1.isUndefined)(data) ? data : JSON.stringify(data)
    };
};
const convertAxiosResponse = (original) => {
    if (!original)
        return { headers: {}, statusCode: 0, statusMessage: "" };
    const { headers, data, status, statusText } = original;
    return {
        headers: headers ? { ...headers } : {},
        statusCode: status,
        statusMessage: statusText,
        body: (0, utilities_1.isString)(data) ? data : JSON.stringify(data)
    };
};
const convertResponse = (original) => {
    if (!original)
        return { headers: {}, statusCode: 0, statusMessage: "" };
    if ((0, _1.isAdtException)(original)) {
        const resp = {
            headers: {},
            statusCode: (0, _1.isAdtError)(original) ? original.err : 501,
            statusMessage: original.message
        };
        return resp;
    }
    else {
        const { headers, body, status, statusText } = original;
        return {
            headers: headers ? { ...headers } : {},
            statusCode: status,
            statusMessage: statusText,
            body: (0, utilities_1.isString)(body) ? body : JSON.stringify(body)
        };
    }
};
const logError = (clientId, error, callback, config) => {
    try {
        if (!callback)
            return;
        if (axios_1.default.isAxiosError(error)) {
            const request = convertRequest(error.config);
            const response = convertAxiosResponse(error.response);
            callback(createLogData(request, response, clientId, error.config, error));
        }
        else {
            const resp = (0, _1.isAdtException)(error)
                ? convertResponse(error)
                : convertResponse(undefined);
            callback(createLogData(convertRequest(config), resp, clientId, config, error));
        }
    }
    catch (error) { }
};
exports.logError = logError;
const logResponse = (clientId, original, config, callback) => {
    try {
        if (!callback)
            return;
        const request = convertRequest(config);
        const response = convertResponse(original);
        callback(createLogData(request, response, clientId, config));
    }
    catch (error) { }
};
exports.logResponse = logResponse;


/***/ }),

/***/ "./build/utilities.js":
/*!****************************!*\
  !*** ./build/utilities.js ***!
  \****************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.mixed = exports.orUndefined = exports.toXmlAttributes = exports.formatQS = exports.boolFromAbap = exports.followUrl = exports.parts = exports.btoa = exports.parseJsonDate = exports.toSapDate = exports.parseSapDate = exports.toInt = exports.parse = exports.fullParse = exports.numberParseOptions = exports.bar = exports.typedNodeAttr = exports.xmlNodeAttr = exports.stripNs = exports.xmlRoot = exports.xmlArray = exports.xmlFlatArray = exports.xmlNode = exports.extractXmlArray = exports.xmlArrayType = exports.JSON2AbapXML = exports.isUndefined = exports.isNativeError = exports.isNumber = exports.isString = exports.isArray = exports.isObject = exports.encodeEntity = void 0;
const fast_xml_parser_1 = __webpack_require__(/*! fast-xml-parser */ "./node_modules/fast-xml-parser/src/fxp.js");
const t = __importStar(__webpack_require__(/*! io-ts */ "./node_modules/io-ts/es6/index.js"));
var html_entities_1 = __webpack_require__(/*! html-entities */ "./node_modules/html-entities/dist/commonjs/index.js");
Object.defineProperty(exports, "encodeEntity", ({ enumerable: true, get: function () { return html_entities_1.encode; } }));
const html_entities_2 = __webpack_require__(/*! html-entities */ "./node_modules/html-entities/dist/commonjs/index.js");
const isObject = (x) => !!x && typeof x === "object";
exports.isObject = isObject;
const isArray = (x) => Array.isArray(x);
exports.isArray = isArray;
const isString = (x) => typeof x === "string";
exports.isString = isString;
const isNumber = (x) => typeof x === "number";
exports.isNumber = isNumber;
const isNativeError = (e) => !!e && e instanceof Error;
exports.isNativeError = isNativeError;
const isUndefined = (x) => typeof x === "undefined";
exports.isUndefined = isUndefined;
function JSON2AbapXML(original, root = "DATA") {
    // only flat objects for now, might extend later...
    let inner = "";
    for (const key of Object.keys(original))
        if (original[key])
            inner = `${inner}\n<${key}>${(0, html_entities_2.encode)(original[key]) || ""}</${key}>`;
        else
            inner = `${inner}\n<${key}/>`;
    return `<?xml version="1.0" encoding="UTF-8"?><asx:abap xmlns:asx="http://www.sap.com/abapxml" version="1.0">
    <asx:values>
      <${root}>
        ${inner}
      </${root}>
    </asx:values>
  </asx:abap>`;
}
exports.JSON2AbapXML = JSON2AbapXML;
const xmlArrayType = (x) => t.union([t.array(x), x, t.undefined]);
exports.xmlArrayType = xmlArrayType;
const extractXmlArray = (x) => x ? ((0, exports.isArray)(x) ? x : [x]) : [];
exports.extractXmlArray = extractXmlArray;
function xmlNode(xml, ...path) {
    let current = xml;
    path.some(key => {
        // @ts-ignore
        if ((0, exports.isObject)(current))
            current = current[key];
        return !current;
    });
    return current;
}
exports.xmlNode = xmlNode;
function xmlFlatArray(xml, ...path) {
    if (!xml)
        return [];
    if (path.length === 0) {
        if ((0, exports.isArray)(xml))
            return xml;
        else
            return [xml];
    }
    if ((0, exports.isArray)(xml))
        return xml.reduce((arr, x) => [...arr, ...xmlFlatArray(x, ...path)], []);
    if ((0, exports.isObject)(xml)) {
        const [idx, ...rest] = path;
        // @ts-ignore
        return xmlFlatArray(xml[idx], ...rest);
    }
    return [];
}
exports.xmlFlatArray = xmlFlatArray;
function xmlArray(xml, ...path) {
    const node = xmlNode(xml, ...path);
    if (node) {
        if ((0, exports.isArray)(node))
            return node;
        else
            return [node];
    }
    return [];
}
exports.xmlArray = xmlArray;
const ok = Object.keys;
const xmlRoot = (o) => o[ok(o).filter(k => k !== "?xml")[0]];
exports.xmlRoot = xmlRoot;
const stripNs = (x) => x &&
    ok(x).reduce((obj, key) => {
        const nk = key.split(":").slice(1).join(":") || key;
        if (nk in obj)
            obj[key] = key;
        else
            obj[nk] = x[key];
        return obj;
    }, {});
exports.stripNs = stripNs;
const stripAttrPrefix = (x) => x.replace(/^@_/, "");
// extract XML attributes of a node from its JSON representation
const xmlNodeAttr = (n) => n &&
    ok(n)
        .filter(k => k.match(/^(?!@_xmlns)@_/))
        .reduce((part, cur) => {
        part[cur.replace(/^@_/, "")] = n[cur];
        return part;
    }, {});
exports.xmlNodeAttr = xmlNodeAttr;
const typedNodeAttr = (n) => n &&
    ok(n)
        .filter(k => k.match(/^(?!@_xmlns)@_/))
        .reduce((part, cur) => {
        // @ts-ignore
        part[cur.replace(/^@_/, "")] = n[cur];
        return part;
    }, {});
exports.typedNodeAttr = typedNodeAttr;
exports.bar = stripAttrPrefix("@_pip");
exports.numberParseOptions = {
    leadingZeros: false,
    hex: true,
    skipLike: new RegExp("")
};
const fullParse = (xml, options = {}) => new fast_xml_parser_1.XMLParser({
    ignoreAttributes: false,
    trimValues: false,
    parseAttributeValue: true,
    ...options
}).parse(xml);
exports.fullParse = fullParse;
const parse = (xml, options = {}) => new fast_xml_parser_1.XMLParser(options).parse(xml);
exports.parse = parse;
function toInt(x) {
    if (!x)
        return 0;
    if (x.match(/^\s*[+-]?\d*\s*$/))
        return Number.parseInt(x, 10);
    return 0;
}
exports.toInt = toInt;
const parseSapDate = (d) => {
    const match = d.match(/(\d\d\d\d)(\d\d)(\d\d)/);
    if (!match)
        return new Date(); // wrong but valid
    const [Y, M, D] = match.slice(1);
    return Date.UTC(toInt(Y), toInt(M) - 1, toInt(D));
};
exports.parseSapDate = parseSapDate;
const toSapDate = (d) => d.getUTCFullYear() * 10000 + (d.getUTCMonth() + 1) * 100 + d.getUTCDate();
exports.toSapDate = toSapDate;
const parseJsonDate = (d) => new Date(Date.parse(d));
exports.parseJsonDate = parseJsonDate;
function btoa(s) {
    return Buffer.from(s).toString("base64");
}
exports.btoa = btoa;
function parts(whole, pattern) {
    if (!(0, exports.isString)(whole))
        return [];
    const match = whole.match(pattern);
    return match ? match.slice(1) : [];
}
exports.parts = parts;
const followUrl = (base, extra) => {
    if (extra.match(/^\.\//)) {
        base = base.replace(/[^\/]*$/, "");
        extra = extra.replace(/^\.\//, "");
    }
    else
        extra = extra.replace(/^\//, "");
    base = base.replace(/\/$/, "");
    return base + "/" + extra;
};
exports.followUrl = followUrl;
const boolFromAbap = (x) => x === "X";
exports.boolFromAbap = boolFromAbap;
function formatQS(raw) {
    const val = (key, x) => (0, exports.isArray)(x)
        ? x.map(e => val(key, e)).join("&")
        : `${key}=${encodeURIComponent(x)}`;
    return Object.getOwnPropertyNames(raw)
        .map(k => val(k, raw[k]))
        .join("&");
}
exports.formatQS = formatQS;
const toXmlAttributes = (o, prefix) => {
    const sep = prefix ? ":" : "";
    return o
        ? Object.getOwnPropertyNames(o)
            .sort()
            .map(k => `${prefix}${sep}${k.replace(/^@_/, "")}="${o[k]}"`)
            .join(" ")
        : "";
};
exports.toXmlAttributes = toXmlAttributes;
const orUndefined = (x) => t.union([t.undefined, x]);
exports.orUndefined = orUndefined;
function mixed(required, optional) {
    return t.intersection([t.type(required), t.partial(optional)]);
}
exports.mixed = mixed;


/***/ }),

/***/ "./node_modules/fast-xml-parser/src/fxp.js":
/*!*************************************************!*\
  !*** ./node_modules/fast-xml-parser/src/fxp.js ***!
  \*************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const validator = __webpack_require__(/*! ./validator */ "./node_modules/fast-xml-parser/src/validator.js");
const XMLParser = __webpack_require__(/*! ./xmlparser/XMLParser */ "./node_modules/fast-xml-parser/src/xmlparser/XMLParser.js");
const XMLBuilder = __webpack_require__(/*! ./xmlbuilder/json2xml */ "./node_modules/fast-xml-parser/src/xmlbuilder/json2xml.js");

module.exports = {
  XMLParser: XMLParser,
  XMLValidator: validator,
  XMLBuilder: XMLBuilder
}

/***/ }),

/***/ "./node_modules/fast-xml-parser/src/ignoreAttributes.js":
/*!**************************************************************!*\
  !*** ./node_modules/fast-xml-parser/src/ignoreAttributes.js ***!
  \**************************************************************/
/***/ ((module) => {

function getIgnoreAttributesFn(ignoreAttributes) {
    if (typeof ignoreAttributes === 'function') {
        return ignoreAttributes
    }
    if (Array.isArray(ignoreAttributes)) {
        return (attrName) => {
            for (const pattern of ignoreAttributes) {
                if (typeof pattern === 'string' && attrName === pattern) {
                    return true
                }
                if (pattern instanceof RegExp && pattern.test(attrName)) {
                    return true
                }
            }
        }
    }
    return () => false
}

module.exports = getIgnoreAttributesFn

/***/ }),

/***/ "./node_modules/fast-xml-parser/src/util.js":
/*!**************************************************!*\
  !*** ./node_modules/fast-xml-parser/src/util.js ***!
  \**************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";


const nameStartChar = ':A-Za-z_\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD';
const nameChar = nameStartChar + '\\-.\\d\\u00B7\\u0300-\\u036F\\u203F-\\u2040';
const nameRegexp = '[' + nameStartChar + '][' + nameChar + ']*'
const regexName = new RegExp('^' + nameRegexp + '$');

const getAllMatches = function(string, regex) {
  const matches = [];
  let match = regex.exec(string);
  while (match) {
    const allmatches = [];
    allmatches.startIndex = regex.lastIndex - match[0].length;
    const len = match.length;
    for (let index = 0; index < len; index++) {
      allmatches.push(match[index]);
    }
    matches.push(allmatches);
    match = regex.exec(string);
  }
  return matches;
};

const isName = function(string) {
  const match = regexName.exec(string);
  return !(match === null || typeof match === 'undefined');
};

exports.isExist = function(v) {
  return typeof v !== 'undefined';
};

exports.isEmptyObject = function(obj) {
  return Object.keys(obj).length === 0;
};

/**
 * Copy all the properties of a into b.
 * @param {*} target
 * @param {*} a
 */
exports.merge = function(target, a, arrayMode) {
  if (a) {
    const keys = Object.keys(a); // will return an array of own properties
    const len = keys.length; //don't make it inline
    for (let i = 0; i < len; i++) {
      if (arrayMode === 'strict') {
        target[keys[i]] = [ a[keys[i]] ];
      } else {
        target[keys[i]] = a[keys[i]];
      }
    }
  }
};
/* exports.merge =function (b,a){
  return Object.assign(b,a);
} */

exports.getValue = function(v) {
  if (exports.isExist(v)) {
    return v;
  } else {
    return '';
  }
};

// const fakeCall = function(a) {return a;};
// const fakeCallNoReturn = function() {};

exports.isName = isName;
exports.getAllMatches = getAllMatches;
exports.nameRegexp = nameRegexp;


/***/ }),

/***/ "./node_modules/fast-xml-parser/src/validator.js":
/*!*******************************************************!*\
  !*** ./node_modules/fast-xml-parser/src/validator.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


const util = __webpack_require__(/*! ./util */ "./node_modules/fast-xml-parser/src/util.js");

const defaultOptions = {
  allowBooleanAttributes: false, //A tag can have attributes without any value
  unpairedTags: []
};

//const tagsPattern = new RegExp("<\\/?([\\w:\\-_\.]+)\\s*\/?>","g");
exports.validate = function (xmlData, options) {
  options = Object.assign({}, defaultOptions, options);

  //xmlData = xmlData.replace(/(\r\n|\n|\r)/gm,"");//make it single line
  //xmlData = xmlData.replace(/(^\s*<\?xml.*?\?>)/g,"");//Remove XML starting tag
  //xmlData = xmlData.replace(/(<!DOCTYPE[\s\w\"\.\/\-\:]+(\[.*\])*\s*>)/g,"");//Remove DOCTYPE
  const tags = [];
  let tagFound = false;

  //indicates that the root tag has been closed (aka. depth 0 has been reached)
  let reachedRoot = false;

  if (xmlData[0] === '\ufeff') {
    // check for byte order mark (BOM)
    xmlData = xmlData.substr(1);
  }
  
  for (let i = 0; i < xmlData.length; i++) {

    if (xmlData[i] === '<' && xmlData[i+1] === '?') {
      i+=2;
      i = readPI(xmlData,i);
      if (i.err) return i;
    }else if (xmlData[i] === '<') {
      //starting of tag
      //read until you reach to '>' avoiding any '>' in attribute value
      let tagStartPos = i;
      i++;
      
      if (xmlData[i] === '!') {
        i = readCommentAndCDATA(xmlData, i);
        continue;
      } else {
        let closingTag = false;
        if (xmlData[i] === '/') {
          //closing tag
          closingTag = true;
          i++;
        }
        //read tagname
        let tagName = '';
        for (; i < xmlData.length &&
          xmlData[i] !== '>' &&
          xmlData[i] !== ' ' &&
          xmlData[i] !== '\t' &&
          xmlData[i] !== '\n' &&
          xmlData[i] !== '\r'; i++
        ) {
          tagName += xmlData[i];
        }
        tagName = tagName.trim();
        //console.log(tagName);

        if (tagName[tagName.length - 1] === '/') {
          //self closing tag without attributes
          tagName = tagName.substring(0, tagName.length - 1);
          //continue;
          i--;
        }
        if (!validateTagName(tagName)) {
          let msg;
          if (tagName.trim().length === 0) {
            msg = "Invalid space after '<'.";
          } else {
            msg = "Tag '"+tagName+"' is an invalid name.";
          }
          return getErrorObject('InvalidTag', msg, getLineNumberForPosition(xmlData, i));
        }

        const result = readAttributeStr(xmlData, i);
        if (result === false) {
          return getErrorObject('InvalidAttr', "Attributes for '"+tagName+"' have open quote.", getLineNumberForPosition(xmlData, i));
        }
        let attrStr = result.value;
        i = result.index;

        if (attrStr[attrStr.length - 1] === '/') {
          //self closing tag
          const attrStrStart = i - attrStr.length;
          attrStr = attrStr.substring(0, attrStr.length - 1);
          const isValid = validateAttributeString(attrStr, options);
          if (isValid === true) {
            tagFound = true;
            //continue; //text may presents after self closing tag
          } else {
            //the result from the nested function returns the position of the error within the attribute
            //in order to get the 'true' error line, we need to calculate the position where the attribute begins (i - attrStr.length) and then add the position within the attribute
            //this gives us the absolute index in the entire xml, which we can use to find the line at last
            return getErrorObject(isValid.err.code, isValid.err.msg, getLineNumberForPosition(xmlData, attrStrStart + isValid.err.line));
          }
        } else if (closingTag) {
          if (!result.tagClosed) {
            return getErrorObject('InvalidTag', "Closing tag '"+tagName+"' doesn't have proper closing.", getLineNumberForPosition(xmlData, i));
          } else if (attrStr.trim().length > 0) {
            return getErrorObject('InvalidTag', "Closing tag '"+tagName+"' can't have attributes or invalid starting.", getLineNumberForPosition(xmlData, tagStartPos));
          } else if (tags.length === 0) {
            return getErrorObject('InvalidTag', "Closing tag '"+tagName+"' has not been opened.", getLineNumberForPosition(xmlData, tagStartPos));
          } else {
            const otg = tags.pop();
            if (tagName !== otg.tagName) {
              let openPos = getLineNumberForPosition(xmlData, otg.tagStartPos);
              return getErrorObject('InvalidTag',
                "Expected closing tag '"+otg.tagName+"' (opened in line "+openPos.line+", col "+openPos.col+") instead of closing tag '"+tagName+"'.",
                getLineNumberForPosition(xmlData, tagStartPos));
            }

            //when there are no more tags, we reached the root level.
            if (tags.length == 0) {
              reachedRoot = true;
            }
          }
        } else {
          const isValid = validateAttributeString(attrStr, options);
          if (isValid !== true) {
            //the result from the nested function returns the position of the error within the attribute
            //in order to get the 'true' error line, we need to calculate the position where the attribute begins (i - attrStr.length) and then add the position within the attribute
            //this gives us the absolute index in the entire xml, which we can use to find the line at last
            return getErrorObject(isValid.err.code, isValid.err.msg, getLineNumberForPosition(xmlData, i - attrStr.length + isValid.err.line));
          }

          //if the root level has been reached before ...
          if (reachedRoot === true) {
            return getErrorObject('InvalidXml', 'Multiple possible root nodes found.', getLineNumberForPosition(xmlData, i));
          } else if(options.unpairedTags.indexOf(tagName) !== -1){
            //don't push into stack
          } else {
            tags.push({tagName, tagStartPos});
          }
          tagFound = true;
        }

        //skip tag text value
        //It may include comments and CDATA value
        for (i++; i < xmlData.length; i++) {
          if (xmlData[i] === '<') {
            if (xmlData[i + 1] === '!') {
              //comment or CADATA
              i++;
              i = readCommentAndCDATA(xmlData, i);
              continue;
            } else if (xmlData[i+1] === '?') {
              i = readPI(xmlData, ++i);
              if (i.err) return i;
            } else{
              break;
            }
          } else if (xmlData[i] === '&') {
            const afterAmp = validateAmpersand(xmlData, i);
            if (afterAmp == -1)
              return getErrorObject('InvalidChar', "char '&' is not expected.", getLineNumberForPosition(xmlData, i));
            i = afterAmp;
          }else{
            if (reachedRoot === true && !isWhiteSpace(xmlData[i])) {
              return getErrorObject('InvalidXml', "Extra text at the end", getLineNumberForPosition(xmlData, i));
            }
          }
        } //end of reading tag text value
        if (xmlData[i] === '<') {
          i--;
        }
      }
    } else {
      if ( isWhiteSpace(xmlData[i])) {
        continue;
      }
      return getErrorObject('InvalidChar', "char '"+xmlData[i]+"' is not expected.", getLineNumberForPosition(xmlData, i));
    }
  }

  if (!tagFound) {
    return getErrorObject('InvalidXml', 'Start tag expected.', 1);
  }else if (tags.length == 1) {
      return getErrorObject('InvalidTag', "Unclosed tag '"+tags[0].tagName+"'.", getLineNumberForPosition(xmlData, tags[0].tagStartPos));
  }else if (tags.length > 0) {
      return getErrorObject('InvalidXml', "Invalid '"+
          JSON.stringify(tags.map(t => t.tagName), null, 4).replace(/\r?\n/g, '')+
          "' found.", {line: 1, col: 1});
  }

  return true;
};

function isWhiteSpace(char){
  return char === ' ' || char === '\t' || char === '\n'  || char === '\r';
}
/**
 * Read Processing insstructions and skip
 * @param {*} xmlData
 * @param {*} i
 */
function readPI(xmlData, i) {
  const start = i;
  for (; i < xmlData.length; i++) {
    if (xmlData[i] == '?' || xmlData[i] == ' ') {
      //tagname
      const tagname = xmlData.substr(start, i - start);
      if (i > 5 && tagname === 'xml') {
        return getErrorObject('InvalidXml', 'XML declaration allowed only at the start of the document.', getLineNumberForPosition(xmlData, i));
      } else if (xmlData[i] == '?' && xmlData[i + 1] == '>') {
        //check if valid attribut string
        i++;
        break;
      } else {
        continue;
      }
    }
  }
  return i;
}

function readCommentAndCDATA(xmlData, i) {
  if (xmlData.length > i + 5 && xmlData[i + 1] === '-' && xmlData[i + 2] === '-') {
    //comment
    for (i += 3; i < xmlData.length; i++) {
      if (xmlData[i] === '-' && xmlData[i + 1] === '-' && xmlData[i + 2] === '>') {
        i += 2;
        break;
      }
    }
  } else if (
    xmlData.length > i + 8 &&
    xmlData[i + 1] === 'D' &&
    xmlData[i + 2] === 'O' &&
    xmlData[i + 3] === 'C' &&
    xmlData[i + 4] === 'T' &&
    xmlData[i + 5] === 'Y' &&
    xmlData[i + 6] === 'P' &&
    xmlData[i + 7] === 'E'
  ) {
    let angleBracketsCount = 1;
    for (i += 8; i < xmlData.length; i++) {
      if (xmlData[i] === '<') {
        angleBracketsCount++;
      } else if (xmlData[i] === '>') {
        angleBracketsCount--;
        if (angleBracketsCount === 0) {
          break;
        }
      }
    }
  } else if (
    xmlData.length > i + 9 &&
    xmlData[i + 1] === '[' &&
    xmlData[i + 2] === 'C' &&
    xmlData[i + 3] === 'D' &&
    xmlData[i + 4] === 'A' &&
    xmlData[i + 5] === 'T' &&
    xmlData[i + 6] === 'A' &&
    xmlData[i + 7] === '['
  ) {
    for (i += 8; i < xmlData.length; i++) {
      if (xmlData[i] === ']' && xmlData[i + 1] === ']' && xmlData[i + 2] === '>') {
        i += 2;
        break;
      }
    }
  }

  return i;
}

const doubleQuote = '"';
const singleQuote = "'";

/**
 * Keep reading xmlData until '<' is found outside the attribute value.
 * @param {string} xmlData
 * @param {number} i
 */
function readAttributeStr(xmlData, i) {
  let attrStr = '';
  let startChar = '';
  let tagClosed = false;
  for (; i < xmlData.length; i++) {
    if (xmlData[i] === doubleQuote || xmlData[i] === singleQuote) {
      if (startChar === '') {
        startChar = xmlData[i];
      } else if (startChar !== xmlData[i]) {
        //if vaue is enclosed with double quote then single quotes are allowed inside the value and vice versa
      } else {
        startChar = '';
      }
    } else if (xmlData[i] === '>') {
      if (startChar === '') {
        tagClosed = true;
        break;
      }
    }
    attrStr += xmlData[i];
  }
  if (startChar !== '') {
    return false;
  }

  return {
    value: attrStr,
    index: i,
    tagClosed: tagClosed
  };
}

/**
 * Select all the attributes whether valid or invalid.
 */
const validAttrStrRegxp = new RegExp('(\\s*)([^\\s=]+)(\\s*=)?(\\s*([\'"])(([\\s\\S])*?)\\5)?', 'g');

//attr, ="sd", a="amit's", a="sd"b="saf", ab  cd=""

function validateAttributeString(attrStr, options) {
  //console.log("start:"+attrStr+":end");

  //if(attrStr.trim().length === 0) return true; //empty string

  const matches = util.getAllMatches(attrStr, validAttrStrRegxp);
  const attrNames = {};

  for (let i = 0; i < matches.length; i++) {
    if (matches[i][1].length === 0) {
      //nospace before attribute name: a="sd"b="saf"
      return getErrorObject('InvalidAttr', "Attribute '"+matches[i][2]+"' has no space in starting.", getPositionFromMatch(matches[i]))
    } else if (matches[i][3] !== undefined && matches[i][4] === undefined) {
      return getErrorObject('InvalidAttr', "Attribute '"+matches[i][2]+"' is without value.", getPositionFromMatch(matches[i]));
    } else if (matches[i][3] === undefined && !options.allowBooleanAttributes) {
      //independent attribute: ab
      return getErrorObject('InvalidAttr', "boolean attribute '"+matches[i][2]+"' is not allowed.", getPositionFromMatch(matches[i]));
    }
    /* else if(matches[i][6] === undefined){//attribute without value: ab=
                    return { err: { code:"InvalidAttr",msg:"attribute " + matches[i][2] + " has no value assigned."}};
                } */
    const attrName = matches[i][2];
    if (!validateAttrName(attrName)) {
      return getErrorObject('InvalidAttr', "Attribute '"+attrName+"' is an invalid name.", getPositionFromMatch(matches[i]));
    }
    if (!attrNames.hasOwnProperty(attrName)) {
      //check for duplicate attribute.
      attrNames[attrName] = 1;
    } else {
      return getErrorObject('InvalidAttr', "Attribute '"+attrName+"' is repeated.", getPositionFromMatch(matches[i]));
    }
  }

  return true;
}

function validateNumberAmpersand(xmlData, i) {
  let re = /\d/;
  if (xmlData[i] === 'x') {
    i++;
    re = /[\da-fA-F]/;
  }
  for (; i < xmlData.length; i++) {
    if (xmlData[i] === ';')
      return i;
    if (!xmlData[i].match(re))
      break;
  }
  return -1;
}

function validateAmpersand(xmlData, i) {
  // https://www.w3.org/TR/xml/#dt-charref
  i++;
  if (xmlData[i] === ';')
    return -1;
  if (xmlData[i] === '#') {
    i++;
    return validateNumberAmpersand(xmlData, i);
  }
  let count = 0;
  for (; i < xmlData.length; i++, count++) {
    if (xmlData[i].match(/\w/) && count < 20)
      continue;
    if (xmlData[i] === ';')
      break;
    return -1;
  }
  return i;
}

function getErrorObject(code, message, lineNumber) {
  return {
    err: {
      code: code,
      msg: message,
      line: lineNumber.line || lineNumber,
      col: lineNumber.col,
    },
  };
}

function validateAttrName(attrName) {
  return util.isName(attrName);
}

// const startsWithXML = /^xml/i;

function validateTagName(tagname) {
  return util.isName(tagname) /* && !tagname.match(startsWithXML) */;
}

//this function returns the line number for the character at the given index
function getLineNumberForPosition(xmlData, index) {
  const lines = xmlData.substring(0, index).split(/\r?\n/);
  return {
    line: lines.length,

    // column number is last line's length + 1, because column numbering starts at 1:
    col: lines[lines.length - 1].length + 1
  };
}

//this function returns the position of the first character of match within attrStr
function getPositionFromMatch(match) {
  return match.startIndex + match[1].length;
}


/***/ }),

/***/ "./node_modules/fast-xml-parser/src/xmlbuilder/json2xml.js":
/*!*****************************************************************!*\
  !*** ./node_modules/fast-xml-parser/src/xmlbuilder/json2xml.js ***!
  \*****************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

//parse Empty Node as self closing node
const buildFromOrderedJs = __webpack_require__(/*! ./orderedJs2Xml */ "./node_modules/fast-xml-parser/src/xmlbuilder/orderedJs2Xml.js");
const getIgnoreAttributesFn = __webpack_require__(/*! ../ignoreAttributes */ "./node_modules/fast-xml-parser/src/ignoreAttributes.js")

const defaultOptions = {
  attributeNamePrefix: '@_',
  attributesGroupName: false,
  textNodeName: '#text',
  ignoreAttributes: true,
  cdataPropName: false,
  format: false,
  indentBy: '  ',
  suppressEmptyNode: false,
  suppressUnpairedNode: true,
  suppressBooleanAttributes: true,
  tagValueProcessor: function(key, a) {
    return a;
  },
  attributeValueProcessor: function(attrName, a) {
    return a;
  },
  preserveOrder: false,
  commentPropName: false,
  unpairedTags: [],
  entities: [
    { regex: new RegExp("&", "g"), val: "&amp;" },//it must be on top
    { regex: new RegExp(">", "g"), val: "&gt;" },
    { regex: new RegExp("<", "g"), val: "&lt;" },
    { regex: new RegExp("\'", "g"), val: "&apos;" },
    { regex: new RegExp("\"", "g"), val: "&quot;" }
  ],
  processEntities: true,
  stopNodes: [],
  // transformTagName: false,
  // transformAttributeName: false,
  oneListGroup: false
};

function Builder(options) {
  this.options = Object.assign({}, defaultOptions, options);
  if (this.options.ignoreAttributes === true || this.options.attributesGroupName) {
    this.isAttribute = function(/*a*/) {
      return false;
    };
  } else {
    this.ignoreAttributesFn = getIgnoreAttributesFn(this.options.ignoreAttributes)
    this.attrPrefixLen = this.options.attributeNamePrefix.length;
    this.isAttribute = isAttribute;
  }

  this.processTextOrObjNode = processTextOrObjNode

  if (this.options.format) {
    this.indentate = indentate;
    this.tagEndChar = '>\n';
    this.newLine = '\n';
  } else {
    this.indentate = function() {
      return '';
    };
    this.tagEndChar = '>';
    this.newLine = '';
  }
}

Builder.prototype.build = function(jObj) {
  if(this.options.preserveOrder){
    return buildFromOrderedJs(jObj, this.options);
  }else {
    if(Array.isArray(jObj) && this.options.arrayNodeName && this.options.arrayNodeName.length > 1){
      jObj = {
        [this.options.arrayNodeName] : jObj
      }
    }
    return this.j2x(jObj, 0, []).val;
  }
};

Builder.prototype.j2x = function(jObj, level, ajPath) {
  let attrStr = '';
  let val = '';
  const jPath = ajPath.join('.')
  for (let key in jObj) {
    if(!Object.prototype.hasOwnProperty.call(jObj, key)) continue;
    if (typeof jObj[key] === 'undefined') {
      // supress undefined node only if it is not an attribute
      if (this.isAttribute(key)) {
        val += '';
      }
    } else if (jObj[key] === null) {
      // null attribute should be ignored by the attribute list, but should not cause the tag closing
      if (this.isAttribute(key)) {
        val += '';
      } else if (key === this.options.cdataPropName) {
        val += '';
      } else if (key[0] === '?') {
        val += this.indentate(level) + '<' + key + '?' + this.tagEndChar;
      } else {
        val += this.indentate(level) + '<' + key + '/' + this.tagEndChar;
      }
      // val += this.indentate(level) + '<' + key + '/' + this.tagEndChar;
    } else if (jObj[key] instanceof Date) {
      val += this.buildTextValNode(jObj[key], key, '', level);
    } else if (typeof jObj[key] !== 'object') {
      //premitive type
      const attr = this.isAttribute(key);
      if (attr && !this.ignoreAttributesFn(attr, jPath)) {
        attrStr += this.buildAttrPairStr(attr, '' + jObj[key]);
      } else if (!attr) {
        //tag value
        if (key === this.options.textNodeName) {
          let newval = this.options.tagValueProcessor(key, '' + jObj[key]);
          val += this.replaceEntitiesValue(newval);
        } else {
          val += this.buildTextValNode(jObj[key], key, '', level);
        }
      }
    } else if (Array.isArray(jObj[key])) {
      //repeated nodes
      const arrLen = jObj[key].length;
      let listTagVal = "";
      let listTagAttr = "";
      for (let j = 0; j < arrLen; j++) {
        const item = jObj[key][j];
        if (typeof item === 'undefined') {
          // supress undefined node
        } else if (item === null) {
          if(key[0] === "?") val += this.indentate(level) + '<' + key + '?' + this.tagEndChar;
          else val += this.indentate(level) + '<' + key + '/' + this.tagEndChar;
          // val += this.indentate(level) + '<' + key + '/' + this.tagEndChar;
        } else if (typeof item === 'object') {
          if(this.options.oneListGroup){
            const result = this.j2x(item, level + 1, ajPath.concat(key));
            listTagVal += result.val;
            if (this.options.attributesGroupName && item.hasOwnProperty(this.options.attributesGroupName)) {
              listTagAttr += result.attrStr
            }
          }else{
            listTagVal += this.processTextOrObjNode(item, key, level, ajPath)
          }
        } else {
          if (this.options.oneListGroup) {
            let textValue = this.options.tagValueProcessor(key, item);
            textValue = this.replaceEntitiesValue(textValue);
            listTagVal += textValue;
          } else {
            listTagVal += this.buildTextValNode(item, key, '', level);
          }
        }
      }
      if(this.options.oneListGroup){
        listTagVal = this.buildObjectNode(listTagVal, key, listTagAttr, level);
      }
      val += listTagVal;
    } else {
      //nested node
      if (this.options.attributesGroupName && key === this.options.attributesGroupName) {
        const Ks = Object.keys(jObj[key]);
        const L = Ks.length;
        for (let j = 0; j < L; j++) {
          attrStr += this.buildAttrPairStr(Ks[j], '' + jObj[key][Ks[j]]);
        }
      } else {
        val += this.processTextOrObjNode(jObj[key], key, level, ajPath)
      }
    }
  }
  return {attrStr: attrStr, val: val};
};

Builder.prototype.buildAttrPairStr = function(attrName, val){
  val = this.options.attributeValueProcessor(attrName, '' + val);
  val = this.replaceEntitiesValue(val);
  if (this.options.suppressBooleanAttributes && val === "true") {
    return ' ' + attrName;
  } else return ' ' + attrName + '="' + val + '"';
}

function processTextOrObjNode (object, key, level, ajPath) {
  const result = this.j2x(object, level + 1, ajPath.concat(key));
  if (object[this.options.textNodeName] !== undefined && Object.keys(object).length === 1) {
    return this.buildTextValNode(object[this.options.textNodeName], key, result.attrStr, level);
  } else {
    return this.buildObjectNode(result.val, key, result.attrStr, level);
  }
}

Builder.prototype.buildObjectNode = function(val, key, attrStr, level) {
  if(val === ""){
    if(key[0] === "?") return  this.indentate(level) + '<' + key + attrStr+ '?' + this.tagEndChar;
    else {
      return this.indentate(level) + '<' + key + attrStr + this.closeTag(key) + this.tagEndChar;
    }
  }else{

    let tagEndExp = '</' + key + this.tagEndChar;
    let piClosingChar = "";
    
    if(key[0] === "?") {
      piClosingChar = "?";
      tagEndExp = "";
    }
  
    // attrStr is an empty string in case the attribute came as undefined or null
    if ((attrStr || attrStr === '') && val.indexOf('<') === -1) {
      return ( this.indentate(level) + '<' +  key + attrStr + piClosingChar + '>' + val + tagEndExp );
    } else if (this.options.commentPropName !== false && key === this.options.commentPropName && piClosingChar.length === 0) {
      return this.indentate(level) + `<!--${val}-->` + this.newLine;
    }else {
      return (
        this.indentate(level) + '<' + key + attrStr + piClosingChar + this.tagEndChar +
        val +
        this.indentate(level) + tagEndExp    );
    }
  }
}

Builder.prototype.closeTag = function(key){
  let closeTag = "";
  if(this.options.unpairedTags.indexOf(key) !== -1){ //unpaired
    if(!this.options.suppressUnpairedNode) closeTag = "/"
  }else if(this.options.suppressEmptyNode){ //empty
    closeTag = "/";
  }else{
    closeTag = `></${key}`
  }
  return closeTag;
}

function buildEmptyObjNode(val, key, attrStr, level) {
  if (val !== '') {
    return this.buildObjectNode(val, key, attrStr, level);
  } else {
    if(key[0] === "?") return  this.indentate(level) + '<' + key + attrStr+ '?' + this.tagEndChar;
    else {
      return  this.indentate(level) + '<' + key + attrStr + '/' + this.tagEndChar;
      // return this.buildTagStr(level,key, attrStr);
    }
  }
}

Builder.prototype.buildTextValNode = function(val, key, attrStr, level) {
  if (this.options.cdataPropName !== false && key === this.options.cdataPropName) {
    return this.indentate(level) + `<![CDATA[${val}]]>` +  this.newLine;
  }else if (this.options.commentPropName !== false && key === this.options.commentPropName) {
    return this.indentate(level) + `<!--${val}-->` +  this.newLine;
  }else if(key[0] === "?") {//PI tag
    return  this.indentate(level) + '<' + key + attrStr+ '?' + this.tagEndChar; 
  }else{
    let textValue = this.options.tagValueProcessor(key, val);
    textValue = this.replaceEntitiesValue(textValue);
  
    if( textValue === ''){
      return this.indentate(level) + '<' + key + attrStr + this.closeTag(key) + this.tagEndChar;
    }else{
      return this.indentate(level) + '<' + key + attrStr + '>' +
         textValue +
        '</' + key + this.tagEndChar;
    }
  }
}

Builder.prototype.replaceEntitiesValue = function(textValue){
  if(textValue && textValue.length > 0 && this.options.processEntities){
    for (let i=0; i<this.options.entities.length; i++) {
      const entity = this.options.entities[i];
      textValue = textValue.replace(entity.regex, entity.val);
    }
  }
  return textValue;
}

function indentate(level) {
  return this.options.indentBy.repeat(level);
}

function isAttribute(name /*, options*/) {
  if (name.startsWith(this.options.attributeNamePrefix) && name !== this.options.textNodeName) {
    return name.substr(this.attrPrefixLen);
  } else {
    return false;
  }
}

module.exports = Builder;


/***/ }),

/***/ "./node_modules/fast-xml-parser/src/xmlbuilder/orderedJs2Xml.js":
/*!**********************************************************************!*\
  !*** ./node_modules/fast-xml-parser/src/xmlbuilder/orderedJs2Xml.js ***!
  \**********************************************************************/
/***/ ((module) => {

const EOL = "\n";

/**
 * 
 * @param {array} jArray 
 * @param {any} options 
 * @returns 
 */
function toXml(jArray, options) {
    let indentation = "";
    if (options.format && options.indentBy.length > 0) {
        indentation = EOL;
    }
    return arrToStr(jArray, options, "", indentation);
}

function arrToStr(arr, options, jPath, indentation) {
    let xmlStr = "";
    let isPreviousElementTag = false;

    for (let i = 0; i < arr.length; i++) {
        const tagObj = arr[i];
        const tagName = propName(tagObj);
        if(tagName === undefined) continue;

        let newJPath = "";
        if (jPath.length === 0) newJPath = tagName
        else newJPath = `${jPath}.${tagName}`;

        if (tagName === options.textNodeName) {
            let tagText = tagObj[tagName];
            if (!isStopNode(newJPath, options)) {
                tagText = options.tagValueProcessor(tagName, tagText);
                tagText = replaceEntitiesValue(tagText, options);
            }
            if (isPreviousElementTag) {
                xmlStr += indentation;
            }
            xmlStr += tagText;
            isPreviousElementTag = false;
            continue;
        } else if (tagName === options.cdataPropName) {
            if (isPreviousElementTag) {
                xmlStr += indentation;
            }
            xmlStr += `<![CDATA[${tagObj[tagName][0][options.textNodeName]}]]>`;
            isPreviousElementTag = false;
            continue;
        } else if (tagName === options.commentPropName) {
            xmlStr += indentation + `<!--${tagObj[tagName][0][options.textNodeName]}-->`;
            isPreviousElementTag = true;
            continue;
        } else if (tagName[0] === "?") {
            const attStr = attr_to_str(tagObj[":@"], options);
            const tempInd = tagName === "?xml" ? "" : indentation;
            let piTextNodeName = tagObj[tagName][0][options.textNodeName];
            piTextNodeName = piTextNodeName.length !== 0 ? " " + piTextNodeName : ""; //remove extra spacing
            xmlStr += tempInd + `<${tagName}${piTextNodeName}${attStr}?>`;
            isPreviousElementTag = true;
            continue;
        }
        let newIdentation = indentation;
        if (newIdentation !== "") {
            newIdentation += options.indentBy;
        }
        const attStr = attr_to_str(tagObj[":@"], options);
        const tagStart = indentation + `<${tagName}${attStr}`;
        const tagValue = arrToStr(tagObj[tagName], options, newJPath, newIdentation);
        if (options.unpairedTags.indexOf(tagName) !== -1) {
            if (options.suppressUnpairedNode) xmlStr += tagStart + ">";
            else xmlStr += tagStart + "/>";
        } else if ((!tagValue || tagValue.length === 0) && options.suppressEmptyNode) {
            xmlStr += tagStart + "/>";
        } else if (tagValue && tagValue.endsWith(">")) {
            xmlStr += tagStart + `>${tagValue}${indentation}</${tagName}>`;
        } else {
            xmlStr += tagStart + ">";
            if (tagValue && indentation !== "" && (tagValue.includes("/>") || tagValue.includes("</"))) {
                xmlStr += indentation + options.indentBy + tagValue + indentation;
            } else {
                xmlStr += tagValue;
            }
            xmlStr += `</${tagName}>`;
        }
        isPreviousElementTag = true;
    }

    return xmlStr;
}

function propName(obj) {
    const keys = Object.keys(obj);
    for (let i = 0; i < keys.length; i++) {
        const key = keys[i];
        if(!obj.hasOwnProperty(key)) continue;
        if (key !== ":@") return key;
    }
}

function attr_to_str(attrMap, options) {
    let attrStr = "";
    if (attrMap && !options.ignoreAttributes) {
        for (let attr in attrMap) {
            if(!attrMap.hasOwnProperty(attr)) continue;
            let attrVal = options.attributeValueProcessor(attr, attrMap[attr]);
            attrVal = replaceEntitiesValue(attrVal, options);
            if (attrVal === true && options.suppressBooleanAttributes) {
                attrStr += ` ${attr.substr(options.attributeNamePrefix.length)}`;
            } else {
                attrStr += ` ${attr.substr(options.attributeNamePrefix.length)}="${attrVal}"`;
            }
        }
    }
    return attrStr;
}

function isStopNode(jPath, options) {
    jPath = jPath.substr(0, jPath.length - options.textNodeName.length - 1);
    let tagName = jPath.substr(jPath.lastIndexOf(".") + 1);
    for (let index in options.stopNodes) {
        if (options.stopNodes[index] === jPath || options.stopNodes[index] === "*." + tagName) return true;
    }
    return false;
}

function replaceEntitiesValue(textValue, options) {
    if (textValue && textValue.length > 0 && options.processEntities) {
        for (let i = 0; i < options.entities.length; i++) {
            const entity = options.entities[i];
            textValue = textValue.replace(entity.regex, entity.val);
        }
    }
    return textValue;
}
module.exports = toXml;


/***/ }),

/***/ "./node_modules/fast-xml-parser/src/xmlparser/DocTypeReader.js":
/*!*********************************************************************!*\
  !*** ./node_modules/fast-xml-parser/src/xmlparser/DocTypeReader.js ***!
  \*********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const util = __webpack_require__(/*! ../util */ "./node_modules/fast-xml-parser/src/util.js");

//TODO: handle comments
function readDocType(xmlData, i){
    
    const entities = {};
    if( xmlData[i + 3] === 'O' &&
         xmlData[i + 4] === 'C' &&
         xmlData[i + 5] === 'T' &&
         xmlData[i + 6] === 'Y' &&
         xmlData[i + 7] === 'P' &&
         xmlData[i + 8] === 'E')
    {    
        i = i+9;
        let angleBracketsCount = 1;
        let hasBody = false, comment = false;
        let exp = "";
        for(;i<xmlData.length;i++){
            if (xmlData[i] === '<' && !comment) { //Determine the tag type
                if( hasBody && isEntity(xmlData, i)){
                    i += 7; 
                    let entityName, val;
                    [entityName, val,i] = readEntityExp(xmlData,i+1);
                    if(val.indexOf("&") === -1) //Parameter entities are not supported
                        entities[ validateEntityName(entityName) ] = {
                            regx : RegExp( `&${entityName};`,"g"),
                            val: val
                        };
                }
                else if( hasBody && isElement(xmlData, i))  i += 8;//Not supported
                else if( hasBody && isAttlist(xmlData, i))  i += 8;//Not supported
                else if( hasBody && isNotation(xmlData, i)) i += 9;//Not supported
                else if( isComment)                         comment = true;
                else                                        throw new Error("Invalid DOCTYPE");

                angleBracketsCount++;
                exp = "";
            } else if (xmlData[i] === '>') { //Read tag content
                if(comment){
                    if( xmlData[i - 1] === "-" && xmlData[i - 2] === "-"){
                        comment = false;
                        angleBracketsCount--;
                    }
                }else{
                    angleBracketsCount--;
                }
                if (angleBracketsCount === 0) {
                  break;
                }
            }else if( xmlData[i] === '['){
                hasBody = true;
            }else{
                exp += xmlData[i];
            }
        }
        if(angleBracketsCount !== 0){
            throw new Error(`Unclosed DOCTYPE`);
        }
    }else{
        throw new Error(`Invalid Tag instead of DOCTYPE`);
    }
    return {entities, i};
}

function readEntityExp(xmlData,i){
    //External entities are not supported
    //    <!ENTITY ext SYSTEM "http://normal-website.com" >

    //Parameter entities are not supported
    //    <!ENTITY entityname "&anotherElement;">

    //Internal entities are supported
    //    <!ENTITY entityname "replacement text">
    
    //read EntityName
    let entityName = "";
    for (; i < xmlData.length && (xmlData[i] !== "'" && xmlData[i] !== '"' ); i++) {
        // if(xmlData[i] === " ") continue;
        // else 
        entityName += xmlData[i];
    }
    entityName = entityName.trim();
    if(entityName.indexOf(" ") !== -1) throw new Error("External entites are not supported");

    //read Entity Value
    const startChar = xmlData[i++];
    let val = ""
    for (; i < xmlData.length && xmlData[i] !== startChar ; i++) {
        val += xmlData[i];
    }
    return [entityName, val, i];
}

function isComment(xmlData, i){
    if(xmlData[i+1] === '!' &&
    xmlData[i+2] === '-' &&
    xmlData[i+3] === '-') return true
    return false
}
function isEntity(xmlData, i){
    if(xmlData[i+1] === '!' &&
    xmlData[i+2] === 'E' &&
    xmlData[i+3] === 'N' &&
    xmlData[i+4] === 'T' &&
    xmlData[i+5] === 'I' &&
    xmlData[i+6] === 'T' &&
    xmlData[i+7] === 'Y') return true
    return false
}
function isElement(xmlData, i){
    if(xmlData[i+1] === '!' &&
    xmlData[i+2] === 'E' &&
    xmlData[i+3] === 'L' &&
    xmlData[i+4] === 'E' &&
    xmlData[i+5] === 'M' &&
    xmlData[i+6] === 'E' &&
    xmlData[i+7] === 'N' &&
    xmlData[i+8] === 'T') return true
    return false
}

function isAttlist(xmlData, i){
    if(xmlData[i+1] === '!' &&
    xmlData[i+2] === 'A' &&
    xmlData[i+3] === 'T' &&
    xmlData[i+4] === 'T' &&
    xmlData[i+5] === 'L' &&
    xmlData[i+6] === 'I' &&
    xmlData[i+7] === 'S' &&
    xmlData[i+8] === 'T') return true
    return false
}
function isNotation(xmlData, i){
    if(xmlData[i+1] === '!' &&
    xmlData[i+2] === 'N' &&
    xmlData[i+3] === 'O' &&
    xmlData[i+4] === 'T' &&
    xmlData[i+5] === 'A' &&
    xmlData[i+6] === 'T' &&
    xmlData[i+7] === 'I' &&
    xmlData[i+8] === 'O' &&
    xmlData[i+9] === 'N') return true
    return false
}

function validateEntityName(name){
    if (util.isName(name))
	return name;
    else
        throw new Error(`Invalid entity name ${name}`);
}

module.exports = readDocType;


/***/ }),

/***/ "./node_modules/fast-xml-parser/src/xmlparser/OptionsBuilder.js":
/*!**********************************************************************!*\
  !*** ./node_modules/fast-xml-parser/src/xmlparser/OptionsBuilder.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, exports) => {


const defaultOptions = {
    preserveOrder: false,
    attributeNamePrefix: '@_',
    attributesGroupName: false,
    textNodeName: '#text',
    ignoreAttributes: true,
    removeNSPrefix: false, // remove NS from tag name or attribute name if true
    allowBooleanAttributes: false, //a tag can have attributes without any value
    //ignoreRootElement : false,
    parseTagValue: true,
    parseAttributeValue: false,
    trimValues: true, //Trim string values of tag and attributes
    cdataPropName: false,
    numberParseOptions: {
      hex: true,
      leadingZeros: true,
      eNotation: true
    },
    tagValueProcessor: function(tagName, val) {
      return val;
    },
    attributeValueProcessor: function(attrName, val) {
      return val;
    },
    stopNodes: [], //nested tags will not be parsed even for errors
    alwaysCreateTextNode: false,
    isArray: () => false,
    commentPropName: false,
    unpairedTags: [],
    processEntities: true,
    htmlEntities: false,
    ignoreDeclaration: false,
    ignorePiTags: false,
    transformTagName: false,
    transformAttributeName: false,
    updateTag: function(tagName, jPath, attrs){
      return tagName
    },
    // skipEmptyListItem: false
};
   
const buildOptions = function(options) {
    return Object.assign({}, defaultOptions, options);
};

exports.buildOptions = buildOptions;
exports.defaultOptions = defaultOptions;

/***/ }),

/***/ "./node_modules/fast-xml-parser/src/xmlparser/OrderedObjParser.js":
/*!************************************************************************!*\
  !*** ./node_modules/fast-xml-parser/src/xmlparser/OrderedObjParser.js ***!
  \************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

///@ts-check

const util = __webpack_require__(/*! ../util */ "./node_modules/fast-xml-parser/src/util.js");
const xmlNode = __webpack_require__(/*! ./xmlNode */ "./node_modules/fast-xml-parser/src/xmlparser/xmlNode.js");
const readDocType = __webpack_require__(/*! ./DocTypeReader */ "./node_modules/fast-xml-parser/src/xmlparser/DocTypeReader.js");
const toNumber = __webpack_require__(/*! strnum */ "./node_modules/strnum/strnum.js");
const getIgnoreAttributesFn = __webpack_require__(/*! ../ignoreAttributes */ "./node_modules/fast-xml-parser/src/ignoreAttributes.js")

// const regx =
//   '<((!\\[CDATA\\[([\\s\\S]*?)(]]>))|((NAME:)?(NAME))([^>]*)>|((\\/)(NAME)\\s*>))([^<]*)'
//   .replace(/NAME/g, util.nameRegexp);

//const tagsRegx = new RegExp("<(\\/?[\\w:\\-\._]+)([^>]*)>(\\s*"+cdataRegx+")*([^<]+)?","g");
//const tagsRegx = new RegExp("<(\\/?)((\\w*:)?([\\w:\\-\._]+))([^>]*)>([^<]*)("+cdataRegx+"([^<]*))*([^<]+)?","g");

class OrderedObjParser{
  constructor(options){
    this.options = options;
    this.currentNode = null;
    this.tagsNodeStack = [];
    this.docTypeEntities = {};
    this.lastEntities = {
      "apos" : { regex: /&(apos|#39|#x27);/g, val : "'"},
      "gt" : { regex: /&(gt|#62|#x3E);/g, val : ">"},
      "lt" : { regex: /&(lt|#60|#x3C);/g, val : "<"},
      "quot" : { regex: /&(quot|#34|#x22);/g, val : "\""},
    };
    this.ampEntity = { regex: /&(amp|#38|#x26);/g, val : "&"};
    this.htmlEntities = {
      "space": { regex: /&(nbsp|#160);/g, val: " " },
      // "lt" : { regex: /&(lt|#60);/g, val: "<" },
      // "gt" : { regex: /&(gt|#62);/g, val: ">" },
      // "amp" : { regex: /&(amp|#38);/g, val: "&" },
      // "quot" : { regex: /&(quot|#34);/g, val: "\"" },
      // "apos" : { regex: /&(apos|#39);/g, val: "'" },
      "cent" : { regex: /&(cent|#162);/g, val: "" },
      "pound" : { regex: /&(pound|#163);/g, val: "" },
      "yen" : { regex: /&(yen|#165);/g, val: "" },
      "euro" : { regex: /&(euro|#8364);/g, val: "" },
      "copyright" : { regex: /&(copy|#169);/g, val: "" },
      "reg" : { regex: /&(reg|#174);/g, val: "" },
      "inr" : { regex: /&(inr|#8377);/g, val: "" },
      "num_dec": { regex: /&#([0-9]{1,7});/g, val : (_, str) => String.fromCharCode(Number.parseInt(str, 10)) },
      "num_hex": { regex: /&#x([0-9a-fA-F]{1,6});/g, val : (_, str) => String.fromCharCode(Number.parseInt(str, 16)) },
    };
    this.addExternalEntities = addExternalEntities;
    this.parseXml = parseXml;
    this.parseTextData = parseTextData;
    this.resolveNameSpace = resolveNameSpace;
    this.buildAttributesMap = buildAttributesMap;
    this.isItStopNode = isItStopNode;
    this.replaceEntitiesValue = replaceEntitiesValue;
    this.readStopNodeData = readStopNodeData;
    this.saveTextToParentTag = saveTextToParentTag;
    this.addChild = addChild;
    this.ignoreAttributesFn = getIgnoreAttributesFn(this.options.ignoreAttributes)
  }

}

function addExternalEntities(externalEntities){
  const entKeys = Object.keys(externalEntities);
  for (let i = 0; i < entKeys.length; i++) {
    const ent = entKeys[i];
    this.lastEntities[ent] = {
       regex: new RegExp("&"+ent+";","g"),
       val : externalEntities[ent]
    }
  }
}

/**
 * @param {string} val
 * @param {string} tagName
 * @param {string} jPath
 * @param {boolean} dontTrim
 * @param {boolean} hasAttributes
 * @param {boolean} isLeafNode
 * @param {boolean} escapeEntities
 */
function parseTextData(val, tagName, jPath, dontTrim, hasAttributes, isLeafNode, escapeEntities) {
  if (val !== undefined) {
    if (this.options.trimValues && !dontTrim) {
      val = val.trim();
    }
    if(val.length > 0){
      if(!escapeEntities) val = this.replaceEntitiesValue(val);
      
      const newval = this.options.tagValueProcessor(tagName, val, jPath, hasAttributes, isLeafNode);
      if(newval === null || newval === undefined){
        //don't parse
        return val;
      }else if(typeof newval !== typeof val || newval !== val){
        //overwrite
        return newval;
      }else if(this.options.trimValues){
        return parseValue(val, this.options.parseTagValue, this.options.numberParseOptions);
      }else{
        const trimmedVal = val.trim();
        if(trimmedVal === val){
          return parseValue(val, this.options.parseTagValue, this.options.numberParseOptions);
        }else{
          return val;
        }
      }
    }
  }
}

function resolveNameSpace(tagname) {
  if (this.options.removeNSPrefix) {
    const tags = tagname.split(':');
    const prefix = tagname.charAt(0) === '/' ? '/' : '';
    if (tags[0] === 'xmlns') {
      return '';
    }
    if (tags.length === 2) {
      tagname = prefix + tags[1];
    }
  }
  return tagname;
}

//TODO: change regex to capture NS
//const attrsRegx = new RegExp("([\\w\\-\\.\\:]+)\\s*=\\s*(['\"])((.|\n)*?)\\2","gm");
const attrsRegx = new RegExp('([^\\s=]+)\\s*(=\\s*([\'"])([\\s\\S]*?)\\3)?', 'gm');

function buildAttributesMap(attrStr, jPath, tagName) {
  if (this.options.ignoreAttributes !== true && typeof attrStr === 'string') {
    // attrStr = attrStr.replace(/\r?\n/g, ' ');
    //attrStr = attrStr || attrStr.trim();

    const matches = util.getAllMatches(attrStr, attrsRegx);
    const len = matches.length; //don't make it inline
    const attrs = {};
    for (let i = 0; i < len; i++) {
      const attrName = this.resolveNameSpace(matches[i][1]);
      if (this.ignoreAttributesFn(attrName, jPath)) {
        continue
      }
      let oldVal = matches[i][4];
      let aName = this.options.attributeNamePrefix + attrName;
      if (attrName.length) {
        if (this.options.transformAttributeName) {
          aName = this.options.transformAttributeName(aName);
        }
        if(aName === "__proto__") aName  = "#__proto__";
        if (oldVal !== undefined) {
          if (this.options.trimValues) {
            oldVal = oldVal.trim();
          }
          oldVal = this.replaceEntitiesValue(oldVal);
          const newVal = this.options.attributeValueProcessor(attrName, oldVal, jPath);
          if(newVal === null || newVal === undefined){
            //don't parse
            attrs[aName] = oldVal;
          }else if(typeof newVal !== typeof oldVal || newVal !== oldVal){
            //overwrite
            attrs[aName] = newVal;
          }else{
            //parse
            attrs[aName] = parseValue(
              oldVal,
              this.options.parseAttributeValue,
              this.options.numberParseOptions
            );
          }
        } else if (this.options.allowBooleanAttributes) {
          attrs[aName] = true;
        }
      }
    }
    if (!Object.keys(attrs).length) {
      return;
    }
    if (this.options.attributesGroupName) {
      const attrCollection = {};
      attrCollection[this.options.attributesGroupName] = attrs;
      return attrCollection;
    }
    return attrs
  }
}

const parseXml = function(xmlData) {
  xmlData = xmlData.replace(/\r\n?/g, "\n"); //TODO: remove this line
  const xmlObj = new xmlNode('!xml');
  let currentNode = xmlObj;
  let textData = "";
  let jPath = "";
  for(let i=0; i< xmlData.length; i++){//for each char in XML data
    const ch = xmlData[i];
    if(ch === '<'){
      // const nextIndex = i+1;
      // const _2ndChar = xmlData[nextIndex];
      if( xmlData[i+1] === '/') {//Closing Tag
        const closeIndex = findClosingIndex(xmlData, ">", i, "Closing Tag is not closed.")
        let tagName = xmlData.substring(i+2,closeIndex).trim();

        if(this.options.removeNSPrefix){
          const colonIndex = tagName.indexOf(":");
          if(colonIndex !== -1){
            tagName = tagName.substr(colonIndex+1);
          }
        }

        if(this.options.transformTagName) {
          tagName = this.options.transformTagName(tagName);
        }

        if(currentNode){
          textData = this.saveTextToParentTag(textData, currentNode, jPath);
        }

        //check if last tag of nested tag was unpaired tag
        const lastTagName = jPath.substring(jPath.lastIndexOf(".")+1);
        if(tagName && this.options.unpairedTags.indexOf(tagName) !== -1 ){
          throw new Error(`Unpaired tag can not be used as closing tag: </${tagName}>`);
        }
        let propIndex = 0
        if(lastTagName && this.options.unpairedTags.indexOf(lastTagName) !== -1 ){
          propIndex = jPath.lastIndexOf('.', jPath.lastIndexOf('.')-1)
          this.tagsNodeStack.pop();
        }else{
          propIndex = jPath.lastIndexOf(".");
        }
        jPath = jPath.substring(0, propIndex);

        currentNode = this.tagsNodeStack.pop();//avoid recursion, set the parent tag scope
        textData = "";
        i = closeIndex;
      } else if( xmlData[i+1] === '?') {

        let tagData = readTagExp(xmlData,i, false, "?>");
        if(!tagData) throw new Error("Pi Tag is not closed.");

        textData = this.saveTextToParentTag(textData, currentNode, jPath);
        if( (this.options.ignoreDeclaration && tagData.tagName === "?xml") || this.options.ignorePiTags){

        }else{
  
          const childNode = new xmlNode(tagData.tagName);
          childNode.add(this.options.textNodeName, "");
          
          if(tagData.tagName !== tagData.tagExp && tagData.attrExpPresent){
            childNode[":@"] = this.buildAttributesMap(tagData.tagExp, jPath, tagData.tagName);
          }
          this.addChild(currentNode, childNode, jPath)

        }


        i = tagData.closeIndex + 1;
      } else if(xmlData.substr(i + 1, 3) === '!--') {
        const endIndex = findClosingIndex(xmlData, "-->", i+4, "Comment is not closed.")
        if(this.options.commentPropName){
          const comment = xmlData.substring(i + 4, endIndex - 2);

          textData = this.saveTextToParentTag(textData, currentNode, jPath);

          currentNode.add(this.options.commentPropName, [ { [this.options.textNodeName] : comment } ]);
        }
        i = endIndex;
      } else if( xmlData.substr(i + 1, 2) === '!D') {
        const result = readDocType(xmlData, i);
        this.docTypeEntities = result.entities;
        i = result.i;
      }else if(xmlData.substr(i + 1, 2) === '![') {
        const closeIndex = findClosingIndex(xmlData, "]]>", i, "CDATA is not closed.") - 2;
        const tagExp = xmlData.substring(i + 9,closeIndex);

        textData = this.saveTextToParentTag(textData, currentNode, jPath);

        let val = this.parseTextData(tagExp, currentNode.tagname, jPath, true, false, true, true);
        if(val == undefined) val = "";

        //cdata should be set even if it is 0 length string
        if(this.options.cdataPropName){
          currentNode.add(this.options.cdataPropName, [ { [this.options.textNodeName] : tagExp } ]);
        }else{
          currentNode.add(this.options.textNodeName, val);
        }
        
        i = closeIndex + 2;
      }else {//Opening tag
        let result = readTagExp(xmlData,i, this.options.removeNSPrefix);
        let tagName= result.tagName;
        const rawTagName = result.rawTagName;
        let tagExp = result.tagExp;
        let attrExpPresent = result.attrExpPresent;
        let closeIndex = result.closeIndex;

        if (this.options.transformTagName) {
          tagName = this.options.transformTagName(tagName);
        }
        
        //save text as child node
        if (currentNode && textData) {
          if(currentNode.tagname !== '!xml'){
            //when nested tag is found
            textData = this.saveTextToParentTag(textData, currentNode, jPath, false);
          }
        }

        //check if last tag was unpaired tag
        const lastTag = currentNode;
        if(lastTag && this.options.unpairedTags.indexOf(lastTag.tagname) !== -1 ){
          currentNode = this.tagsNodeStack.pop();
          jPath = jPath.substring(0, jPath.lastIndexOf("."));
        }
        if(tagName !== xmlObj.tagname){
          jPath += jPath ? "." + tagName : tagName;
        }
        if (this.isItStopNode(this.options.stopNodes, jPath, tagName)) {
          let tagContent = "";
          //self-closing tag
          if(tagExp.length > 0 && tagExp.lastIndexOf("/") === tagExp.length - 1){
            if(tagName[tagName.length - 1] === "/"){ //remove trailing '/'
              tagName = tagName.substr(0, tagName.length - 1);
              jPath = jPath.substr(0, jPath.length - 1);
              tagExp = tagName;
            }else{
              tagExp = tagExp.substr(0, tagExp.length - 1);
            }
            i = result.closeIndex;
          }
          //unpaired tag
          else if(this.options.unpairedTags.indexOf(tagName) !== -1){
            
            i = result.closeIndex;
          }
          //normal tag
          else{
            //read until closing tag is found
            const result = this.readStopNodeData(xmlData, rawTagName, closeIndex + 1);
            if(!result) throw new Error(`Unexpected end of ${rawTagName}`);
            i = result.i;
            tagContent = result.tagContent;
          }

          const childNode = new xmlNode(tagName);
          if(tagName !== tagExp && attrExpPresent){
            childNode[":@"] = this.buildAttributesMap(tagExp, jPath, tagName);
          }
          if(tagContent) {
            tagContent = this.parseTextData(tagContent, tagName, jPath, true, attrExpPresent, true, true);
          }
          
          jPath = jPath.substr(0, jPath.lastIndexOf("."));
          childNode.add(this.options.textNodeName, tagContent);
          
          this.addChild(currentNode, childNode, jPath)
        }else{
  //selfClosing tag
          if(tagExp.length > 0 && tagExp.lastIndexOf("/") === tagExp.length - 1){
            if(tagName[tagName.length - 1] === "/"){ //remove trailing '/'
              tagName = tagName.substr(0, tagName.length - 1);
              jPath = jPath.substr(0, jPath.length - 1);
              tagExp = tagName;
            }else{
              tagExp = tagExp.substr(0, tagExp.length - 1);
            }
            
            if(this.options.transformTagName) {
              tagName = this.options.transformTagName(tagName);
            }

            const childNode = new xmlNode(tagName);
            if(tagName !== tagExp && attrExpPresent){
              childNode[":@"] = this.buildAttributesMap(tagExp, jPath, tagName);
            }
            this.addChild(currentNode, childNode, jPath)
            jPath = jPath.substr(0, jPath.lastIndexOf("."));
          }
    //opening tag
          else{
            const childNode = new xmlNode( tagName);
            this.tagsNodeStack.push(currentNode);
            
            if(tagName !== tagExp && attrExpPresent){
              childNode[":@"] = this.buildAttributesMap(tagExp, jPath, tagName);
            }
            this.addChild(currentNode, childNode, jPath)
            currentNode = childNode;
          }
          textData = "";
          i = closeIndex;
        }
      }
    }else{
      textData += xmlData[i];
    }
  }
  return xmlObj.child;
}

function addChild(currentNode, childNode, jPath){
  const result = this.options.updateTag(childNode.tagname, jPath, childNode[":@"])
  if(result === false){
  }else if(typeof result === "string"){
    childNode.tagname = result
    currentNode.addChild(childNode);
  }else{
    currentNode.addChild(childNode);
  }
}

const replaceEntitiesValue = function(val){

  if(this.options.processEntities){
    for(let entityName in this.docTypeEntities){
      const entity = this.docTypeEntities[entityName];
      val = val.replace( entity.regx, entity.val);
    }
    for(let entityName in this.lastEntities){
      const entity = this.lastEntities[entityName];
      val = val.replace( entity.regex, entity.val);
    }
    if(this.options.htmlEntities){
      for(let entityName in this.htmlEntities){
        const entity = this.htmlEntities[entityName];
        val = val.replace( entity.regex, entity.val);
      }
    }
    val = val.replace( this.ampEntity.regex, this.ampEntity.val);
  }
  return val;
}
function saveTextToParentTag(textData, currentNode, jPath, isLeafNode) {
  if (textData) { //store previously collected data as textNode
    if(isLeafNode === undefined) isLeafNode = currentNode.child.length === 0
    
    textData = this.parseTextData(textData,
      currentNode.tagname,
      jPath,
      false,
      currentNode[":@"] ? Object.keys(currentNode[":@"]).length !== 0 : false,
      isLeafNode);

    if (textData !== undefined && textData !== "")
      currentNode.add(this.options.textNodeName, textData);
    textData = "";
  }
  return textData;
}

//TODO: use jPath to simplify the logic
/**
 * 
 * @param {string[]} stopNodes 
 * @param {string} jPath
 * @param {string} currentTagName 
 */
function isItStopNode(stopNodes, jPath, currentTagName){
  const allNodesExp = "*." + currentTagName;
  for (const stopNodePath in stopNodes) {
    const stopNodeExp = stopNodes[stopNodePath];
    if( allNodesExp === stopNodeExp || jPath === stopNodeExp  ) return true;
  }
  return false;
}

/**
 * Returns the tag Expression and where it is ending handling single-double quotes situation
 * @param {string} xmlData 
 * @param {number} i starting index
 * @returns 
 */
function tagExpWithClosingIndex(xmlData, i, closingChar = ">"){
  let attrBoundary;
  let tagExp = "";
  for (let index = i; index < xmlData.length; index++) {
    let ch = xmlData[index];
    if (attrBoundary) {
        if (ch === attrBoundary) attrBoundary = "";//reset
    } else if (ch === '"' || ch === "'") {
        attrBoundary = ch;
    } else if (ch === closingChar[0]) {
      if(closingChar[1]){
        if(xmlData[index + 1] === closingChar[1]){
          return {
            data: tagExp,
            index: index
          }
        }
      }else{
        return {
          data: tagExp,
          index: index
        }
      }
    } else if (ch === '\t') {
      ch = " "
    }
    tagExp += ch;
  }
}

function findClosingIndex(xmlData, str, i, errMsg){
  const closingIndex = xmlData.indexOf(str, i);
  if(closingIndex === -1){
    throw new Error(errMsg)
  }else{
    return closingIndex + str.length - 1;
  }
}

function readTagExp(xmlData,i, removeNSPrefix, closingChar = ">"){
  const result = tagExpWithClosingIndex(xmlData, i+1, closingChar);
  if(!result) return;
  let tagExp = result.data;
  const closeIndex = result.index;
  const separatorIndex = tagExp.search(/\s/);
  let tagName = tagExp;
  let attrExpPresent = true;
  if(separatorIndex !== -1){//separate tag name and attributes expression
    tagName = tagExp.substring(0, separatorIndex);
    tagExp = tagExp.substring(separatorIndex + 1).trimStart();
  }

  const rawTagName = tagName;
  if(removeNSPrefix){
    const colonIndex = tagName.indexOf(":");
    if(colonIndex !== -1){
      tagName = tagName.substr(colonIndex+1);
      attrExpPresent = tagName !== result.data.substr(colonIndex + 1);
    }
  }

  return {
    tagName: tagName,
    tagExp: tagExp,
    closeIndex: closeIndex,
    attrExpPresent: attrExpPresent,
    rawTagName: rawTagName,
  }
}
/**
 * find paired tag for a stop node
 * @param {string} xmlData 
 * @param {string} tagName 
 * @param {number} i 
 */
function readStopNodeData(xmlData, tagName, i){
  const startIndex = i;
  // Starting at 1 since we already have an open tag
  let openTagCount = 1;

  for (; i < xmlData.length; i++) {
    if( xmlData[i] === "<"){ 
      if (xmlData[i+1] === "/") {//close tag
          const closeIndex = findClosingIndex(xmlData, ">", i, `${tagName} is not closed`);
          let closeTagName = xmlData.substring(i+2,closeIndex).trim();
          if(closeTagName === tagName){
            openTagCount--;
            if (openTagCount === 0) {
              return {
                tagContent: xmlData.substring(startIndex, i),
                i : closeIndex
              }
            }
          }
          i=closeIndex;
        } else if(xmlData[i+1] === '?') { 
          const closeIndex = findClosingIndex(xmlData, "?>", i+1, "StopNode is not closed.")
          i=closeIndex;
        } else if(xmlData.substr(i + 1, 3) === '!--') { 
          const closeIndex = findClosingIndex(xmlData, "-->", i+3, "StopNode is not closed.")
          i=closeIndex;
        } else if(xmlData.substr(i + 1, 2) === '![') { 
          const closeIndex = findClosingIndex(xmlData, "]]>", i, "StopNode is not closed.") - 2;
          i=closeIndex;
        } else {
          const tagData = readTagExp(xmlData, i, '>')

          if (tagData) {
            const openTagName = tagData && tagData.tagName;
            if (openTagName === tagName && tagData.tagExp[tagData.tagExp.length-1] !== "/") {
              openTagCount++;
            }
            i=tagData.closeIndex;
          }
        }
      }
  }//end for loop
}

function parseValue(val, shouldParse, options) {
  if (shouldParse && typeof val === 'string') {
    //console.log(options)
    const newval = val.trim();
    if(newval === 'true' ) return true;
    else if(newval === 'false' ) return false;
    else return toNumber(val, options);
  } else {
    if (util.isExist(val)) {
      return val;
    } else {
      return '';
    }
  }
}


module.exports = OrderedObjParser;


/***/ }),

/***/ "./node_modules/fast-xml-parser/src/xmlparser/XMLParser.js":
/*!*****************************************************************!*\
  !*** ./node_modules/fast-xml-parser/src/xmlparser/XMLParser.js ***!
  \*****************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const { buildOptions} = __webpack_require__(/*! ./OptionsBuilder */ "./node_modules/fast-xml-parser/src/xmlparser/OptionsBuilder.js");
const OrderedObjParser = __webpack_require__(/*! ./OrderedObjParser */ "./node_modules/fast-xml-parser/src/xmlparser/OrderedObjParser.js");
const { prettify} = __webpack_require__(/*! ./node2json */ "./node_modules/fast-xml-parser/src/xmlparser/node2json.js");
const validator = __webpack_require__(/*! ../validator */ "./node_modules/fast-xml-parser/src/validator.js");

class XMLParser{
    
    constructor(options){
        this.externalEntities = {};
        this.options = buildOptions(options);
        
    }
    /**
     * Parse XML dats to JS object 
     * @param {string|Buffer} xmlData 
     * @param {boolean|Object} validationOption 
     */
    parse(xmlData,validationOption){
        if(typeof xmlData === "string"){
        }else if( xmlData.toString){
            xmlData = xmlData.toString();
        }else{
            throw new Error("XML data is accepted in String or Bytes[] form.")
        }
        if( validationOption){
            if(validationOption === true) validationOption = {}; //validate with default options
            
            const result = validator.validate(xmlData, validationOption);
            if (result !== true) {
              throw Error( `${result.err.msg}:${result.err.line}:${result.err.col}` )
            }
          }
        const orderedObjParser = new OrderedObjParser(this.options);
        orderedObjParser.addExternalEntities(this.externalEntities);
        const orderedResult = orderedObjParser.parseXml(xmlData);
        if(this.options.preserveOrder || orderedResult === undefined) return orderedResult;
        else return prettify(orderedResult, this.options);
    }

    /**
     * Add Entity which is not by default supported by this library
     * @param {string} key 
     * @param {string} value 
     */
    addEntity(key, value){
        if(value.indexOf("&") !== -1){
            throw new Error("Entity value can't have '&'")
        }else if(key.indexOf("&") !== -1 || key.indexOf(";") !== -1){
            throw new Error("An entity must be set without '&' and ';'. Eg. use '#xD' for '&#xD;'")
        }else if(value === "&"){
            throw new Error("An entity with value '&' is not permitted");
        }else{
            this.externalEntities[key] = value;
        }
    }
}

module.exports = XMLParser;

/***/ }),

/***/ "./node_modules/fast-xml-parser/src/xmlparser/node2json.js":
/*!*****************************************************************!*\
  !*** ./node_modules/fast-xml-parser/src/xmlparser/node2json.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";


/**
 * 
 * @param {array} node 
 * @param {any} options 
 * @returns 
 */
function prettify(node, options){
  return compress( node, options);
}

/**
 * 
 * @param {array} arr 
 * @param {object} options 
 * @param {string} jPath 
 * @returns object
 */
function compress(arr, options, jPath){
  let text;
  const compressedObj = {};
  for (let i = 0; i < arr.length; i++) {
    const tagObj = arr[i];
    const property = propName(tagObj);
    let newJpath = "";
    if(jPath === undefined) newJpath = property;
    else newJpath = jPath + "." + property;

    if(property === options.textNodeName){
      if(text === undefined) text = tagObj[property];
      else text += "" + tagObj[property];
    }else if(property === undefined){
      continue;
    }else if(tagObj[property]){
      
      let val = compress(tagObj[property], options, newJpath);
      const isLeaf = isLeafTag(val, options);

      if(tagObj[":@"]){
        assignAttributes( val, tagObj[":@"], newJpath, options);
      }else if(Object.keys(val).length === 1 && val[options.textNodeName] !== undefined && !options.alwaysCreateTextNode){
        val = val[options.textNodeName];
      }else if(Object.keys(val).length === 0){
        if(options.alwaysCreateTextNode) val[options.textNodeName] = "";
        else val = "";
      }

      if(compressedObj[property] !== undefined && compressedObj.hasOwnProperty(property)) {
        if(!Array.isArray(compressedObj[property])) {
            compressedObj[property] = [ compressedObj[property] ];
        }
        compressedObj[property].push(val);
      }else{
        //TODO: if a node is not an array, then check if it should be an array
        //also determine if it is a leaf node
        if (options.isArray(property, newJpath, isLeaf )) {
          compressedObj[property] = [val];
        }else{
          compressedObj[property] = val;
        }
      }
    }
    
  }
  // if(text && text.length > 0) compressedObj[options.textNodeName] = text;
  if(typeof text === "string"){
    if(text.length > 0) compressedObj[options.textNodeName] = text;
  }else if(text !== undefined) compressedObj[options.textNodeName] = text;
  return compressedObj;
}

function propName(obj){
  const keys = Object.keys(obj);
  for (let i = 0; i < keys.length; i++) {
    const key = keys[i];
    if(key !== ":@") return key;
  }
}

function assignAttributes(obj, attrMap, jpath, options){
  if (attrMap) {
    const keys = Object.keys(attrMap);
    const len = keys.length; //don't make it inline
    for (let i = 0; i < len; i++) {
      const atrrName = keys[i];
      if (options.isArray(atrrName, jpath + "." + atrrName, true, true)) {
        obj[atrrName] = [ attrMap[atrrName] ];
      } else {
        obj[atrrName] = attrMap[atrrName];
      }
    }
  }
}

function isLeafTag(obj, options){
  const { textNodeName } = options;
  const propCount = Object.keys(obj).length;
  
  if (propCount === 0) {
    return true;
  }

  if (
    propCount === 1 &&
    (obj[textNodeName] || typeof obj[textNodeName] === "boolean" || obj[textNodeName] === 0)
  ) {
    return true;
  }

  return false;
}
exports.prettify = prettify;


/***/ }),

/***/ "./node_modules/fast-xml-parser/src/xmlparser/xmlNode.js":
/*!***************************************************************!*\
  !*** ./node_modules/fast-xml-parser/src/xmlparser/xmlNode.js ***!
  \***************************************************************/
/***/ ((module) => {

"use strict";


class XmlNode{
  constructor(tagname) {
    this.tagname = tagname;
    this.child = []; //nested tags, text, cdata, comments in order
    this[":@"] = {}; //attributes map
  }
  add(key,val){
    // this.child.push( {name : key, val: val, isCdata: isCdata });
    if(key === "__proto__") key = "#__proto__";
    this.child.push( {[key]: val });
  }
  addChild(node) {
    if(node.tagname === "__proto__") node.tagname = "#__proto__";
    if(node[":@"] && Object.keys(node[":@"]).length > 0){
      this.child.push( { [node.tagname]: node.child, [":@"]: node[":@"] });
    }else{
      this.child.push( { [node.tagname]: node.child });
    }
  };
};


module.exports = XmlNode;

/***/ }),

/***/ "./node_modules/fp-ts/es6/Applicative.js":
/*!***********************************************!*\
  !*** ./node_modules/fp-ts/es6/Applicative.js ***!
  \***********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   getApplicativeComposition: () => (/* binding */ getApplicativeComposition),
/* harmony export */   getApplicativeMonoid: () => (/* binding */ getApplicativeMonoid)
/* harmony export */ });
/* harmony import */ var _Apply__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Apply */ "./node_modules/fp-ts/es6/Apply.js");
/* harmony import */ var _function__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./function */ "./node_modules/fp-ts/es6/function.js");
/* harmony import */ var _Functor__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Functor */ "./node_modules/fp-ts/es6/Functor.js");
/**
 * The `Applicative` type class extends the `Apply` type class with a `of` function, which can be used to create values
 * of type `f a` from values of type `a`.
 *
 * Where `Apply` provides the ability to lift functions of two or more arguments to functions whose arguments are
 * wrapped using `f`, and `Functor` provides the ability to lift functions of one argument, `pure` can be seen as the
 * function which lifts functions of _zero_ arguments. That is, `Applicative` functors support a lifting operation for
 * any number of function arguments.
 *
 * Instances must satisfy the following laws in addition to the `Apply` laws:
 *
 * 1. Identity: `A.ap(A.of(a => a), fa) <-> fa`
 * 2. Homomorphism: `A.ap(A.of(ab), A.of(a)) <-> A.of(ab(a))`
 * 3. Interchange: `A.ap(fab, A.of(a)) <-> A.ap(A.of(ab => ab(a)), fab)`
 *
 * Note. `Functor`'s `map` can be derived: `A.map(x, f) = A.ap(A.of(f), x)`
 *
 * @since 2.0.0
 */



function getApplicativeMonoid(F) {
    var f = (0,_Apply__WEBPACK_IMPORTED_MODULE_0__.getApplySemigroup)(F);
    return function (M) { return ({
        concat: f(M).concat,
        empty: F.of(M.empty)
    }); };
}
/** @deprecated */
function getApplicativeComposition(F, G) {
    var map = (0,_Functor__WEBPACK_IMPORTED_MODULE_1__.getFunctorComposition)(F, G).map;
    var _ap = (0,_Apply__WEBPACK_IMPORTED_MODULE_0__.ap)(F, G);
    return {
        map: map,
        of: function (a) { return F.of(G.of(a)); },
        ap: function (fgab, fga) { return (0,_function__WEBPACK_IMPORTED_MODULE_2__.pipe)(fgab, _ap(fga)); }
    };
}


/***/ }),

/***/ "./node_modules/fp-ts/es6/Apply.js":
/*!*****************************************!*\
  !*** ./node_modules/fp-ts/es6/Apply.js ***!
  \*****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   ap: () => (/* binding */ ap),
/* harmony export */   apFirst: () => (/* binding */ apFirst),
/* harmony export */   apS: () => (/* binding */ apS),
/* harmony export */   apSecond: () => (/* binding */ apSecond),
/* harmony export */   getApplySemigroup: () => (/* binding */ getApplySemigroup),
/* harmony export */   sequenceS: () => (/* binding */ sequenceS),
/* harmony export */   sequenceT: () => (/* binding */ sequenceT)
/* harmony export */ });
/* harmony import */ var _function__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./function */ "./node_modules/fp-ts/es6/function.js");
/* harmony import */ var _internal__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./internal */ "./node_modules/fp-ts/es6/internal.js");
/**
 * The `Apply` class provides the `ap` which is used to apply a function to an argument under a type constructor.
 *
 * `Apply` can be used to lift functions of two or more arguments to work on values wrapped with the type constructor
 * `f`.
 *
 * Instances must satisfy the following law in addition to the `Functor` laws:
 *
 * 1. Associative composition: `F.ap(F.ap(F.map(fbc, bc => ab => a => bc(ab(a))), fab), fa) <-> F.ap(fbc, F.ap(fab, fa))`
 *
 * Formally, `Apply` represents a strong lax semi-monoidal endofunctor.
 *
 * @example
 * import * as O from 'fp-ts/Option'
 * import { pipe } from 'fp-ts/function'
 *
 * const f = (a: string) => (b: number) => (c: boolean) => a + String(b) + String(c)
 * const fa: O.Option<string> = O.some('s')
 * const fb: O.Option<number> = O.some(1)
 * const fc: O.Option<boolean> = O.some(true)
 *
 * assert.deepStrictEqual(
 *   pipe(
 *     // lift a function
 *     O.some(f),
 *     // apply the first argument
 *     O.ap(fa),
 *     // apply the second argument
 *     O.ap(fb),
 *     // apply the third argument
 *     O.ap(fc)
 *   ),
 *   O.some('s1true')
 * )
 *
 * @since 2.0.0
 */


function ap(F, G) {
    return function (fa) {
        return function (fab) {
            return F.ap(F.map(fab, function (gab) { return function (ga) { return G.ap(gab, ga); }; }), fa);
        };
    };
}
function apFirst(A) {
    return function (second) { return function (first) {
        return A.ap(A.map(first, function (a) { return function () { return a; }; }), second);
    }; };
}
function apSecond(A) {
    return function (second) {
        return function (first) {
            return A.ap(A.map(first, function () { return function (b) { return b; }; }), second);
        };
    };
}
function apS(F) {
    return function (name, fb) {
        return function (fa) {
            return F.ap(F.map(fa, function (a) { return function (b) {
                var _a;
                return Object.assign({}, a, (_a = {}, _a[name] = b, _a));
            }; }), fb);
        };
    };
}
function getApplySemigroup(F) {
    return function (S) { return ({
        concat: function (first, second) {
            return F.ap(F.map(first, function (x) { return function (y) { return S.concat(x, y); }; }), second);
        }
    }); };
}
function curried(f, n, acc) {
    return function (x) {
        var combined = Array(acc.length + 1);
        for (var i = 0; i < acc.length; i++) {
            combined[i] = acc[i];
        }
        combined[acc.length] = x;
        return n === 0 ? f.apply(null, combined) : curried(f, n - 1, combined);
    };
}
var tupleConstructors = {
    1: function (a) { return [a]; },
    2: function (a) { return function (b) { return [a, b]; }; },
    3: function (a) { return function (b) { return function (c) { return [a, b, c]; }; }; },
    4: function (a) { return function (b) { return function (c) { return function (d) { return [a, b, c, d]; }; }; }; },
    5: function (a) { return function (b) { return function (c) { return function (d) { return function (e) { return [a, b, c, d, e]; }; }; }; }; }
};
function getTupleConstructor(len) {
    if (!_internal__WEBPACK_IMPORTED_MODULE_0__.has.call(tupleConstructors, len)) {
        tupleConstructors[len] = curried(_function__WEBPACK_IMPORTED_MODULE_1__.tuple, len - 1, []);
    }
    return tupleConstructors[len];
}
function sequenceT(F) {
    return function () {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        var len = args.length;
        var f = getTupleConstructor(len);
        var fas = F.map(args[0], f);
        for (var i = 1; i < len; i++) {
            fas = F.ap(fas, args[i]);
        }
        return fas;
    };
}
function getRecordConstructor(keys) {
    var len = keys.length;
    switch (len) {
        case 1:
            return function (a) {
                var _a;
                return (_a = {}, _a[keys[0]] = a, _a);
            };
        case 2:
            return function (a) { return function (b) {
                var _a;
                return (_a = {}, _a[keys[0]] = a, _a[keys[1]] = b, _a);
            }; };
        case 3:
            return function (a) { return function (b) { return function (c) {
                var _a;
                return (_a = {}, _a[keys[0]] = a, _a[keys[1]] = b, _a[keys[2]] = c, _a);
            }; }; };
        case 4:
            return function (a) { return function (b) { return function (c) { return function (d) {
                var _a;
                return (_a = {},
                    _a[keys[0]] = a,
                    _a[keys[1]] = b,
                    _a[keys[2]] = c,
                    _a[keys[3]] = d,
                    _a);
            }; }; }; };
        case 5:
            return function (a) { return function (b) { return function (c) { return function (d) { return function (e) {
                var _a;
                return (_a = {},
                    _a[keys[0]] = a,
                    _a[keys[1]] = b,
                    _a[keys[2]] = c,
                    _a[keys[3]] = d,
                    _a[keys[4]] = e,
                    _a);
            }; }; }; }; };
        default:
            return curried(function () {
                var args = [];
                for (var _i = 0; _i < arguments.length; _i++) {
                    args[_i] = arguments[_i];
                }
                var r = {};
                for (var i = 0; i < len; i++) {
                    r[keys[i]] = args[i];
                }
                return r;
            }, len - 1, []);
    }
}
function sequenceS(F) {
    return function (r) {
        var keys = Object.keys(r);
        var len = keys.length;
        var f = getRecordConstructor(keys);
        var fr = F.map(r[keys[0]], f);
        for (var i = 1; i < len; i++) {
            fr = F.ap(fr, r[keys[i]]);
        }
        return fr;
    };
}


/***/ }),

/***/ "./node_modules/fp-ts/es6/Array.js":
/*!*****************************************!*\
  !*** ./node_modules/fp-ts/es6/Array.js ***!
  \*****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Alt: () => (/* binding */ Alt),
/* harmony export */   Alternative: () => (/* binding */ Alternative),
/* harmony export */   Applicative: () => (/* binding */ Applicative),
/* harmony export */   Apply: () => (/* binding */ Apply),
/* harmony export */   Chain: () => (/* binding */ Chain),
/* harmony export */   ChainRecBreadthFirst: () => (/* binding */ ChainRecBreadthFirst),
/* harmony export */   ChainRecDepthFirst: () => (/* binding */ ChainRecDepthFirst),
/* harmony export */   Compactable: () => (/* binding */ Compactable),
/* harmony export */   Do: () => (/* binding */ Do),
/* harmony export */   Extend: () => (/* binding */ Extend),
/* harmony export */   Filterable: () => (/* binding */ Filterable),
/* harmony export */   FilterableWithIndex: () => (/* binding */ FilterableWithIndex),
/* harmony export */   Foldable: () => (/* binding */ Foldable),
/* harmony export */   FoldableWithIndex: () => (/* binding */ FoldableWithIndex),
/* harmony export */   FromEither: () => (/* binding */ FromEither),
/* harmony export */   Functor: () => (/* binding */ Functor),
/* harmony export */   FunctorWithIndex: () => (/* binding */ FunctorWithIndex),
/* harmony export */   Monad: () => (/* binding */ Monad),
/* harmony export */   Pointed: () => (/* binding */ Pointed),
/* harmony export */   Traversable: () => (/* binding */ Traversable),
/* harmony export */   TraversableWithIndex: () => (/* binding */ TraversableWithIndex),
/* harmony export */   URI: () => (/* binding */ URI),
/* harmony export */   Unfoldable: () => (/* binding */ Unfoldable),
/* harmony export */   Witherable: () => (/* binding */ Witherable),
/* harmony export */   Zero: () => (/* binding */ Zero),
/* harmony export */   alt: () => (/* binding */ alt),
/* harmony export */   altW: () => (/* binding */ altW),
/* harmony export */   ap: () => (/* binding */ ap),
/* harmony export */   apFirst: () => (/* binding */ apFirst),
/* harmony export */   apS: () => (/* binding */ apS),
/* harmony export */   apSecond: () => (/* binding */ apSecond),
/* harmony export */   append: () => (/* binding */ append),
/* harmony export */   appendW: () => (/* binding */ appendW),
/* harmony export */   array: () => (/* binding */ array),
/* harmony export */   bind: () => (/* binding */ bind),
/* harmony export */   bindTo: () => (/* binding */ bindTo),
/* harmony export */   chain: () => (/* binding */ chain),
/* harmony export */   chainFirst: () => (/* binding */ chainFirst),
/* harmony export */   chainRecBreadthFirst: () => (/* binding */ chainRecBreadthFirst),
/* harmony export */   chainRecDepthFirst: () => (/* binding */ chainRecDepthFirst),
/* harmony export */   chainWithIndex: () => (/* binding */ chainWithIndex),
/* harmony export */   chop: () => (/* binding */ chop),
/* harmony export */   chunksOf: () => (/* binding */ chunksOf),
/* harmony export */   compact: () => (/* binding */ compact),
/* harmony export */   comprehension: () => (/* binding */ comprehension),
/* harmony export */   concat: () => (/* binding */ concat),
/* harmony export */   concatW: () => (/* binding */ concatW),
/* harmony export */   cons: () => (/* binding */ cons),
/* harmony export */   copy: () => (/* binding */ copy),
/* harmony export */   deleteAt: () => (/* binding */ deleteAt),
/* harmony export */   difference: () => (/* binding */ difference),
/* harmony export */   dropLeft: () => (/* binding */ dropLeft),
/* harmony export */   dropLeftWhile: () => (/* binding */ dropLeftWhile),
/* harmony export */   dropRight: () => (/* binding */ dropRight),
/* harmony export */   duplicate: () => (/* binding */ duplicate),
/* harmony export */   elem: () => (/* binding */ elem),
/* harmony export */   empty: () => (/* binding */ empty),
/* harmony export */   every: () => (/* binding */ every),
/* harmony export */   exists: () => (/* binding */ exists),
/* harmony export */   extend: () => (/* binding */ extend),
/* harmony export */   filter: () => (/* binding */ filter),
/* harmony export */   filterE: () => (/* binding */ filterE),
/* harmony export */   filterMap: () => (/* binding */ filterMap),
/* harmony export */   filterMapWithIndex: () => (/* binding */ filterMapWithIndex),
/* harmony export */   filterWithIndex: () => (/* binding */ filterWithIndex),
/* harmony export */   findFirst: () => (/* binding */ findFirst),
/* harmony export */   findFirstMap: () => (/* binding */ findFirstMap),
/* harmony export */   findIndex: () => (/* binding */ findIndex),
/* harmony export */   findLast: () => (/* binding */ findLast),
/* harmony export */   findLastIndex: () => (/* binding */ findLastIndex),
/* harmony export */   findLastMap: () => (/* binding */ findLastMap),
/* harmony export */   flap: () => (/* binding */ flap),
/* harmony export */   flatMap: () => (/* binding */ flatMap),
/* harmony export */   flatten: () => (/* binding */ flatten),
/* harmony export */   foldLeft: () => (/* binding */ foldLeft),
/* harmony export */   foldMap: () => (/* binding */ foldMap),
/* harmony export */   foldMapWithIndex: () => (/* binding */ foldMapWithIndex),
/* harmony export */   foldRight: () => (/* binding */ foldRight),
/* harmony export */   fromEither: () => (/* binding */ fromEither),
/* harmony export */   fromEitherK: () => (/* binding */ fromEitherK),
/* harmony export */   fromOption: () => (/* binding */ fromOption),
/* harmony export */   fromOptionK: () => (/* binding */ fromOptionK),
/* harmony export */   fromPredicate: () => (/* binding */ fromPredicate),
/* harmony export */   getDifferenceMagma: () => (/* binding */ getDifferenceMagma),
/* harmony export */   getEq: () => (/* binding */ getEq),
/* harmony export */   getIntersectionSemigroup: () => (/* binding */ getIntersectionSemigroup),
/* harmony export */   getMonoid: () => (/* binding */ getMonoid),
/* harmony export */   getOrd: () => (/* binding */ getOrd),
/* harmony export */   getSemigroup: () => (/* binding */ getSemigroup),
/* harmony export */   getShow: () => (/* binding */ getShow),
/* harmony export */   getUnionMonoid: () => (/* binding */ getUnionMonoid),
/* harmony export */   getUnionSemigroup: () => (/* binding */ getUnionSemigroup),
/* harmony export */   guard: () => (/* binding */ guard),
/* harmony export */   head: () => (/* binding */ head),
/* harmony export */   init: () => (/* binding */ init),
/* harmony export */   insertAt: () => (/* binding */ insertAt),
/* harmony export */   intercalate: () => (/* binding */ intercalate),
/* harmony export */   intersection: () => (/* binding */ intersection),
/* harmony export */   intersperse: () => (/* binding */ intersperse),
/* harmony export */   isEmpty: () => (/* binding */ isEmpty),
/* harmony export */   isNonEmpty: () => (/* binding */ isNonEmpty),
/* harmony export */   isOutOfBound: () => (/* binding */ isOutOfBound),
/* harmony export */   last: () => (/* binding */ last),
/* harmony export */   lefts: () => (/* binding */ lefts),
/* harmony export */   "let": () => (/* binding */ let_),
/* harmony export */   lookup: () => (/* binding */ lookup),
/* harmony export */   makeBy: () => (/* binding */ makeBy),
/* harmony export */   map: () => (/* binding */ map),
/* harmony export */   mapWithIndex: () => (/* binding */ mapWithIndex),
/* harmony export */   match: () => (/* binding */ match),
/* harmony export */   matchLeft: () => (/* binding */ matchLeft),
/* harmony export */   matchLeftW: () => (/* binding */ matchLeftW),
/* harmony export */   matchRight: () => (/* binding */ matchRight),
/* harmony export */   matchRightW: () => (/* binding */ matchRightW),
/* harmony export */   matchW: () => (/* binding */ matchW),
/* harmony export */   modifyAt: () => (/* binding */ modifyAt),
/* harmony export */   of: () => (/* binding */ of),
/* harmony export */   partition: () => (/* binding */ partition),
/* harmony export */   partitionMap: () => (/* binding */ partitionMap),
/* harmony export */   partitionMapWithIndex: () => (/* binding */ partitionMapWithIndex),
/* harmony export */   partitionWithIndex: () => (/* binding */ partitionWithIndex),
/* harmony export */   prepend: () => (/* binding */ prepend),
/* harmony export */   prependAll: () => (/* binding */ prependAll),
/* harmony export */   prependToAll: () => (/* binding */ prependToAll),
/* harmony export */   prependW: () => (/* binding */ prependW),
/* harmony export */   range: () => (/* binding */ range),
/* harmony export */   reduce: () => (/* binding */ reduce),
/* harmony export */   reduceRight: () => (/* binding */ reduceRight),
/* harmony export */   reduceRightWithIndex: () => (/* binding */ reduceRightWithIndex),
/* harmony export */   reduceWithIndex: () => (/* binding */ reduceWithIndex),
/* harmony export */   replicate: () => (/* binding */ replicate),
/* harmony export */   reverse: () => (/* binding */ reverse),
/* harmony export */   rights: () => (/* binding */ rights),
/* harmony export */   rotate: () => (/* binding */ rotate),
/* harmony export */   scanLeft: () => (/* binding */ scanLeft),
/* harmony export */   scanRight: () => (/* binding */ scanRight),
/* harmony export */   separate: () => (/* binding */ separate),
/* harmony export */   sequence: () => (/* binding */ sequence),
/* harmony export */   size: () => (/* binding */ size),
/* harmony export */   snoc: () => (/* binding */ snoc),
/* harmony export */   some: () => (/* binding */ some),
/* harmony export */   sort: () => (/* binding */ sort),
/* harmony export */   sortBy: () => (/* binding */ sortBy),
/* harmony export */   spanLeft: () => (/* binding */ spanLeft),
/* harmony export */   splitAt: () => (/* binding */ splitAt),
/* harmony export */   tail: () => (/* binding */ tail),
/* harmony export */   takeLeft: () => (/* binding */ takeLeft),
/* harmony export */   takeLeftWhile: () => (/* binding */ takeLeftWhile),
/* harmony export */   takeRight: () => (/* binding */ takeRight),
/* harmony export */   traverse: () => (/* binding */ traverse),
/* harmony export */   traverseWithIndex: () => (/* binding */ traverseWithIndex),
/* harmony export */   unfold: () => (/* binding */ unfold),
/* harmony export */   union: () => (/* binding */ union),
/* harmony export */   uniq: () => (/* binding */ uniq),
/* harmony export */   unsafeDeleteAt: () => (/* binding */ unsafeDeleteAt),
/* harmony export */   unsafeInsertAt: () => (/* binding */ unsafeInsertAt),
/* harmony export */   unsafeUpdateAt: () => (/* binding */ unsafeUpdateAt),
/* harmony export */   unzip: () => (/* binding */ unzip),
/* harmony export */   updateAt: () => (/* binding */ updateAt),
/* harmony export */   wilt: () => (/* binding */ wilt),
/* harmony export */   wither: () => (/* binding */ wither),
/* harmony export */   zero: () => (/* binding */ zero),
/* harmony export */   zip: () => (/* binding */ zip),
/* harmony export */   zipWith: () => (/* binding */ zipWith)
/* harmony export */ });
/* harmony import */ var _Apply__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./Apply */ "./node_modules/fp-ts/es6/Apply.js");
/* harmony import */ var _Chain__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./Chain */ "./node_modules/fp-ts/es6/Chain.js");
/* harmony import */ var _FromEither__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./FromEither */ "./node_modules/fp-ts/es6/FromEither.js");
/* harmony import */ var _function__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./function */ "./node_modules/fp-ts/es6/function.js");
/* harmony import */ var _Functor__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./Functor */ "./node_modules/fp-ts/es6/Functor.js");
/* harmony import */ var _internal__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./internal */ "./node_modules/fp-ts/es6/internal.js");
/* harmony import */ var _NonEmptyArray__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./NonEmptyArray */ "./node_modules/fp-ts/es6/NonEmptyArray.js");
/* harmony import */ var _ReadonlyArray__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./ReadonlyArray */ "./node_modules/fp-ts/es6/ReadonlyArray.js");
/* harmony import */ var _Separated__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./Separated */ "./node_modules/fp-ts/es6/Separated.js");
/* harmony import */ var _Witherable__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./Witherable */ "./node_modules/fp-ts/es6/Witherable.js");
/* harmony import */ var _Zero__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./Zero */ "./node_modules/fp-ts/es6/Zero.js");











// -------------------------------------------------------------------------------------
// refinements
// -------------------------------------------------------------------------------------
/**
 * Test whether an array is empty
 *
 * @example
 * import { isEmpty } from 'fp-ts/Array'
 *
 * assert.strictEqual(isEmpty([]), true)
 * assert.strictEqual(isEmpty(['a']), false)
 *
 * @category refinements
 * @since 2.0.0
 */
var isEmpty = function (as) { return as.length === 0; };
/**
 * Test whether an array is non empty narrowing down the type to `NonEmptyArray<A>`
 *
 * @example
 * import { isNonEmpty } from 'fp-ts/Array'
 *
 * assert.strictEqual(isNonEmpty([]), false)
 * assert.strictEqual(isNonEmpty(['a']), true)
 *
 * @category refinements
 * @since 2.0.0
 */
var isNonEmpty = _NonEmptyArray__WEBPACK_IMPORTED_MODULE_0__.isNonEmpty;
// -------------------------------------------------------------------------------------
// constructors
// -------------------------------------------------------------------------------------
/**
 * Prepend an element to the front of a `Array`, creating a new `NonEmptyArray`.
 *
 * @example
 * import { prepend } from 'fp-ts/Array'
 * import { pipe } from 'fp-ts/function'
 *
 * assert.deepStrictEqual(pipe([2, 3, 4], prepend(1)), [1, 2, 3, 4])
 *
 * @since 2.10.0
 */
var prepend = _NonEmptyArray__WEBPACK_IMPORTED_MODULE_0__.prepend;
/**
 * Less strict version of [`prepend`](#prepend).
 *
 * @example
 * import { prependW } from 'fp-ts/Array'
 * import { pipe } from 'fp-ts/function'
 *
 * assert.deepStrictEqual(pipe([2, 3, 4], prependW("a")), ["a", 2, 3, 4]);
 *
 * @since 2.11.0
 */
var prependW = _NonEmptyArray__WEBPACK_IMPORTED_MODULE_0__.prependW;
/**
 * Append an element to the end of a `Array`, creating a new `NonEmptyArray`.
 *
 * @example
 * import { append } from 'fp-ts/Array'
 * import { pipe } from 'fp-ts/function'
 *
 * assert.deepStrictEqual(pipe([1, 2, 3], append(4)), [1, 2, 3, 4])
 *
 * @since 2.10.0
 */
var append = _NonEmptyArray__WEBPACK_IMPORTED_MODULE_0__.append;
/**
 * Less strict version of [`append`](#append).
 *
 * @example
 * import { appendW } from 'fp-ts/Array'
 * import { pipe } from 'fp-ts/function'
 *
 * assert.deepStrictEqual(pipe([1, 2, 3], appendW("d")), [1, 2, 3, "d"]);
 *
 * @since 2.11.0
 */
var appendW = _NonEmptyArray__WEBPACK_IMPORTED_MODULE_0__.appendW;
/**
 * Return a `Array` of length `n` with element `i` initialized with `f(i)`.
 *
 * **Note**. `n` is normalized to a non negative integer.
 *
 * @example
 * import { makeBy } from 'fp-ts/Array'
 *
 * const double = (i: number): number => i * 2
 * assert.deepStrictEqual(makeBy(5, double), [0, 2, 4, 6, 8])
 * assert.deepStrictEqual(makeBy(-3, double), [])
 * assert.deepStrictEqual(makeBy(4.32164, double), [0, 2, 4, 6])
 *
 * @category constructors
 * @since 2.0.0
 */
var makeBy = function (n, f) { return (n <= 0 ? [] : _NonEmptyArray__WEBPACK_IMPORTED_MODULE_0__.makeBy(f)(n)); };
/**
 * Create a `Array` containing a value repeated the specified number of times.
 *
 * **Note**. `n` is normalized to a non negative integer.
 *
 * @example
 * import { replicate } from 'fp-ts/Array'
 *
 * assert.deepStrictEqual(replicate(3, 'a'), ['a', 'a', 'a'])
 * assert.deepStrictEqual(replicate(-3, 'a'), [])
 * assert.deepStrictEqual(replicate(2.985647, 'a'), ['a', 'a'])
 *
 * @category constructors
 * @since 2.0.0
 */
var replicate = function (n, a) { return makeBy(n, function () { return a; }); };
function fromPredicate(predicate) {
    return function (a) { return (predicate(a) ? [a] : []); };
}
// -------------------------------------------------------------------------------------
// conversions
// -------------------------------------------------------------------------------------
/**
 * Create an array from an `Option`. The resulting array will contain the content of the
 * `Option` if it is `Some` and it will be empty if the `Option` is `None`.
 *
 * @example
 * import { fromOption } from 'fp-ts/Array'
 * import { option } from "fp-ts";
 * import { pipe } from 'fp-ts/function'
 *
 * assert.deepStrictEqual(pipe(option.some("a"), fromOption),["a"])
 * assert.deepStrictEqual(pipe(option.none, fromOption),[])
 *
 * @category conversions
 * @since 2.11.0
 */
var fromOption = function (ma) { return (_internal__WEBPACK_IMPORTED_MODULE_1__.isNone(ma) ? [] : [ma.value]); };
/**
 * Create an array from an `Either`. The resulting array will contain the content of the
 * `Either` if it is `Right` and it will be empty if the `Either` is `Left`.
 *
 * @example
 * import { fromEither } from 'fp-ts/Array'
 * import { either } from "fp-ts";
 * import { pipe } from 'fp-ts/function'
 *
 * assert.deepStrictEqual(pipe(either.right("r"), fromEither), ["r"]);
 * assert.deepStrictEqual(pipe(either.left("l"), fromEither), []);
 *
 * @category conversions
 * @since 2.11.0
 */
var fromEither = function (e) { return (_internal__WEBPACK_IMPORTED_MODULE_1__.isLeft(e) ? [] : [e.right]); };
/**
 * Less strict version of [`match`](#match).
 *
 * The `W` suffix (short for **W**idening) means that the handler return types will be merged.
 *
 * @example
 * import { matchW } from 'fp-ts/Array'
 * import { pipe } from 'fp-ts/function'
 *
 * const matcherW = matchW(
 *   () => "No elements",
 *   (as) => as.length
 * );
 * assert.deepStrictEqual(pipe([1, 2, 3, 4], matcherW), 4);
 * assert.deepStrictEqual(pipe([], matcherW), "No elements");
 *
 * @category pattern matching
 * @since 2.11.0
 */
var matchW = function (onEmpty, onNonEmpty) {
    return function (as) {
        return isNonEmpty(as) ? onNonEmpty(as) : onEmpty();
    };
};
/**
 * Takes an array, if the array is empty it returns the result of `onEmpty`, otherwise
 * it passes the array to `onNonEmpty` and returns the result.
 *
 * @example
 * import { match } from 'fp-ts/Array'
 * import { pipe } from 'fp-ts/function'
 *
 * const matcher = match(
 *   () => "No elements",
 *   (as) => `Found ${as.length} element(s)`
 * );
 * assert.deepStrictEqual(pipe([1, 2, 3, 4], matcher), "Found 4 element(s)");
 * assert.deepStrictEqual(pipe([], matcher), "No elements");
 *
 * @category pattern matching
 * @since 2.11.0
 */
var match = matchW;
/**
 * Less strict version of [`matchLeft`](#matchleft). It will work when `onEmpty` and
 * `onNonEmpty` have different return types.
 *
 * @example
 * import { matchLeftW } from 'fp-ts/Array'
 *
 * const f = matchLeftW(
 *   () => 0,
 *   (head: string, tail: string[]) => `Found "${head}" followed by ${tail.length} elements`
 * );
 * assert.strictEqual(f(["a", "b", "c"]), 'Found "a" followed by 2 elements');
 * assert.strictEqual(f([]), 0);
 *
 * @category pattern matching
 * @since 2.11.0
 */
var matchLeftW = function (onEmpty, onNonEmpty) {
    return function (as) {
        return isNonEmpty(as) ? onNonEmpty(_NonEmptyArray__WEBPACK_IMPORTED_MODULE_0__.head(as), _NonEmptyArray__WEBPACK_IMPORTED_MODULE_0__.tail(as)) : onEmpty();
    };
};
/**
 * Takes an array, if the array is empty it returns the result of `onEmpty`, otherwise
 * it passes the array to `onNonEmpty` broken into its first element and remaining elements.
 *
 * @example
 * import { matchLeft } from 'fp-ts/Array'
 *
 * const len: <A>(as: Array<A>) => number = matchLeft(() => 0, (_, tail) => 1 + len(tail))
 * assert.strictEqual(len([1, 2, 3]), 3)
 *
 * @category pattern matching
 * @since 2.10.0
 */
var matchLeft = matchLeftW;
/**
 * Alias of [`matchLeft`](#matchleft).
 *
 * @category pattern matching
 * @since 2.0.0
 */
var foldLeft = matchLeft;
/**
 * Less strict version of [`matchRight`](#matchright). It will work when `onEmpty` and
 * `onNonEmpty` have different return types.
 *
 * @example
 * import { matchRightW } from 'fp-ts/Array'
 *
 * const f = matchRightW(
 *   () => 0,
 *   (head: string[], tail: string) => `Found ${head.length} elements folllowed by "${tail}"`
 * );
 * assert.strictEqual(f(["a", "b", "c"]), 'Found 2 elements folllowed by "c"');
 * assert.strictEqual(f([]), 0);
 *
 * @category pattern matching
 * @since 2.11.0
 */
var matchRightW = function (onEmpty, onNonEmpty) {
    return function (as) {
        return isNonEmpty(as) ? onNonEmpty(_NonEmptyArray__WEBPACK_IMPORTED_MODULE_0__.init(as), _NonEmptyArray__WEBPACK_IMPORTED_MODULE_0__.last(as)) : onEmpty();
    };
};
/**
 * Takes an array, if the array is empty it returns the result of `onEmpty`, otherwise
 * it passes the array to `onNonEmpty` broken  into its initial elements and the last element.
 *
 * @example
 * import { matchRight } from 'fp-ts/Array'
 *
 * const len: <A>(as: Array<A>) => number = matchRight(
 *   () => 0,
 *   (head, _) => 1 + len(head)
 * );
 * assert.strictEqual(len([1, 2, 3]), 3);
 *
 * @category pattern matching
 * @since 2.10.0
 */
var matchRight = matchRightW;
/**
 * Alias of [`matchRight`](#matchright).
 *
 * @category pattern matching
 * @since 2.0.0
 */
var foldRight = matchRight;
// -------------------------------------------------------------------------------------
// combinators
// -------------------------------------------------------------------------------------
/**
 * Same as [`chain`](#chain), but passing also the index to the iterating function.
 *
 * @example
 * import { chainWithIndex, replicate } from 'fp-ts/Array'
 * import { pipe } from 'fp-ts/function'
 *
 * const f = (index: number, x: string) => replicate(2, `${x}${index}`);
 * assert.deepStrictEqual(pipe(["a", "b", "c"], chainWithIndex(f)), ["a0", "a0", "b1", "b1", "c2", "c2"]);
 *
 * @category sequencing
 * @since 2.7.0
 */
var chainWithIndex = function (f) {
    return function (as) {
        var out = [];
        for (var i = 0; i < as.length; i++) {
            var bs = f(i, as[i]);
            for (var j = 0; j < bs.length; j++) {
                out.push(bs[j]);
            }
        }
        return out;
    };
};
/**
 * Same as `reduce` but it carries over the intermediate steps
 *
 * @example
 * import { scanLeft } from 'fp-ts/Array'
 *
 * assert.deepStrictEqual(scanLeft(10, (b, a: number) => b - a)([1, 2, 3]), [10, 9, 7, 4])
 *
 * @since 2.0.0
 */
var scanLeft = function (b, f) {
    return function (as) {
        var len = as.length;
        var out = new Array(len + 1);
        out[0] = b;
        for (var i = 0; i < len; i++) {
            out[i + 1] = f(out[i], as[i]);
        }
        return out;
    };
};
/**
 * Fold an array from the right, keeping all intermediate results instead of only the final result
 *
 * @example
 * import { scanRight } from 'fp-ts/Array'
 *
 * assert.deepStrictEqual(scanRight(10, (a: number, b) => b - a)([1, 2, 3]), [4, 5, 7, 10])
 *
 * @since 2.0.0
 */
var scanRight = function (b, f) {
    return function (as) {
        var len = as.length;
        var out = new Array(len + 1);
        out[len] = b;
        for (var i = len - 1; i >= 0; i--) {
            out[i] = f(as[i], out[i + 1]);
        }
        return out;
    };
};
/**
 * Calculate the number of elements in a `Array`.
 *
 * @example
 * import { size } from 'fp-ts/Array'
 *
 * assert.strictEqual(size(["a","b","c"]),3)
 *
 * @since 2.10.0
 */
var size = function (as) { return as.length; };
/**
 * Test whether an array contains a particular index
 *
 * @example
 * import { isOutOfBound } from 'fp-ts/Array'
 *
 * assert.strictEqual(isOutOfBound(1,["a","b","c"]),false)
 * assert.strictEqual(isOutOfBound(-1,["a","b","c"]),true)
 * assert.strictEqual(isOutOfBound(3,["a","b","c"]),true)
 *
 * @since 2.0.0
 */
var isOutOfBound = _NonEmptyArray__WEBPACK_IMPORTED_MODULE_0__.isOutOfBound;
// TODO: remove non-curried overloading in v3
/**
 * This function provides a safe way to read a value at a particular index from an array.
 * It returns a `none` if the index is out of bounds, and a `some` of the element if the
 * index is valid.
 *
 * @example
 * import { lookup } from 'fp-ts/Array'
 * import { some, none } from 'fp-ts/Option'
 * import { pipe } from 'fp-ts/function'
 *
 * assert.deepStrictEqual(pipe([1, 2, 3], lookup(1)), some(2))
 * assert.deepStrictEqual(pipe([1, 2, 3], lookup(3)), none)
 *
 * @since 2.0.0
 */
var lookup = _ReadonlyArray__WEBPACK_IMPORTED_MODULE_2__.lookup;
/**
 * Get the first element in an array, or `None` if the array is empty
 *
 * @example
 * import { head } from 'fp-ts/Array'
 * import { some, none } from 'fp-ts/Option'
 *
 * assert.deepStrictEqual(head([1, 2, 3]), some(1))
 * assert.deepStrictEqual(head([]), none)
 *
 * @since 2.0.0
 */
var head = _ReadonlyArray__WEBPACK_IMPORTED_MODULE_2__.head;
/**
 * Get the last element in an array, or `None` if the array is empty
 *
 * @example
 * import { last } from 'fp-ts/Array'
 * import { some, none } from 'fp-ts/Option'
 *
 * assert.deepStrictEqual(last([1, 2, 3]), some(3))
 * assert.deepStrictEqual(last([]), none)
 *
 * @since 2.0.0
 */
var last = _ReadonlyArray__WEBPACK_IMPORTED_MODULE_2__.last;
/**
 * Get all but the first element of an array, creating a new array, or `None` if the array is empty
 *
 * @example
 * import { tail } from 'fp-ts/Array'
 * import { some, none } from 'fp-ts/Option'
 *
 * assert.deepStrictEqual(tail([1, 2, 3]), some([2, 3]))
 * assert.deepStrictEqual(tail([]), none)
 *
 * @since 2.0.0
 */
var tail = function (as) { return (isNonEmpty(as) ? _internal__WEBPACK_IMPORTED_MODULE_1__.some(_NonEmptyArray__WEBPACK_IMPORTED_MODULE_0__.tail(as)) : _internal__WEBPACK_IMPORTED_MODULE_1__.none); };
/**
 * Get all but the last element of an array, creating a new array, or `None` if the array is empty
 *
 * @example
 * import { init } from 'fp-ts/Array'
 * import { some, none } from 'fp-ts/Option'
 *
 * assert.deepStrictEqual(init([1, 2, 3]), some([1, 2]))
 * assert.deepStrictEqual(init([]), none)
 *
 * @since 2.0.0
 */
var init = function (as) { return (isNonEmpty(as) ? _internal__WEBPACK_IMPORTED_MODULE_1__.some(_NonEmptyArray__WEBPACK_IMPORTED_MODULE_0__.init(as)) : _internal__WEBPACK_IMPORTED_MODULE_1__.none); };
/**
 * Keep only a max number of elements from the start of an `Array`, creating a new `Array`.
 *
 * **Note**. `n` is normalized to a non negative integer.
 *
 * @example
 * import { takeLeft } from 'fp-ts/Array'
 *
 * assert.deepStrictEqual(takeLeft(2)([1, 2, 3, 4, 5]), [1, 2]);
 * assert.deepStrictEqual(takeLeft(7)([1, 2, 3, 4, 5]), [1, 2, 3, 4, 5]);
 * assert.deepStrictEqual(takeLeft(0)([1, 2, 3, 4, 5]), []);
 * assert.deepStrictEqual(takeLeft(-1)([1, 2, 3, 4, 5]), [1, 2, 3, 4, 5]);
 *
 * @since 2.0.0
 */
var takeLeft = function (n) {
    return function (as) {
        return isOutOfBound(n, as) ? copy(as) : as.slice(0, n);
    };
};
/**
 * Keep only a max number of elements from the end of an `Array`, creating a new `Array`.
 *
 * **Note**. `n` is normalized to a non negative integer.
 *
 * @example
 * import { takeRight } from 'fp-ts/Array'
 *
 * assert.deepStrictEqual(takeRight(2)([1, 2, 3, 4, 5]), [4, 5]);
 * assert.deepStrictEqual(takeRight(7)([1, 2, 3, 4, 5]), [1, 2, 3, 4, 5]);
 * assert.deepStrictEqual(takeRight(0)([1, 2, 3, 4, 5]), []);
 * assert.deepStrictEqual(takeRight(-1)([1, 2, 3, 4, 5]), [1, 2, 3, 4, 5]);
 *
 * @since 2.0.0
 */
var takeRight = function (n) {
    return function (as) {
        return isOutOfBound(n, as) ? copy(as) : n === 0 ? [] : as.slice(-n);
    };
};
function takeLeftWhile(predicate) {
    return function (as) {
        var out = [];
        for (var _i = 0, as_1 = as; _i < as_1.length; _i++) {
            var a = as_1[_i];
            if (!predicate(a)) {
                break;
            }
            out.push(a);
        }
        return out;
    };
}
var spanLeftIndex = function (as, predicate) {
    var l = as.length;
    var i = 0;
    for (; i < l; i++) {
        if (!predicate(as[i])) {
            break;
        }
    }
    return i;
};
function spanLeft(predicate) {
    return function (as) {
        var _a = splitAt(spanLeftIndex(as, predicate))(as), init = _a[0], rest = _a[1];
        return { init: init, rest: rest };
    };
}
/**
 * Creates a new `Array` which is a copy of the input dropping a max number of elements from the start.
 *
 * **Note**. `n` is normalized to a non negative integer.
 *
 * @example
 * import { dropLeft } from 'fp-ts/Array'
 *
 * assert.deepStrictEqual(dropLeft(2)([1, 2, 3]), [3]);
 * assert.deepStrictEqual(dropLeft(5)([1, 2, 3]), []);
 * assert.deepStrictEqual(dropLeft(0)([1, 2, 3]), [1, 2, 3]);
 * assert.deepStrictEqual(dropLeft(-2)([1, 2, 3]), [1, 2, 3]);
 *
 * @since 2.0.0
 */
var dropLeft = function (n) {
    return function (as) {
        return n <= 0 || isEmpty(as) ? copy(as) : n >= as.length ? [] : as.slice(n, as.length);
    };
};
/**
 * Creates a new `Array` which is a copy of the input dropping a max number of elements from the end.
 *
 * **Note**. `n` is normalized to a non negative integer.
 *
 * @example
 * import { dropRight } from 'fp-ts/Array'
 *
 * assert.deepStrictEqual(dropRight(2)([1, 2, 3]), [1]);
 * assert.deepStrictEqual(dropRight(5)([1, 2, 3]), []);
 * assert.deepStrictEqual(dropRight(0)([1, 2, 3]), [1, 2, 3]);
 * assert.deepStrictEqual(dropRight(-2)([1, 2, 3]), [1, 2, 3]);
 *
 * @since 2.0.0
 */
var dropRight = function (n) {
    return function (as) {
        return n <= 0 || isEmpty(as) ? copy(as) : n >= as.length ? [] : as.slice(0, as.length - n);
    };
};
function dropLeftWhile(predicate) {
    return function (as) { return as.slice(spanLeftIndex(as, predicate)); };
}
/**
 * `findIndex` returns an `Option` containing the first index for which a predicate holds.
 * It returns `None` if no element satisfies the predicate.
 * Similar to [`findFirst`](#findFirst) but returning the index instead of the element.
 *
 * @example
 * import { findIndex } from 'fp-ts/Array'
 * import { some, none } from 'fp-ts/Option'
 *
 * assert.deepStrictEqual(findIndex((n: number) => n === 2)([1, 2, 3]), some(1))
 * assert.deepStrictEqual(findIndex((n: number) => n === 2)([]), none)
 *
 * @since 2.0.0
 */
var findIndex = _ReadonlyArray__WEBPACK_IMPORTED_MODULE_2__.findIndex;
function findFirst(predicate) {
    return _ReadonlyArray__WEBPACK_IMPORTED_MODULE_2__.findFirst(predicate);
}
/**
 * Given a selector function which takes an element and returns an option,
 * this function applies the selector to each element of the array and
 * returns the first `Some` result. Otherwise it returns `None`.
 *
 * @example
 * import { findFirstMap } from 'fp-ts/Array'
 * import { some, none } from 'fp-ts/Option'
 *
 * interface Person {
 *   readonly name: string;
 *   readonly age: number;
 * }
 *
 * const persons: Array<Person> = [
 *   { name: "John", age: 16 },
 *   { name: "Mary", age: 45 },
 *   { name: "Joey", age: 28 },
 * ];
 *
 * const nameOfPersonAbove18 = (p: Person) => (p.age <= 18 ? none : some(p.name));
 * const nameOfPersonAbove70 = (p: Person) => (p.age <= 70 ? none : some(p.name));
 * assert.deepStrictEqual(findFirstMap(nameOfPersonAbove18)(persons), some("Mary"));
 * assert.deepStrictEqual(findFirstMap(nameOfPersonAbove70)(persons), none);
 *
 * @since 2.0.0
 */
var findFirstMap = _ReadonlyArray__WEBPACK_IMPORTED_MODULE_2__.findFirstMap;
function findLast(predicate) {
    return _ReadonlyArray__WEBPACK_IMPORTED_MODULE_2__.findLast(predicate);
}
/**
 * Given a selector function which takes an element and returns an option,
 * this function applies the selector to each element of the array starting from the
 * end and returns the last `Some` result. Otherwise it returns `None`.
 *
 * @example
 * import { findLastMap } from 'fp-ts/Array'
 * import { some, none } from 'fp-ts/Option'
 *
 * interface Person {
 *   readonly name: string;
 *   readonly age: number;
 * }
 *
 * const persons: Array<Person> = [
 *   { name: "John", age: 16 },
 *   { name: "Mary", age: 45 },
 *   { name: "Joey", age: 28 },
 * ];
 *
 * const nameOfPersonAbove18 = (p: Person) => (p.age <= 18 ? none : some(p.name));
 * const nameOfPersonAbove70 = (p: Person) => (p.age <= 70 ? none : some(p.name));
 * assert.deepStrictEqual(findLastMap(nameOfPersonAbove18)(persons), some("Joey"));
 * assert.deepStrictEqual(findLastMap(nameOfPersonAbove70)(persons), none);
 *
 * @since 2.0.0
 */
var findLastMap = _ReadonlyArray__WEBPACK_IMPORTED_MODULE_2__.findLastMap;
/**
 * Returns the index of the last element of the list which matches the predicate.
 * It returns an `Option` containing the index or `None` if not found.
 *
 * @example
 * import { findLastIndex } from 'fp-ts/Array'
 * import { some, none } from 'fp-ts/Option'
 *
 * interface X {
 *   readonly a: number
 *   readonly b: number
 * }
 * const xs: Array<X> = [{ a: 1, b: 0 }, { a: 1, b: 1 }]
 * assert.deepStrictEqual(findLastIndex((x: { readonly a: number }) => x.a === 1)(xs), some(1))
 * assert.deepStrictEqual(findLastIndex((x: { readonly a: number }) => x.a === 4)(xs), none)
 *
 * @since 2.0.0
 */
var findLastIndex = _ReadonlyArray__WEBPACK_IMPORTED_MODULE_2__.findLastIndex;
/**
 * This function takes an array and makes a new array containing the same elements.
 *
 * @since 2.0.0
 */
var copy = function (as) { return as.slice(); };
/**
 * Insert an element at the specified index, creating a new array,
 * or returning `None` if the index is out of bounds.
 *
 * @example
 * import { insertAt } from 'fp-ts/Array'
 * import { some } from 'fp-ts/Option'
 *
 * assert.deepStrictEqual(insertAt(2, 5)([1, 2, 3, 4]), some([1, 2, 5, 3, 4]))
 *
 * @since 2.0.0
 */
var insertAt = function (i, a) {
    return function (as) {
        return i < 0 || i > as.length ? _internal__WEBPACK_IMPORTED_MODULE_1__.none : _internal__WEBPACK_IMPORTED_MODULE_1__.some(unsafeInsertAt(i, a, as));
    };
};
/**
 * Change the element at the specified index, creating a new array,
 * or returning `None` if the index is out of bounds.
 *
 * @example
 * import { updateAt } from 'fp-ts/Array'
 * import { some, none } from 'fp-ts/Option'
 *
 * assert.deepStrictEqual(updateAt(1, 1)([1, 2, 3]), some([1, 1, 3]))
 * assert.deepStrictEqual(updateAt(1, 1)([]), none)
 *
 * @since 2.0.0
 */
var updateAt = function (i, a) { return modifyAt(i, function () { return a; }); };
/**
 * Delete the element at the specified index, creating a new array, or returning `None` if the index is out of bounds.
 *
 * @example
 * import { deleteAt } from 'fp-ts/Array'
 * import { some, none } from 'fp-ts/Option'
 *
 * assert.deepStrictEqual(deleteAt(0)([1, 2, 3]), some([2, 3]))
 * assert.deepStrictEqual(deleteAt(1)([]), none)
 *
 * @since 2.0.0
 */
var deleteAt = function (i) {
    return function (as) {
        return isOutOfBound(i, as) ? _internal__WEBPACK_IMPORTED_MODULE_1__.none : _internal__WEBPACK_IMPORTED_MODULE_1__.some(unsafeDeleteAt(i, as));
    };
};
/**
 * Apply a function to the element at the specified index, creating a new array, or returning `None` if the index is out
 * of bounds.
 *
 * @example
 * import { modifyAt } from 'fp-ts/Array'
 * import { some, none } from 'fp-ts/Option'
 *
 * const double = (x: number): number => x * 2
 * assert.deepStrictEqual(modifyAt(1, double)([1, 2, 3]), some([1, 4, 3]))
 * assert.deepStrictEqual(modifyAt(1, double)([]), none)
 *
 * @since 2.0.0
 */
var modifyAt = function (i, f) {
    return function (as) {
        return isOutOfBound(i, as) ? _internal__WEBPACK_IMPORTED_MODULE_1__.none : _internal__WEBPACK_IMPORTED_MODULE_1__.some(unsafeUpdateAt(i, f(as[i]), as));
    };
};
/**
 * Reverse an array, creating a new array
 *
 * @example
 * import { reverse } from 'fp-ts/Array'
 *
 * assert.deepStrictEqual(reverse([1, 2, 3]), [3, 2, 1])
 *
 * @since 2.0.0
 */
var reverse = function (as) { return (isEmpty(as) ? [] : as.slice().reverse()); };
/**
 * Takes an `Array` of `Either` and produces a new `Array` containing
 * the values of all the `Right` elements in the same order.
 *
 * @example
 * import { rights } from 'fp-ts/Array'
 * import { right, left } from 'fp-ts/Either'
 *
 * assert.deepStrictEqual(rights([right(1), left('foo'), right(2)]), [1, 2])
 *
 * @since 2.0.0
 */
var rights = function (as) {
    var r = [];
    for (var i = 0; i < as.length; i++) {
        var a = as[i];
        if (a._tag === 'Right') {
            r.push(a.right);
        }
    }
    return r;
};
/**
 * Takes an `Array` of `Either` and produces a new `Array` containing
 * the values of all the `Left` elements in the same order.
 *
 * @example
 * import { lefts } from 'fp-ts/Array'
 * import { left, right } from 'fp-ts/Either'
 *
 * assert.deepStrictEqual(lefts([right(1), left('foo'), right(2)]), ['foo'])
 *
 * @since 2.0.0
 */
var lefts = function (as) {
    var r = [];
    for (var i = 0; i < as.length; i++) {
        var a = as[i];
        if (a._tag === 'Left') {
            r.push(a.left);
        }
    }
    return r;
};
/**
 * Sort the elements of an array in increasing order, creating a new array
 *
 * @example
 * import { sort } from 'fp-ts/Array'
 * import * as N from 'fp-ts/number'
 *
 * assert.deepStrictEqual(sort(N.Ord)([3, 2, 1]), [1, 2, 3])
 *
 * @since 2.0.0
 */
var sort = function (O) {
    return function (as) {
        return as.length <= 1 ? copy(as) : as.slice().sort(O.compare);
    };
};
/**
 * Apply a function to pairs of elements at the same index in two arrays, collecting the results in a new array. If one
 * input array is short, excess elements of the longer array are discarded.
 *
 * @example
 * import { zipWith } from 'fp-ts/Array'
 *
 * assert.deepStrictEqual(zipWith([1, 2, 3], ['a', 'b', 'c', 'd'], (n, s) => s + n), ['a1', 'b2', 'c3'])
 *
 * @since 2.0.0
 */
var zipWith = function (fa, fb, f) {
    var fc = [];
    var len = Math.min(fa.length, fb.length);
    for (var i = 0; i < len; i++) {
        fc[i] = f(fa[i], fb[i]);
    }
    return fc;
};
function zip(as, bs) {
    if (bs === undefined) {
        return function (bs) { return zip(bs, as); };
    }
    return zipWith(as, bs, function (a, b) { return [a, b]; });
}
/**
 * The function is reverse of `zip`. Takes an array of pairs and return two corresponding arrays
 *
 * @example
 * import { unzip } from 'fp-ts/Array'
 *
 * assert.deepStrictEqual(unzip([[1, 'a'], [2, 'b'], [3, 'c']]), [[1, 2, 3], ['a', 'b', 'c']])
 *
 * @since 2.0.0
 */
var unzip = function (as) {
    var fa = [];
    var fb = [];
    for (var i = 0; i < as.length; i++) {
        fa[i] = as[i][0];
        fb[i] = as[i][1];
    }
    return [fa, fb];
};
/**
 * Creates a new `Array`, prepending an element to every member of the input `Array`.
 *
 * @example
 * import { prependAll } from 'fp-ts/Array'
 *
 * assert.deepStrictEqual(prependAll(9)([1, 2, 3, 4]), [9, 1, 9, 2, 9, 3, 9, 4])
 *
 * @since 2.10.0
 */
var prependAll = function (middle) {
    var f = _NonEmptyArray__WEBPACK_IMPORTED_MODULE_0__.prependAll(middle);
    return function (as) { return (isNonEmpty(as) ? f(as) : []); };
};
/**
 * Creates a new `Array` placing an element in between members of the input `Array`.
 *
 * @example
 * import { intersperse } from 'fp-ts/Array'
 *
 * assert.deepStrictEqual(intersperse(9)([1, 2, 3, 4]), [1, 9, 2, 9, 3, 9, 4])
 *
 * @since 2.9.0
 */
var intersperse = function (middle) {
    var f = _NonEmptyArray__WEBPACK_IMPORTED_MODULE_0__.intersperse(middle);
    return function (as) { return (isNonEmpty(as) ? f(as) : copy(as)); };
};
/**
 * Creates a new `Array` rotating the input `Array` by `n` steps.
 *
 * @example
 * import { rotate } from 'fp-ts/Array'
 *
 * assert.deepStrictEqual(rotate(2)([1, 2, 3, 4, 5]), [4, 5, 1, 2, 3])
 *
 * @since 2.0.0
 */
var rotate = function (n) {
    var f = _NonEmptyArray__WEBPACK_IMPORTED_MODULE_0__.rotate(n);
    return function (as) { return (isNonEmpty(as) ? f(as) : copy(as)); };
};
// TODO: remove non-curried overloading in v3
/**
 * Test if a value is a member of an `Array`. Takes a `Eq<A>` as a single
 * argument which returns the function to use to search for a value of type `A` in
 * an `Array<A>`.
 *
 * @example
 * import { elem } from 'fp-ts/Array'
 * import * as N from 'fp-ts/number'
 * import { pipe } from 'fp-ts/function'
 *
 * assert.strictEqual(pipe([1, 2, 3], elem(N.Eq)(2)), true)
 * assert.strictEqual(pipe([1, 2, 3], elem(N.Eq)(0)), false)
 *
 * @since 2.0.0
 */
var elem = _ReadonlyArray__WEBPACK_IMPORTED_MODULE_2__.elem;
/**
 * Creates a new `Array` removing duplicate elements, keeping the first occurrence of an element,
 * based on a `Eq<A>`.
 *
 * @example
 * import { uniq } from 'fp-ts/Array'
 * import * as N from 'fp-ts/number'
 *
 * assert.deepStrictEqual(uniq(N.Eq)([1, 2, 1]), [1, 2])
 *
 * @since 2.0.0
 */
var uniq = function (E) {
    var f = _NonEmptyArray__WEBPACK_IMPORTED_MODULE_0__.uniq(E);
    return function (as) { return (isNonEmpty(as) ? f(as) : copy(as)); };
};
/**
 * Sort the elements of an array in increasing order, where elements are compared using first `ords[0]`, then `ords[1]`,
 * etc...
 *
 * @example
 * import { sortBy } from 'fp-ts/Array'
 * import { contramap } from 'fp-ts/Ord'
 * import * as S from 'fp-ts/string'
 * import * as N from 'fp-ts/number'
 * import { pipe } from 'fp-ts/function'
 *
 * interface Person {
 *   readonly name: string
 *   readonly age: number
 * }
 * const byName = pipe(S.Ord, contramap((p: Person) => p.name))
 * const byAge = pipe(N.Ord, contramap((p: Person) => p.age))
 *
 * const sortByNameByAge = sortBy([byName, byAge])
 *
 * const persons = [{ name: 'a', age: 1 }, { name: 'b', age: 3 }, { name: 'c', age: 2 }, { name: 'b', age: 2 }]
 * assert.deepStrictEqual(sortByNameByAge(persons), [
 *   { name: 'a', age: 1 },
 *   { name: 'b', age: 2 },
 *   { name: 'b', age: 3 },
 *   { name: 'c', age: 2 }
 * ])
 *
 * @since 2.0.0
 */
var sortBy = function (ords) {
    var f = _NonEmptyArray__WEBPACK_IMPORTED_MODULE_0__.sortBy(ords);
    return function (as) { return (isNonEmpty(as) ? f(as) : copy(as)); };
};
/**
 * A useful recursion pattern for processing an array to produce a new array, often used for "chopping" up the input
 * array. Typically chop is called with some function that will consume an initial prefix of the array and produce a
 * value and the rest of the array.
 *
 * @example
 * import { Eq } from 'fp-ts/Eq'
 * import * as A from 'fp-ts/Array'
 * import * as N from 'fp-ts/number'
 * import { pipe } from 'fp-ts/function'
 *
 * const group = <A>(S: Eq<A>): ((as: Array<A>) => Array<Array<A>>) => {
 *   return A.chop(as => {
 *     const { init, rest } = pipe(as, A.spanLeft((a: A) => S.equals(a, as[0])))
 *     return [init, rest]
 *   })
 * }
 * assert.deepStrictEqual(group(N.Eq)([1, 1, 2, 3, 3, 4]), [[1, 1], [2], [3, 3], [4]])
 *
 * @since 2.0.0
 */
var chop = function (f) {
    var g = _NonEmptyArray__WEBPACK_IMPORTED_MODULE_0__.chop(f);
    return function (as) { return (isNonEmpty(as) ? g(as) : []); };
};
/**
 * Splits an `Array` into two pieces, the first piece has max `n` elements.
 *
 * @example
 * import { splitAt } from 'fp-ts/Array'
 *
 * assert.deepStrictEqual(splitAt(2)([1, 2, 3, 4, 5]), [[1, 2], [3, 4, 5]])
 *
 * @since 2.0.0
 */
var splitAt = function (n) {
    return function (as) {
        return n >= 1 && isNonEmpty(as) ? _NonEmptyArray__WEBPACK_IMPORTED_MODULE_0__.splitAt(n)(as) : isEmpty(as) ? [copy(as), []] : [[], copy(as)];
    };
};
/**
 * Splits an array into length-`n` pieces. The last piece will be shorter if `n` does not evenly divide the length of
 * the array. Note that `chunksOf(n)([])` is `[]`, not `[[]]`. This is intentional, and is consistent with a recursive
 * definition of `chunksOf`; it satisfies the property that
 *
 * ```ts
 * chunksOf(n)(xs).concat(chunksOf(n)(ys)) == chunksOf(n)(xs.concat(ys)))
 * ```
 *
 * whenever `n` evenly divides the length of `xs`.
 *
 * @example
 * import { chunksOf } from 'fp-ts/Array'
 *
 * assert.deepStrictEqual(chunksOf(2)([1, 2, 3, 4, 5]), [[1, 2], [3, 4], [5]])
 *
 * @since 2.0.0
 */
var chunksOf = function (n) {
    var f = _NonEmptyArray__WEBPACK_IMPORTED_MODULE_0__.chunksOf(n);
    return function (as) { return (isNonEmpty(as) ? f(as) : []); };
};
/**
 * @category lifting
 * @since 2.11.0
 */
var fromOptionK = function (f) {
    return function () {
        var a = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            a[_i] = arguments[_i];
        }
        return fromOption(f.apply(void 0, a));
    };
};
function comprehension(input, f, g) {
    if (g === void 0) { g = function () { return true; }; }
    var go = function (scope, input) {
        return isNonEmpty(input)
            ? flatMap(_NonEmptyArray__WEBPACK_IMPORTED_MODULE_0__.head(input), function (a) { return go((0,_function__WEBPACK_IMPORTED_MODULE_3__.pipe)(scope, append(a)), _NonEmptyArray__WEBPACK_IMPORTED_MODULE_0__.tail(input)); })
            : g.apply(void 0, scope) ? [f.apply(void 0, scope)]
                : [];
    };
    return go([], input);
}
/**
 * @since 2.11.0
 */
var concatW = function (second) {
    return function (first) {
        return isEmpty(first) ? copy(second) : isEmpty(second) ? copy(first) : first.concat(second);
    };
};
/**
 * @since 2.11.0
 */
var concat = concatW;
function union(E) {
    var unionE = _NonEmptyArray__WEBPACK_IMPORTED_MODULE_0__.union(E);
    return function (first, second) {
        if (second === undefined) {
            var unionE_1 = union(E);
            return function (second) { return unionE_1(second, first); };
        }
        return isNonEmpty(first) && isNonEmpty(second)
            ? unionE(second)(first)
            : isNonEmpty(first)
                ? copy(first)
                : copy(second);
    };
}
function intersection(E) {
    var elemE = elem(E);
    return function (xs, ys) {
        if (ys === undefined) {
            var intersectionE_1 = intersection(E);
            return function (ys) { return intersectionE_1(ys, xs); };
        }
        return xs.filter(function (a) { return elemE(a, ys); });
    };
}
function difference(E) {
    var elemE = elem(E);
    return function (xs, ys) {
        if (ys === undefined) {
            var differenceE_1 = difference(E);
            return function (ys) { return differenceE_1(ys, xs); };
        }
        return xs.filter(function (a) { return !elemE(a, ys); });
    };
}
var _map = function (fa, f) { return (0,_function__WEBPACK_IMPORTED_MODULE_3__.pipe)(fa, map(f)); };
/* istanbul ignore next */
var _mapWithIndex = function (fa, f) { return (0,_function__WEBPACK_IMPORTED_MODULE_3__.pipe)(fa, mapWithIndex(f)); };
var _ap = function (fab, fa) { return (0,_function__WEBPACK_IMPORTED_MODULE_3__.pipe)(fab, ap(fa)); };
/* istanbul ignore next */
var _filter = function (fa, predicate) { return (0,_function__WEBPACK_IMPORTED_MODULE_3__.pipe)(fa, filter(predicate)); };
/* istanbul ignore next */
var _filterMap = function (fa, f) { return (0,_function__WEBPACK_IMPORTED_MODULE_3__.pipe)(fa, filterMap(f)); };
/* istanbul ignore next */
var _partition = function (fa, predicate) {
    return (0,_function__WEBPACK_IMPORTED_MODULE_3__.pipe)(fa, partition(predicate));
};
/* istanbul ignore next */
var _partitionMap = function (fa, f) { return (0,_function__WEBPACK_IMPORTED_MODULE_3__.pipe)(fa, partitionMap(f)); };
/* istanbul ignore next */
var _partitionWithIndex = function (fa, predicateWithIndex) { return (0,_function__WEBPACK_IMPORTED_MODULE_3__.pipe)(fa, partitionWithIndex(predicateWithIndex)); };
/* istanbul ignore next */
var _partitionMapWithIndex = function (fa, f) { return (0,_function__WEBPACK_IMPORTED_MODULE_3__.pipe)(fa, partitionMapWithIndex(f)); };
/* istanbul ignore next */
var _alt = function (fa, that) { return (0,_function__WEBPACK_IMPORTED_MODULE_3__.pipe)(fa, alt(that)); };
var _reduce = function (fa, b, f) { return (0,_function__WEBPACK_IMPORTED_MODULE_3__.pipe)(fa, reduce(b, f)); };
/* istanbul ignore next */
var _foldMap = function (M) {
    var foldMapM = foldMap(M);
    return function (fa, f) { return (0,_function__WEBPACK_IMPORTED_MODULE_3__.pipe)(fa, foldMapM(f)); };
};
/* istanbul ignore next */
var _reduceRight = function (fa, b, f) { return (0,_function__WEBPACK_IMPORTED_MODULE_3__.pipe)(fa, reduceRight(b, f)); };
/* istanbul ignore next */
var _reduceWithIndex = function (fa, b, f) {
    return (0,_function__WEBPACK_IMPORTED_MODULE_3__.pipe)(fa, reduceWithIndex(b, f));
};
/* istanbul ignore next */
var _foldMapWithIndex = function (M) {
    var foldMapWithIndexM = foldMapWithIndex(M);
    return function (fa, f) { return (0,_function__WEBPACK_IMPORTED_MODULE_3__.pipe)(fa, foldMapWithIndexM(f)); };
};
/* istanbul ignore next */
var _reduceRightWithIndex = function (fa, b, f) {
    return (0,_function__WEBPACK_IMPORTED_MODULE_3__.pipe)(fa, reduceRightWithIndex(b, f));
};
/* istanbul ignore next */
var _filterMapWithIndex = function (fa, f) { return (0,_function__WEBPACK_IMPORTED_MODULE_3__.pipe)(fa, filterMapWithIndex(f)); };
/* istanbul ignore next */
var _filterWithIndex = function (fa, predicateWithIndex) { return (0,_function__WEBPACK_IMPORTED_MODULE_3__.pipe)(fa, filterWithIndex(predicateWithIndex)); };
/* istanbul ignore next */
var _extend = function (fa, f) { return (0,_function__WEBPACK_IMPORTED_MODULE_3__.pipe)(fa, extend(f)); };
/* istanbul ignore next */
var _traverse = function (F) {
    var traverseF = traverse(F);
    return function (ta, f) { return (0,_function__WEBPACK_IMPORTED_MODULE_3__.pipe)(ta, traverseF(f)); };
};
/* istanbul ignore next */
var _traverseWithIndex = function (F) {
    var traverseWithIndexF = traverseWithIndex(F);
    return function (ta, f) { return (0,_function__WEBPACK_IMPORTED_MODULE_3__.pipe)(ta, traverseWithIndexF(f)); };
};
var _chainRecDepthFirst = _ReadonlyArray__WEBPACK_IMPORTED_MODULE_2__._chainRecDepthFirst;
var _chainRecBreadthFirst = _ReadonlyArray__WEBPACK_IMPORTED_MODULE_2__._chainRecBreadthFirst;
/**
 * Given an element of the base type, `of` builds an `Array` containing just that
 * element of the base type (this is useful for building a `Monad`).
 *
 * @example
 * import { of } from 'fp-ts/Array'
 *
 * assert.deepStrictEqual(of("a"), ["a"]);
 *
 * @category constructors
 * @since 2.0.0
 */
var of = _NonEmptyArray__WEBPACK_IMPORTED_MODULE_0__.of;
/**
 * Makes an empty `Array`, useful for building a [`Monoid`](#Monoid)
 *
 * @since 2.7.0
 */
var zero = function () { return []; };
/**
 * `map` can be used to turn functions `(a: A) => B` into functions `(fa: Array<A>) => Array<B>`.
 * In practice it applies the base function to each element of the array and collects the
 * results in a new array.
 *
 * @example
 * import { map } from 'fp-ts/Array'
 * import { pipe } from 'fp-ts/function'
 *
 * const f = (n: number) => n * 2;
 * assert.deepStrictEqual(pipe([1, 2, 3], map(f)), [2, 4, 6]);
 *
 * @category mapping
 * @since 2.0.0
 */
var map = function (f) { return function (fa) { return fa.map(function (a) { return f(a); }); }; };
/**
 * @example
 * import { ap, map, of } from 'fp-ts/Array'
 * import { pipe } from 'fp-ts/function'
 *
 * // a curried function with 3 input parameteres
 * const f = (s1: string) => (n: number) => (s2: string) => s1 + n + s2;
 *
 * // let's use `ap` to iterate `f` over an array for each input parameter
 * assert.deepStrictEqual(pipe(["a", "b"], map(f), ap([1, 2]), ap(["", "", ""])), [
 *   "a1", "a1", "a1",
 *   "a2", "a2", "a2",
 *   "b1", "b1", "b1",
 *   "b2", "b2", "b2",
 * ]);
 *
 * // given Array implements the Applicative interface with the `of` method,
 * // we can write exactly the same thing in a more symmetric way
 * // using `of` on `f` and `ap` on each array in input
 * assert.deepStrictEqual(
 *   pipe(of(f), ap(["a", "b"]), ap([1, 2]), ap(["", "", ""])),
 *   pipe(["a", "b"], map(f), ap([1, 2]), ap(["", "", ""]))
 * );
 *
 * @since 2.0.0
 */
var ap = function (fa) {
    return flatMap(function (f) { return (0,_function__WEBPACK_IMPORTED_MODULE_3__.pipe)(fa, map(f)); });
};
/**
 * Composes computations in sequence, using the return value of one computation to
 * determine the next computation.
 *
 * In other words it takes a function `f` that produces an array from a single element of
 * the base type `A` and returns a new function which applies `f` to each element of the
 * input array (like [`map`](#map)) and, instead of returning an array of arrays, concatenates the
 * results into a single array (like [`flatten`](#flatten)).
 *
 * @example
 * import { flatMap, map, replicate } from 'fp-ts/Array'
 * import { pipe } from 'fp-ts/function'
 *
 * const f = (n: number) => replicate(n, `${n}`);
 * assert.deepStrictEqual(pipe([1, 2, 3], map(f)), [["1"], ["2", "2"], ["3", "3", "3"]]);
 * assert.deepStrictEqual(pipe([1, 2, 3], flatMap(f)), ["1", "2", "2", "3", "3", "3"]);
 *
 * @category sequencing
 * @since 2.14.0
 */
var flatMap = /*#__PURE__*/ (0,_function__WEBPACK_IMPORTED_MODULE_3__.dual)(2, function (ma, f) {
    return (0,_function__WEBPACK_IMPORTED_MODULE_3__.pipe)(ma, chainWithIndex(function (i, a) { return f(a, i); }));
});
/**
 * Takes an array of arrays of `A` and flattens them into an array of `A`
 * by concatenating the elements of each array in order.
 *
 * @example
 * import { flatten } from 'fp-ts/Array'
 *
 * assert.deepStrictEqual(flatten([["a"], ["b", "c"], ["d", "e", "f"]]), ["a", "b", "c", "d", "e", "f"]);
 *
 * @category sequencing
 * @since 2.5.0
 */
var flatten = /*#__PURE__*/ flatMap(_function__WEBPACK_IMPORTED_MODULE_3__.identity);
/**
 * Same as [`map`](#map), but the iterating function takes both the index and the value
 * of the element.
 *
 * @example
 * import { mapWithIndex } from 'fp-ts/Array'
 * import { pipe } from 'fp-ts/function'
 *
 * const f = (i: number, s: string) => `${s} - ${i}`;
 * assert.deepStrictEqual(pipe(["a", "b", "c"], mapWithIndex(f)), ["a - 0", "b - 1", "c - 2"]);
 *
 * @category mapping
 * @since 2.0.0
 */
var mapWithIndex = function (f) { return function (fa) {
    return fa.map(function (a, i) { return f(i, a); });
}; };
/**
 * Maps an array with an iterating function that takes the index and the value of
 * each element and returns an `Option`. It keeps only the `Some` values discarding
 * the `None`s.
 *
 * Same as [`filterMap`](#filterMap), but with an iterating function which takes also
 * the index as input.
 *
 * @example
 * import { filterMapWithIndex } from 'fp-ts/Array'
 * import { pipe } from 'fp-ts/function'
 * import { option } from "fp-ts";
 *
 * const f = (i: number, s: string) => (i % 2 === 1 ? option.some(s.toUpperCase()) : option.none);
 * assert.deepStrictEqual(pipe(["a", "no", "neither", "b"], filterMapWithIndex(f)), ["NO", "B"]);
 *
 * @category filtering
 * @since 2.0.0
 */
var filterMapWithIndex = function (f) {
    return function (fa) {
        var out = [];
        for (var i = 0; i < fa.length; i++) {
            var optionB = f(i, fa[i]);
            if (_internal__WEBPACK_IMPORTED_MODULE_1__.isSome(optionB)) {
                out.push(optionB.value);
            }
        }
        return out;
    };
};
/**
 * Maps an array with an iterating function that returns an `Option`
 * and it keeps only the `Some` values discarding the `None`s.
 *
 * @example
 * import { filterMap } from 'fp-ts/Array'
 * import { pipe } from 'fp-ts/function'
 * import { option } from "fp-ts";
 *
 * const f = (s: string) => s.length === 1 ? option.some(s.toUpperCase()) : option.none;
 * assert.deepStrictEqual(pipe(["a", "no", "neither", "b"], filterMap(f)), ["A", "B"]);
 *
 * @category filtering
 * @since 2.0.0
 */
var filterMap = function (f) {
    return filterMapWithIndex(function (_, a) { return f(a); });
};
/**
 * Compact an array of `Option`s discarding the `None` values and
 * keeping the `Some` values. It returns a new array containing the values of
 * the `Some` options.
 *
 * @example
 * import { compact } from 'fp-ts/Array'
 * import { option } from "fp-ts";
 *
 * assert.deepStrictEqual(compact([option.some("a"), option.none, option.some("b")]), ["a", "b"]);
 *
 * @category filtering
 * @since 2.0.0
 */
var compact = /*#__PURE__*/ filterMap(_function__WEBPACK_IMPORTED_MODULE_3__.identity);
/**
 * Separate an array of `Either`s into `Left`s and `Right`s, creating two new arrays:
 * one containing all the left values and one containing all the right values.
 *
 * @example
 * import { separate } from 'fp-ts/Array'
 * import { either } from "fp-ts";
 *
 * assert.deepStrictEqual(separate([either.right("r1"), either.left("l1"), either.right("r2")]), {
 *   left: ["l1"],
 *   right: ["r1", "r2"],
 * });
 *
 * @category filtering
 * @since 2.0.0
 */
var separate = function (fa) {
    var left = [];
    var right = [];
    for (var _i = 0, fa_1 = fa; _i < fa_1.length; _i++) {
        var e = fa_1[_i];
        if (e._tag === 'Left') {
            left.push(e.left);
        }
        else {
            right.push(e.right);
        }
    }
    return (0,_Separated__WEBPACK_IMPORTED_MODULE_4__.separated)(left, right);
};
/**
 * Given an iterating function that is a `Predicate` or a `Refinement`,
 * `filter` creates a new `Array` containing the elements of the original
 * `Array` for which the iterating function is `true`.
 *
 * @example
 * import { filter } from 'fp-ts/Array'
 * import { isString } from "fp-ts/string";
 *
 * assert.deepStrictEqual(filter(isString)(["a", 1, {}, "b", 5]), ["a", "b"]);
 * assert.deepStrictEqual(filter((x:number) => x > 0)([-3, 1, -2, 5]), [1, 5]);
 *
 * @category filtering
 * @since 2.0.0
 */
var filter = function (predicate) {
    return function (as) {
        return as.filter(predicate);
    };
};
/**
 * Given an iterating function that is a `Predicate` or a `Refinement`,
 * `partition` creates two new `Array`s: `right` containing the elements of the original
 * `Array` for which the iterating function is `true`, `left` containing the elements
 * for which it is false.
 *
 * @example
 * import { partition } from 'fp-ts/Array'
 * import { isString } from "fp-ts/string";
 *
 * assert.deepStrictEqual(partition(isString)(["a", 1, {}, "b", 5]), { left: [1, {}, 5], right: ["a", "b"] });
 * assert.deepStrictEqual(partition((x: number) => x > 0)([-3, 1, -2, 5]), { left: [-3, -2], right: [1, 5] });
 *
 * @category filtering
 * @since 2.0.0
 */
var partition = function (predicate) {
    return partitionWithIndex(function (_, a) { return predicate(a); });
};
/**
 * Same as [`partition`](#partition), but passing also the index to the iterating function.
 *
 * @example
 * import { partitionWithIndex } from 'fp-ts/Array'
 *
 * assert.deepStrictEqual(partitionWithIndex((index, x: number) => index < 3 && x > 0)([-2, 5, 6, 7]), {
 *   left: [-2, 7],
 *   right: [5, 6],
 * });
 *
 * @category filtering
 * @since 2.0.0
 */
var partitionWithIndex = function (predicateWithIndex) {
    return function (as) {
        var left = [];
        var right = [];
        for (var i = 0; i < as.length; i++) {
            var b = as[i];
            if (predicateWithIndex(i, b)) {
                right.push(b);
            }
            else {
                left.push(b);
            }
        }
        return (0,_Separated__WEBPACK_IMPORTED_MODULE_4__.separated)(left, right);
    };
};
/**
 * Given an iterating function that returns an `Either`,
 * `partitionMap` applies the iterating function to each element and it creates two `Array`s:
 * `right` containing the values of `Right` results, `left` containing the values of `Left` results.
 *
 * @example
 * import { partitionMap } from 'fp-ts/Array'
 * import { Either, left, right } from "fp-ts/Either";
 *
 * const upperIfString = <B>(x: B): Either<B, string> =>
 *   typeof x === "string" ? right(x.toUpperCase()) : left(x);
 * assert.deepStrictEqual(partitionMap(upperIfString)([-2, "hello", 6, 7, "world"]), {
 *   left: [-2, 6, 7],
 *   right: [ 'HELLO', 'WORLD' ],
 * });
 *
 * @category filtering
 * @since 2.0.0
 */
var partitionMap = function (f) { return partitionMapWithIndex(function (_, a) { return f(a); }); };
/**
 * Same as [`partitionMap`](#partitionMap), but passing also the index to the iterating function.
 *
 * @example
 * import { partitionMapWithIndex } from 'fp-ts/Array'
 * import { Either, left, right } from "fp-ts/Either";
 *
 * const upperIfStringBefore3 = <B>(index: number, x: B): Either<B, string> =>
 *   index < 3 && typeof x === "string" ? right(x.toUpperCase()) : left(x);
 * assert.deepStrictEqual(partitionMapWithIndex(upperIfStringBefore3)([-2, "hello", 6, 7, "world"]), {
 *   left: [-2, 6, 7, "world"],
 *   right: ["HELLO"],
 * });
 *
 * @category filtering
 * @since 2.0.0
 */
var partitionMapWithIndex = function (f) {
    return function (fa) {
        var left = [];
        var right = [];
        for (var i = 0; i < fa.length; i++) {
            var e = f(i, fa[i]);
            if (e._tag === 'Left') {
                left.push(e.left);
            }
            else {
                right.push(e.right);
            }
        }
        return (0,_Separated__WEBPACK_IMPORTED_MODULE_4__.separated)(left, right);
    };
};
/**
 * Less strict version of [`alt`](#alt).
 *
 * The `W` suffix (short for **W**idening) means that the return types will be merged.
 *
 * @example
 * import * as A from 'fp-ts/Array'
 * import { pipe } from 'fp-ts/function'
 *
 * assert.deepStrictEqual(
 *   pipe(
 *     [1, 2, 3],
 *     A.altW(() => ['a', 'b'])
 *   ),
 *   [1, 2, 3, 'a', 'b']
 * )
 *
 * @category error handling
 * @since 2.9.0
 */
var altW = function (that) {
    return function (fa) {
        return fa.concat(that());
    };
};
/**
 * Identifies an associative operation on a type constructor. It is similar to `Semigroup`, except that it applies to
 * types of kind `* -> *`.
 *
 * In case of `Array` concatenates the inputs into a single array.
 *
 * @example
 * import * as A from 'fp-ts/Array'
 * import { pipe } from 'fp-ts/function'
 *
 * assert.deepStrictEqual(
 *   pipe(
 *     [1, 2, 3],
 *     A.alt(() => [4, 5])
 *   ),
 *   [1, 2, 3, 4, 5]
 * )
 *
 * @category error handling
 * @since 2.0.0
 */
var alt = altW;
/**
 * Same as [`filter`](#filter), but passing also the index to the iterating function.
 *
 * @example
 * import { filterWithIndex } from 'fp-ts/Array';
 *
 * const f = (index: number, x: number) => x > 0 && index <= 2;
 * assert.deepStrictEqual(filterWithIndex(f)([-3, 1, -2, 5]), [1]);
 *
 * @category filtering
 * @since 2.0.0
 */
var filterWithIndex = function (predicateWithIndex) {
    return function (as) {
        return as.filter(function (b, i) { return predicateWithIndex(i, b); });
    };
};
/**
 * Given an iterating function that takes `Array<A>` as input, `extend` returns
 * an array containing the results of the iterating function applied to the whole input
 * `Array`, then to the input `Array` without the first element, then to the input
 * `Array` without the first two elements, etc.
 *
 * @example
 * import { extend } from 'fp-ts/Array'
 *
 * const f = (a: string[]) => a.join(",");
 * assert.deepStrictEqual(extend(f)(["a", "b", "c"]), ["a,b,c", "b,c", "c"]);
 *
 * @since 2.0.0
 */
var extend = function (f) { return function (wa) {
    return wa.map(function (_, i) { return f(wa.slice(i)); });
}; };
/**
 * `duplicate` returns an array containing the whole input `Array`,
 * then to the input `Array` dropping the first element, then to the input
 * `Array` dropping the first two elements, etc.
 *
 * @example
 * import { duplicate } from 'fp-ts/Array'
 *
 * assert.deepStrictEqual(duplicate(["a", "b", "c"]), [["a", "b", "c"], ["b", "c"], ["c"]]);
 *
 * @since 2.0.0
 */
var duplicate = /*#__PURE__*/ extend(_function__WEBPACK_IMPORTED_MODULE_3__.identity);
/**
 * Map and fold an `Array`.
 * Map the `Array` passing each value to the iterating function.
 * Then fold the results using the provided `Monoid`.
 *
 * @example
 * import { foldMap } from 'fp-ts/Array'
 *
 * const monoid = { concat: (a: string, b: string) => a + b, empty: "" };
 * const f = (s: string) => s.toUpperCase()
 * assert.deepStrictEqual(foldMap(monoid)(f)(["a", "b", "c"]), "ABC");
 *
 * @category folding
 * @since 2.0.0
 */
var foldMap = _ReadonlyArray__WEBPACK_IMPORTED_MODULE_2__.foldMap;
/**
 * Same as [`foldMap`](#foldMap) but passing also the index to the iterating function.
 *
 * @example
 * import { foldMapWithIndex } from 'fp-ts/Array'
 *
 * const monoid = { concat: (a: string, b: string) => a + b, empty: "" };
 * const f = (index:number, s: string) => `${s.toUpperCase()}(${index})`
 * assert.deepStrictEqual(foldMapWithIndex(monoid)(f)(["a", "b", "c"]), "A(0)B(1)C(2)");
 *
 * @category folding
 * @since 2.0.0
 */
var foldMapWithIndex = _ReadonlyArray__WEBPACK_IMPORTED_MODULE_2__.foldMapWithIndex;
/**
 * Reduces an `Array`.
 *
 * `reduce` executes the supplied iterating function on each element of the array,
 * in order, passing in the element and the return value from the calculation on the preceding element.
 *
 * The first time that the iterating function is called there is no "return value of the
 * previous calculation", the initial value is used in its place.
 *
 * @example
 * import { reduce } from 'fp-ts/Array'
 *
 * assert.deepStrictEqual(reduce(5, (acc: number, cur: number) => acc * cur)([2, 3]), 5 * 2 * 3);
 *
 * @category folding
 * @since 2.0.0
 */
var reduce = _ReadonlyArray__WEBPACK_IMPORTED_MODULE_2__.reduce;
/**
 * Same as [`reduce`](#reduce) but passing also the index to the iterating function.
 *
 * @example
 * import { reduceWithIndex } from 'fp-ts/Array'
 *
 * const f = (index: number, acc: string, cur: unknown) =>
 *   acc + (typeof cur === "string" ? cur.toUpperCase() + index : "");
 * assert.deepStrictEqual(reduceWithIndex("", f)([2, "a", "b", null]), "A1B2");
 *
 * @category folding
 * @since 2.0.0
 */
var reduceWithIndex = _ReadonlyArray__WEBPACK_IMPORTED_MODULE_2__.reduceWithIndex;
/**
 * Same as [`reduce`](#reduce) but applied from the end to the start.
 *
 * *Note*: the iterating function in this case takes the accumulator as the last argument.
 *
 * @example
 * import { reduceRight } from 'fp-ts/Array'
 *
 * assert.deepStrictEqual(reduceRight("", (cur: string, acc: string) => acc + cur)(["a", "b", "c"]), "cba");
 *
 * @category folding
 * @since 2.0.0
 */
var reduceRight = _ReadonlyArray__WEBPACK_IMPORTED_MODULE_2__.reduceRight;
/**
 * Same as [`reduceRight`](#reduceRight) but passing also the index to the iterating function.
 *
 * @example
 * import { reduceRightWithIndex } from 'fp-ts/Array'
 *
 * const f = (index: number, cur: unknown, acc: string) =>
 *   acc + (typeof cur === "string" ? cur.toUpperCase() + index : "");
 * assert.deepStrictEqual(reduceRightWithIndex("", f)([2, "a", "b", null]), "B2A1");
 *
 * @category folding
 * @since 2.0.0
 */
var reduceRightWithIndex = _ReadonlyArray__WEBPACK_IMPORTED_MODULE_2__.reduceRightWithIndex;
/**
 * Given an iterating function that returns a `HKT` (higher kinded type), `traverse`
 * applies the iterating function to each element of the `Array` and then [`sequence`](#sequence)-s
 * the results using the provided `Applicative`.
 *
 * E.g. suppose you have an `Array` and you want to format each element with a function
 * that returns a result or an error as `f = (a: A) => Either<Error, B>`, using `traverse`
 * you can apply `f` to all elements and directly obtain as a result an `Either<Error,Array<B>>`
 * i.e. an `Array<B>` if all the results are `B`, or an `Error` if some of the results
 * are `Error`s.
 *
 * @example
 * import { traverse } from 'fp-ts/Array'
 * import { Applicative, left, right } from "fp-ts/Either";
 *
 * const f = (x: unknown) =>
 *   typeof x === "string" ? right(x.toUpperCase()) : left(new Error("not a string"));
 * assert.deepStrictEqual(traverse(Applicative)(f)(["a", "b"]), right(["A", "B"]));
 * assert.deepStrictEqual(traverse(Applicative)(f)(["a", 5]), left(new Error("not a string")));
 *
 * @category traversing
 * @since 2.6.3
 */
var traverse = function (F) {
    var traverseWithIndexF = traverseWithIndex(F);
    return function (f) { return traverseWithIndexF(function (_, a) { return f(a); }); };
};
/**
 * `sequence` takes an `Array` where elements are `HKT<A>` (higher kinded type) and,
 * using an applicative of that `HKT`, returns an `HKT` of `Array<A>`.
 * E.g. it can turn an `Array<Either<Error, string>>` into an `Either<Error, Array<string>>`.
 *
 * `sequence` requires an `Applicative` of the `HKT` you are targeting, e.g. to turn an
 * `Array<Either<E, A>>` into an `Either<E, Array<A>>`, it needs an
 * `Applicative` for `Either`, to to turn an `Array<Option<A>>` into an `Option<Array<A>>`,
 * it needs an `Applicative` for `Option`.
 *
 * @example
 * import { sequence } from 'fp-ts/Array'
 * import { Applicative, left, right } from "fp-ts/Either";
 *
 * assert.deepStrictEqual(sequence(Applicative)([right("a"), right("b")]), right(["a", "b"]));
 * assert.deepStrictEqual(
 *   sequence(Applicative)([right("a"), left(new Error("not a string"))]),
 *   left(new Error("not a string"))
 * );
 *
 * @category traversing
 * @since 2.6.3
 */
var sequence = function (F) {
    return function (ta) {
        return _reduce(ta, F.of(zero()), function (fas, fa) {
            return F.ap(F.map(fas, function (as) { return function (a) { return (0,_function__WEBPACK_IMPORTED_MODULE_3__.pipe)(as, append(a)); }; }), fa);
        });
    };
};
/**
 * Same as [`traverse`](#traverse) but passing also the index to the iterating function.
 *
 * @example
 * import { traverseWithIndex } from 'fp-ts/Array'
 * import { Applicative, left, right } from "fp-ts/Either";
 *
 * const f = (index:number, x:unknown) =>
 *   typeof x === "string" ? right(x.toUpperCase() + index) : left(new Error("not a string"));
 * assert.deepStrictEqual(traverseWithIndex(Applicative)(f)(["a", "b"]), right(["A0", "B1"]));
 * assert.deepStrictEqual(traverseWithIndex(Applicative)(f)(["a", 5]), left(new Error("not a string")));
 *
 * @category sequencing
 * @since 2.6.3
 */
var traverseWithIndex = function (F) {
    return function (f) {
        return reduceWithIndex(F.of(zero()), function (i, fbs, a) {
            return F.ap(F.map(fbs, function (bs) { return function (b) { return (0,_function__WEBPACK_IMPORTED_MODULE_3__.pipe)(bs, append(b)); }; }), f(i, a));
        });
    };
};
/**
 * @category filtering
 * @since 2.6.5
 */
var wither = function (F) {
    var _witherF = _wither(F);
    return function (f) { return function (fa) { return _witherF(fa, f); }; };
};
/**
 * @category filtering
 * @since 2.6.5
 */
var wilt = function (F) {
    var _wiltF = _wilt(F);
    return function (f) { return function (fa) { return _wiltF(fa, f); }; };
};
/**
 * `unfold` takes a function `f` which returns an `Option` of a tuple containing an outcome
 * value and an input for the following iteration.
 * `unfold` applies `f` to the initial value `b` and then recursively to the second
 * element of the tuple contained in the returned `option` of the previous
 * calculation until `f` returns `Option.none`.
 *
 * @example
 * import { unfold } from 'fp-ts/Array'
 * import { option } from 'fp-ts'
 *
 * const f = (n: number) => {
 *   if (n <= 0) return option.none;
 *   const returnValue = n * 2;
 *   const inputForNextRound = n - 1;
 *   return option.some([returnValue, inputForNextRound] as const);
 * };
 * assert.deepStrictEqual(unfold(5, f), [10, 8, 6, 4, 2]);
 *
 * @since 2.6.6
 */
var unfold = function (b, f) {
    var out = [];
    var bb = b;
    // eslint-disable-next-line no-constant-condition
    while (true) {
        var mt = f(bb);
        if (_internal__WEBPACK_IMPORTED_MODULE_1__.isSome(mt)) {
            var _a = mt.value, a = _a[0], b_1 = _a[1];
            out.push(a);
            bb = b_1;
        }
        else {
            break;
        }
    }
    return out;
};
/**
 * @category type lambdas
 * @since 2.0.0
 */
var URI = 'Array';
/**
 * `getShow` makes a `Show` for an `Array<A>` from a `Show` for
 * an `A`.
 *
 * @example
 * import { getShow } from 'fp-ts/Array'
 *
 * const numShow = { show: (n: number) => (n >= 0 ? `${n}` : `(${-n})`) };
 * assert.deepStrictEqual(getShow(numShow).show([-2, -1, 0, 1]), "[(2), (1), 0, 1]");
 *
 * @category instances
 * @since 2.0.0
 */
var getShow = _ReadonlyArray__WEBPACK_IMPORTED_MODULE_2__.getShow;
/**
 * Get a `Semigroup` based on the concatenation of `Array`s.
 * See also [`getMonoid`](#getMonoid).
 *
 * @example
 * import { getSemigroup } from 'fp-ts/Array'
 *
 * const S = getSemigroup<number>();
 * assert.deepStrictEqual(S.concat([1, 2], [2, 3]), [1, 2, 2, 3]);
 *
 * @category instances
 * @since 2.10.0
 */
var getSemigroup = function () { return ({
    concat: function (first, second) { return first.concat(second); }
}); };
/**
 * Returns a `Monoid` for `Array<A>` based on the concatenation of `Array`s.
 *
 * @example
 * import { getMonoid } from 'fp-ts/Array'
 *
 * const M = getMonoid<number>()
 * assert.deepStrictEqual(M.concat([1, 2], [3, 4]), [1, 2, 3, 4])
 *
 * @category instances
 * @since 2.0.0
 */
var getMonoid = function () { return ({
    concat: getSemigroup().concat,
    empty: []
}); };
/**
 * Derives an `Eq` over the `Array` of a given element type from the `Eq` of that type. The derived `Eq` defines two
 * arrays as equal if all elements of both arrays are compared equal pairwise with the given `E`. In case of arrays of
 * different lengths, the result is non equality.
 *
 * @example
 * import * as S from 'fp-ts/string'
 * import { getEq } from 'fp-ts/Array'
 *
 * const E = getEq(S.Eq)
 * assert.strictEqual(E.equals(['a', 'b'], ['a', 'b']), true)
 * assert.strictEqual(E.equals(['a'], []), false)
 *
 * @category instances
 * @since 2.0.0
 */
var getEq = _ReadonlyArray__WEBPACK_IMPORTED_MODULE_2__.getEq;
/**
 * Derives an `Ord` over the `Array` of a given element type from the `Ord` of that type. The ordering between two such
 * arrays is equal to: the first non equal comparison of each arrays elements taken pairwise in increasing order, in
 * case of equality over all the pairwise elements; the longest array is considered the greatest, if both arrays have
 * the same length, the result is equality.
 *
 * @example
 * import { getOrd } from 'fp-ts/Array'
 * import * as S from 'fp-ts/string'
 *
 * const O = getOrd(S.Ord)
 * assert.strictEqual(O.compare(['b'], ['a']), 1)
 * assert.strictEqual(O.compare(['a'], ['a']), 0)
 * assert.strictEqual(O.compare(['a'], ['b']), -1)
 *
 * @category instances
 * @since 2.0.0
 */
var getOrd = _ReadonlyArray__WEBPACK_IMPORTED_MODULE_2__.getOrd;
/**
 * Get a `Semigroup` based on the union of the elements of `Array`s.
 * Elements which equal according to the provided `Eq` are included
 * only once in the result.
 * See also [`getUnionMonoid`](#getUnionMonoid).
 *
 * @example
 * import { getUnionSemigroup } from 'fp-ts/Array';
 * import { Eq } from 'fp-ts/number';
 *
 * const S = getUnionSemigroup<number>(Eq);
 * assert.deepStrictEqual(S.concat([1, 2], [2, 3]), [1, 2, 3]);
 *
 * @category instances
 * @since 2.11.0
 */
var getUnionSemigroup = function (E) {
    var unionE = union(E);
    return {
        concat: function (first, second) { return unionE(second)(first); }
    };
};
/**
 * Get a `Monoid` based on the union of the elements of `Array`s.
 * Elements which equal according to the provided `Eq` are included
 * only once in the result.
 *
 * @example
 * import { getUnionMonoid } from 'fp-ts/Array'
 * import { Eq } from 'fp-ts/number';
 *
 * const M = getUnionMonoid<number>(Eq);
 * assert.deepStrictEqual(M.concat([1, 2], [2, 3]), [1, 2, 3]);
 * assert.deepStrictEqual(M.empty,[]);
 *
 * @category instances
 * @since 2.11.0
 */
var getUnionMonoid = function (E) { return ({
    concat: getUnionSemigroup(E).concat,
    empty: []
}); };
/**
 * Get a `Semigroup` based on the intersection of the elements of `Array`s.
 * Only elements present in the two arrays which are equal according to the
 * provided `Eq` are included in the result.
 *
 * @example
 * import { getIntersectionSemigroup } from 'fp-ts/Array'
 * import { Eq } from 'fp-ts/number';
 *
 * const S = getIntersectionSemigroup<number>(Eq);
 * assert.deepStrictEqual(S.concat([1, 2], [2, 3]), [2]);
 *
 * @category instances
 * @since 2.11.0
 */
var getIntersectionSemigroup = function (E) {
    var intersectionE = intersection(E);
    return {
        concat: function (first, second) { return intersectionE(second)(first); }
    };
};
/**
 * Get a `Magma` for `Array` where the `concat` function is the differnce between
 * the first and the second array, i.e. the result contains all the elements of the
 * first array for which their is no equal element in the second array according
 * to the `Eq` provided.
 *
 *
 * @example
 * import { getDifferenceMagma } from 'fp-ts/Array'
 * import { Eq } from 'fp-ts/number';
 *
 * const S = getDifferenceMagma<number>(Eq);
 * assert.deepStrictEqual(S.concat([1, 2], [2, 3]), [1]);
 *
 * @category instances
 * @since 2.11.0
 */
var getDifferenceMagma = function (E) {
    var differenceE = difference(E);
    return {
        concat: function (first, second) { return differenceE(second)(first); }
    };
};
/**
 * @category instances
 * @since 2.7.0
 */
var Functor = {
    URI: URI,
    map: _map
};
/**
 * Given an input an `Array` of functions, `flap` returns an `Array` containing
 * the results of applying each function to the given input.
 *
 * @example
 * import { flap } from 'fp-ts/Array'
 *
 * const funs = [
 *   (n: number) => `Double: ${n * 2}`,
 *   (n: number) => `Triple: ${n * 3}`,
 *   (n: number) => `Square: ${n * n}`,
 * ];
 * assert.deepStrictEqual(flap(4)(funs), ['Double: 8', 'Triple: 12', 'Square: 16']);
 *
 * @category mapping
 * @since 2.10.0
 */
var flap = /*#__PURE__*/ (0,_Functor__WEBPACK_IMPORTED_MODULE_5__.flap)(Functor);
/**
 * @category instances
 * @since 2.10.0
 */
var Pointed = {
    URI: URI,
    of: of
};
/**
 * @category instances
 * @since 2.7.0
 */
var FunctorWithIndex = {
    URI: URI,
    map: _map,
    mapWithIndex: _mapWithIndex
};
/**
 * @category instances
 * @since 2.10.0
 */
var Apply = {
    URI: URI,
    map: _map,
    ap: _ap
};
/**
 * Combine two effectful actions, keeping only the result of the first.
 *
 * @since 2.5.0
 */
var apFirst = /*#__PURE__*/ (0,_Apply__WEBPACK_IMPORTED_MODULE_6__.apFirst)(Apply);
/**
 * Combine two effectful actions, keeping only the result of the second.
 *
 * @since 2.5.0
 */
var apSecond = /*#__PURE__*/ (0,_Apply__WEBPACK_IMPORTED_MODULE_6__.apSecond)(Apply);
/**
 * @category instances
 * @since 2.7.0
 */
var Applicative = {
    URI: URI,
    map: _map,
    ap: _ap,
    of: of
};
/**
 * @category instances
 * @since 2.10.0
 */
var Chain = {
    URI: URI,
    map: _map,
    ap: _ap,
    chain: flatMap
};
/**
 * Composes computations in sequence, using the return value of one computation to determine the next computation and
 * keeping only the result of the first.
 *
 * @example
 * import * as A from 'fp-ts/Array'
 * import { pipe } from 'fp-ts/function'
 *
 * assert.deepStrictEqual(
 *   pipe(
 *     [1, 2, 3],
 *     A.chainFirst(() => ['a', 'b'])
 *   ),
 *   [1, 1, 2, 2, 3, 3]
 * )
 * assert.deepStrictEqual(
 *   pipe(
 *     [1, 2, 3],
 *     A.chainFirst(() => [])
 *   ),
 *   []
 * )
 *
 * @category sequencing
 * @since 2.0.0
 */
var chainFirst = 
/*#__PURE__*/ (0,_Chain__WEBPACK_IMPORTED_MODULE_7__.chainFirst)(Chain);
/**
 * @category instances
 * @since 2.7.0
 */
var Monad = {
    URI: URI,
    map: _map,
    ap: _ap,
    of: of,
    chain: flatMap
};
/**
 * @category instances
 * @since 2.7.0
 */
var Unfoldable = {
    URI: URI,
    unfold: unfold
};
/**
 * @category instances
 * @since 2.7.0
 */
var Alt = {
    URI: URI,
    map: _map,
    alt: _alt
};
/**
 * @category instances
 * @since 2.11.0
 */
var Zero = {
    URI: URI,
    zero: zero
};
/**
 * @category do notation
 * @since 2.11.0
 */
var guard = /*#__PURE__*/ (0,_Zero__WEBPACK_IMPORTED_MODULE_8__.guard)(Zero, Pointed);
/**
 * @category instances
 * @since 2.7.0
 */
var Alternative = {
    URI: URI,
    map: _map,
    ap: _ap,
    of: of,
    alt: _alt,
    zero: zero
};
/**
 * @category instances
 * @since 2.7.0
 */
var Extend = {
    URI: URI,
    map: _map,
    extend: _extend
};
/**
 * @category instances
 * @since 2.7.0
 */
var Compactable = {
    URI: URI,
    compact: compact,
    separate: separate
};
/**
 * @category instances
 * @since 2.7.0
 */
var Filterable = {
    URI: URI,
    map: _map,
    compact: compact,
    separate: separate,
    filter: _filter,
    filterMap: _filterMap,
    partition: _partition,
    partitionMap: _partitionMap
};
/**
 * @category instances
 * @since 2.7.0
 */
var FilterableWithIndex = {
    URI: URI,
    map: _map,
    mapWithIndex: _mapWithIndex,
    compact: compact,
    separate: separate,
    filter: _filter,
    filterMap: _filterMap,
    partition: _partition,
    partitionMap: _partitionMap,
    partitionMapWithIndex: _partitionMapWithIndex,
    partitionWithIndex: _partitionWithIndex,
    filterMapWithIndex: _filterMapWithIndex,
    filterWithIndex: _filterWithIndex
};
/**
 * @category instances
 * @since 2.7.0
 */
var Foldable = {
    URI: URI,
    reduce: _reduce,
    foldMap: _foldMap,
    reduceRight: _reduceRight
};
/**
 * @category instances
 * @since 2.7.0
 */
var FoldableWithIndex = {
    URI: URI,
    reduce: _reduce,
    foldMap: _foldMap,
    reduceRight: _reduceRight,
    reduceWithIndex: _reduceWithIndex,
    foldMapWithIndex: _foldMapWithIndex,
    reduceRightWithIndex: _reduceRightWithIndex
};
/**
 * @category instances
 * @since 2.7.0
 */
var Traversable = {
    URI: URI,
    map: _map,
    reduce: _reduce,
    foldMap: _foldMap,
    reduceRight: _reduceRight,
    traverse: _traverse,
    sequence: sequence
};
/**
 * @category instances
 * @since 2.7.0
 */
var TraversableWithIndex = {
    URI: URI,
    map: _map,
    mapWithIndex: _mapWithIndex,
    reduce: _reduce,
    foldMap: _foldMap,
    reduceRight: _reduceRight,
    reduceWithIndex: _reduceWithIndex,
    foldMapWithIndex: _foldMapWithIndex,
    reduceRightWithIndex: _reduceRightWithIndex,
    traverse: _traverse,
    sequence: sequence,
    traverseWithIndex: _traverseWithIndex
};
var _wither = /*#__PURE__*/ (0,_Witherable__WEBPACK_IMPORTED_MODULE_9__.witherDefault)(Traversable, Compactable);
var _wilt = /*#__PURE__*/ (0,_Witherable__WEBPACK_IMPORTED_MODULE_9__.wiltDefault)(Traversable, Compactable);
/**
 * @category instances
 * @since 2.7.0
 */
var Witherable = {
    URI: URI,
    map: _map,
    compact: compact,
    separate: separate,
    filter: _filter,
    filterMap: _filterMap,
    partition: _partition,
    partitionMap: _partitionMap,
    reduce: _reduce,
    foldMap: _foldMap,
    reduceRight: _reduceRight,
    traverse: _traverse,
    sequence: sequence,
    wither: _wither,
    wilt: _wilt
};
/**
 * @category sequencing
 * @since 2.11.0
 */
var chainRecDepthFirst = _ReadonlyArray__WEBPACK_IMPORTED_MODULE_2__.chainRecDepthFirst;
/**
 * @category instances
 * @since 2.11.0
 */
var ChainRecDepthFirst = {
    URI: URI,
    map: _map,
    ap: _ap,
    chain: flatMap,
    chainRec: _chainRecDepthFirst
};
/**
 * @category sequencing
 * @since 2.11.0
 */
var chainRecBreadthFirst = _ReadonlyArray__WEBPACK_IMPORTED_MODULE_2__.chainRecBreadthFirst;
/**
 * @category instances
 * @since 2.11.0
 */
var ChainRecBreadthFirst = {
    URI: URI,
    map: _map,
    ap: _ap,
    chain: flatMap,
    chainRec: _chainRecBreadthFirst
};
/**
 * Filter values inside a context.
 *
 * @since 2.11.0
 */
var filterE = /*#__PURE__*/ (0,_Witherable__WEBPACK_IMPORTED_MODULE_9__.filterE)(Witherable);
/**
 * @category instances
 * @since 2.11.0
 */
var FromEither = {
    URI: URI,
    fromEither: fromEither
};
/**
 * @category lifting
 * @since 2.11.0
 */
var fromEitherK = /*#__PURE__*/ (0,_FromEither__WEBPACK_IMPORTED_MODULE_10__.fromEitherK)(FromEither);
// -------------------------------------------------------------------------------------
// unsafe
// -------------------------------------------------------------------------------------
/**
 * @category unsafe
 * @since 2.0.0
 */
var unsafeInsertAt = _NonEmptyArray__WEBPACK_IMPORTED_MODULE_0__.unsafeInsertAt;
/**
 * @category unsafe
 * @since 2.0.0
 */
var unsafeUpdateAt = function (i, a, as) {
    return isNonEmpty(as) ? _NonEmptyArray__WEBPACK_IMPORTED_MODULE_0__.unsafeUpdateAt(i, a, as) : [];
};
/**
 * @category unsafe
 * @since 2.0.0
 */
var unsafeDeleteAt = function (i, as) {
    var xs = as.slice();
    xs.splice(i, 1);
    return xs;
};
// -------------------------------------------------------------------------------------
// utils
// -------------------------------------------------------------------------------------
/**
 * `every` tells if the provided predicate holds true for every element in the `Array`.
 *
 * @example
 * import { every } from 'fp-ts/Array'
 *
 * assert.equal(every((x: number) => x >= 0)([1, 2, 3]), true);
 * assert.equal(every((x: number) => x >= 0)([-1, 2, 3]), false);
 *
 * @since 2.9.0
 */
var every = _ReadonlyArray__WEBPACK_IMPORTED_MODULE_2__.every;
/**
 * `some` tells if the provided predicate holds true at least for one element in the `Array`.
 *
 * @example
 * import { some } from 'fp-ts/Array'
 *
 * assert.equal(some((x: number) => x >= 0)([1, 2, 3]), true);
 * assert.equal(some((x: number) => x >= 10)([1, 2, 3]), false);
 *
 * @since 2.9.0
 */
var some = function (predicate) {
    return function (as) {
        return as.some(predicate);
    };
};
/**
 * Alias of [`some`](#some)
 *
 * @since 2.11.0
 */
var exists = some;
/**
 * Places an element in between members of an `Array`, then folds the results using the provided `Monoid`.
 *
 * @example
 * import * as S from 'fp-ts/string'
 * import { intercalate } from 'fp-ts/Array'
 *
 * assert.deepStrictEqual(intercalate(S.Monoid)('-')(['a', 'b', 'c']), 'a-b-c')
 *
 * @since 2.12.0
 */
var intercalate = _ReadonlyArray__WEBPACK_IMPORTED_MODULE_2__.intercalate;
// -------------------------------------------------------------------------------------
// do notation
// -------------------------------------------------------------------------------------
/**
 * @category do notation
 * @since 2.9.0
 */
var Do = /*#__PURE__*/ of(_internal__WEBPACK_IMPORTED_MODULE_1__.emptyRecord);
/**
 * @category do notation
 * @since 2.8.0
 */
var bindTo = /*#__PURE__*/ (0,_Functor__WEBPACK_IMPORTED_MODULE_5__.bindTo)(Functor);
var let_ = /*#__PURE__*/ (0,_Functor__WEBPACK_IMPORTED_MODULE_5__["let"])(Functor);

/**
 * @category do notation
 * @since 2.8.0
 */
var bind = /*#__PURE__*/ (0,_Chain__WEBPACK_IMPORTED_MODULE_7__.bind)(Chain);
/**
 * @category do notation
 * @since 2.8.0
 */
var apS = /*#__PURE__*/ (0,_Apply__WEBPACK_IMPORTED_MODULE_6__.apS)(Apply);
// -------------------------------------------------------------------------------------
// legacy
// -------------------------------------------------------------------------------------
/**
 * Alias of `flatMap`.
 *
 * @category legacy
 * @since 2.0.0
 */
var chain = flatMap;
// -------------------------------------------------------------------------------------
// deprecated
// -------------------------------------------------------------------------------------
/**
 * Use `NonEmptyArray` module instead.
 *
 * @category zone of death
 * @since 2.0.0
 * @deprecated
 */
var range = _NonEmptyArray__WEBPACK_IMPORTED_MODULE_0__.range;
/**
 * Use a new `[]` instead.
 *
 * @category zone of death
 * @since 2.0.0
 * @deprecated
 */
var empty = [];
/**
 * Use `prepend` instead.
 *
 * @category zone of death
 * @since 2.0.0
 * @deprecated
 */
var cons = _NonEmptyArray__WEBPACK_IMPORTED_MODULE_0__.cons;
/**
 * Use `append` instead.
 *
 * @category zone of death
 * @since 2.0.0
 * @deprecated
 */
var snoc = _NonEmptyArray__WEBPACK_IMPORTED_MODULE_0__.snoc;
/**
 * Use `prependAll` instead
 *
 * @category zone of death
 * @since 2.9.0
 * @deprecated
 */
var prependToAll = prependAll;
/**
 * This instance is deprecated, use small, specific instances instead.
 * For example if a function needs a `Functor` instance, pass `A.Functor` instead of `A.array`
 * (where `A` is from `import A from 'fp-ts/Array'`)
 *
 * @category zone of death
 * @since 2.0.0
 * @deprecated
 */
var array = {
    URI: URI,
    compact: compact,
    separate: separate,
    map: _map,
    ap: _ap,
    of: of,
    chain: flatMap,
    filter: _filter,
    filterMap: _filterMap,
    partition: _partition,
    partitionMap: _partitionMap,
    mapWithIndex: _mapWithIndex,
    partitionMapWithIndex: _partitionMapWithIndex,
    partitionWithIndex: _partitionWithIndex,
    filterMapWithIndex: _filterMapWithIndex,
    filterWithIndex: _filterWithIndex,
    alt: _alt,
    zero: zero,
    unfold: unfold,
    reduce: _reduce,
    foldMap: _foldMap,
    reduceRight: _reduceRight,
    traverse: _traverse,
    sequence: sequence,
    reduceWithIndex: _reduceWithIndex,
    foldMapWithIndex: _foldMapWithIndex,
    reduceRightWithIndex: _reduceRightWithIndex,
    traverseWithIndex: _traverseWithIndex,
    extend: _extend,
    wither: _wither,
    wilt: _wilt
};


/***/ }),

/***/ "./node_modules/fp-ts/es6/Chain.js":
/*!*****************************************!*\
  !*** ./node_modules/fp-ts/es6/Chain.js ***!
  \*****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   bind: () => (/* binding */ bind),
/* harmony export */   chainFirst: () => (/* binding */ chainFirst),
/* harmony export */   tap: () => (/* binding */ tap)
/* harmony export */ });
function chainFirst(M) {
    var tapM = tap(M);
    return function (f) { return function (first) { return tapM(first, f); }; };
}
/** @internal */
function tap(M) {
    return function (first, f) { return M.chain(first, function (a) { return M.map(f(a), function () { return a; }); }); };
}
function bind(M) {
    return function (name, f) { return function (ma) { return M.chain(ma, function (a) { return M.map(f(a), function (b) {
        var _a;
        return Object.assign({}, a, (_a = {}, _a[name] = b, _a));
    }); }); }; };
}


/***/ }),

/***/ "./node_modules/fp-ts/es6/ChainRec.js":
/*!********************************************!*\
  !*** ./node_modules/fp-ts/es6/ChainRec.js ***!
  \********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   tailRec: () => (/* binding */ tailRec)
/* harmony export */ });
/**
 * @since 2.0.0
 */
var tailRec = function (startWith, f) {
    var ab = f(startWith);
    while (ab._tag === 'Left') {
        ab = f(ab.left);
    }
    return ab.right;
};


/***/ }),

/***/ "./node_modules/fp-ts/es6/Either.js":
/*!******************************************!*\
  !*** ./node_modules/fp-ts/es6/Either.js ***!
  \******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Alt: () => (/* binding */ Alt),
/* harmony export */   ApT: () => (/* binding */ ApT),
/* harmony export */   Applicative: () => (/* binding */ Applicative),
/* harmony export */   Apply: () => (/* binding */ Apply),
/* harmony export */   Bifunctor: () => (/* binding */ Bifunctor),
/* harmony export */   Chain: () => (/* binding */ Chain),
/* harmony export */   ChainRec: () => (/* binding */ ChainRec),
/* harmony export */   Do: () => (/* binding */ Do),
/* harmony export */   Extend: () => (/* binding */ Extend),
/* harmony export */   Foldable: () => (/* binding */ Foldable),
/* harmony export */   FromEither: () => (/* binding */ FromEither),
/* harmony export */   Functor: () => (/* binding */ Functor),
/* harmony export */   Monad: () => (/* binding */ Monad),
/* harmony export */   MonadThrow: () => (/* binding */ MonadThrow),
/* harmony export */   Pointed: () => (/* binding */ Pointed),
/* harmony export */   Traversable: () => (/* binding */ Traversable),
/* harmony export */   URI: () => (/* binding */ URI),
/* harmony export */   alt: () => (/* binding */ alt),
/* harmony export */   altW: () => (/* binding */ altW),
/* harmony export */   ap: () => (/* binding */ ap),
/* harmony export */   apFirst: () => (/* binding */ apFirst),
/* harmony export */   apFirstW: () => (/* binding */ apFirstW),
/* harmony export */   apS: () => (/* binding */ apS),
/* harmony export */   apSW: () => (/* binding */ apSW),
/* harmony export */   apSecond: () => (/* binding */ apSecond),
/* harmony export */   apSecondW: () => (/* binding */ apSecondW),
/* harmony export */   apW: () => (/* binding */ apW),
/* harmony export */   as: () => (/* binding */ as),
/* harmony export */   asUnit: () => (/* binding */ asUnit),
/* harmony export */   bimap: () => (/* binding */ bimap),
/* harmony export */   bind: () => (/* binding */ bind),
/* harmony export */   bindTo: () => (/* binding */ bindTo),
/* harmony export */   bindW: () => (/* binding */ bindW),
/* harmony export */   chain: () => (/* binding */ chain),
/* harmony export */   chainFirst: () => (/* binding */ chainFirst),
/* harmony export */   chainFirstW: () => (/* binding */ chainFirstW),
/* harmony export */   chainNullableK: () => (/* binding */ chainNullableK),
/* harmony export */   chainOptionK: () => (/* binding */ chainOptionK),
/* harmony export */   chainOptionKW: () => (/* binding */ chainOptionKW),
/* harmony export */   chainW: () => (/* binding */ chainW),
/* harmony export */   duplicate: () => (/* binding */ duplicate),
/* harmony export */   either: () => (/* binding */ either),
/* harmony export */   elem: () => (/* binding */ elem),
/* harmony export */   exists: () => (/* binding */ exists),
/* harmony export */   extend: () => (/* binding */ extend),
/* harmony export */   filterOrElse: () => (/* binding */ filterOrElse),
/* harmony export */   filterOrElseW: () => (/* binding */ filterOrElseW),
/* harmony export */   flap: () => (/* binding */ flap),
/* harmony export */   flatMap: () => (/* binding */ flatMap),
/* harmony export */   flatMapNullable: () => (/* binding */ flatMapNullable),
/* harmony export */   flatMapOption: () => (/* binding */ flatMapOption),
/* harmony export */   flatten: () => (/* binding */ flatten),
/* harmony export */   flattenW: () => (/* binding */ flattenW),
/* harmony export */   fold: () => (/* binding */ fold),
/* harmony export */   foldMap: () => (/* binding */ foldMap),
/* harmony export */   foldW: () => (/* binding */ foldW),
/* harmony export */   fromNullable: () => (/* binding */ fromNullable),
/* harmony export */   fromNullableK: () => (/* binding */ fromNullableK),
/* harmony export */   fromOption: () => (/* binding */ fromOption),
/* harmony export */   fromOptionK: () => (/* binding */ fromOptionK),
/* harmony export */   fromPredicate: () => (/* binding */ fromPredicate),
/* harmony export */   getAltValidation: () => (/* binding */ getAltValidation),
/* harmony export */   getApplicativeValidation: () => (/* binding */ getApplicativeValidation),
/* harmony export */   getApplyMonoid: () => (/* binding */ getApplyMonoid),
/* harmony export */   getApplySemigroup: () => (/* binding */ getApplySemigroup),
/* harmony export */   getCompactable: () => (/* binding */ getCompactable),
/* harmony export */   getEq: () => (/* binding */ getEq),
/* harmony export */   getFilterable: () => (/* binding */ getFilterable),
/* harmony export */   getOrElse: () => (/* binding */ getOrElse),
/* harmony export */   getOrElseW: () => (/* binding */ getOrElseW),
/* harmony export */   getSemigroup: () => (/* binding */ getSemigroup),
/* harmony export */   getShow: () => (/* binding */ getShow),
/* harmony export */   getValidation: () => (/* binding */ getValidation),
/* harmony export */   getValidationMonoid: () => (/* binding */ getValidationMonoid),
/* harmony export */   getValidationSemigroup: () => (/* binding */ getValidationSemigroup),
/* harmony export */   getWitherable: () => (/* binding */ getWitherable),
/* harmony export */   isLeft: () => (/* binding */ isLeft),
/* harmony export */   isRight: () => (/* binding */ isRight),
/* harmony export */   left: () => (/* binding */ left),
/* harmony export */   "let": () => (/* binding */ let_),
/* harmony export */   liftNullable: () => (/* binding */ liftNullable),
/* harmony export */   liftOption: () => (/* binding */ liftOption),
/* harmony export */   map: () => (/* binding */ map),
/* harmony export */   mapLeft: () => (/* binding */ mapLeft),
/* harmony export */   match: () => (/* binding */ match),
/* harmony export */   matchW: () => (/* binding */ matchW),
/* harmony export */   of: () => (/* binding */ of),
/* harmony export */   orElse: () => (/* binding */ orElse),
/* harmony export */   orElseW: () => (/* binding */ orElseW),
/* harmony export */   parseJSON: () => (/* binding */ parseJSON),
/* harmony export */   reduce: () => (/* binding */ reduce),
/* harmony export */   reduceRight: () => (/* binding */ reduceRight),
/* harmony export */   right: () => (/* binding */ right),
/* harmony export */   sequence: () => (/* binding */ sequence),
/* harmony export */   sequenceArray: () => (/* binding */ sequenceArray),
/* harmony export */   stringifyJSON: () => (/* binding */ stringifyJSON),
/* harmony export */   swap: () => (/* binding */ swap),
/* harmony export */   tap: () => (/* binding */ tap),
/* harmony export */   throwError: () => (/* binding */ throwError),
/* harmony export */   toError: () => (/* binding */ toError),
/* harmony export */   toUnion: () => (/* binding */ toUnion),
/* harmony export */   traverse: () => (/* binding */ traverse),
/* harmony export */   traverseArray: () => (/* binding */ traverseArray),
/* harmony export */   traverseArrayWithIndex: () => (/* binding */ traverseArrayWithIndex),
/* harmony export */   traverseReadonlyArrayWithIndex: () => (/* binding */ traverseReadonlyArrayWithIndex),
/* harmony export */   traverseReadonlyNonEmptyArrayWithIndex: () => (/* binding */ traverseReadonlyNonEmptyArrayWithIndex),
/* harmony export */   tryCatch: () => (/* binding */ tryCatch),
/* harmony export */   tryCatchK: () => (/* binding */ tryCatchK)
/* harmony export */ });
/* harmony import */ var _Applicative__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./Applicative */ "./node_modules/fp-ts/es6/Applicative.js");
/* harmony import */ var _Apply__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./Apply */ "./node_modules/fp-ts/es6/Apply.js");
/* harmony import */ var _Chain__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./Chain */ "./node_modules/fp-ts/es6/Chain.js");
/* harmony import */ var _ChainRec__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./ChainRec */ "./node_modules/fp-ts/es6/ChainRec.js");
/* harmony import */ var _FromEither__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./FromEither */ "./node_modules/fp-ts/es6/FromEither.js");
/* harmony import */ var _function__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./function */ "./node_modules/fp-ts/es6/function.js");
/* harmony import */ var _Functor__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./Functor */ "./node_modules/fp-ts/es6/Functor.js");
/* harmony import */ var _internal__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./internal */ "./node_modules/fp-ts/es6/internal.js");
/* harmony import */ var _Separated__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Separated */ "./node_modules/fp-ts/es6/Separated.js");
/* harmony import */ var _Witherable__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./Witherable */ "./node_modules/fp-ts/es6/Witherable.js");










// -------------------------------------------------------------------------------------
// constructors
// -------------------------------------------------------------------------------------
/**
 * Constructs a new `Either` holding a `Left` value. This usually represents a failure, due to the right-bias of this
 * structure.
 *
 * @category constructors
 * @since 2.0.0
 */
var left = _internal__WEBPACK_IMPORTED_MODULE_0__.left;
/**
 * Constructs a new `Either` holding a `Right` value. This usually represents a successful value due to the right bias
 * of this structure.
 *
 * @category constructors
 * @since 2.0.0
 */
var right = _internal__WEBPACK_IMPORTED_MODULE_0__.right;
/**
 * @category sequencing
 * @since 2.14.0
 */
var flatMap = /*#__PURE__*/ (0,_function__WEBPACK_IMPORTED_MODULE_1__.dual)(2, function (ma, f) { return (isLeft(ma) ? ma : f(ma.right)); });
var _map = function (fa, f) { return (0,_function__WEBPACK_IMPORTED_MODULE_1__.pipe)(fa, map(f)); };
var _ap = function (fab, fa) { return (0,_function__WEBPACK_IMPORTED_MODULE_1__.pipe)(fab, ap(fa)); };
/* istanbul ignore next */
var _reduce = function (fa, b, f) { return (0,_function__WEBPACK_IMPORTED_MODULE_1__.pipe)(fa, reduce(b, f)); };
/* istanbul ignore next */
var _foldMap = function (M) { return function (fa, f) {
    var foldMapM = foldMap(M);
    return (0,_function__WEBPACK_IMPORTED_MODULE_1__.pipe)(fa, foldMapM(f));
}; };
/* istanbul ignore next */
var _reduceRight = function (fa, b, f) { return (0,_function__WEBPACK_IMPORTED_MODULE_1__.pipe)(fa, reduceRight(b, f)); };
var _traverse = function (F) {
    var traverseF = traverse(F);
    return function (ta, f) { return (0,_function__WEBPACK_IMPORTED_MODULE_1__.pipe)(ta, traverseF(f)); };
};
var _bimap = function (fa, f, g) { return (0,_function__WEBPACK_IMPORTED_MODULE_1__.pipe)(fa, bimap(f, g)); };
var _mapLeft = function (fa, f) { return (0,_function__WEBPACK_IMPORTED_MODULE_1__.pipe)(fa, mapLeft(f)); };
/* istanbul ignore next */
var _alt = function (fa, that) { return (0,_function__WEBPACK_IMPORTED_MODULE_1__.pipe)(fa, alt(that)); };
/* istanbul ignore next */
var _extend = function (wa, f) { return (0,_function__WEBPACK_IMPORTED_MODULE_1__.pipe)(wa, extend(f)); };
var _chainRec = function (a, f) {
    return (0,_ChainRec__WEBPACK_IMPORTED_MODULE_2__.tailRec)(f(a), function (e) {
        return isLeft(e) ? right(left(e.left)) : isLeft(e.right) ? left(f(e.right.left)) : right(right(e.right.right));
    });
};
/**
 * @category type lambdas
 * @since 2.0.0
 */
var URI = 'Either';
/**
 * @category instances
 * @since 2.0.0
 */
var getShow = function (SE, SA) { return ({
    show: function (ma) { return (isLeft(ma) ? "left(".concat(SE.show(ma.left), ")") : "right(".concat(SA.show(ma.right), ")")); }
}); };
/**
 * @category instances
 * @since 2.0.0
 */
var getEq = function (EL, EA) { return ({
    equals: function (x, y) {
        return x === y || (isLeft(x) ? isLeft(y) && EL.equals(x.left, y.left) : isRight(y) && EA.equals(x.right, y.right));
    }
}); };
/**
 * Semigroup returning the left-most non-`Left` value. If both operands are `Right`s then the inner values are
 * concatenated using the provided `Semigroup`
 *
 * @example
 * import { getSemigroup, left, right } from 'fp-ts/Either'
 * import { SemigroupSum } from 'fp-ts/number'
 *
 * const S = getSemigroup<string, number>(SemigroupSum)
 * assert.deepStrictEqual(S.concat(left('a'), left('b')), left('a'))
 * assert.deepStrictEqual(S.concat(left('a'), right(2)), right(2))
 * assert.deepStrictEqual(S.concat(right(1), left('b')), right(1))
 * assert.deepStrictEqual(S.concat(right(1), right(2)), right(3))
 *
 * @category instances
 * @since 2.0.0
 */
var getSemigroup = function (S) { return ({
    concat: function (x, y) { return (isLeft(y) ? x : isLeft(x) ? y : right(S.concat(x.right, y.right))); }
}); };
/**
 * Builds a `Compactable` instance for `Either` given `Monoid` for the left side.
 *
 * @category filtering
 * @since 2.10.0
 */
var getCompactable = function (M) {
    var empty = left(M.empty);
    return {
        URI: URI,
        _E: undefined,
        compact: function (ma) { return (isLeft(ma) ? ma : ma.right._tag === 'None' ? empty : right(ma.right.value)); },
        separate: function (ma) {
            return isLeft(ma)
                ? (0,_Separated__WEBPACK_IMPORTED_MODULE_3__.separated)(ma, ma)
                : isLeft(ma.right)
                    ? (0,_Separated__WEBPACK_IMPORTED_MODULE_3__.separated)(right(ma.right.left), empty)
                    : (0,_Separated__WEBPACK_IMPORTED_MODULE_3__.separated)(empty, right(ma.right.right));
        }
    };
};
/**
 * Builds a `Filterable` instance for `Either` given `Monoid` for the left side
 *
 * @category filtering
 * @since 2.10.0
 */
var getFilterable = function (M) {
    var empty = left(M.empty);
    var _a = getCompactable(M), compact = _a.compact, separate = _a.separate;
    var filter = function (ma, predicate) {
        return isLeft(ma) ? ma : predicate(ma.right) ? ma : empty;
    };
    var partition = function (ma, p) {
        return isLeft(ma)
            ? (0,_Separated__WEBPACK_IMPORTED_MODULE_3__.separated)(ma, ma)
            : p(ma.right)
                ? (0,_Separated__WEBPACK_IMPORTED_MODULE_3__.separated)(empty, right(ma.right))
                : (0,_Separated__WEBPACK_IMPORTED_MODULE_3__.separated)(right(ma.right), empty);
    };
    return {
        URI: URI,
        _E: undefined,
        map: _map,
        compact: compact,
        separate: separate,
        filter: filter,
        filterMap: function (ma, f) {
            if (isLeft(ma)) {
                return ma;
            }
            var ob = f(ma.right);
            return ob._tag === 'None' ? empty : right(ob.value);
        },
        partition: partition,
        partitionMap: function (ma, f) {
            if (isLeft(ma)) {
                return (0,_Separated__WEBPACK_IMPORTED_MODULE_3__.separated)(ma, ma);
            }
            var e = f(ma.right);
            return isLeft(e) ? (0,_Separated__WEBPACK_IMPORTED_MODULE_3__.separated)(right(e.left), empty) : (0,_Separated__WEBPACK_IMPORTED_MODULE_3__.separated)(empty, right(e.right));
        }
    };
};
/**
 * Builds `Witherable` instance for `Either` given `Monoid` for the left side
 *
 * @category filtering
 * @since 2.0.0
 */
var getWitherable = function (M) {
    var F_ = getFilterable(M);
    var C = getCompactable(M);
    return {
        URI: URI,
        _E: undefined,
        map: _map,
        compact: F_.compact,
        separate: F_.separate,
        filter: F_.filter,
        filterMap: F_.filterMap,
        partition: F_.partition,
        partitionMap: F_.partitionMap,
        traverse: _traverse,
        sequence: sequence,
        reduce: _reduce,
        foldMap: _foldMap,
        reduceRight: _reduceRight,
        wither: (0,_Witherable__WEBPACK_IMPORTED_MODULE_4__.witherDefault)(Traversable, C),
        wilt: (0,_Witherable__WEBPACK_IMPORTED_MODULE_4__.wiltDefault)(Traversable, C)
    };
};
/**
 * The default [`Applicative`](#applicative) instance returns the first error, if you want to
 * get all errors you need to provide a way to concatenate them via a `Semigroup`.
 *
 * @example
 * import * as A from 'fp-ts/Apply'
 * import * as E from 'fp-ts/Either'
 * import { pipe } from 'fp-ts/function'
 * import * as S from 'fp-ts/Semigroup'
 * import * as string from 'fp-ts/string'
 *
 * const parseString = (u: unknown): E.Either<string, string> =>
 *   typeof u === 'string' ? E.right(u) : E.left('not a string')
 *
 * const parseNumber = (u: unknown): E.Either<string, number> =>
 *   typeof u === 'number' ? E.right(u) : E.left('not a number')
 *
 * interface Person {
 *   readonly name: string
 *   readonly age: number
 * }
 *
 * const parsePerson = (
 *   input: Record<string, unknown>
 * ): E.Either<string, Person> =>
 *   pipe(
 *     E.Do,
 *     E.apS('name', parseString(input.name)),
 *     E.apS('age', parseNumber(input.age))
 *   )
 *
 * assert.deepStrictEqual(parsePerson({}), E.left('not a string')) // <= first error
 *
 * const Applicative = E.getApplicativeValidation(
 *   pipe(string.Semigroup, S.intercalate(', '))
 * )
 *
 * const apS = A.apS(Applicative)
 *
 * const parsePersonAll = (
 *   input: Record<string, unknown>
 * ): E.Either<string, Person> =>
 *   pipe(
 *     E.Do,
 *     apS('name', parseString(input.name)),
 *     apS('age', parseNumber(input.age))
 *   )
 *
 * assert.deepStrictEqual(parsePersonAll({}), E.left('not a string, not a number')) // <= all errors
 *
 * @category error handling
 * @since 2.7.0
 */
var getApplicativeValidation = function (SE) { return ({
    URI: URI,
    _E: undefined,
    map: _map,
    ap: function (fab, fa) {
        return isLeft(fab)
            ? isLeft(fa)
                ? left(SE.concat(fab.left, fa.left))
                : fab
            : isLeft(fa)
                ? fa
                : right(fab.right(fa.right));
    },
    of: of
}); };
/**
 * The default [`Alt`](#alt) instance returns the last error, if you want to
 * get all errors you need to provide a way to concatenate them via a `Semigroup`.
 *
 * @example
 * import * as E from 'fp-ts/Either'
 * import { pipe } from 'fp-ts/function'
 * import * as S from 'fp-ts/Semigroup'
 * import * as string from 'fp-ts/string'
 *
 * const parseString = (u: unknown): E.Either<string, string> =>
 *   typeof u === 'string' ? E.right(u) : E.left('not a string')
 *
 * const parseNumber = (u: unknown): E.Either<string, number> =>
 *   typeof u === 'number' ? E.right(u) : E.left('not a number')
 *
 * const parse = (u: unknown): E.Either<string, string | number> =>
 *   pipe(
 *     parseString(u),
 *     E.alt<string, string | number>(() => parseNumber(u))
 *   )
 *
 * assert.deepStrictEqual(parse(true), E.left('not a number')) // <= last error
 *
 * const Alt = E.getAltValidation(pipe(string.Semigroup, S.intercalate(', ')))
 *
 * const parseAll = (u: unknown): E.Either<string, string | number> =>
 *   Alt.alt<string | number>(parseString(u), () => parseNumber(u))
 *
 * assert.deepStrictEqual(parseAll(true), E.left('not a string, not a number')) // <= all errors
 *
 * @category error handling
 * @since 2.7.0
 */
var getAltValidation = function (SE) { return ({
    URI: URI,
    _E: undefined,
    map: _map,
    alt: function (me, that) {
        if (isRight(me)) {
            return me;
        }
        var ea = that();
        return isLeft(ea) ? left(SE.concat(me.left, ea.left)) : ea;
    }
}); };
/**
 * @category mapping
 * @since 2.0.0
 */
var map = function (f) { return function (fa) {
    return isLeft(fa) ? fa : right(f(fa.right));
}; };
/**
 * @category instances
 * @since 2.7.0
 */
var Functor = {
    URI: URI,
    map: _map
};
/**
 * Maps the `Right` value of this `Either` to the specified constant value.
 *
 * @category mapping
 * @since 2.16.0
 */
var as = (0,_function__WEBPACK_IMPORTED_MODULE_1__.dual)(2, (0,_Functor__WEBPACK_IMPORTED_MODULE_5__.as)(Functor));
/**
 * Maps the `Right` value of this `Either` to the void constant value.
 *
 * @category mapping
 * @since 2.16.0
 */
var asUnit = (0,_Functor__WEBPACK_IMPORTED_MODULE_5__.asUnit)(Functor);
/**
 * @category constructors
 * @since 2.7.0
 */
var of = right;
/**
 * @category instances
 * @since 2.10.0
 */
var Pointed = {
    URI: URI,
    of: of
};
/**
 * Less strict version of [`ap`](#ap).
 *
 * The `W` suffix (short for **W**idening) means that the error types will be merged.
 *
 * @since 2.8.0
 */
var apW = function (fa) { return function (fab) {
    return isLeft(fab) ? fab : isLeft(fa) ? fa : right(fab.right(fa.right));
}; };
/**
 * @since 2.0.0
 */
var ap = apW;
/**
 * @category instances
 * @since 2.10.0
 */
var Apply = {
    URI: URI,
    map: _map,
    ap: _ap
};
/**
 * @category instances
 * @since 2.7.0
 */
var Applicative = {
    URI: URI,
    map: _map,
    ap: _ap,
    of: of
};
/**
 * @category instances
 * @since 2.10.0
 */
var Chain = {
    URI: URI,
    map: _map,
    ap: _ap,
    chain: flatMap
};
/**
 * @category instances
 * @since 2.7.0
 */
var Monad = {
    URI: URI,
    map: _map,
    ap: _ap,
    of: of,
    chain: flatMap
};
/**
 * Left-associative fold of a structure.
 *
 * @example
 * import { pipe } from 'fp-ts/function'
 * import * as E from 'fp-ts/Either'
 *
 * const startWith = 'prefix'
 * const concat = (a: string, b: string) => `${a}:${b}`
 *
 * assert.deepStrictEqual(
 *   pipe(E.right('a'), E.reduce(startWith, concat)),
 *   'prefix:a'
 * )
 *
 * assert.deepStrictEqual(
 *   pipe(E.left('e'), E.reduce(startWith, concat)),
 *   'prefix'
 * )
 *
 * @category folding
 * @since 2.0.0
 */
var reduce = function (b, f) { return function (fa) {
    return isLeft(fa) ? b : f(b, fa.right);
}; };
/**
 * Map each element of the structure to a monoid, and combine the results.
 *
 * @example
 * import { pipe } from 'fp-ts/function'
 * import * as E from 'fp-ts/Either'
 * import * as S from 'fp-ts/string'
 *
 * const yell = (a: string) => `${a}!`
 *
 * assert.deepStrictEqual(
 *   pipe(E.right('a'), E.foldMap(S.Monoid)(yell)),
 *   'a!'
 * )
 *
 * assert.deepStrictEqual(
 *   pipe(E.left('e'), E.foldMap(S.Monoid)(yell)),
 *   S.Monoid.empty
 * )
 *
 * @category folding
 * @since 2.0.0
 */
var foldMap = function (M) { return function (f) { return function (fa) {
    return isLeft(fa) ? M.empty : f(fa.right);
}; }; };
/**
 * Right-associative fold of a structure.
 *
 * @example
 * import { pipe } from 'fp-ts/function'
 * import * as E from 'fp-ts/Either'
 *
 * const startWith = 'postfix'
 * const concat = (a: string, b: string) => `${a}:${b}`
 *
 * assert.deepStrictEqual(
 *   pipe(E.right('a'), E.reduceRight(startWith, concat)),
 *   'a:postfix'
 * )
 *
 * assert.deepStrictEqual(
 *   pipe(E.left('e'), E.reduceRight(startWith, concat)),
 *   'postfix'
 * )
 *
 * @category folding
 * @since 2.0.0
 */
var reduceRight = function (b, f) { return function (fa) {
    return isLeft(fa) ? b : f(fa.right, b);
}; };
/**
 * @category instances
 * @since 2.7.0
 */
var Foldable = {
    URI: URI,
    reduce: _reduce,
    foldMap: _foldMap,
    reduceRight: _reduceRight
};
/**
 * Map each element of a structure to an action, evaluate these actions from left to right, and collect the results.
 *
 * @example
 * import { pipe } from 'fp-ts/function'
 * import * as RA from 'fp-ts/ReadonlyArray'
 * import * as E from 'fp-ts/Either'
 * import * as O from 'fp-ts/Option'
 *
 * assert.deepStrictEqual(
 *   pipe(E.right(['a']), E.traverse(O.Applicative)(RA.head)),
 *   O.some(E.right('a'))
 *  )
 *
 * assert.deepStrictEqual(
 *   pipe(E.right([]), E.traverse(O.Applicative)(RA.head)),
 *   O.none
 * )
 *
 * @category traversing
 * @since 2.6.3
 */
var traverse = function (F) {
    return function (f) {
        return function (ta) {
            return isLeft(ta) ? F.of(left(ta.left)) : F.map(f(ta.right), right);
        };
    };
};
/**
 * Evaluate each monadic action in the structure from left to right, and collect the results.
 *
 * @example
 * import { pipe } from 'fp-ts/function'
 * import * as E from 'fp-ts/Either'
 * import * as O from 'fp-ts/Option'
 *
 * assert.deepStrictEqual(
 *   pipe(E.right(O.some('a')), E.sequence(O.Applicative)),
 *   O.some(E.right('a'))
 *  )
 *
 * assert.deepStrictEqual(
 *   pipe(E.right(O.none), E.sequence(O.Applicative)),
 *   O.none
 * )
 *
 * @category traversing
 * @since 2.6.3
 */
var sequence = function (F) {
    return function (ma) {
        return isLeft(ma) ? F.of(left(ma.left)) : F.map(ma.right, right);
    };
};
/**
 * @category instances
 * @since 2.7.0
 */
var Traversable = {
    URI: URI,
    map: _map,
    reduce: _reduce,
    foldMap: _foldMap,
    reduceRight: _reduceRight,
    traverse: _traverse,
    sequence: sequence
};
/**
 * Map a pair of functions over the two type arguments of the bifunctor.
 *
 * @category mapping
 * @since 2.0.0
 */
var bimap = function (f, g) { return function (fa) {
    return isLeft(fa) ? left(f(fa.left)) : right(g(fa.right));
}; };
/**
 * Map a function over the first type argument of a bifunctor.
 *
 * @category error handling
 * @since 2.0.0
 */
var mapLeft = function (f) { return function (fa) {
    return isLeft(fa) ? left(f(fa.left)) : fa;
}; };
/**
 * @category instances
 * @since 2.7.0
 */
var Bifunctor = {
    URI: URI,
    bimap: _bimap,
    mapLeft: _mapLeft
};
/**
 * Less strict version of [`alt`](#alt).
 *
 * The `W` suffix (short for **W**idening) means that the error and the return types will be merged.
 *
 * @category error handling
 * @since 2.9.0
 */
var altW = function (that) { return function (fa) {
    return isLeft(fa) ? that() : fa;
}; };
/**
 * Identifies an associative operation on a type constructor. It is similar to `Semigroup`, except that it applies to
 * types of kind `* -> *`.
 *
 * In case of `Either` returns the left-most non-`Left` value (or the right-most `Left` value if both values are `Left`).
 *
 * | x        | y        | pipe(x, alt(() => y) |
 * | -------- | -------- | -------------------- |
 * | left(a)  | left(b)  | left(b)              |
 * | left(a)  | right(2) | right(2)             |
 * | right(1) | left(b)  | right(1)             |
 * | right(1) | right(2) | right(1)             |
 *
 * @example
 * import * as E from 'fp-ts/Either'
 * import { pipe } from 'fp-ts/function'
 *
 * assert.deepStrictEqual(
 *   pipe(
 *     E.left('a'),
 *     E.alt(() => E.left('b'))
 *   ),
 *   E.left('b')
 * )
 * assert.deepStrictEqual(
 *   pipe(
 *     E.left('a'),
 *     E.alt(() => E.right(2))
 *   ),
 *   E.right(2)
 * )
 * assert.deepStrictEqual(
 *   pipe(
 *     E.right(1),
 *     E.alt(() => E.left('b'))
 *   ),
 *   E.right(1)
 * )
 * assert.deepStrictEqual(
 *   pipe(
 *     E.right(1),
 *     E.alt(() => E.right(2))
 *   ),
 *   E.right(1)
 * )
 *
 * @category error handling
 * @since 2.0.0
 */
var alt = altW;
/**
 * @category instances
 * @since 2.7.0
 */
var Alt = {
    URI: URI,
    map: _map,
    alt: _alt
};
/**
 * @since 2.0.0
 */
var extend = function (f) { return function (wa) {
    return isLeft(wa) ? wa : right(f(wa));
}; };
/**
 * @category instances
 * @since 2.7.0
 */
var Extend = {
    URI: URI,
    map: _map,
    extend: _extend
};
/**
 * @category instances
 * @since 2.7.0
 */
var ChainRec = {
    URI: URI,
    map: _map,
    ap: _ap,
    chain: flatMap,
    chainRec: _chainRec
};
/**
 * @since 2.6.3
 */
var throwError = left;
/**
 * @category instances
 * @since 2.7.0
 */
var MonadThrow = {
    URI: URI,
    map: _map,
    ap: _ap,
    of: of,
    chain: flatMap,
    throwError: throwError
};
/**
 * @category instances
 * @since 2.10.0
 */
var FromEither = {
    URI: URI,
    fromEither: _function__WEBPACK_IMPORTED_MODULE_1__.identity
};
/**
 * @example
 * import { fromPredicate, left, right } from 'fp-ts/Either'
 * import { pipe } from 'fp-ts/function'
 *
 * assert.deepStrictEqual(
 *   pipe(
 *     1,
 *     fromPredicate(
 *       (n) => n > 0,
 *       () => 'error'
 *     )
 *   ),
 *   right(1)
 * )
 * assert.deepStrictEqual(
 *   pipe(
 *     -1,
 *     fromPredicate(
 *       (n) => n > 0,
 *       () => 'error'
 *     )
 *   ),
 *   left('error')
 * )
 *
 * @category lifting
 * @since 2.0.0
 */
var fromPredicate = /*#__PURE__*/ (0,_FromEither__WEBPACK_IMPORTED_MODULE_6__.fromPredicate)(FromEither);
// -------------------------------------------------------------------------------------
// conversions
// -------------------------------------------------------------------------------------
/**
 * @example
 * import * as E from 'fp-ts/Either'
 * import { pipe } from 'fp-ts/function'
 * import * as O from 'fp-ts/Option'
 *
 * assert.deepStrictEqual(
 *   pipe(
 *     O.some(1),
 *     E.fromOption(() => 'error')
 *   ),
 *   E.right(1)
 * )
 * assert.deepStrictEqual(
 *   pipe(
 *     O.none,
 *     E.fromOption(() => 'error')
 *   ),
 *   E.left('error')
 * )
 *
 * @category conversions
 * @since 2.0.0
 */
var fromOption = 
/*#__PURE__*/ (0,_FromEither__WEBPACK_IMPORTED_MODULE_6__.fromOption)(FromEither);
// -------------------------------------------------------------------------------------
// refinements
// -------------------------------------------------------------------------------------
/**
 * Returns `true` if the either is an instance of `Left`, `false` otherwise.
 *
 * @category refinements
 * @since 2.0.0
 */
var isLeft = _internal__WEBPACK_IMPORTED_MODULE_0__.isLeft;
/**
 * Returns `true` if the either is an instance of `Right`, `false` otherwise.
 *
 * @category refinements
 * @since 2.0.0
 */
var isRight = _internal__WEBPACK_IMPORTED_MODULE_0__.isRight;
/**
 * Less strict version of [`match`](#match).
 *
 * The `W` suffix (short for **W**idening) means that the handler return types will be merged.
 *
 * @category pattern matching
 * @since 2.10.0
 */
var matchW = function (onLeft, onRight) {
    return function (ma) {
        return isLeft(ma) ? onLeft(ma.left) : onRight(ma.right);
    };
};
/**
 * Alias of [`matchW`](#matchw).
 *
 * @category pattern matching
 * @since 2.10.0
 */
var foldW = matchW;
/**
 * Takes two functions and an `Either` value, if the value is a `Left` the inner value is applied to the first function,
 * if the value is a `Right` the inner value is applied to the second function.
 *
 * @example
 * import { match, left, right } from 'fp-ts/Either'
 * import { pipe } from 'fp-ts/function'
 *
 * function onLeft(errors: Array<string>): string {
 *   return `Errors: ${errors.join(', ')}`
 * }
 *
 * function onRight(value: number): string {
 *   return `Ok: ${value}`
 * }
 *
 * assert.strictEqual(
 *   pipe(
 *     right(1),
 *     match(onLeft, onRight)
 *   ),
 *   'Ok: 1'
 * )
 * assert.strictEqual(
 *   pipe(
 *     left(['error 1', 'error 2']),
 *     match(onLeft, onRight)
 *   ),
 *   'Errors: error 1, error 2'
 * )
 *
 * @category pattern matching
 * @since 2.10.0
 */
var match = matchW;
/**
 * Alias of [`match`](#match).
 *
 * @category pattern matching
 * @since 2.0.0
 */
var fold = match;
/**
 * Less strict version of [`getOrElse`](#getorelse).
 *
 * The `W` suffix (short for **W**idening) means that the handler return type will be merged.
 *
 * @category error handling
 * @since 2.6.0
 */
var getOrElseW = function (onLeft) {
    return function (ma) {
        return isLeft(ma) ? onLeft(ma.left) : ma.right;
    };
};
/**
 * Returns the wrapped value if it's a `Right` or a default value if is a `Left`.
 *
 * @example
 * import { getOrElse, left, right } from 'fp-ts/Either'
 * import { pipe } from 'fp-ts/function'
 *
 * assert.deepStrictEqual(
 *   pipe(
 *     right(1),
 *     getOrElse(() => 0)
 *   ),
 *   1
 * )
 * assert.deepStrictEqual(
 *   pipe(
 *     left('error'),
 *     getOrElse(() => 0)
 *   ),
 *   0
 * )
 *
 * @category error handling
 * @since 2.0.0
 */
var getOrElse = getOrElseW;
// -------------------------------------------------------------------------------------
// combinators
// -------------------------------------------------------------------------------------
/**
 * @category mapping
 * @since 2.10.0
 */
var flap = /*#__PURE__*/ (0,_Functor__WEBPACK_IMPORTED_MODULE_5__.flap)(Functor);
/**
 * Combine two effectful actions, keeping only the result of the first.
 *
 * @since 2.0.0
 */
var apFirst = /*#__PURE__*/ (0,_Apply__WEBPACK_IMPORTED_MODULE_7__.apFirst)(Apply);
/**
 * Less strict version of [`apFirst`](#apfirst)
 *
 * The `W` suffix (short for **W**idening) means that the error types will be merged.
 *
 * @since 2.12.0
 */
var apFirstW = apFirst;
/**
 * Combine two effectful actions, keeping only the result of the second.
 *
 * @since 2.0.0
 */
var apSecond = /*#__PURE__*/ (0,_Apply__WEBPACK_IMPORTED_MODULE_7__.apSecond)(Apply);
/**
 * Less strict version of [`apSecond`](#apsecond)
 *
 * The `W` suffix (short for **W**idening) means that the error types will be merged.
 *
 * @since 2.12.0
 */
var apSecondW = apSecond;
/**
 * Composes computations in sequence, using the return value of one computation to determine the next computation and
 * keeping only the result of the first.
 *
 * @category combinators
 * @since 2.15.0
 */
var tap = /*#__PURE__*/ (0,_function__WEBPACK_IMPORTED_MODULE_1__.dual)(2, _Chain__WEBPACK_IMPORTED_MODULE_8__.tap(Chain));
/**
 * Less strict version of [`flatten`](#flatten).
 *
 * The `W` suffix (short for **W**idening) means that the error types will be merged.
 *
 * @category sequencing
 * @since 2.11.0
 */
var flattenW = 
/*#__PURE__*/ flatMap(_function__WEBPACK_IMPORTED_MODULE_1__.identity);
/**
 * The `flatten` function is the conventional monad join operator. It is used to remove one level of monadic structure, projecting its bound argument into the outer level.
 *
 * @example
 * import * as E from 'fp-ts/Either'
 *
 * assert.deepStrictEqual(E.flatten(E.right(E.right('a'))), E.right('a'))
 * assert.deepStrictEqual(E.flatten(E.right(E.left('e'))), E.left('e'))
 * assert.deepStrictEqual(E.flatten(E.left('e')), E.left('e'))
 *
 * @category sequencing
 * @since 2.0.0
 */
var flatten = flattenW;
/**
 * @since 2.0.0
 */
var duplicate = /*#__PURE__*/ extend(_function__WEBPACK_IMPORTED_MODULE_1__.identity);
/**
 * Use `liftOption`.
 *
 * @category legacy
 * @since 2.10.0
 */
var fromOptionK = 
/*#__PURE__*/ (0,_FromEither__WEBPACK_IMPORTED_MODULE_6__.fromOptionK)(FromEither);
/**
 * Use `flatMapOption`.
 *
 * @category legacy
 * @since 2.11.0
 */
var chainOptionK = /*#__PURE__*/ (0,_FromEither__WEBPACK_IMPORTED_MODULE_6__.chainOptionK)(FromEither, Chain);
/**
 * Use `flatMapOption`.
 *
 * @category legacy
 * @since 2.13.2
 */
var chainOptionKW = chainOptionK;
/** @internal */
var _FromEither = {
    fromEither: FromEither.fromEither
};
/**
 * @category lifting
 * @since 2.15.0
 */
var liftNullable = /*#__PURE__*/ _internal__WEBPACK_IMPORTED_MODULE_0__.liftNullable(_FromEither);
/**
 * @category lifting
 * @since 2.15.0
 */
var liftOption = /*#__PURE__*/ _internal__WEBPACK_IMPORTED_MODULE_0__.liftOption(_FromEither);
/** @internal */
var _FlatMap = {
    flatMap: flatMap
};
/**
 * @category sequencing
 * @since 2.15.0
 */
var flatMapNullable = /*#__PURE__*/ _internal__WEBPACK_IMPORTED_MODULE_0__.flatMapNullable(_FromEither, _FlatMap);
/**
 * @category sequencing
 * @since 2.15.0
 */
var flatMapOption = /*#__PURE__*/ _internal__WEBPACK_IMPORTED_MODULE_0__.flatMapOption(_FromEither, _FlatMap);
/**
 * @example
 * import * as E from 'fp-ts/Either'
 * import { pipe } from 'fp-ts/function'
 *
 * assert.deepStrictEqual(
 *   pipe(
 *     E.right(1),
 *     E.filterOrElse(
 *       (n) => n > 0,
 *       () => 'error'
 *     )
 *   ),
 *   E.right(1)
 * )
 * assert.deepStrictEqual(
 *   pipe(
 *     E.right(-1),
 *     E.filterOrElse(
 *       (n) => n > 0,
 *       () => 'error'
 *     )
 *   ),
 *   E.left('error')
 * )
 * assert.deepStrictEqual(
 *   pipe(
 *     E.left('a'),
 *     E.filterOrElse(
 *       (n) => n > 0,
 *       () => 'error'
 *     )
 *   ),
 *   E.left('a')
 * )
 *
 * @category filtering
 * @since 2.0.0
 */
var filterOrElse = /*#__PURE__*/ (0,_FromEither__WEBPACK_IMPORTED_MODULE_6__.filterOrElse)(FromEither, Chain);
/**
 * Less strict version of [`filterOrElse`](#filterorelse).
 *
 * The `W` suffix (short for **W**idening) means that the error types will be merged.
 *
 * @category filtering
 * @since 2.9.0
 */
var filterOrElseW = filterOrElse;
/**
 * Returns a `Right` if is a `Left` (and vice versa).
 *
 * @since 2.0.0
 */
var swap = function (ma) { return (isLeft(ma) ? right(ma.left) : left(ma.right)); };
/**
 * Less strict version of [`orElse`](#orelse).
 *
 * The `W` suffix (short for **W**idening) means that the return types will be merged.
 *
 * @category error handling
 * @since 2.10.0
 */
var orElseW = function (onLeft) {
    return function (ma) {
        return isLeft(ma) ? onLeft(ma.left) : ma;
    };
};
/**
 * Useful for recovering from errors.
 *
 * @category error handling
 * @since 2.0.0
 */
var orElse = orElseW;
/**
 * Takes a default and a nullable value, if the value is not nully, turn it into a `Right`, if the value is nully use
 * the provided default as a `Left`.
 *
 * @example
 * import { fromNullable, left, right } from 'fp-ts/Either'
 *
 * const parse = fromNullable('nully')
 *
 * assert.deepStrictEqual(parse(1), right(1))
 * assert.deepStrictEqual(parse(null), left('nully'))
 *
 * @category conversions
 * @since 2.0.0
 */
var fromNullable = function (e) {
    return function (a) {
        return a == null ? left(e) : right(a);
    };
};
/**
 * Constructs a new `Either` from a function that might throw.
 *
 * See also [`tryCatchK`](#trycatchk).
 *
 * @example
 * import * as E from 'fp-ts/Either'
 *
 * const unsafeHead = <A>(as: ReadonlyArray<A>): A => {
 *   if (as.length > 0) {
 *     return as[0]
 *   } else {
 *     throw new Error('empty array')
 *   }
 * }
 *
 * const head = <A>(as: ReadonlyArray<A>): E.Either<Error, A> =>
 *   E.tryCatch(() => unsafeHead(as), e => (e instanceof Error ? e : new Error('unknown error')))
 *
 * assert.deepStrictEqual(head([]), E.left(new Error('empty array')))
 * assert.deepStrictEqual(head([1, 2, 3]), E.right(1))
 *
 * @category interop
 * @since 2.0.0
 */
var tryCatch = function (f, onThrow) {
    try {
        return right(f());
    }
    catch (e) {
        return left(onThrow(e));
    }
};
/**
 * Converts a function that may throw to one returning a `Either`.
 *
 * @category interop
 * @since 2.10.0
 */
var tryCatchK = function (f, onThrow) {
    return function () {
        var a = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            a[_i] = arguments[_i];
        }
        return tryCatch(function () { return f.apply(void 0, a); }, onThrow);
    };
};
/**
 * Use `liftNullable`.
 *
 * @category legacy
 * @since 2.9.0
 */
var fromNullableK = function (e) {
    var from = fromNullable(e);
    return function (f) { return (0,_function__WEBPACK_IMPORTED_MODULE_1__.flow)(f, from); };
};
/**
 * Use `flatMapNullable`.
 *
 * @category legacy
 * @since 2.9.0
 */
var chainNullableK = function (e) {
    var from = fromNullableK(e);
    return function (f) { return flatMap(from(f)); };
};
/**
 * @category conversions
 * @since 2.10.0
 */
var toUnion = /*#__PURE__*/ foldW(_function__WEBPACK_IMPORTED_MODULE_1__.identity, _function__WEBPACK_IMPORTED_MODULE_1__.identity);
// -------------------------------------------------------------------------------------
// utils
// -------------------------------------------------------------------------------------
/**
 * Default value for the `onError` argument of `tryCatch`
 *
 * @since 2.0.0
 */
function toError(e) {
    try {
        return e instanceof Error ? e : new Error(String(e));
    }
    catch (error) {
        return new Error();
    }
}
function elem(E) {
    return function (a, ma) {
        if (ma === undefined) {
            var elemE_1 = elem(E);
            return function (ma) { return elemE_1(a, ma); };
        }
        return isLeft(ma) ? false : E.equals(a, ma.right);
    };
}
/**
 * Returns `false` if `Left` or returns the result of the application of the given predicate to the `Right` value.
 *
 * @example
 * import { exists, left, right } from 'fp-ts/Either'
 *
 * const gt2 = exists((n: number) => n > 2)
 *
 * assert.strictEqual(gt2(left('a')), false)
 * assert.strictEqual(gt2(right(1)), false)
 * assert.strictEqual(gt2(right(3)), true)
 *
 * @since 2.0.0
 */
var exists = function (predicate) {
    return function (ma) {
        return isLeft(ma) ? false : predicate(ma.right);
    };
};
// -------------------------------------------------------------------------------------
// do notation
// -------------------------------------------------------------------------------------
/**
 * @category do notation
 * @since 2.9.0
 */
var Do = /*#__PURE__*/ of(_internal__WEBPACK_IMPORTED_MODULE_0__.emptyRecord);
/**
 * @category do notation
 * @since 2.8.0
 */
var bindTo = /*#__PURE__*/ (0,_Functor__WEBPACK_IMPORTED_MODULE_5__.bindTo)(Functor);
var let_ = /*#__PURE__*/ (0,_Functor__WEBPACK_IMPORTED_MODULE_5__["let"])(Functor);

/**
 * @category do notation
 * @since 2.8.0
 */
var bind = /*#__PURE__*/ _Chain__WEBPACK_IMPORTED_MODULE_8__.bind(Chain);
/**
 * The `W` suffix (short for **W**idening) means that the error types will be merged.
 *
 * @category do notation
 * @since 2.8.0
 */
var bindW = bind;
/**
 * @category do notation
 * @since 2.8.0
 */
var apS = /*#__PURE__*/ (0,_Apply__WEBPACK_IMPORTED_MODULE_7__.apS)(Apply);
/**
 * Less strict version of [`apS`](#aps).
 *
 * The `W` suffix (short for **W**idening) means that the error types will be merged.
 *
 * @category do notation
 * @since 2.8.0
 */
var apSW = apS;
/**
 * @since 2.11.0
 */
var ApT = /*#__PURE__*/ of(_internal__WEBPACK_IMPORTED_MODULE_0__.emptyReadonlyArray);
// -------------------------------------------------------------------------------------
// array utils
// -------------------------------------------------------------------------------------
/**
 * Equivalent to `ReadonlyNonEmptyArray#traverseWithIndex(Applicative)`.
 *
 * @category traversing
 * @since 2.11.0
 */
var traverseReadonlyNonEmptyArrayWithIndex = function (f) {
    return function (as) {
        var e = f(0, _internal__WEBPACK_IMPORTED_MODULE_0__.head(as));
        if (isLeft(e)) {
            return e;
        }
        var out = [e.right];
        for (var i = 1; i < as.length; i++) {
            var e_1 = f(i, as[i]);
            if (isLeft(e_1)) {
                return e_1;
            }
            out.push(e_1.right);
        }
        return right(out);
    };
};
/**
 * Equivalent to `ReadonlyArray#traverseWithIndex(Applicative)`.
 *
 * @category traversing
 * @since 2.11.0
 */
var traverseReadonlyArrayWithIndex = function (f) {
    var g = traverseReadonlyNonEmptyArrayWithIndex(f);
    return function (as) { return (_internal__WEBPACK_IMPORTED_MODULE_0__.isNonEmpty(as) ? g(as) : ApT); };
};
/**
 * Equivalent to `ReadonlyArray#traverseWithIndex(Applicative)`.
 *
 * @category traversing
 * @since 2.9.0
 */
var traverseArrayWithIndex = traverseReadonlyArrayWithIndex;
/**
 * Equivalent to `ReadonlyArray#traverse(Applicative)`.
 *
 * @category traversing
 * @since 2.9.0
 */
var traverseArray = function (f) { return traverseReadonlyArrayWithIndex(function (_, a) { return f(a); }); };
/**
 * Equivalent to `ReadonlyArray#sequence(Applicative)`.
 *
 * @category traversing
 * @since 2.9.0
 */
var sequenceArray = 
/*#__PURE__*/ traverseArray(_function__WEBPACK_IMPORTED_MODULE_1__.identity);
// -------------------------------------------------------------------------------------
// legacy
// -------------------------------------------------------------------------------------
/**
 * Alias of `flatMap`.
 *
 * @category legacy
 * @since 2.6.0
 */
var chainW = flatMap;
/**
 * Alias of `flatMap`.
 *
 * @category legacy
 * @since 2.0.0
 */
var chain = flatMap;
/**
 * Alias of `tap`.
 *
 * @category legacy
 * @since 2.0.0
 */
var chainFirst = tap;
/**
 * Alias of `tap`.
 *
 * @category legacy
 * @since 2.8.0
 */
var chainFirstW = tap;
/**
 * Use [`parse`](./Json.ts.html#parse) instead.
 *
 * @category zone of death
 * @since 2.0.0
 * @deprecated
 */
function parseJSON(s, onError) {
    return tryCatch(function () { return JSON.parse(s); }, onError);
}
/**
 * Use [`stringify`](./Json.ts.html#stringify) instead.
 *
 * @category zone of death
 * @since 2.0.0
 * @deprecated
 */
var stringifyJSON = function (u, onError) {
    return tryCatch(function () {
        var s = JSON.stringify(u);
        if (typeof s !== 'string') {
            throw new Error('Converting unsupported structure to JSON');
        }
        return s;
    }, onError);
};
/**
 * This instance is deprecated, use small, specific instances instead.
 * For example if a function needs a `Functor` instance, pass `E.Functor` instead of `E.either`
 * (where `E` is from `import E from 'fp-ts/Either'`)
 *
 * @category zone of death
 * @since 2.0.0
 * @deprecated
 */
var either = {
    URI: URI,
    map: _map,
    of: of,
    ap: _ap,
    chain: flatMap,
    reduce: _reduce,
    foldMap: _foldMap,
    reduceRight: _reduceRight,
    traverse: _traverse,
    sequence: sequence,
    bimap: _bimap,
    mapLeft: _mapLeft,
    alt: _alt,
    extend: _extend,
    chainRec: _chainRec,
    throwError: throwError
};
/**
 * Use [`getApplySemigroup`](./Apply.ts.html#getapplysemigroup) instead.
 *
 * Semigroup returning the left-most `Left` value. If both operands are `Right`s then the inner values
 * are concatenated using the provided `Semigroup`
 *
 * @category zone of death
 * @since 2.0.0
 * @deprecated
 */
var getApplySemigroup = 
/*#__PURE__*/ (0,_Apply__WEBPACK_IMPORTED_MODULE_7__.getApplySemigroup)(Apply);
/**
 * Use [`getApplicativeMonoid`](./Applicative.ts.html#getapplicativemonoid) instead.
 *
 * @category zone of death
 * @since 2.0.0
 * @deprecated
 */
var getApplyMonoid = 
/*#__PURE__*/ (0,_Applicative__WEBPACK_IMPORTED_MODULE_9__.getApplicativeMonoid)(Applicative);
/**
 * Use [`getApplySemigroup`](./Apply.ts.html#getapplysemigroup) instead.
 *
 * @category zone of death
 * @since 2.0.0
 * @deprecated
 */
var getValidationSemigroup = function (SE, SA) {
    return (0,_Apply__WEBPACK_IMPORTED_MODULE_7__.getApplySemigroup)(getApplicativeValidation(SE))(SA);
};
/**
 * Use [`getApplicativeMonoid`](./Applicative.ts.html#getapplicativemonoid) instead.
 *
 * @category zone of death
 * @since 2.0.0
 * @deprecated
 */
var getValidationMonoid = function (SE, MA) {
    return (0,_Applicative__WEBPACK_IMPORTED_MODULE_9__.getApplicativeMonoid)(getApplicativeValidation(SE))(MA);
};
/**
 * Use [`getApplicativeValidation`](#getapplicativevalidation) and [`getAltValidation`](#getaltvalidation) instead.
 *
 * @category zone of death
 * @since 2.0.0
 * @deprecated
 */
function getValidation(SE) {
    var ap = getApplicativeValidation(SE).ap;
    var alt = getAltValidation(SE).alt;
    return {
        URI: URI,
        _E: undefined,
        map: _map,
        of: of,
        chain: flatMap,
        bimap: _bimap,
        mapLeft: _mapLeft,
        reduce: _reduce,
        foldMap: _foldMap,
        reduceRight: _reduceRight,
        extend: _extend,
        traverse: _traverse,
        sequence: sequence,
        chainRec: _chainRec,
        throwError: throwError,
        ap: ap,
        alt: alt
    };
}


/***/ }),

/***/ "./node_modules/fp-ts/es6/Eq.js":
/*!**************************************!*\
  !*** ./node_modules/fp-ts/es6/Eq.js ***!
  \**************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Contravariant: () => (/* binding */ Contravariant),
/* harmony export */   URI: () => (/* binding */ URI),
/* harmony export */   contramap: () => (/* binding */ contramap),
/* harmony export */   eq: () => (/* binding */ eq),
/* harmony export */   eqBoolean: () => (/* binding */ eqBoolean),
/* harmony export */   eqDate: () => (/* binding */ eqDate),
/* harmony export */   eqNumber: () => (/* binding */ eqNumber),
/* harmony export */   eqStrict: () => (/* binding */ eqStrict),
/* harmony export */   eqString: () => (/* binding */ eqString),
/* harmony export */   fromEquals: () => (/* binding */ fromEquals),
/* harmony export */   getMonoid: () => (/* binding */ getMonoid),
/* harmony export */   getSemigroup: () => (/* binding */ getSemigroup),
/* harmony export */   getStructEq: () => (/* binding */ getStructEq),
/* harmony export */   getTupleEq: () => (/* binding */ getTupleEq),
/* harmony export */   strictEqual: () => (/* binding */ strictEqual),
/* harmony export */   struct: () => (/* binding */ struct),
/* harmony export */   tuple: () => (/* binding */ tuple)
/* harmony export */ });
/* harmony import */ var _function__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./function */ "./node_modules/fp-ts/es6/function.js");

// -------------------------------------------------------------------------------------
// constructors
// -------------------------------------------------------------------------------------
/**
 * @category constructors
 * @since 2.0.0
 */
var fromEquals = function (equals) { return ({
    equals: function (x, y) { return x === y || equals(x, y); }
}); };
// -------------------------------------------------------------------------------------
// combinators
// -------------------------------------------------------------------------------------
/**
 * @since 2.10.0
 */
var struct = function (eqs) {
    return fromEquals(function (first, second) {
        for (var key in eqs) {
            if (!eqs[key].equals(first[key], second[key])) {
                return false;
            }
        }
        return true;
    });
};
/**
 * Given a tuple of `Eq`s returns a `Eq` for the tuple
 *
 * @example
 * import { tuple } from 'fp-ts/Eq'
 * import * as S from 'fp-ts/string'
 * import * as N from 'fp-ts/number'
 * import * as B from 'fp-ts/boolean'
 *
 * const E = tuple(S.Eq, N.Eq, B.Eq)
 * assert.strictEqual(E.equals(['a', 1, true], ['a', 1, true]), true)
 * assert.strictEqual(E.equals(['a', 1, true], ['b', 1, true]), false)
 * assert.strictEqual(E.equals(['a', 1, true], ['a', 2, true]), false)
 * assert.strictEqual(E.equals(['a', 1, true], ['a', 1, false]), false)
 *
 * @since 2.10.0
 */
var tuple = function () {
    var eqs = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        eqs[_i] = arguments[_i];
    }
    return fromEquals(function (first, second) { return eqs.every(function (E, i) { return E.equals(first[i], second[i]); }); });
};
/* istanbul ignore next */
var contramap_ = function (fa, f) { return (0,_function__WEBPACK_IMPORTED_MODULE_0__.pipe)(fa, contramap(f)); };
/**
 * A typical use case for `contramap` would be like, given some `User` type, to construct an `Eq<User>`.
 *
 * We can do so with a function from `User -> X` where `X` is some value that we know how to compare
 * for equality (meaning we have an `Eq<X>`)
 *
 * For example, given the following `User` type, we want to construct an `Eq<User>` that just looks at the `key` field
 * for each user (since it's known to be unique).
 *
 * If we have a way of comparing `UUID`s for equality (`eqUUID: Eq<UUID>`) and we know how to go from `User -> UUID`,
 * using `contramap` we can do this
 *
 * @example
 * import { contramap, Eq } from 'fp-ts/Eq'
 * import { pipe } from 'fp-ts/function'
 * import * as S from 'fp-ts/string'
 *
 * type UUID = string
 *
 * interface User {
 *   readonly key: UUID
 *   readonly firstName: string
 *   readonly lastName: string
 * }
 *
 * const eqUUID: Eq<UUID> = S.Eq
 *
 * const eqUserByKey: Eq<User> = pipe(
 *   eqUUID,
 *   contramap((user) => user.key)
 * )
 *
 * assert.deepStrictEqual(
 *   eqUserByKey.equals(
 *     { key: 'k1', firstName: 'a1', lastName: 'b1' },
 *     { key: 'k2', firstName: 'a1', lastName: 'b1' }
 *   ),
 *   false
 * )
 * assert.deepStrictEqual(
 *   eqUserByKey.equals(
 *     { key: 'k1', firstName: 'a1', lastName: 'b1' },
 *     { key: 'k1', firstName: 'a2', lastName: 'b1' }
 *   ),
 *   true
 * )
 *
 * @since 2.0.0
 */
var contramap = function (f) { return function (fa) {
    return fromEquals(function (x, y) { return fa.equals(f(x), f(y)); });
}; };
/**
 * @category type lambdas
 * @since 2.0.0
 */
var URI = 'Eq';
/**
 * @category instances
 * @since 2.5.0
 */
var eqStrict = {
    equals: function (a, b) { return a === b; }
};
var empty = {
    equals: function () { return true; }
};
/**
 * @category instances
 * @since 2.10.0
 */
var getSemigroup = function () { return ({
    concat: function (x, y) { return fromEquals(function (a, b) { return x.equals(a, b) && y.equals(a, b); }); }
}); };
/**
 * @category instances
 * @since 2.6.0
 */
var getMonoid = function () { return ({
    concat: getSemigroup().concat,
    empty: empty
}); };
/**
 * @category instances
 * @since 2.7.0
 */
var Contravariant = {
    URI: URI,
    contramap: contramap_
};
// -------------------------------------------------------------------------------------
// deprecated
// -------------------------------------------------------------------------------------
/**
 * Use [`tuple`](#tuple) instead.
 *
 * @category zone of death
 * @since 2.0.0
 * @deprecated
 */
var getTupleEq = tuple;
/**
 * Use [`struct`](#struct) instead.
 *
 * @category zone of death
 * @since 2.0.0
 * @deprecated
 */
var getStructEq = struct;
/**
 * Use [`eqStrict`](#eqstrict) instead
 *
 * @category zone of death
 * @since 2.0.0
 * @deprecated
 */
var strictEqual = eqStrict.equals;
/**
 * This instance is deprecated, use small, specific instances instead.
 * For example if a function needs a `Contravariant` instance, pass `E.Contravariant` instead of `E.eq`
 * (where `E` is from `import E from 'fp-ts/Eq'`)
 *
 * @category zone of death
 * @since 2.0.0
 * @deprecated
 */
var eq = Contravariant;
/**
 * Use [`Eq`](./boolean.ts.html#eq) instead.
 *
 * @category zone of death
 * @since 2.0.0
 * @deprecated
 */
var eqBoolean = eqStrict;
/**
 * Use [`Eq`](./string.ts.html#eq) instead.
 *
 * @category zone of death
 * @since 2.0.0
 * @deprecated
 */
var eqString = eqStrict;
/**
 * Use [`Eq`](./number.ts.html#eq) instead.
 *
 * @category zone of death
 * @since 2.0.0
 * @deprecated
 */
var eqNumber = eqStrict;
/**
 * Use [`Eq`](./Date.ts.html#eq) instead.
 *
 * @category zone of death
 * @since 2.0.0
 * @deprecated
 */
var eqDate = {
    equals: function (first, second) { return first.valueOf() === second.valueOf(); }
};


/***/ }),

/***/ "./node_modules/fp-ts/es6/FromEither.js":
/*!**********************************************!*\
  !*** ./node_modules/fp-ts/es6/FromEither.js ***!
  \**********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   chainEitherK: () => (/* binding */ chainEitherK),
/* harmony export */   chainFirstEitherK: () => (/* binding */ chainFirstEitherK),
/* harmony export */   chainOptionK: () => (/* binding */ chainOptionK),
/* harmony export */   filterOrElse: () => (/* binding */ filterOrElse),
/* harmony export */   fromEitherK: () => (/* binding */ fromEitherK),
/* harmony export */   fromOption: () => (/* binding */ fromOption),
/* harmony export */   fromOptionK: () => (/* binding */ fromOptionK),
/* harmony export */   fromPredicate: () => (/* binding */ fromPredicate),
/* harmony export */   tapEither: () => (/* binding */ tapEither)
/* harmony export */ });
/* harmony import */ var _Chain__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Chain */ "./node_modules/fp-ts/es6/Chain.js");
/* harmony import */ var _function__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./function */ "./node_modules/fp-ts/es6/function.js");
/* harmony import */ var _internal__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./internal */ "./node_modules/fp-ts/es6/internal.js");
/**
 * The `FromEither` type class represents those data types which support errors.
 *
 * @since 2.10.0
 */



function fromOption(F) {
    return function (onNone) { return function (ma) { return F.fromEither(_internal__WEBPACK_IMPORTED_MODULE_0__.isNone(ma) ? _internal__WEBPACK_IMPORTED_MODULE_0__.left(onNone()) : _internal__WEBPACK_IMPORTED_MODULE_0__.right(ma.value)); }; };
}
function fromPredicate(F) {
    return function (predicate, onFalse) {
        return function (a) {
            return F.fromEither(predicate(a) ? _internal__WEBPACK_IMPORTED_MODULE_0__.right(a) : _internal__WEBPACK_IMPORTED_MODULE_0__.left(onFalse(a)));
        };
    };
}
function fromOptionK(F) {
    var fromOptionF = fromOption(F);
    return function (onNone) {
        var from = fromOptionF(onNone);
        return function (f) { return (0,_function__WEBPACK_IMPORTED_MODULE_1__.flow)(f, from); };
    };
}
function chainOptionK(F, M) {
    var fromOptionKF = fromOptionK(F);
    return function (onNone) {
        var from = fromOptionKF(onNone);
        return function (f) { return function (ma) { return M.chain(ma, from(f)); }; };
    };
}
function fromEitherK(F) {
    return function (f) { return (0,_function__WEBPACK_IMPORTED_MODULE_1__.flow)(f, F.fromEither); };
}
function chainEitherK(F, M) {
    var fromEitherKF = fromEitherK(F);
    return function (f) { return function (ma) { return M.chain(ma, fromEitherKF(f)); }; };
}
function chainFirstEitherK(F, M) {
    var tapEitherM = tapEither(F, M);
    return function (f) { return function (ma) { return tapEitherM(ma, f); }; };
}
function filterOrElse(F, M) {
    return function (predicate, onFalse) {
        return function (ma) {
            return M.chain(ma, function (a) { return F.fromEither(predicate(a) ? _internal__WEBPACK_IMPORTED_MODULE_0__.right(a) : _internal__WEBPACK_IMPORTED_MODULE_0__.left(onFalse(a))); });
        };
    };
}
/** @internal */
function tapEither(F, M) {
    var fromEither = fromEitherK(F);
    var tapM = (0,_Chain__WEBPACK_IMPORTED_MODULE_2__.tap)(M);
    return function (self, f) { return tapM(self, fromEither(f)); };
}


/***/ }),

/***/ "./node_modules/fp-ts/es6/Functor.js":
/*!*******************************************!*\
  !*** ./node_modules/fp-ts/es6/Functor.js ***!
  \*******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   as: () => (/* binding */ as),
/* harmony export */   asUnit: () => (/* binding */ asUnit),
/* harmony export */   bindTo: () => (/* binding */ bindTo),
/* harmony export */   flap: () => (/* binding */ flap),
/* harmony export */   getFunctorComposition: () => (/* binding */ getFunctorComposition),
/* harmony export */   "let": () => (/* binding */ let_),
/* harmony export */   map: () => (/* binding */ map)
/* harmony export */ });
/* harmony import */ var _function__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./function */ "./node_modules/fp-ts/es6/function.js");
/**
 * A `Functor` is a type constructor which supports a mapping operation `map`.
 *
 * `map` can be used to turn functions `a -> b` into functions `f a -> f b` whose argument and return types use the type
 * constructor `f` to represent some computational context.
 *
 * Instances must satisfy the following laws:
 *
 * 1. Identity: `F.map(fa, a => a) <-> fa`
 * 2. Composition: `F.map(fa, a => bc(ab(a))) <-> F.map(F.map(fa, ab), bc)`
 *
 * @since 2.0.0
 */

function map(F, G) {
    return function (f) { return function (fa) { return F.map(fa, function (ga) { return G.map(ga, f); }); }; };
}
function flap(F) {
    return function (a) { return function (fab) { return F.map(fab, function (f) { return f(a); }); }; };
}
function bindTo(F) {
    return function (name) { return function (fa) { return F.map(fa, function (a) {
        var _a;
        return (_a = {}, _a[name] = a, _a);
    }); }; };
}
function let_(F) {
    return function (name, f) { return function (fa) { return F.map(fa, function (a) {
        var _a;
        return Object.assign({}, a, (_a = {}, _a[name] = f(a), _a));
    }); }; };
}

/** @deprecated */
function getFunctorComposition(F, G) {
    var _map = map(F, G);
    return {
        map: function (fga, f) { return (0,_function__WEBPACK_IMPORTED_MODULE_0__.pipe)(fga, _map(f)); }
    };
}
/** @internal */
function as(F) {
    return function (self, b) { return F.map(self, function () { return b; }); };
}
/** @internal */
function asUnit(F) {
    var asM = as(F);
    return function (self) { return asM(self, undefined); };
}


/***/ }),

/***/ "./node_modules/fp-ts/es6/Magma.js":
/*!*****************************************!*\
  !*** ./node_modules/fp-ts/es6/Magma.js ***!
  \*****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   concatAll: () => (/* binding */ concatAll),
/* harmony export */   endo: () => (/* binding */ endo),
/* harmony export */   filterFirst: () => (/* binding */ filterFirst),
/* harmony export */   filterSecond: () => (/* binding */ filterSecond),
/* harmony export */   reverse: () => (/* binding */ reverse)
/* harmony export */ });
/**
 * A `Magma` is a pair `(A, concat)` in which `A` is a non-empty set and `concat` is a binary operation on `A`
 *
 * See [Semigroup](https://gcanti.github.io/fp-ts/modules/Semigroup.ts.html) for some instances.
 *
 * @since 2.0.0
 */
// -------------------------------------------------------------------------------------
// combinators
// -------------------------------------------------------------------------------------
/**
 * The dual of a `Magma`, obtained by swapping the arguments of `concat`.
 *
 * @example
 * import { reverse, concatAll } from 'fp-ts/Magma'
 * import * as N from 'fp-ts/number'
 *
 * const subAll = concatAll(reverse(N.MagmaSub))(0)
 *
 * assert.deepStrictEqual(subAll([1, 2, 3]), 2)
 *
 * @since 2.11.0
 */
var reverse = function (M) { return ({
    concat: function (first, second) { return M.concat(second, first); }
}); };
/**
 * @since 2.11.0
 */
var filterFirst = function (predicate) {
    return function (M) { return ({
        concat: function (first, second) { return (predicate(first) ? M.concat(first, second) : second); }
    }); };
};
/**
 * @since 2.11.0
 */
var filterSecond = function (predicate) {
    return function (M) { return ({
        concat: function (first, second) { return (predicate(second) ? M.concat(first, second) : first); }
    }); };
};
/**
 * @since 2.11.0
 */
var endo = function (f) {
    return function (M) { return ({
        concat: function (first, second) { return M.concat(f(first), f(second)); }
    }); };
};
// -------------------------------------------------------------------------------------
// utils
// -------------------------------------------------------------------------------------
/**
 * Given a sequence of `as`, concat them and return the total.
 *
 * If `as` is empty, return the provided `startWith` value.
 *
 * @example
 * import { concatAll } from 'fp-ts/Magma'
 * import * as N from 'fp-ts/number'
 *
 * const subAll = concatAll(N.MagmaSub)(0)
 *
 * assert.deepStrictEqual(subAll([1, 2, 3]), -6)
 *
 * @since 2.11.0
 */
var concatAll = function (M) {
    return function (startWith) {
        return function (as) {
            return as.reduce(function (a, acc) { return M.concat(a, acc); }, startWith);
        };
    };
};


/***/ }),

/***/ "./node_modules/fp-ts/es6/NonEmptyArray.js":
/*!*************************************************!*\
  !*** ./node_modules/fp-ts/es6/NonEmptyArray.js ***!
  \*************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Alt: () => (/* binding */ Alt),
/* harmony export */   Applicative: () => (/* binding */ Applicative),
/* harmony export */   Apply: () => (/* binding */ Apply),
/* harmony export */   Chain: () => (/* binding */ Chain),
/* harmony export */   Comonad: () => (/* binding */ Comonad),
/* harmony export */   Do: () => (/* binding */ Do),
/* harmony export */   Foldable: () => (/* binding */ Foldable),
/* harmony export */   FoldableWithIndex: () => (/* binding */ FoldableWithIndex),
/* harmony export */   Functor: () => (/* binding */ Functor),
/* harmony export */   FunctorWithIndex: () => (/* binding */ FunctorWithIndex),
/* harmony export */   Monad: () => (/* binding */ Monad),
/* harmony export */   Pointed: () => (/* binding */ Pointed),
/* harmony export */   Traversable: () => (/* binding */ Traversable),
/* harmony export */   TraversableWithIndex: () => (/* binding */ TraversableWithIndex),
/* harmony export */   URI: () => (/* binding */ URI),
/* harmony export */   alt: () => (/* binding */ alt),
/* harmony export */   altW: () => (/* binding */ altW),
/* harmony export */   ap: () => (/* binding */ ap),
/* harmony export */   apFirst: () => (/* binding */ apFirst),
/* harmony export */   apS: () => (/* binding */ apS),
/* harmony export */   apSecond: () => (/* binding */ apSecond),
/* harmony export */   append: () => (/* binding */ append),
/* harmony export */   appendW: () => (/* binding */ appendW),
/* harmony export */   bind: () => (/* binding */ bind),
/* harmony export */   bindTo: () => (/* binding */ bindTo),
/* harmony export */   chain: () => (/* binding */ chain),
/* harmony export */   chainFirst: () => (/* binding */ chainFirst),
/* harmony export */   chainWithIndex: () => (/* binding */ chainWithIndex),
/* harmony export */   chop: () => (/* binding */ chop),
/* harmony export */   chunksOf: () => (/* binding */ chunksOf),
/* harmony export */   concat: () => (/* binding */ concat),
/* harmony export */   concatAll: () => (/* binding */ concatAll),
/* harmony export */   concatW: () => (/* binding */ concatW),
/* harmony export */   cons: () => (/* binding */ cons),
/* harmony export */   copy: () => (/* binding */ copy),
/* harmony export */   duplicate: () => (/* binding */ duplicate),
/* harmony export */   extend: () => (/* binding */ extend),
/* harmony export */   extract: () => (/* binding */ extract),
/* harmony export */   filter: () => (/* binding */ filter),
/* harmony export */   filterWithIndex: () => (/* binding */ filterWithIndex),
/* harmony export */   flap: () => (/* binding */ flap),
/* harmony export */   flatMap: () => (/* binding */ flatMap),
/* harmony export */   flatten: () => (/* binding */ flatten),
/* harmony export */   fold: () => (/* binding */ fold),
/* harmony export */   foldMap: () => (/* binding */ foldMap),
/* harmony export */   foldMapWithIndex: () => (/* binding */ foldMapWithIndex),
/* harmony export */   fromArray: () => (/* binding */ fromArray),
/* harmony export */   fromReadonlyNonEmptyArray: () => (/* binding */ fromReadonlyNonEmptyArray),
/* harmony export */   getEq: () => (/* binding */ getEq),
/* harmony export */   getSemigroup: () => (/* binding */ getSemigroup),
/* harmony export */   getShow: () => (/* binding */ getShow),
/* harmony export */   getUnionSemigroup: () => (/* binding */ getUnionSemigroup),
/* harmony export */   group: () => (/* binding */ group),
/* harmony export */   groupBy: () => (/* binding */ groupBy),
/* harmony export */   groupSort: () => (/* binding */ groupSort),
/* harmony export */   head: () => (/* binding */ head),
/* harmony export */   init: () => (/* binding */ init),
/* harmony export */   insertAt: () => (/* binding */ insertAt),
/* harmony export */   intercalate: () => (/* binding */ intercalate),
/* harmony export */   intersperse: () => (/* binding */ intersperse),
/* harmony export */   isNonEmpty: () => (/* binding */ isNonEmpty),
/* harmony export */   isOutOfBound: () => (/* binding */ isOutOfBound),
/* harmony export */   last: () => (/* binding */ last),
/* harmony export */   "let": () => (/* binding */ let_),
/* harmony export */   makeBy: () => (/* binding */ makeBy),
/* harmony export */   map: () => (/* binding */ map),
/* harmony export */   mapWithIndex: () => (/* binding */ mapWithIndex),
/* harmony export */   matchLeft: () => (/* binding */ matchLeft),
/* harmony export */   matchRight: () => (/* binding */ matchRight),
/* harmony export */   max: () => (/* binding */ max),
/* harmony export */   min: () => (/* binding */ min),
/* harmony export */   modifyAt: () => (/* binding */ modifyAt),
/* harmony export */   modifyHead: () => (/* binding */ modifyHead),
/* harmony export */   modifyLast: () => (/* binding */ modifyLast),
/* harmony export */   nonEmptyArray: () => (/* binding */ nonEmptyArray),
/* harmony export */   of: () => (/* binding */ of),
/* harmony export */   prepend: () => (/* binding */ prepend),
/* harmony export */   prependAll: () => (/* binding */ prependAll),
/* harmony export */   prependToAll: () => (/* binding */ prependToAll),
/* harmony export */   prependW: () => (/* binding */ prependW),
/* harmony export */   range: () => (/* binding */ range),
/* harmony export */   reduce: () => (/* binding */ reduce),
/* harmony export */   reduceRight: () => (/* binding */ reduceRight),
/* harmony export */   reduceRightWithIndex: () => (/* binding */ reduceRightWithIndex),
/* harmony export */   reduceWithIndex: () => (/* binding */ reduceWithIndex),
/* harmony export */   replicate: () => (/* binding */ replicate),
/* harmony export */   reverse: () => (/* binding */ reverse),
/* harmony export */   rotate: () => (/* binding */ rotate),
/* harmony export */   sequence: () => (/* binding */ sequence),
/* harmony export */   snoc: () => (/* binding */ snoc),
/* harmony export */   sort: () => (/* binding */ sort),
/* harmony export */   sortBy: () => (/* binding */ sortBy),
/* harmony export */   splitAt: () => (/* binding */ splitAt),
/* harmony export */   tail: () => (/* binding */ tail),
/* harmony export */   traverse: () => (/* binding */ traverse),
/* harmony export */   traverseWithIndex: () => (/* binding */ traverseWithIndex),
/* harmony export */   unappend: () => (/* binding */ unappend),
/* harmony export */   uncons: () => (/* binding */ uncons),
/* harmony export */   union: () => (/* binding */ union),
/* harmony export */   uniq: () => (/* binding */ uniq),
/* harmony export */   unprepend: () => (/* binding */ unprepend),
/* harmony export */   unsafeInsertAt: () => (/* binding */ unsafeInsertAt),
/* harmony export */   unsafeUpdateAt: () => (/* binding */ unsafeUpdateAt),
/* harmony export */   unsnoc: () => (/* binding */ unsnoc),
/* harmony export */   unzip: () => (/* binding */ unzip),
/* harmony export */   updateAt: () => (/* binding */ updateAt),
/* harmony export */   updateHead: () => (/* binding */ updateHead),
/* harmony export */   updateLast: () => (/* binding */ updateLast),
/* harmony export */   zip: () => (/* binding */ zip),
/* harmony export */   zipWith: () => (/* binding */ zipWith)
/* harmony export */ });
/* harmony import */ var _Apply__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./Apply */ "./node_modules/fp-ts/es6/Apply.js");
/* harmony import */ var _Chain__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./Chain */ "./node_modules/fp-ts/es6/Chain.js");
/* harmony import */ var _function__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./function */ "./node_modules/fp-ts/es6/function.js");
/* harmony import */ var _Functor__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./Functor */ "./node_modules/fp-ts/es6/Functor.js");
/* harmony import */ var _internal__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./internal */ "./node_modules/fp-ts/es6/internal.js");
/* harmony import */ var _Ord__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Ord */ "./node_modules/fp-ts/es6/Ord.js");
/* harmony import */ var _ReadonlyNonEmptyArray__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./ReadonlyNonEmptyArray */ "./node_modules/fp-ts/es6/ReadonlyNonEmptyArray.js");
var __spreadArray = (undefined && undefined.__spreadArray) || function (to, from, pack) {
    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
        }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
};







// -------------------------------------------------------------------------------------
// internal
// -------------------------------------------------------------------------------------
/**
 * @internal
 */
var isNonEmpty = function (as) { return as.length > 0; };
/**
 * @internal
 */
var isOutOfBound = function (i, as) { return i < 0 || i >= as.length; };
/**
 * @internal
 */
var prependW = function (head) {
    return function (tail) {
        return __spreadArray([head], tail, true);
    };
};
/**
 * @internal
 */
var prepend = prependW;
/**
 * @internal
 */
var appendW = function (end) {
    return function (init) {
        return __spreadArray(__spreadArray([], init, true), [end], false);
    };
};
/**
 * @internal
 */
var append = appendW;
/**
 * @internal
 */
var unsafeInsertAt = function (i, a, as) {
    if (isNonEmpty(as)) {
        var xs = fromReadonlyNonEmptyArray(as);
        xs.splice(i, 0, a);
        return xs;
    }
    return [a];
};
/**
 * @internal
 */
var unsafeUpdateAt = function (i, a, as) {
    var xs = fromReadonlyNonEmptyArray(as);
    xs[i] = a;
    return xs;
};
/**
 * Remove duplicates from a `NonEmptyArray`, keeping the first occurrence of an element.
 *
 * @example
 * import { uniq } from 'fp-ts/NonEmptyArray'
 * import * as N from 'fp-ts/number'
 *
 * assert.deepStrictEqual(uniq(N.Eq)([1, 2, 1]), [1, 2])
 *
 * @since 2.11.0
 */
var uniq = function (E) {
    return function (as) {
        if (as.length === 1) {
            return copy(as);
        }
        var out = [head(as)];
        var rest = tail(as);
        var _loop_1 = function (a) {
            if (out.every(function (o) { return !E.equals(o, a); })) {
                out.push(a);
            }
        };
        for (var _i = 0, rest_1 = rest; _i < rest_1.length; _i++) {
            var a = rest_1[_i];
            _loop_1(a);
        }
        return out;
    };
};
/**
 * Sort the elements of a `NonEmptyArray` in increasing order, where elements are compared using first `ords[0]`, then `ords[1]`,
 * etc...
 *
 * @example
 * import * as NEA from 'fp-ts/NonEmptyArray'
 * import { contramap } from 'fp-ts/Ord'
 * import * as S from 'fp-ts/string'
 * import * as N from 'fp-ts/number'
 * import { pipe } from 'fp-ts/function'
 *
 * interface Person {
 *   name: string
 *   age: number
 * }
 *
 * const byName = pipe(S.Ord, contramap((p: Person) => p.name))
 *
 * const byAge = pipe(N.Ord, contramap((p: Person) => p.age))
 *
 * const sortByNameByAge = NEA.sortBy([byName, byAge])
 *
 * const persons: NEA.NonEmptyArray<Person> = [
 *   { name: 'a', age: 1 },
 *   { name: 'b', age: 3 },
 *   { name: 'c', age: 2 },
 *   { name: 'b', age: 2 }
 * ]
 *
 * assert.deepStrictEqual(sortByNameByAge(persons), [
 *   { name: 'a', age: 1 },
 *   { name: 'b', age: 2 },
 *   { name: 'b', age: 3 },
 *   { name: 'c', age: 2 }
 * ])
 *
 * @since 2.11.0
 */
var sortBy = function (ords) {
    if (isNonEmpty(ords)) {
        var M = (0,_Ord__WEBPACK_IMPORTED_MODULE_0__.getMonoid)();
        return sort(ords.reduce(M.concat, M.empty));
    }
    return copy;
};
/**
 * @since 2.11.0
 */
var union = function (E) {
    var uniqE = uniq(E);
    return function (second) { return function (first) { return uniqE((0,_function__WEBPACK_IMPORTED_MODULE_1__.pipe)(first, concat(second))); }; };
};
/**
 * Rotate a `NonEmptyArray` by `n` steps.
 *
 * @example
 * import { rotate } from 'fp-ts/NonEmptyArray'
 *
 * assert.deepStrictEqual(rotate(2)([1, 2, 3, 4, 5]), [4, 5, 1, 2, 3])
 * assert.deepStrictEqual(rotate(-2)([1, 2, 3, 4, 5]), [3, 4, 5, 1, 2])
 *
 * @since 2.11.0
 */
var rotate = function (n) {
    return function (as) {
        var len = as.length;
        var m = Math.round(n) % len;
        if (isOutOfBound(Math.abs(m), as) || m === 0) {
            return copy(as);
        }
        if (m < 0) {
            var _a = splitAt(-m)(as), f = _a[0], s = _a[1];
            return (0,_function__WEBPACK_IMPORTED_MODULE_1__.pipe)(s, concat(f));
        }
        else {
            return rotate(m - len)(as);
        }
    };
};
// -------------------------------------------------------------------------------------
// constructors
// -------------------------------------------------------------------------------------
/**
 * @category conversions
 * @since 2.10.0
 */
var fromReadonlyNonEmptyArray = _internal__WEBPACK_IMPORTED_MODULE_2__.fromReadonlyNonEmptyArray;
/**
 * Builds a `NonEmptyArray` from an `Array` returning `none` if `as` is an empty array
 *
 * @category conversions
 * @since 2.0.0
 */
var fromArray = function (as) { return (isNonEmpty(as) ? _internal__WEBPACK_IMPORTED_MODULE_2__.some(as) : _internal__WEBPACK_IMPORTED_MODULE_2__.none); };
/**
 * Return a `NonEmptyArray` of length `n` with element `i` initialized with `f(i)`.
 *
 * **Note**. `n` is normalized to a natural number.
 *
 * @example
 * import { makeBy } from 'fp-ts/NonEmptyArray'
 * import { pipe } from 'fp-ts/function'
 *
 * const double = (n: number): number => n * 2
 * assert.deepStrictEqual(pipe(5, makeBy(double)), [0, 2, 4, 6, 8])
 *
 * @category constructors
 * @since 2.11.0
 */
var makeBy = function (f) {
    return function (n) {
        var j = Math.max(0, Math.floor(n));
        var out = [f(0)];
        for (var i = 1; i < j; i++) {
            out.push(f(i));
        }
        return out;
    };
};
/**
 * Create a `NonEmptyArray` containing a value repeated the specified number of times.
 *
 * **Note**. `n` is normalized to a natural number.
 *
 * @example
 * import { replicate } from 'fp-ts/NonEmptyArray'
 * import { pipe } from 'fp-ts/function'
 *
 * assert.deepStrictEqual(pipe(3, replicate('a')), ['a', 'a', 'a'])
 *
 * @category constructors
 * @since 2.11.0
 */
var replicate = function (a) { return makeBy(function () { return a; }); };
/**
 * Create a `NonEmptyArray` containing a range of integers, including both endpoints.
 *
 * @example
 * import { range } from 'fp-ts/NonEmptyArray'
 *
 * assert.deepStrictEqual(range(1, 5), [1, 2, 3, 4, 5])
 *
 * @category constructors
 * @since 2.11.0
 */
var range = function (start, end) {
    return start <= end ? makeBy(function (i) { return start + i; })(end - start + 1) : [start];
};
/**
 * Return the tuple of the `head` and the `tail`.
 *
 * @example
 * import { unprepend } from 'fp-ts/NonEmptyArray'
 *
 * assert.deepStrictEqual(unprepend([1, 2, 3]), [1, [2, 3]])
 *
 * @since 2.9.0
 */
var unprepend = function (as) { return [head(as), tail(as)]; };
/**
 * Return the tuple of the `init` and the `last`.
 *
 * @example
 * import { unappend } from 'fp-ts/NonEmptyArray'
 *
 * assert.deepStrictEqual(unappend([1, 2, 3, 4]), [[1, 2, 3], 4])
 *
 * @since 2.9.0
 */
var unappend = function (as) { return [init(as), last(as)]; };
function concatW(second) {
    return function (first) { return first.concat(second); };
}
function concat(x, y) {
    return y ? x.concat(y) : function (y) { return y.concat(x); };
}
/**
 * @since 2.0.0
 */
var reverse = function (as) { return __spreadArray([last(as)], as.slice(0, -1).reverse(), true); };
function group(E) {
    return function (as) {
        var len = as.length;
        if (len === 0) {
            return [];
        }
        var out = [];
        var head = as[0];
        var nea = [head];
        for (var i = 1; i < len; i++) {
            var a = as[i];
            if (E.equals(a, head)) {
                nea.push(a);
            }
            else {
                out.push(nea);
                head = a;
                nea = [head];
            }
        }
        out.push(nea);
        return out;
    };
}
/**
 * Splits an array into sub-non-empty-arrays stored in an object, based on the result of calling a `string`-returning
 * function on each element, and grouping the results according to values returned
 *
 * @example
 * import { groupBy } from 'fp-ts/NonEmptyArray'
 *
 * assert.deepStrictEqual(groupBy((s: string) => String(s.length))(['a', 'b', 'ab']), {
 *   '1': ['a', 'b'],
 *   '2': ['ab']
 * })
 *
 * @since 2.0.0
 */
var groupBy = function (f) {
    return function (as) {
        var out = {};
        for (var _i = 0, as_1 = as; _i < as_1.length; _i++) {
            var a = as_1[_i];
            var k = f(a);
            if (_internal__WEBPACK_IMPORTED_MODULE_2__.has.call(out, k)) {
                out[k].push(a);
            }
            else {
                out[k] = [a];
            }
        }
        return out;
    };
};
/**
 * @since 2.0.0
 */
var sort = function (O) {
    return function (as) {
        return as.slice().sort(O.compare);
    };
};
/**
 * @since 2.0.0
 */
var insertAt = function (i, a) {
    return function (as) {
        return i < 0 || i > as.length ? _internal__WEBPACK_IMPORTED_MODULE_2__.none : _internal__WEBPACK_IMPORTED_MODULE_2__.some(unsafeInsertAt(i, a, as));
    };
};
/**
 * @since 2.0.0
 */
var updateAt = function (i, a) {
    return modifyAt(i, function () { return a; });
};
/**
 * @since 2.0.0
 */
var modifyAt = function (i, f) {
    return function (as) {
        return isOutOfBound(i, as) ? _internal__WEBPACK_IMPORTED_MODULE_2__.none : _internal__WEBPACK_IMPORTED_MODULE_2__.some(unsafeUpdateAt(i, f(as[i]), as));
    };
};
/**
 * @since 2.0.0
 */
var copy = fromReadonlyNonEmptyArray;
/**
 * @category constructors
 * @since 2.0.0
 */
var of = function (a) { return [a]; };
/**
 * @since 2.5.1
 */
var zipWith = function (as, bs, f) {
    var cs = [f(as[0], bs[0])];
    var len = Math.min(as.length, bs.length);
    for (var i = 1; i < len; i++) {
        cs[i] = f(as[i], bs[i]);
    }
    return cs;
};
function zip(as, bs) {
    if (bs === undefined) {
        return function (bs) { return zip(bs, as); };
    }
    return zipWith(as, bs, function (a, b) { return [a, b]; });
}
/**
 * @since 2.5.1
 */
var unzip = function (abs) {
    var fa = [abs[0][0]];
    var fb = [abs[0][1]];
    for (var i = 1; i < abs.length; i++) {
        fa[i] = abs[i][0];
        fb[i] = abs[i][1];
    }
    return [fa, fb];
};
/**
 * Prepend an element to every member of an array
 *
 * @example
 * import { prependAll } from 'fp-ts/NonEmptyArray'
 *
 * assert.deepStrictEqual(prependAll(9)([1, 2, 3, 4]), [9, 1, 9, 2, 9, 3, 9, 4])
 *
 * @since 2.10.0
 */
var prependAll = function (middle) {
    return function (as) {
        var out = [middle, as[0]];
        for (var i = 1; i < as.length; i++) {
            out.push(middle, as[i]);
        }
        return out;
    };
};
/**
 * Places an element in between members of an array
 *
 * @example
 * import { intersperse } from 'fp-ts/NonEmptyArray'
 *
 * assert.deepStrictEqual(intersperse(9)([1, 2, 3, 4]), [1, 9, 2, 9, 3, 9, 4])
 *
 * @since 2.9.0
 */
var intersperse = function (middle) {
    return function (as) {
        var rest = tail(as);
        return isNonEmpty(rest) ? (0,_function__WEBPACK_IMPORTED_MODULE_1__.pipe)(rest, prependAll(middle), prepend(head(as))) : copy(as);
    };
};
/**
 * @category folding
 * @since 2.0.0
 */
var foldMapWithIndex = _ReadonlyNonEmptyArray__WEBPACK_IMPORTED_MODULE_3__.foldMapWithIndex;
/**
 * @category folding
 * @since 2.0.0
 */
var foldMap = _ReadonlyNonEmptyArray__WEBPACK_IMPORTED_MODULE_3__.foldMap;
/**
 * @category sequencing
 * @since 2.10.0
 */
var chainWithIndex = function (f) {
    return function (as) {
        var out = fromReadonlyNonEmptyArray(f(0, head(as)));
        for (var i = 1; i < as.length; i++) {
            var bs = f(i, as[i]);
            for (var j = 0; j < bs.length; j++) {
                out.push(bs[j]);
            }
        }
        return out;
    };
};
/**
 * @since 2.10.0
 */
var chop = function (f) {
    return function (as) {
        var _a = f(as), b = _a[0], rest = _a[1];
        var out = [b];
        var next = rest;
        while (isNonEmpty(next)) {
            var _b = f(next), b_1 = _b[0], rest_2 = _b[1];
            out.push(b_1);
            next = rest_2;
        }
        return out;
    };
};
/**
 * Splits a `NonEmptyArray` into two pieces, the first piece has max `n` elements.
 *
 * @since 2.10.0
 */
var splitAt = function (n) {
    return function (as) {
        var m = Math.max(1, n);
        return m >= as.length ? [copy(as), []] : [(0,_function__WEBPACK_IMPORTED_MODULE_1__.pipe)(as.slice(1, m), prepend(head(as))), as.slice(m)];
    };
};
/**
 * @since 2.10.0
 */
var chunksOf = function (n) { return chop(splitAt(n)); };
/* istanbul ignore next */
var _map = function (fa, f) { return (0,_function__WEBPACK_IMPORTED_MODULE_1__.pipe)(fa, map(f)); };
/* istanbul ignore next */
var _mapWithIndex = function (fa, f) { return (0,_function__WEBPACK_IMPORTED_MODULE_1__.pipe)(fa, mapWithIndex(f)); };
/* istanbul ignore next */
var _ap = function (fab, fa) { return (0,_function__WEBPACK_IMPORTED_MODULE_1__.pipe)(fab, ap(fa)); };
/* istanbul ignore next */
var _extend = function (wa, f) { return (0,_function__WEBPACK_IMPORTED_MODULE_1__.pipe)(wa, extend(f)); };
/* istanbul ignore next */
var _reduce = function (fa, b, f) { return (0,_function__WEBPACK_IMPORTED_MODULE_1__.pipe)(fa, reduce(b, f)); };
/* istanbul ignore next */
var _foldMap = function (M) {
    var foldMapM = foldMap(M);
    return function (fa, f) { return (0,_function__WEBPACK_IMPORTED_MODULE_1__.pipe)(fa, foldMapM(f)); };
};
/* istanbul ignore next */
var _reduceRight = function (fa, b, f) { return (0,_function__WEBPACK_IMPORTED_MODULE_1__.pipe)(fa, reduceRight(b, f)); };
/* istanbul ignore next */
var _traverse = function (F) {
    var traverseF = traverse(F);
    return function (ta, f) { return (0,_function__WEBPACK_IMPORTED_MODULE_1__.pipe)(ta, traverseF(f)); };
};
/* istanbul ignore next */
var _alt = function (fa, that) { return (0,_function__WEBPACK_IMPORTED_MODULE_1__.pipe)(fa, alt(that)); };
/* istanbul ignore next */
var _reduceWithIndex = function (fa, b, f) {
    return (0,_function__WEBPACK_IMPORTED_MODULE_1__.pipe)(fa, reduceWithIndex(b, f));
};
/* istanbul ignore next */
var _foldMapWithIndex = function (M) {
    var foldMapWithIndexM = foldMapWithIndex(M);
    return function (fa, f) { return (0,_function__WEBPACK_IMPORTED_MODULE_1__.pipe)(fa, foldMapWithIndexM(f)); };
};
/* istanbul ignore next */
var _reduceRightWithIndex = function (fa, b, f) {
    return (0,_function__WEBPACK_IMPORTED_MODULE_1__.pipe)(fa, reduceRightWithIndex(b, f));
};
/* istanbul ignore next */
var _traverseWithIndex = function (F) {
    var traverseWithIndexF = traverseWithIndex(F);
    return function (ta, f) { return (0,_function__WEBPACK_IMPORTED_MODULE_1__.pipe)(ta, traverseWithIndexF(f)); };
};
/**
 * Less strict version of [`alt`](#alt).
 *
 * The `W` suffix (short for **W**idening) means that the return types will be merged.
 *
 * @example
 * import * as NEA from 'fp-ts/NonEmptyArray'
 * import { pipe } from 'fp-ts/function'
 *
 * assert.deepStrictEqual(
 *   pipe(
 *     [1, 2, 3] as NEA.NonEmptyArray<number>,
 *     NEA.altW(() => ['a', 'b'])
 *   ),
 *   [1, 2, 3, 'a', 'b']
 * )
 *
 * @category error handling
 * @since 2.9.0
 */
var altW = function (that) {
    return function (as) {
        return (0,_function__WEBPACK_IMPORTED_MODULE_1__.pipe)(as, concatW(that()));
    };
};
/**
 * Identifies an associative operation on a type constructor. It is similar to `Semigroup`, except that it applies to
 * types of kind `* -> *`.
 *
 * In case of `NonEmptyArray` concatenates the inputs into a single array.
 *
 * @example
 * import * as NEA from 'fp-ts/NonEmptyArray'
 * import { pipe } from 'fp-ts/function'
 *
 * assert.deepStrictEqual(
 *   pipe(
 *     [1, 2, 3],
 *     NEA.alt(() => [4, 5])
 *   ),
 *   [1, 2, 3, 4, 5]
 * )
 *
 * @category error handling
 * @since 2.6.2
 */
var alt = altW;
/**
 * Apply a function to an argument under a type constructor.
 *
 * @since 2.0.0
 */
var ap = function (as) {
    return flatMap(function (f) { return (0,_function__WEBPACK_IMPORTED_MODULE_1__.pipe)(as, map(f)); });
};
/**
 * @example
 * import * as NEA from 'fp-ts/NonEmptyArray'
 * import { pipe } from 'fp-ts/function'
 *
 * assert.deepStrictEqual(
 *   pipe(
 *     [1, 2, 3],
 *     NEA.flatMap((n) => [`a${n}`, `b${n}`])
 *   ),
 *   ['a1', 'b1', 'a2', 'b2', 'a3', 'b3']
 * )
 *
 * @category sequencing
 * @since 2.14.0
 */
var flatMap = /*#__PURE__*/ (0,_function__WEBPACK_IMPORTED_MODULE_1__.dual)(2, function (ma, f) {
    return (0,_function__WEBPACK_IMPORTED_MODULE_1__.pipe)(ma, chainWithIndex(function (i, a) { return f(a, i); }));
});
/**
 * @since 2.0.0
 */
var extend = function (f) {
    return function (as) {
        var next = tail(as);
        var out = [f(as)];
        while (isNonEmpty(next)) {
            out.push(f(next));
            next = tail(next);
        }
        return out;
    };
};
/**
 * @since 2.5.0
 */
var duplicate = /*#__PURE__*/ extend(_function__WEBPACK_IMPORTED_MODULE_1__.identity);
/**
 * @category sequencing
 * @since 2.5.0
 */
var flatten = /*#__PURE__*/ flatMap(_function__WEBPACK_IMPORTED_MODULE_1__.identity);
/**
 * `map` can be used to turn functions `(a: A) => B` into functions `(fa: F<A>) => F<B>` whose argument and return types
 * use the type constructor `F` to represent some computational context.
 *
 * @category mapping
 * @since 2.0.0
 */
var map = function (f) { return mapWithIndex(function (_, a) { return f(a); }); };
/**
 * @category mapping
 * @since 2.0.0
 */
var mapWithIndex = function (f) {
    return function (as) {
        var out = [f(0, head(as))];
        for (var i = 1; i < as.length; i++) {
            out.push(f(i, as[i]));
        }
        return out;
    };
};
/**
 * @category folding
 * @since 2.0.0
 */
var reduce = _ReadonlyNonEmptyArray__WEBPACK_IMPORTED_MODULE_3__.reduce;
/**
 * @category folding
 * @since 2.0.0
 */
var reduceWithIndex = _ReadonlyNonEmptyArray__WEBPACK_IMPORTED_MODULE_3__.reduceWithIndex;
/**
 * @category folding
 * @since 2.0.0
 */
var reduceRight = _ReadonlyNonEmptyArray__WEBPACK_IMPORTED_MODULE_3__.reduceRight;
/**
 * @category folding
 * @since 2.0.0
 */
var reduceRightWithIndex = _ReadonlyNonEmptyArray__WEBPACK_IMPORTED_MODULE_3__.reduceRightWithIndex;
/**
 * @category traversing
 * @since 2.6.3
 */
var traverse = function (F) {
    var traverseWithIndexF = traverseWithIndex(F);
    return function (f) { return traverseWithIndexF(function (_, a) { return f(a); }); };
};
/**
 * @category traversing
 * @since 2.6.3
 */
var sequence = function (F) { return traverseWithIndex(F)(function (_, a) { return a; }); };
/**
 * @category sequencing
 * @since 2.6.3
 */
var traverseWithIndex = function (F) {
    return function (f) {
        return function (as) {
            var out = F.map(f(0, head(as)), of);
            for (var i = 1; i < as.length; i++) {
                out = F.ap(F.map(out, function (bs) { return function (b) { return (0,_function__WEBPACK_IMPORTED_MODULE_1__.pipe)(bs, append(b)); }; }), f(i, as[i]));
            }
            return out;
        };
    };
};
/**
 * @since 2.7.0
 */
var extract = _ReadonlyNonEmptyArray__WEBPACK_IMPORTED_MODULE_3__.head;
/**
 * @category type lambdas
 * @since 2.0.0
 */
var URI = 'NonEmptyArray';
/**
 * @category instances
 * @since 2.0.0
 */
var getShow = _ReadonlyNonEmptyArray__WEBPACK_IMPORTED_MODULE_3__.getShow;
/**
 * Builds a `Semigroup` instance for `NonEmptyArray`
 *
 * @category instances
 * @since 2.0.0
 */
var getSemigroup = function () { return ({
    concat: concat
}); };
/**
 * @example
 * import { getEq } from 'fp-ts/NonEmptyArray'
 * import * as N from 'fp-ts/number'
 *
 * const E = getEq(N.Eq)
 * assert.strictEqual(E.equals([1, 2], [1, 2]), true)
 * assert.strictEqual(E.equals([1, 2], [1, 3]), false)
 *
 * @category instances
 * @since 2.0.0
 */
var getEq = _ReadonlyNonEmptyArray__WEBPACK_IMPORTED_MODULE_3__.getEq;
/**
 * @since 2.11.0
 */
var getUnionSemigroup = function (E) {
    var unionE = union(E);
    return {
        concat: function (first, second) { return unionE(second)(first); }
    };
};
/**
 * @category instances
 * @since 2.7.0
 */
var Functor = {
    URI: URI,
    map: _map
};
/**
 * @category mapping
 * @since 2.10.0
 */
var flap = /*#__PURE__*/ (0,_Functor__WEBPACK_IMPORTED_MODULE_4__.flap)(Functor);
/**
 * @category instances
 * @since 2.10.0
 */
var Pointed = {
    URI: URI,
    of: of
};
/**
 * @category instances
 * @since 2.7.0
 */
var FunctorWithIndex = {
    URI: URI,
    map: _map,
    mapWithIndex: _mapWithIndex
};
/**
 * @category instances
 * @since 2.10.0
 */
var Apply = {
    URI: URI,
    map: _map,
    ap: _ap
};
/**
 * Combine two effectful actions, keeping only the result of the first.
 *
 * @since 2.5.0
 */
var apFirst = /*#__PURE__*/ (0,_Apply__WEBPACK_IMPORTED_MODULE_5__.apFirst)(Apply);
/**
 * Combine two effectful actions, keeping only the result of the second.
 *
 * @since 2.5.0
 */
var apSecond = /*#__PURE__*/ (0,_Apply__WEBPACK_IMPORTED_MODULE_5__.apSecond)(Apply);
/**
 * @category instances
 * @since 2.7.0
 */
var Applicative = {
    URI: URI,
    map: _map,
    ap: _ap,
    of: of
};
/**
 * @category instances
 * @since 2.10.0
 */
var Chain = {
    URI: URI,
    map: _map,
    ap: _ap,
    chain: flatMap
};
/**
 * Composes computations in sequence, using the return value of one computation to determine the next computation and
 * keeping only the result of the first.
 *
 * @category sequencing
 * @since 2.5.0
 */
var chainFirst = 
/*#__PURE__*/ (0,_Chain__WEBPACK_IMPORTED_MODULE_6__.chainFirst)(Chain);
/**
 * @category instances
 * @since 2.7.0
 */
var Monad = {
    URI: URI,
    map: _map,
    ap: _ap,
    of: of,
    chain: flatMap
};
/**
 * @category instances
 * @since 2.7.0
 */
var Foldable = {
    URI: URI,
    reduce: _reduce,
    foldMap: _foldMap,
    reduceRight: _reduceRight
};
/**
 * @category instances
 * @since 2.7.0
 */
var FoldableWithIndex = {
    URI: URI,
    reduce: _reduce,
    foldMap: _foldMap,
    reduceRight: _reduceRight,
    reduceWithIndex: _reduceWithIndex,
    foldMapWithIndex: _foldMapWithIndex,
    reduceRightWithIndex: _reduceRightWithIndex
};
/**
 * @category instances
 * @since 2.7.0
 */
var Traversable = {
    URI: URI,
    map: _map,
    reduce: _reduce,
    foldMap: _foldMap,
    reduceRight: _reduceRight,
    traverse: _traverse,
    sequence: sequence
};
/**
 * @category instances
 * @since 2.7.0
 */
var TraversableWithIndex = {
    URI: URI,
    map: _map,
    mapWithIndex: _mapWithIndex,
    reduce: _reduce,
    foldMap: _foldMap,
    reduceRight: _reduceRight,
    traverse: _traverse,
    sequence: sequence,
    reduceWithIndex: _reduceWithIndex,
    foldMapWithIndex: _foldMapWithIndex,
    reduceRightWithIndex: _reduceRightWithIndex,
    traverseWithIndex: _traverseWithIndex
};
/**
 * @category instances
 * @since 2.7.0
 */
var Alt = {
    URI: URI,
    map: _map,
    alt: _alt
};
/**
 * @category instances
 * @since 2.7.0
 */
var Comonad = {
    URI: URI,
    map: _map,
    extend: _extend,
    extract: extract
};
// -------------------------------------------------------------------------------------
// do notation
// -------------------------------------------------------------------------------------
/**
 * @category do notation
 * @since 2.9.0
 */
var Do = /*#__PURE__*/ of(_internal__WEBPACK_IMPORTED_MODULE_2__.emptyRecord);
/**
 * @category do notation
 * @since 2.8.0
 */
var bindTo = /*#__PURE__*/ (0,_Functor__WEBPACK_IMPORTED_MODULE_4__.bindTo)(Functor);
var let_ = /*#__PURE__*/ (0,_Functor__WEBPACK_IMPORTED_MODULE_4__["let"])(Functor);

/**
 * @category do notation
 * @since 2.8.0
 */
var bind = /*#__PURE__*/ (0,_Chain__WEBPACK_IMPORTED_MODULE_6__.bind)(Chain);
/**
 * @category do notation
 * @since 2.8.0
 */
var apS = /*#__PURE__*/ (0,_Apply__WEBPACK_IMPORTED_MODULE_5__.apS)(Apply);
// -------------------------------------------------------------------------------------
// utils
// -------------------------------------------------------------------------------------
/**
 * @since 2.0.0
 */
var head = _ReadonlyNonEmptyArray__WEBPACK_IMPORTED_MODULE_3__.head;
/**
 * @since 2.0.0
 */
var tail = function (as) { return as.slice(1); };
/**
 * @since 2.0.0
 */
var last = _ReadonlyNonEmptyArray__WEBPACK_IMPORTED_MODULE_3__.last;
/**
 * Get all but the last element of a non empty array, creating a new array.
 *
 * @example
 * import { init } from 'fp-ts/NonEmptyArray'
 *
 * assert.deepStrictEqual(init([1, 2, 3]), [1, 2])
 * assert.deepStrictEqual(init([1]), [])
 *
 * @since 2.2.0
 */
var init = function (as) { return as.slice(0, -1); };
/**
 * @since 2.0.0
 */
var min = _ReadonlyNonEmptyArray__WEBPACK_IMPORTED_MODULE_3__.min;
/**
 * @since 2.0.0
 */
var max = _ReadonlyNonEmptyArray__WEBPACK_IMPORTED_MODULE_3__.max;
/**
 * @since 2.10.0
 */
var concatAll = function (S) {
    return function (as) {
        return as.reduce(S.concat);
    };
};
/**
 * Break an `Array` into its first element and remaining elements.
 *
 * @category pattern matching
 * @since 2.11.0
 */
var matchLeft = function (f) {
    return function (as) {
        return f(head(as), tail(as));
    };
};
/**
 * Break an `Array` into its initial elements and the last element.
 *
 * @category pattern matching
 * @since 2.11.0
 */
var matchRight = function (f) {
    return function (as) {
        return f(init(as), last(as));
    };
};
/**
 * Apply a function to the head, creating a new `NonEmptyArray`.
 *
 * @since 2.11.0
 */
var modifyHead = function (f) {
    return function (as) {
        return __spreadArray([f(head(as))], tail(as), true);
    };
};
/**
 * Change the head, creating a new `NonEmptyArray`.
 *
 * @since 2.11.0
 */
var updateHead = function (a) { return modifyHead(function () { return a; }); };
/**
 * Apply a function to the last element, creating a new `NonEmptyArray`.
 *
 * @since 2.11.0
 */
var modifyLast = function (f) {
    return function (as) {
        return (0,_function__WEBPACK_IMPORTED_MODULE_1__.pipe)(init(as), append(f(last(as))));
    };
};
/**
 * Change the last element, creating a new `NonEmptyArray`.
 *
 * @since 2.11.0
 */
var updateLast = function (a) { return modifyLast(function () { return a; }); };
/**
 * Places an element in between members of a `NonEmptyArray`, then folds the results using the provided `Semigroup`.
 *
 * @example
 * import * as S from 'fp-ts/string'
 * import { intercalate } from 'fp-ts/NonEmptyArray'
 *
 * assert.deepStrictEqual(intercalate(S.Semigroup)('-')(['a', 'b', 'c']), 'a-b-c')
 *
 * @since 2.12.0
 */
var intercalate = _ReadonlyNonEmptyArray__WEBPACK_IMPORTED_MODULE_3__.intercalate;
// -------------------------------------------------------------------------------------
// legacy
// -------------------------------------------------------------------------------------
/**
 * Alias of `flatMap`.
 *
 * @category legacy
 * @since 2.0.0
 */
var chain = flatMap;
function groupSort(O) {
    var sortO = sort(O);
    var groupO = group(O);
    return function (as) { return (isNonEmpty(as) ? groupO(sortO(as)) : []); };
}
function filter(predicate) {
    return filterWithIndex(function (_, a) { return predicate(a); });
}
/**
 * Use [`filterWithIndex`](./Array.ts.html#filterwithindex) instead.
 *
 * @category zone of death
 * @since 2.0.0
 * @deprecated
 */
var filterWithIndex = function (predicate) {
    return function (as) {
        return fromArray(as.filter(function (a, i) { return predicate(i, a); }));
    };
};
/**
 * Use [`unprepend`](#unprepend) instead.
 *
 * @category zone of death
 * @since 2.9.0
 * @deprecated
 */
var uncons = unprepend;
/**
 * Use [`unappend`](#unappend) instead.
 *
 * @category zone of death
 * @since 2.9.0
 * @deprecated
 */
var unsnoc = unappend;
function cons(head, tail) {
    return tail === undefined ? prepend(head) : (0,_function__WEBPACK_IMPORTED_MODULE_1__.pipe)(tail, prepend(head));
}
/**
 * Use [`append`](./Array.ts.html#append) instead.
 *
 * @category zone of death
 * @since 2.0.0
 * @deprecated
 */
var snoc = function (init, end) { return (0,_function__WEBPACK_IMPORTED_MODULE_1__.pipe)(init, append(end)); };
/**
 * Use [`prependAll`](#prependall) instead.
 *
 * @category zone of death
 * @since 2.9.0
 * @deprecated
 */
var prependToAll = prependAll;
/**
 * Use [`concatAll`](#concatall) instead.
 *
 * @category zone of death
 * @since 2.5.0
 * @deprecated
 */
var fold = _ReadonlyNonEmptyArray__WEBPACK_IMPORTED_MODULE_3__.concatAll;
/**
 * This instance is deprecated, use small, specific instances instead.
 * For example if a function needs a `Functor` instance, pass `NEA.Functor` instead of `NEA.nonEmptyArray`
 * (where `NEA` is from `import NEA from 'fp-ts/NonEmptyArray'`)
 *
 * @category zone of death
 * @since 2.0.0
 * @deprecated
 */
var nonEmptyArray = {
    URI: URI,
    of: of,
    map: _map,
    mapWithIndex: _mapWithIndex,
    ap: _ap,
    chain: flatMap,
    extend: _extend,
    extract: extract,
    reduce: _reduce,
    foldMap: _foldMap,
    reduceRight: _reduceRight,
    traverse: _traverse,
    sequence: sequence,
    reduceWithIndex: _reduceWithIndex,
    foldMapWithIndex: _foldMapWithIndex,
    reduceRightWithIndex: _reduceRightWithIndex,
    traverseWithIndex: _traverseWithIndex,
    alt: _alt
};


/***/ }),

/***/ "./node_modules/fp-ts/es6/Option.js":
/*!******************************************!*\
  !*** ./node_modules/fp-ts/es6/Option.js ***!
  \******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Alt: () => (/* binding */ Alt),
/* harmony export */   Alternative: () => (/* binding */ Alternative),
/* harmony export */   ApT: () => (/* binding */ ApT),
/* harmony export */   Applicative: () => (/* binding */ Applicative),
/* harmony export */   Apply: () => (/* binding */ Apply),
/* harmony export */   Chain: () => (/* binding */ Chain),
/* harmony export */   Compactable: () => (/* binding */ Compactable),
/* harmony export */   Do: () => (/* binding */ Do),
/* harmony export */   Extend: () => (/* binding */ Extend),
/* harmony export */   Filterable: () => (/* binding */ Filterable),
/* harmony export */   Foldable: () => (/* binding */ Foldable),
/* harmony export */   FromEither: () => (/* binding */ FromEither),
/* harmony export */   Functor: () => (/* binding */ Functor),
/* harmony export */   Monad: () => (/* binding */ Monad),
/* harmony export */   MonadThrow: () => (/* binding */ MonadThrow),
/* harmony export */   Pointed: () => (/* binding */ Pointed),
/* harmony export */   Traversable: () => (/* binding */ Traversable),
/* harmony export */   URI: () => (/* binding */ URI),
/* harmony export */   Witherable: () => (/* binding */ Witherable),
/* harmony export */   Zero: () => (/* binding */ Zero),
/* harmony export */   alt: () => (/* binding */ alt),
/* harmony export */   altW: () => (/* binding */ altW),
/* harmony export */   ap: () => (/* binding */ ap),
/* harmony export */   apFirst: () => (/* binding */ apFirst),
/* harmony export */   apS: () => (/* binding */ apS),
/* harmony export */   apSecond: () => (/* binding */ apSecond),
/* harmony export */   as: () => (/* binding */ as),
/* harmony export */   asUnit: () => (/* binding */ asUnit),
/* harmony export */   bind: () => (/* binding */ bind),
/* harmony export */   bindTo: () => (/* binding */ bindTo),
/* harmony export */   chain: () => (/* binding */ chain),
/* harmony export */   chainEitherK: () => (/* binding */ chainEitherK),
/* harmony export */   chainFirst: () => (/* binding */ chainFirst),
/* harmony export */   chainFirstEitherK: () => (/* binding */ chainFirstEitherK),
/* harmony export */   chainNullableK: () => (/* binding */ chainNullableK),
/* harmony export */   compact: () => (/* binding */ compact),
/* harmony export */   duplicate: () => (/* binding */ duplicate),
/* harmony export */   elem: () => (/* binding */ elem),
/* harmony export */   exists: () => (/* binding */ exists),
/* harmony export */   extend: () => (/* binding */ extend),
/* harmony export */   filter: () => (/* binding */ filter),
/* harmony export */   filterMap: () => (/* binding */ filterMap),
/* harmony export */   flap: () => (/* binding */ flap),
/* harmony export */   flatMap: () => (/* binding */ flatMap),
/* harmony export */   flatten: () => (/* binding */ flatten),
/* harmony export */   fold: () => (/* binding */ fold),
/* harmony export */   foldMap: () => (/* binding */ foldMap),
/* harmony export */   foldW: () => (/* binding */ foldW),
/* harmony export */   fromEither: () => (/* binding */ fromEither),
/* harmony export */   fromEitherK: () => (/* binding */ fromEitherK),
/* harmony export */   fromNullable: () => (/* binding */ fromNullable),
/* harmony export */   fromNullableK: () => (/* binding */ fromNullableK),
/* harmony export */   fromPredicate: () => (/* binding */ fromPredicate),
/* harmony export */   getApplyMonoid: () => (/* binding */ getApplyMonoid),
/* harmony export */   getApplySemigroup: () => (/* binding */ getApplySemigroup),
/* harmony export */   getEq: () => (/* binding */ getEq),
/* harmony export */   getFirstMonoid: () => (/* binding */ getFirstMonoid),
/* harmony export */   getLastMonoid: () => (/* binding */ getLastMonoid),
/* harmony export */   getLeft: () => (/* binding */ getLeft),
/* harmony export */   getMonoid: () => (/* binding */ getMonoid),
/* harmony export */   getOrElse: () => (/* binding */ getOrElse),
/* harmony export */   getOrElseW: () => (/* binding */ getOrElseW),
/* harmony export */   getOrd: () => (/* binding */ getOrd),
/* harmony export */   getRefinement: () => (/* binding */ getRefinement),
/* harmony export */   getRight: () => (/* binding */ getRight),
/* harmony export */   getShow: () => (/* binding */ getShow),
/* harmony export */   guard: () => (/* binding */ guard),
/* harmony export */   isNone: () => (/* binding */ isNone),
/* harmony export */   isSome: () => (/* binding */ isSome),
/* harmony export */   "let": () => (/* binding */ let_),
/* harmony export */   map: () => (/* binding */ map),
/* harmony export */   mapNullable: () => (/* binding */ mapNullable),
/* harmony export */   match: () => (/* binding */ match),
/* harmony export */   matchW: () => (/* binding */ matchW),
/* harmony export */   none: () => (/* binding */ none),
/* harmony export */   of: () => (/* binding */ of),
/* harmony export */   option: () => (/* binding */ option),
/* harmony export */   orElse: () => (/* binding */ orElse),
/* harmony export */   partition: () => (/* binding */ partition),
/* harmony export */   partitionMap: () => (/* binding */ partitionMap),
/* harmony export */   reduce: () => (/* binding */ reduce),
/* harmony export */   reduceRight: () => (/* binding */ reduceRight),
/* harmony export */   separate: () => (/* binding */ separate),
/* harmony export */   sequence: () => (/* binding */ sequence),
/* harmony export */   sequenceArray: () => (/* binding */ sequenceArray),
/* harmony export */   some: () => (/* binding */ some),
/* harmony export */   tap: () => (/* binding */ tap),
/* harmony export */   tapEither: () => (/* binding */ tapEither),
/* harmony export */   throwError: () => (/* binding */ throwError),
/* harmony export */   toNullable: () => (/* binding */ toNullable),
/* harmony export */   toUndefined: () => (/* binding */ toUndefined),
/* harmony export */   traverse: () => (/* binding */ traverse),
/* harmony export */   traverseArray: () => (/* binding */ traverseArray),
/* harmony export */   traverseArrayWithIndex: () => (/* binding */ traverseArrayWithIndex),
/* harmony export */   traverseReadonlyArrayWithIndex: () => (/* binding */ traverseReadonlyArrayWithIndex),
/* harmony export */   traverseReadonlyNonEmptyArrayWithIndex: () => (/* binding */ traverseReadonlyNonEmptyArrayWithIndex),
/* harmony export */   tryCatch: () => (/* binding */ tryCatch),
/* harmony export */   tryCatchK: () => (/* binding */ tryCatchK),
/* harmony export */   wilt: () => (/* binding */ wilt),
/* harmony export */   wither: () => (/* binding */ wither),
/* harmony export */   zero: () => (/* binding */ zero)
/* harmony export */ });
/* harmony import */ var _Applicative__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./Applicative */ "./node_modules/fp-ts/es6/Applicative.js");
/* harmony import */ var _Apply__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./Apply */ "./node_modules/fp-ts/es6/Apply.js");
/* harmony import */ var _Chain__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./Chain */ "./node_modules/fp-ts/es6/Chain.js");
/* harmony import */ var _FromEither__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./FromEither */ "./node_modules/fp-ts/es6/FromEither.js");
/* harmony import */ var _function__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./function */ "./node_modules/fp-ts/es6/function.js");
/* harmony import */ var _Functor__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Functor */ "./node_modules/fp-ts/es6/Functor.js");
/* harmony import */ var _internal__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./internal */ "./node_modules/fp-ts/es6/internal.js");
/* harmony import */ var _Predicate__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./Predicate */ "./node_modules/fp-ts/es6/Predicate.js");
/* harmony import */ var _Semigroup__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./Semigroup */ "./node_modules/fp-ts/es6/Semigroup.js");
/* harmony import */ var _Separated__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./Separated */ "./node_modules/fp-ts/es6/Separated.js");
/* harmony import */ var _Witherable__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./Witherable */ "./node_modules/fp-ts/es6/Witherable.js");
/* harmony import */ var _Zero__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Zero */ "./node_modules/fp-ts/es6/Zero.js");












// -------------------------------------------------------------------------------------
// constructors
// -------------------------------------------------------------------------------------
/**
 * `None` doesn't have a constructor, instead you can use it directly as a value. Represents a missing value.
 *
 * @category constructors
 * @since 2.0.0
 */
var none = _internal__WEBPACK_IMPORTED_MODULE_0__.none;
/**
 * Constructs a `Some`. Represents an optional value that exists.
 *
 * @category constructors
 * @since 2.0.0
 */
var some = _internal__WEBPACK_IMPORTED_MODULE_0__.some;
function fromPredicate(predicate) {
    return function (a) { return (predicate(a) ? some(a) : none); };
}
/**
 * Returns the `Left` value of an `Either` if possible.
 *
 * @example
 * import { getLeft, none, some } from 'fp-ts/Option'
 * import { right, left } from 'fp-ts/Either'
 *
 * assert.deepStrictEqual(getLeft(right(1)), none)
 * assert.deepStrictEqual(getLeft(left('a')), some('a'))
 *
 * @category constructors
 * @since 2.0.0
 */
var getLeft = function (ma) { return (ma._tag === 'Right' ? none : some(ma.left)); };
/**
 * Returns the `Right` value of an `Either` if possible.
 *
 * @example
 * import { getRight, none, some } from 'fp-ts/Option'
 * import { right, left } from 'fp-ts/Either'
 *
 * assert.deepStrictEqual(getRight(right(1)), some(1))
 * assert.deepStrictEqual(getRight(left('a')), none)
 *
 * @category constructors
 * @since 2.0.0
 */
var getRight = function (ma) { return (ma._tag === 'Left' ? none : some(ma.right)); };
var _map = function (fa, f) { return (0,_function__WEBPACK_IMPORTED_MODULE_1__.pipe)(fa, map(f)); };
var _ap = function (fab, fa) { return (0,_function__WEBPACK_IMPORTED_MODULE_1__.pipe)(fab, ap(fa)); };
var _reduce = function (fa, b, f) { return (0,_function__WEBPACK_IMPORTED_MODULE_1__.pipe)(fa, reduce(b, f)); };
var _foldMap = function (M) {
    var foldMapM = foldMap(M);
    return function (fa, f) { return (0,_function__WEBPACK_IMPORTED_MODULE_1__.pipe)(fa, foldMapM(f)); };
};
var _reduceRight = function (fa, b, f) { return (0,_function__WEBPACK_IMPORTED_MODULE_1__.pipe)(fa, reduceRight(b, f)); };
var _traverse = function (F) {
    var traverseF = traverse(F);
    return function (ta, f) { return (0,_function__WEBPACK_IMPORTED_MODULE_1__.pipe)(ta, traverseF(f)); };
};
/* istanbul ignore next */
var _alt = function (fa, that) { return (0,_function__WEBPACK_IMPORTED_MODULE_1__.pipe)(fa, alt(that)); };
var _filter = function (fa, predicate) { return (0,_function__WEBPACK_IMPORTED_MODULE_1__.pipe)(fa, filter(predicate)); };
/* istanbul ignore next */
var _filterMap = function (fa, f) { return (0,_function__WEBPACK_IMPORTED_MODULE_1__.pipe)(fa, filterMap(f)); };
/* istanbul ignore next */
var _extend = function (wa, f) { return (0,_function__WEBPACK_IMPORTED_MODULE_1__.pipe)(wa, extend(f)); };
/* istanbul ignore next */
var _partition = function (fa, predicate) {
    return (0,_function__WEBPACK_IMPORTED_MODULE_1__.pipe)(fa, partition(predicate));
};
/* istanbul ignore next */
var _partitionMap = function (fa, f) { return (0,_function__WEBPACK_IMPORTED_MODULE_1__.pipe)(fa, partitionMap(f)); };
/**
 * @category type lambdas
 * @since 2.0.0
 */
var URI = 'Option';
/**
 * @category instances
 * @since 2.0.0
 */
var getShow = function (S) { return ({
    show: function (ma) { return (isNone(ma) ? 'none' : "some(".concat(S.show(ma.value), ")")); }
}); };
/**
 * @example
 * import { none, some, getEq } from 'fp-ts/Option'
 * import * as N from 'fp-ts/number'
 *
 * const E = getEq(N.Eq)
 * assert.strictEqual(E.equals(none, none), true)
 * assert.strictEqual(E.equals(none, some(1)), false)
 * assert.strictEqual(E.equals(some(1), none), false)
 * assert.strictEqual(E.equals(some(1), some(2)), false)
 * assert.strictEqual(E.equals(some(1), some(1)), true)
 *
 * @category instances
 * @since 2.0.0
 */
var getEq = function (E) { return ({
    equals: function (x, y) { return x === y || (isNone(x) ? isNone(y) : isNone(y) ? false : E.equals(x.value, y.value)); }
}); };
/**
 * The `Ord` instance allows `Option` values to be compared with
 * `compare`, whenever there is an `Ord` instance for
 * the type the `Option` contains.
 *
 * `None` is considered to be less than any `Some` value.
 *
 *
 * @example
 * import { none, some, getOrd } from 'fp-ts/Option'
 * import * as N from 'fp-ts/number'
 *
 * const O = getOrd(N.Ord)
 * assert.strictEqual(O.compare(none, none), 0)
 * assert.strictEqual(O.compare(none, some(1)), -1)
 * assert.strictEqual(O.compare(some(1), none), 1)
 * assert.strictEqual(O.compare(some(1), some(2)), -1)
 * assert.strictEqual(O.compare(some(1), some(1)), 0)
 *
 * @category instances
 * @since 2.0.0
 */
var getOrd = function (O) { return ({
    equals: getEq(O).equals,
    compare: function (x, y) { return (x === y ? 0 : isSome(x) ? (isSome(y) ? O.compare(x.value, y.value) : 1) : -1); }
}); };
/**
 * Monoid returning the left-most non-`None` value. If both operands are `Some`s then the inner values are
 * concatenated using the provided `Semigroup`
 *
 * | x       | y       | concat(x, y)       |
 * | ------- | ------- | ------------------ |
 * | none    | none    | none               |
 * | some(a) | none    | some(a)            |
 * | none    | some(b) | some(b)            |
 * | some(a) | some(b) | some(concat(a, b)) |
 *
 * @example
 * import { getMonoid, some, none } from 'fp-ts/Option'
 * import { SemigroupSum } from 'fp-ts/number'
 *
 * const M = getMonoid(SemigroupSum)
 * assert.deepStrictEqual(M.concat(none, none), none)
 * assert.deepStrictEqual(M.concat(some(1), none), some(1))
 * assert.deepStrictEqual(M.concat(none, some(1)), some(1))
 * assert.deepStrictEqual(M.concat(some(1), some(2)), some(3))
 *
 * @category instances
 * @since 2.0.0
 */
var getMonoid = function (S) { return ({
    concat: function (x, y) { return (isNone(x) ? y : isNone(y) ? x : some(S.concat(x.value, y.value))); },
    empty: none
}); };
/**
 * @category mapping
 * @since 2.0.0
 */
var map = function (f) { return function (fa) {
    return isNone(fa) ? none : some(f(fa.value));
}; };
/**
 * @category instances
 * @since 2.7.0
 */
var Functor = {
    URI: URI,
    map: _map
};
/**
 * Maps the `Some` value of this `Option` to the specified constant value.
 *
 * @category mapping
 * @since 2.16.0
 */
var as = (0,_function__WEBPACK_IMPORTED_MODULE_1__.dual)(2, (0,_Functor__WEBPACK_IMPORTED_MODULE_2__.as)(Functor));
/**
 * Maps the `Some` value of this `Option` to the void constant value.
 *
 * @category mapping
 * @since 2.16.0
 */
var asUnit = (0,_Functor__WEBPACK_IMPORTED_MODULE_2__.asUnit)(Functor);
/**
 * @category constructors
 * @since 2.7.0
 */
var of = some;
/**
 * @category instances
 * @since 2.10.0
 */
var Pointed = {
    URI: URI,
    of: of
};
/**
 * @since 2.0.0
 */
var ap = function (fa) { return function (fab) {
    return isNone(fab) ? none : isNone(fa) ? none : some(fab.value(fa.value));
}; };
/**
 * @category instances
 * @since 2.10.0
 */
var Apply = {
    URI: URI,
    map: _map,
    ap: _ap
};
/**
 * @category instances
 * @since 2.7.0
 */
var Applicative = {
    URI: URI,
    map: _map,
    ap: _ap,
    of: of
};
/**
 * @category sequencing
 * @since 2.14.0
 */
var flatMap = /*#__PURE__*/ (0,_function__WEBPACK_IMPORTED_MODULE_1__.dual)(2, function (ma, f) { return (isNone(ma) ? none : f(ma.value)); });
/**
 * @category instances
 * @since 2.10.0
 */
var Chain = {
    URI: URI,
    map: _map,
    ap: _ap,
    chain: flatMap
};
/**
 * @category instances
 * @since 2.7.0
 */
var Monad = {
    URI: URI,
    map: _map,
    ap: _ap,
    of: of,
    chain: flatMap
};
/**
 * @category folding
 * @since 2.0.0
 */
var reduce = function (b, f) { return function (fa) {
    return isNone(fa) ? b : f(b, fa.value);
}; };
/**
 * @category folding
 * @since 2.0.0
 */
var foldMap = function (M) { return function (f) { return function (fa) {
    return isNone(fa) ? M.empty : f(fa.value);
}; }; };
/**
 * @category folding
 * @since 2.0.0
 */
var reduceRight = function (b, f) { return function (fa) {
    return isNone(fa) ? b : f(fa.value, b);
}; };
/**
 * @category instances
 * @since 2.7.0
 */
var Foldable = {
    URI: URI,
    reduce: _reduce,
    foldMap: _foldMap,
    reduceRight: _reduceRight
};
/**
 * Returns the provided `Option` `that` if `self` is `None`, otherwise returns `self`.
 *
 * @param self - The first `Option` to be checked.
 * @param that - The `Option` to return if `self` is `None`.
 *
 * @example
 * import * as O from "fp-ts/Option"
 *
 * assert.deepStrictEqual(O.orElse(O.none, () => O.none), O.none)
 * assert.deepStrictEqual(O.orElse(O.some(1), () => O.none), O.some(1))
 * assert.deepStrictEqual(O.orElse(O.none, () => O.some('b')), O.some('b'))
 * assert.deepStrictEqual(O.orElse(O.some(1), () => O.some('b')), O.some(1))
 *
 * @category error handling
 * @since 2.16.0
 */
var orElse = (0,_function__WEBPACK_IMPORTED_MODULE_1__.dual)(2, function (self, that) { return (isNone(self) ? that() : self); });
/**
 * Alias of `orElse`.
 *
 * Less strict version of [`alt`](#alt).
 *
 * The `W` suffix (short for **W**idening) means that the return types will be merged.
 *
 * @category legacy
 * @since 2.9.0
 */
var altW = orElse;
/**
 * Alias of `orElse`.
 *
 * @category legacy
 * @since 2.0.0
 */
var alt = orElse;
/**
 * @category instances
 * @since 2.7.0
 */
var Alt = {
    URI: URI,
    map: _map,
    alt: _alt
};
/**
 * @since 2.7.0
 */
var zero = function () { return none; };
/**
 * @category instances
 * @since 2.11.0
 */
var Zero = {
    URI: URI,
    zero: zero
};
/**
 * @category do notation
 * @since 2.11.0
 */
var guard = /*#__PURE__*/ (0,_Zero__WEBPACK_IMPORTED_MODULE_3__.guard)(Zero, Pointed);
/**
 * @category instances
 * @since 2.7.0
 */
var Alternative = {
    URI: URI,
    map: _map,
    ap: _ap,
    of: of,
    alt: _alt,
    zero: zero
};
/**
 * @since 2.0.0
 */
var extend = function (f) { return function (wa) {
    return isNone(wa) ? none : some(f(wa));
}; };
/**
 * @category instances
 * @since 2.7.0
 */
var Extend = {
    URI: URI,
    map: _map,
    extend: _extend
};
/**
 * @category filtering
 * @since 2.0.0
 */
var compact = /*#__PURE__*/ flatMap(_function__WEBPACK_IMPORTED_MODULE_1__.identity);
var defaultSeparated = /*#__PURE__*/ (0,_Separated__WEBPACK_IMPORTED_MODULE_4__.separated)(none, none);
/**
 * @category filtering
 * @since 2.0.0
 */
var separate = function (ma) {
    return isNone(ma) ? defaultSeparated : (0,_Separated__WEBPACK_IMPORTED_MODULE_4__.separated)(getLeft(ma.value), getRight(ma.value));
};
/**
 * @category instances
 * @since 2.7.0
 */
var Compactable = {
    URI: URI,
    compact: compact,
    separate: separate
};
/**
 * @category filtering
 * @since 2.0.0
 */
var filter = function (predicate) {
    return function (fa) {
        return isNone(fa) ? none : predicate(fa.value) ? fa : none;
    };
};
/**
 * @category filtering
 * @since 2.0.0
 */
var filterMap = function (f) { return function (fa) {
    return isNone(fa) ? none : f(fa.value);
}; };
/**
 * @category filtering
 * @since 2.0.0
 */
var partition = function (predicate) {
    return function (fa) {
        return (0,_Separated__WEBPACK_IMPORTED_MODULE_4__.separated)(_filter(fa, (0,_Predicate__WEBPACK_IMPORTED_MODULE_5__.not)(predicate)), _filter(fa, predicate));
    };
};
/**
 * @category filtering
 * @since 2.0.0
 */
var partitionMap = function (f) { return (0,_function__WEBPACK_IMPORTED_MODULE_1__.flow)(map(f), separate); };
/**
 * @category instances
 * @since 2.7.0
 */
var Filterable = {
    URI: URI,
    map: _map,
    compact: compact,
    separate: separate,
    filter: _filter,
    filterMap: _filterMap,
    partition: _partition,
    partitionMap: _partitionMap
};
/**
 * @category traversing
 * @since 2.6.3
 */
var traverse = function (F) {
    return function (f) {
        return function (ta) {
            return isNone(ta) ? F.of(none) : F.map(f(ta.value), some);
        };
    };
};
/**
 * @category traversing
 * @since 2.6.3
 */
var sequence = function (F) {
    return function (ta) {
        return isNone(ta) ? F.of(none) : F.map(ta.value, some);
    };
};
/**
 * @category instances
 * @since 2.7.0
 */
var Traversable = {
    URI: URI,
    map: _map,
    reduce: _reduce,
    foldMap: _foldMap,
    reduceRight: _reduceRight,
    traverse: _traverse,
    sequence: sequence
};
var _wither = /*#__PURE__*/ (0,_Witherable__WEBPACK_IMPORTED_MODULE_6__.witherDefault)(Traversable, Compactable);
var _wilt = /*#__PURE__*/ (0,_Witherable__WEBPACK_IMPORTED_MODULE_6__.wiltDefault)(Traversable, Compactable);
/**
 * @category filtering
 * @since 2.6.5
 */
var wither = function (F) {
    var _witherF = _wither(F);
    return function (f) { return function (fa) { return _witherF(fa, f); }; };
};
/**
 * @category filtering
 * @since 2.6.5
 */
var wilt = function (F) {
    var _wiltF = _wilt(F);
    return function (f) { return function (fa) { return _wiltF(fa, f); }; };
};
/**
 * @category instances
 * @since 2.7.0
 */
var Witherable = {
    URI: URI,
    map: _map,
    reduce: _reduce,
    foldMap: _foldMap,
    reduceRight: _reduceRight,
    traverse: _traverse,
    sequence: sequence,
    compact: compact,
    separate: separate,
    filter: _filter,
    filterMap: _filterMap,
    partition: _partition,
    partitionMap: _partitionMap,
    wither: _wither,
    wilt: _wilt
};
/**
 * @since 2.7.0
 */
var throwError = function () { return none; };
/**
 * @category instances
 * @since 2.7.0
 */
var MonadThrow = {
    URI: URI,
    map: _map,
    ap: _ap,
    of: of,
    chain: flatMap,
    throwError: throwError
};
/**
 * Transforms an `Either` to an `Option` discarding the error.
 *
 * Alias of [getRight](#getright)
 *
 * @category conversions
 * @since 2.0.0
 */
var fromEither = getRight;
/**
 * @category instances
 * @since 2.11.0
 */
var FromEither = {
    URI: URI,
    fromEither: fromEither
};
// -------------------------------------------------------------------------------------
// refinements
// -------------------------------------------------------------------------------------
/**
 * Returns `true` if the option is an instance of `Some`, `false` otherwise.
 *
 * @example
 * import { some, none, isSome } from 'fp-ts/Option'
 *
 * assert.strictEqual(isSome(some(1)), true)
 * assert.strictEqual(isSome(none), false)
 *
 * @category refinements
 * @since 2.0.0
 */
var isSome = _internal__WEBPACK_IMPORTED_MODULE_0__.isSome;
/**
 * Returns `true` if the option is `None`, `false` otherwise.
 *
 * @example
 * import { some, none, isNone } from 'fp-ts/Option'
 *
 * assert.strictEqual(isNone(some(1)), false)
 * assert.strictEqual(isNone(none), true)
 *
 * @category refinements
 * @since 2.0.0
 */
var isNone = function (fa) { return fa._tag === 'None'; };
/**
 * Less strict version of [`match`](#match).
 *
 * The `W` suffix (short for **W**idening) means that the handler return types will be merged.
 *
 * @category pattern matching
 * @since 2.10.0
 */
var matchW = function (onNone, onSome) {
    return function (ma) {
        return isNone(ma) ? onNone() : onSome(ma.value);
    };
};
/**
 * Alias of [`matchW`](#matchw).
 *
 * @category pattern matching
 * @since 2.10.0
 */
var foldW = matchW;
/**
 * Takes a (lazy) default value, a function, and an `Option` value, if the `Option` value is `None` the default value is
 * returned, otherwise the function is applied to the value inside the `Some` and the result is returned.
 *
 * @example
 * import { some, none, match } from 'fp-ts/Option'
 * import { pipe } from 'fp-ts/function'
 *
 * assert.strictEqual(
 *   pipe(
 *     some(1),
 *     match(() => 'a none', a => `a some containing ${a}`)
 *   ),
 *   'a some containing 1'
 * )
 *
 * assert.strictEqual(
 *   pipe(
 *     none,
 *     match(() => 'a none', a => `a some containing ${a}`)
 *   ),
 *   'a none'
 * )
 *
 * @category pattern matching
 * @since 2.10.0
 */
var match = matchW;
/**
 * Alias of [`match`](#match).
 *
 * @category pattern matching
 * @since 2.0.0
 */
var fold = match;
/**
 * Less strict version of [`getOrElse`](#getorelse).
 *
 * The `W` suffix (short for **W**idening) means that the handler return type will be merged.
 *
 * @category error handling
 * @since 2.6.0
 */
var getOrElseW = function (onNone) {
    return function (ma) {
        return isNone(ma) ? onNone() : ma.value;
    };
};
/**
 * Extracts the value out of the structure, if it exists. Otherwise returns the given default value
 *
 * @example
 * import { some, none, getOrElse } from 'fp-ts/Option'
 * import { pipe } from 'fp-ts/function'
 *
 * assert.strictEqual(
 *   pipe(
 *     some(1),
 *     getOrElse(() => 0)
 *   ),
 *   1
 * )
 * assert.strictEqual(
 *   pipe(
 *     none,
 *     getOrElse(() => 0)
 *   ),
 *   0
 * )
 *
 * @category error handling
 * @since 2.0.0
 */
var getOrElse = getOrElseW;
/**
 * @category mapping
 * @since 2.10.0
 */
var flap = /*#__PURE__*/ (0,_Functor__WEBPACK_IMPORTED_MODULE_2__.flap)(Functor);
/**
 * Combine two effectful actions, keeping only the result of the first.
 *
 * @since 2.0.0
 */
var apFirst = /*#__PURE__*/ (0,_Apply__WEBPACK_IMPORTED_MODULE_7__.apFirst)(Apply);
/**
 * Combine two effectful actions, keeping only the result of the second.
 *
 * @since 2.0.0
 */
var apSecond = /*#__PURE__*/ (0,_Apply__WEBPACK_IMPORTED_MODULE_7__.apSecond)(Apply);
/**
 * @category sequencing
 * @since 2.0.0
 */
var flatten = compact;
/**
 * Composes computations in sequence, using the return value of one computation to determine the next computation and
 * keeping only the result of the first.
 *
 * @category combinators
 * @since 2.15.0
 */
var tap = /*#__PURE__*/ (0,_function__WEBPACK_IMPORTED_MODULE_1__.dual)(2, _Chain__WEBPACK_IMPORTED_MODULE_8__.tap(Chain));
/**
 * Composes computations in sequence, using the return value of one computation to determine the next computation and
 * keeping only the result of the first.
 *
 * @example
 * import { pipe } from 'fp-ts/function'
 * import * as O from 'fp-ts/Option'
 * import * as E from 'fp-ts/Either'
 *
 * const compute = (value: number) => pipe(
 *   O.of(value),
 *   O.tapEither((value) => value > 0 ? E.right('ok') : E.left('error')),
 * )
 *
 * assert.deepStrictEqual(compute(1), O.of(1))
 * assert.deepStrictEqual(compute(-42), O.none)
 *
 * @category combinators
 * @since 2.16.0
 */
var tapEither = /*#__PURE__*/ (0,_function__WEBPACK_IMPORTED_MODULE_1__.dual)(2, (0,_FromEither__WEBPACK_IMPORTED_MODULE_9__.tapEither)(FromEither, Chain));
/**
 * @since 2.0.0
 */
var duplicate = /*#__PURE__*/ extend(_function__WEBPACK_IMPORTED_MODULE_1__.identity);
/**
 * @category lifting
 * @since 2.11.0
 */
var fromEitherK = /*#__PURE__*/ (0,_FromEither__WEBPACK_IMPORTED_MODULE_9__.fromEitherK)(FromEither);
/**
 * @category sequencing
 * @since 2.11.0
 */
var chainEitherK = 
/*#__PURE__*/ (0,_FromEither__WEBPACK_IMPORTED_MODULE_9__.chainEitherK)(FromEither, Chain);
/**
 * Alias of `tapEither`.
 *
 * @category legacy
 * @since 2.12.0
 */
var chainFirstEitherK = tapEither;
/**
 * Constructs a new `Option` from a nullable type. If the value is `null` or `undefined`, returns `None`, otherwise
 * returns the value wrapped in a `Some`.
 *
 * @example
 * import { none, some, fromNullable } from 'fp-ts/Option'
 *
 * assert.deepStrictEqual(fromNullable(undefined), none)
 * assert.deepStrictEqual(fromNullable(null), none)
 * assert.deepStrictEqual(fromNullable(1), some(1))
 *
 * @category conversions
 * @since 2.0.0
 */
var fromNullable = function (a) { return (a == null ? none : some(a)); };
/**
 * Transforms an exception into an `Option`. If `f` throws, returns `None`, otherwise returns the output wrapped in a
 * `Some`.
 *
 * See also [`tryCatchK`](#trycatchk).
 *
 * @example
 * import { none, some, tryCatch } from 'fp-ts/Option'
 *
 * assert.deepStrictEqual(
 *   tryCatch(() => {
 *     throw new Error()
 *   }),
 *   none
 * )
 * assert.deepStrictEqual(tryCatch(() => 1), some(1))
 *
 * @category interop
 * @since 2.0.0
 */
var tryCatch = function (f) {
    try {
        return some(f());
    }
    catch (e) {
        return none;
    }
};
/**
 * Converts a function that may throw to one returning a `Option`.
 *
 * @category interop
 * @since 2.10.0
 */
var tryCatchK = function (f) {
    return function () {
        var a = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            a[_i] = arguments[_i];
        }
        return tryCatch(function () { return f.apply(void 0, a); });
    };
};
/**
 * Returns a *smart constructor* from a function that returns a nullable value.
 *
 * @example
 * import { fromNullableK, none, some } from 'fp-ts/Option'
 *
 * const f = (s: string): number | undefined => {
 *   const n = parseFloat(s)
 *   return isNaN(n) ? undefined : n
 * }
 *
 * const g = fromNullableK(f)
 *
 * assert.deepStrictEqual(g('1'), some(1))
 * assert.deepStrictEqual(g('a'), none)
 *
 * @category lifting
 * @since 2.9.0
 */
var fromNullableK = function (f) { return (0,_function__WEBPACK_IMPORTED_MODULE_1__.flow)(f, fromNullable); };
/**
 * This is `chain` + `fromNullable`, useful when working with optional values.
 *
 * @example
 * import { some, none, fromNullable, chainNullableK } from 'fp-ts/Option'
 * import { pipe } from 'fp-ts/function'
 *
 * interface Employee {
 *   readonly company?: {
 *     readonly address?: {
 *       readonly street?: {
 *         readonly name?: string
 *       }
 *     }
 *   }
 * }
 *
 * const employee1: Employee = { company: { address: { street: { name: 'high street' } } } }
 *
 * assert.deepStrictEqual(
 *   pipe(
 *     fromNullable(employee1.company),
 *     chainNullableK(company => company.address),
 *     chainNullableK(address => address.street),
 *     chainNullableK(street => street.name)
 *   ),
 *   some('high street')
 * )
 *
 * const employee2: Employee = { company: { address: { street: {} } } }
 *
 * assert.deepStrictEqual(
 *   pipe(
 *     fromNullable(employee2.company),
 *     chainNullableK(company => company.address),
 *     chainNullableK(address => address.street),
 *     chainNullableK(street => street.name)
 *   ),
 *   none
 * )
 *
 * @category sequencing
 * @since 2.9.0
 */
var chainNullableK = function (f) {
    return function (ma) {
        return isNone(ma) ? none : fromNullable(f(ma.value));
    };
};
/**
 * Extracts the value out of the structure, if it exists. Otherwise returns `null`.
 *
 * @example
 * import { some, none, toNullable } from 'fp-ts/Option'
 * import { pipe } from 'fp-ts/function'
 *
 * assert.strictEqual(
 *   pipe(
 *     some(1),
 *     toNullable
 *   ),
 *   1
 * )
 * assert.strictEqual(
 *   pipe(
 *     none,
 *     toNullable
 *   ),
 *   null
 * )
 *
 * @category conversions
 * @since 2.0.0
 */
var toNullable = /*#__PURE__*/ match(_function__WEBPACK_IMPORTED_MODULE_1__.constNull, _function__WEBPACK_IMPORTED_MODULE_1__.identity);
/**
 * Extracts the value out of the structure, if it exists. Otherwise returns `undefined`.
 *
 * @example
 * import { some, none, toUndefined } from 'fp-ts/Option'
 * import { pipe } from 'fp-ts/function'
 *
 * assert.strictEqual(
 *   pipe(
 *     some(1),
 *     toUndefined
 *   ),
 *   1
 * )
 * assert.strictEqual(
 *   pipe(
 *     none,
 *     toUndefined
 *   ),
 *   undefined
 * )
 *
 * @category conversions
 * @since 2.0.0
 */
var toUndefined = /*#__PURE__*/ match(_function__WEBPACK_IMPORTED_MODULE_1__.constUndefined, _function__WEBPACK_IMPORTED_MODULE_1__.identity);
function elem(E) {
    return function (a, ma) {
        if (ma === undefined) {
            var elemE_1 = elem(E);
            return function (ma) { return elemE_1(a, ma); };
        }
        return isNone(ma) ? false : E.equals(a, ma.value);
    };
}
/**
 * Returns `true` if the predicate is satisfied by the wrapped value
 *
 * @example
 * import { some, none, exists } from 'fp-ts/Option'
 * import { pipe } from 'fp-ts/function'
 *
 * assert.strictEqual(
 *   pipe(
 *     some(1),
 *     exists(n => n > 0)
 *   ),
 *   true
 * )
 * assert.strictEqual(
 *   pipe(
 *     some(1),
 *     exists(n => n > 1)
 *   ),
 *   false
 * )
 * assert.strictEqual(
 *   pipe(
 *     none,
 *     exists(n => n > 0)
 *   ),
 *   false
 * )
 *
 * @since 2.0.0
 */
var exists = function (predicate) {
    return function (ma) {
        return isNone(ma) ? false : predicate(ma.value);
    };
};
// -------------------------------------------------------------------------------------
// do notation
// -------------------------------------------------------------------------------------
/**
 * @category do notation
 * @since 2.9.0
 */
var Do = /*#__PURE__*/ of(_internal__WEBPACK_IMPORTED_MODULE_0__.emptyRecord);
/**
 * @category do notation
 * @since 2.8.0
 */
var bindTo = /*#__PURE__*/ (0,_Functor__WEBPACK_IMPORTED_MODULE_2__.bindTo)(Functor);
var let_ = /*#__PURE__*/ (0,_Functor__WEBPACK_IMPORTED_MODULE_2__["let"])(Functor);

/**
 * @category do notation
 * @since 2.8.0
 */
var bind = /*#__PURE__*/ _Chain__WEBPACK_IMPORTED_MODULE_8__.bind(Chain);
/**
 * @category do notation
 * @since 2.8.0
 */
var apS = /*#__PURE__*/ (0,_Apply__WEBPACK_IMPORTED_MODULE_7__.apS)(Apply);
/**
 * @since 2.11.0
 */
var ApT = /*#__PURE__*/ of(_internal__WEBPACK_IMPORTED_MODULE_0__.emptyReadonlyArray);
// -------------------------------------------------------------------------------------
// array utils
// -------------------------------------------------------------------------------------
/**
 * Equivalent to `ReadonlyNonEmptyArray#traverseWithIndex(Applicative)`.
 *
 * @category traversing
 * @since 2.11.0
 */
var traverseReadonlyNonEmptyArrayWithIndex = function (f) {
    return function (as) {
        var o = f(0, _internal__WEBPACK_IMPORTED_MODULE_0__.head(as));
        if (isNone(o)) {
            return none;
        }
        var out = [o.value];
        for (var i = 1; i < as.length; i++) {
            var o_1 = f(i, as[i]);
            if (isNone(o_1)) {
                return none;
            }
            out.push(o_1.value);
        }
        return some(out);
    };
};
/**
 * Equivalent to `ReadonlyArray#traverseWithIndex(Applicative)`.
 *
 * @category traversing
 * @since 2.11.0
 */
var traverseReadonlyArrayWithIndex = function (f) {
    var g = traverseReadonlyNonEmptyArrayWithIndex(f);
    return function (as) { return (_internal__WEBPACK_IMPORTED_MODULE_0__.isNonEmpty(as) ? g(as) : ApT); };
};
/**
 * Equivalent to `ReadonlyArray#traverseWithIndex(Applicative)`.
 *
 * @category traversing
 * @since 2.9.0
 */
var traverseArrayWithIndex = traverseReadonlyArrayWithIndex;
/**
 * Equivalent to `ReadonlyArray#traverse(Applicative)`.
 *
 * @category traversing
 * @since 2.9.0
 */
var traverseArray = function (f) {
    return traverseReadonlyArrayWithIndex(function (_, a) { return f(a); });
};
/**
 * Equivalent to `ReadonlyArray#sequence(Applicative)`.
 *
 * @category traversing
 * @since 2.9.0
 */
var sequenceArray = 
/*#__PURE__*/ traverseArray(_function__WEBPACK_IMPORTED_MODULE_1__.identity);
// -------------------------------------------------------------------------------------
// legacy
// -------------------------------------------------------------------------------------
/**
 * Alias of `flatMap`.
 *
 * @category legacy
 * @since 2.0.0
 */
var chain = flatMap;
/**
 * Alias of `tap`.
 *
 * @category legacy
 * @since 2.0.0
 */
var chainFirst = tap;
// -------------------------------------------------------------------------------------
// deprecated
// -------------------------------------------------------------------------------------
/**
 * Use `Refinement` module instead.
 *
 * @category zone of death
 * @since 2.0.0
 * @deprecated
 */
function getRefinement(getOption) {
    return function (a) { return isSome(getOption(a)); };
}
/**
 * Use [`chainNullableK`](#chainnullablek) instead.
 *
 * @category zone of death
 * @since 2.0.0
 * @deprecated
 */
var mapNullable = chainNullableK;
/**
 * This instance is deprecated, use small, specific instances instead.
 * For example if a function needs a `Functor` instance, pass `O.Functor` instead of `O.option`
 * (where `O` is from `import O from 'fp-ts/Option'`)
 *
 * @category zone of death
 * @since 2.0.0
 * @deprecated
 */
var option = {
    URI: URI,
    map: _map,
    of: of,
    ap: _ap,
    chain: flatMap,
    reduce: _reduce,
    foldMap: _foldMap,
    reduceRight: _reduceRight,
    traverse: _traverse,
    sequence: sequence,
    zero: zero,
    alt: _alt,
    extend: _extend,
    compact: compact,
    separate: separate,
    filter: _filter,
    filterMap: _filterMap,
    partition: _partition,
    partitionMap: _partitionMap,
    wither: _wither,
    wilt: _wilt,
    throwError: throwError
};
/**
 * Use [`getApplySemigroup`](./Apply.ts.html#getapplysemigroup) instead.
 *
 * @category zone of death
 * @since 2.0.0
 * @deprecated
 */
var getApplySemigroup = /*#__PURE__*/ (0,_Apply__WEBPACK_IMPORTED_MODULE_7__.getApplySemigroup)(Apply);
/**
 * Use [`getApplicativeMonoid`](./Applicative.ts.html#getapplicativemonoid) instead.
 *
 * @category zone of death
 * @since 2.0.0
 * @deprecated
 */
var getApplyMonoid = /*#__PURE__*/ (0,_Applicative__WEBPACK_IMPORTED_MODULE_10__.getApplicativeMonoid)(Applicative);
/**
 * Use
 *
 * ```ts
 * import { first } from 'fp-ts/Semigroup'
 * import { getMonoid } from 'fp-ts/Option'
 *
 * getMonoid(first())
 * ```
 *
 * instead.
 *
 * Monoid returning the left-most non-`None` value
 *
 * | x       | y       | concat(x, y) |
 * | ------- | ------- | ------------ |
 * | none    | none    | none         |
 * | some(a) | none    | some(a)      |
 * | none    | some(b) | some(b)      |
 * | some(a) | some(b) | some(a)      |
 *
 * @example
 * import { getFirstMonoid, some, none } from 'fp-ts/Option'
 *
 * const M = getFirstMonoid<number>()
 * assert.deepStrictEqual(M.concat(none, none), none)
 * assert.deepStrictEqual(M.concat(some(1), none), some(1))
 * assert.deepStrictEqual(M.concat(none, some(2)), some(2))
 * assert.deepStrictEqual(M.concat(some(1), some(2)), some(1))
 *
 * @category zone of death
 * @since 2.0.0
 * @deprecated
 */
var getFirstMonoid = function () { return getMonoid((0,_Semigroup__WEBPACK_IMPORTED_MODULE_11__.first)()); };
/**
 * Use
 *
 * ```ts
 * import { last } from 'fp-ts/Semigroup'
 * import { getMonoid } from 'fp-ts/Option'
 *
 * getMonoid(last())
 * ```
 *
 * instead.
 *
 * Monoid returning the right-most non-`None` value
 *
 * | x       | y       | concat(x, y) |
 * | ------- | ------- | ------------ |
 * | none    | none    | none         |
 * | some(a) | none    | some(a)      |
 * | none    | some(b) | some(b)      |
 * | some(a) | some(b) | some(b)      |
 *
 * @example
 * import { getLastMonoid, some, none } from 'fp-ts/Option'
 *
 * const M = getLastMonoid<number>()
 * assert.deepStrictEqual(M.concat(none, none), none)
 * assert.deepStrictEqual(M.concat(some(1), none), some(1))
 * assert.deepStrictEqual(M.concat(none, some(2)), some(2))
 * assert.deepStrictEqual(M.concat(some(1), some(2)), some(2))
 *
 * @category zone of death
 * @since 2.0.0
 * @deprecated
 */
var getLastMonoid = function () { return getMonoid((0,_Semigroup__WEBPACK_IMPORTED_MODULE_11__.last)()); };


/***/ }),

/***/ "./node_modules/fp-ts/es6/Ord.js":
/*!***************************************!*\
  !*** ./node_modules/fp-ts/es6/Ord.js ***!
  \***************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Contravariant: () => (/* binding */ Contravariant),
/* harmony export */   URI: () => (/* binding */ URI),
/* harmony export */   between: () => (/* binding */ between),
/* harmony export */   clamp: () => (/* binding */ clamp),
/* harmony export */   contramap: () => (/* binding */ contramap),
/* harmony export */   equals: () => (/* binding */ equals),
/* harmony export */   equalsDefault: () => (/* binding */ equalsDefault),
/* harmony export */   fromCompare: () => (/* binding */ fromCompare),
/* harmony export */   geq: () => (/* binding */ geq),
/* harmony export */   getDualOrd: () => (/* binding */ getDualOrd),
/* harmony export */   getMonoid: () => (/* binding */ getMonoid),
/* harmony export */   getSemigroup: () => (/* binding */ getSemigroup),
/* harmony export */   getTupleOrd: () => (/* binding */ getTupleOrd),
/* harmony export */   gt: () => (/* binding */ gt),
/* harmony export */   leq: () => (/* binding */ leq),
/* harmony export */   lt: () => (/* binding */ lt),
/* harmony export */   max: () => (/* binding */ max),
/* harmony export */   min: () => (/* binding */ min),
/* harmony export */   ord: () => (/* binding */ ord),
/* harmony export */   ordBoolean: () => (/* binding */ ordBoolean),
/* harmony export */   ordDate: () => (/* binding */ ordDate),
/* harmony export */   ordNumber: () => (/* binding */ ordNumber),
/* harmony export */   ordString: () => (/* binding */ ordString),
/* harmony export */   reverse: () => (/* binding */ reverse),
/* harmony export */   trivial: () => (/* binding */ trivial),
/* harmony export */   tuple: () => (/* binding */ tuple)
/* harmony export */ });
/* harmony import */ var _Eq__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Eq */ "./node_modules/fp-ts/es6/Eq.js");
/* harmony import */ var _function__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./function */ "./node_modules/fp-ts/es6/function.js");


// -------------------------------------------------------------------------------------
// defaults
// -------------------------------------------------------------------------------------
/**
 * @category defaults
 * @since 2.10.0
 */
var equalsDefault = function (compare) {
    return function (first, second) {
        return first === second || compare(first, second) === 0;
    };
};
// -------------------------------------------------------------------------------------
// constructors
// -------------------------------------------------------------------------------------
/**
 * @category constructors
 * @since 2.0.0
 */
var fromCompare = function (compare) { return ({
    equals: equalsDefault(compare),
    compare: function (first, second) { return (first === second ? 0 : compare(first, second)); }
}); };
// -------------------------------------------------------------------------------------
// combinators
// -------------------------------------------------------------------------------------
/**
 * Given a tuple of `Ord`s returns an `Ord` for the tuple.
 *
 * @example
 * import { tuple } from 'fp-ts/Ord'
 * import * as B from 'fp-ts/boolean'
 * import * as S from 'fp-ts/string'
 * import * as N from 'fp-ts/number'
 *
 * const O = tuple(S.Ord, N.Ord, B.Ord)
 * assert.strictEqual(O.compare(['a', 1, true], ['b', 2, true]), -1)
 * assert.strictEqual(O.compare(['a', 1, true], ['a', 2, true]), -1)
 * assert.strictEqual(O.compare(['a', 1, true], ['a', 1, false]), 1)
 *
 * @since 2.10.0
 */
var tuple = function () {
    var ords = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        ords[_i] = arguments[_i];
    }
    return fromCompare(function (first, second) {
        var i = 0;
        for (; i < ords.length - 1; i++) {
            var r = ords[i].compare(first[i], second[i]);
            if (r !== 0) {
                return r;
            }
        }
        return ords[i].compare(first[i], second[i]);
    });
};
/**
 * @since 2.10.0
 */
var reverse = function (O) { return fromCompare(function (first, second) { return O.compare(second, first); }); };
/* istanbul ignore next */
var contramap_ = function (fa, f) { return (0,_function__WEBPACK_IMPORTED_MODULE_0__.pipe)(fa, contramap(f)); };
/**
 * A typical use case for `contramap` would be like, given some `User` type, to construct an `Ord<User>`.
 *
 * We can do so with a function from `User -> X` where `X` is some value that we know how to compare
 * for ordering (meaning we have an `Ord<X>`)
 *
 * For example, given the following `User` type, there are lots of possible choices for `X`,
 * but let's say we want to sort a list of users by `lastName`.
 *
 * If we have a way of comparing `lastName`s for ordering (`ordLastName: Ord<string>`) and we know how to go from `User -> string`,
 * using `contramap` we can do this
 *
 * @example
 * import { pipe } from 'fp-ts/function'
 * import { contramap, Ord } from 'fp-ts/Ord'
 * import * as RA from 'fp-ts/ReadonlyArray'
 * import * as S from 'fp-ts/string'
 *
 * interface User {
 *   readonly firstName: string
 *   readonly lastName: string
 * }
 *
 * const ordLastName: Ord<string> = S.Ord
 *
 * const ordByLastName: Ord<User> = pipe(
 *   ordLastName,
 *   contramap((user) => user.lastName)
 * )
 *
 * assert.deepStrictEqual(
 *   RA.sort(ordByLastName)([
 *     { firstName: 'a', lastName: 'd' },
 *     { firstName: 'c', lastName: 'b' }
 *   ]),
 *   [
 *     { firstName: 'c', lastName: 'b' },
 *     { firstName: 'a', lastName: 'd' }
 *   ]
 * )
 *
 * @since 2.0.0
 */
var contramap = function (f) { return function (fa) {
    return fromCompare(function (first, second) { return fa.compare(f(first), f(second)); });
}; };
/**
 * @category type lambdas
 * @since 2.0.0
 */
var URI = 'Ord';
/**
 * A typical use case for the `Semigroup` instance of `Ord` is merging two or more orderings.
 *
 * For example the following snippet builds an `Ord` for a type `User` which
 * sorts by `created` date descending, and **then** `lastName`
 *
 * @example
 * import * as D from 'fp-ts/Date'
 * import { pipe } from 'fp-ts/function'
 * import { contramap, getSemigroup, Ord, reverse } from 'fp-ts/Ord'
 * import * as RA from 'fp-ts/ReadonlyArray'
 * import * as S from 'fp-ts/string'
 *
 * interface User {
 *   readonly id: string
 *   readonly lastName: string
 *   readonly created: Date
 * }
 *
 * const ordByLastName: Ord<User> = pipe(
 *   S.Ord,
 *   contramap((user) => user.lastName)
 * )
 *
 * const ordByCreated: Ord<User> = pipe(
 *   D.Ord,
 *   contramap((user) => user.created)
 * )
 *
 * const ordUserByCreatedDescThenLastName = getSemigroup<User>().concat(
 *   reverse(ordByCreated),
 *   ordByLastName
 * )
 *
 * assert.deepStrictEqual(
 *   RA.sort(ordUserByCreatedDescThenLastName)([
 *     { id: 'c', lastName: 'd', created: new Date(1973, 10, 30) },
 *     { id: 'a', lastName: 'b', created: new Date(1973, 10, 30) },
 *     { id: 'e', lastName: 'f', created: new Date(1980, 10, 30) }
 *   ]),
 *   [
 *     { id: 'e', lastName: 'f', created: new Date(1980, 10, 30) },
 *     { id: 'a', lastName: 'b', created: new Date(1973, 10, 30) },
 *     { id: 'c', lastName: 'd', created: new Date(1973, 10, 30) }
 *   ]
 * )
 *
 * @category instances
 * @since 2.0.0
 */
var getSemigroup = function () { return ({
    concat: function (first, second) {
        return fromCompare(function (a, b) {
            var ox = first.compare(a, b);
            return ox !== 0 ? ox : second.compare(a, b);
        });
    }
}); };
/**
 * Returns a `Monoid` such that:
 *
 * - its `concat(ord1, ord2)` operation will order first by `ord1`, and then by `ord2`
 * - its `empty` value is an `Ord` that always considers compared elements equal
 *
 * @example
 * import { sort } from 'fp-ts/Array'
 * import { contramap, reverse, getMonoid } from 'fp-ts/Ord'
 * import * as S from 'fp-ts/string'
 * import * as B from 'fp-ts/boolean'
 * import { pipe } from 'fp-ts/function'
 * import { concatAll } from 'fp-ts/Monoid'
 * import * as N from 'fp-ts/number'
 *
 * interface User {
 *   readonly id: number
 *   readonly name: string
 *   readonly age: number
 *   readonly rememberMe: boolean
 * }
 *
 * const byName = pipe(
 *   S.Ord,
 *   contramap((p: User) => p.name)
 * )
 *
 * const byAge = pipe(
 *   N.Ord,
 *   contramap((p: User) => p.age)
 * )
 *
 * const byRememberMe = pipe(
 *   B.Ord,
 *   contramap((p: User) => p.rememberMe)
 * )
 *
 * const M = getMonoid<User>()
 *
 * const users: Array<User> = [
 *   { id: 1, name: 'Guido', age: 47, rememberMe: false },
 *   { id: 2, name: 'Guido', age: 46, rememberMe: true },
 *   { id: 3, name: 'Giulio', age: 44, rememberMe: false },
 *   { id: 4, name: 'Giulio', age: 44, rememberMe: true }
 * ]
 *
 * // sort by name, then by age, then by `rememberMe`
 * const O1 = concatAll(M)([byName, byAge, byRememberMe])
 * assert.deepStrictEqual(sort(O1)(users), [
 *   { id: 3, name: 'Giulio', age: 44, rememberMe: false },
 *   { id: 4, name: 'Giulio', age: 44, rememberMe: true },
 *   { id: 2, name: 'Guido', age: 46, rememberMe: true },
 *   { id: 1, name: 'Guido', age: 47, rememberMe: false }
 * ])
 *
 * // now `rememberMe = true` first, then by name, then by age
 * const O2 = concatAll(M)([reverse(byRememberMe), byName, byAge])
 * assert.deepStrictEqual(sort(O2)(users), [
 *   { id: 4, name: 'Giulio', age: 44, rememberMe: true },
 *   { id: 2, name: 'Guido', age: 46, rememberMe: true },
 *   { id: 3, name: 'Giulio', age: 44, rememberMe: false },
 *   { id: 1, name: 'Guido', age: 47, rememberMe: false }
 * ])
 *
 * @category instances
 * @since 2.4.0
 */
var getMonoid = function () { return ({
    concat: getSemigroup().concat,
    empty: fromCompare(function () { return 0; })
}); };
/**
 * @category instances
 * @since 2.7.0
 */
var Contravariant = {
    URI: URI,
    contramap: contramap_
};
// -------------------------------------------------------------------------------------
// utils
// -------------------------------------------------------------------------------------
/**
 * @since 2.11.0
 */
var trivial = {
    equals: _function__WEBPACK_IMPORTED_MODULE_0__.constTrue,
    compare: /*#__PURE__*/ (0,_function__WEBPACK_IMPORTED_MODULE_0__.constant)(0)
};
/**
 * @since 2.11.0
 */
var equals = function (O) {
    return function (second) {
        return function (first) {
            return first === second || O.compare(first, second) === 0;
        };
    };
};
// TODO: curry in v3
/**
 * Test whether one value is _strictly less than_ another
 *
 * @since 2.0.0
 */
var lt = function (O) {
    return function (first, second) {
        return O.compare(first, second) === -1;
    };
};
// TODO: curry in v3
/**
 * Test whether one value is _strictly greater than_ another
 *
 * @since 2.0.0
 */
var gt = function (O) {
    return function (first, second) {
        return O.compare(first, second) === 1;
    };
};
// TODO: curry in v3
/**
 * Test whether one value is _non-strictly less than_ another
 *
 * @since 2.0.0
 */
var leq = function (O) {
    return function (first, second) {
        return O.compare(first, second) !== 1;
    };
};
// TODO: curry in v3
/**
 * Test whether one value is _non-strictly greater than_ another
 *
 * @since 2.0.0
 */
var geq = function (O) {
    return function (first, second) {
        return O.compare(first, second) !== -1;
    };
};
// TODO: curry in v3
/**
 * Take the minimum of two values. If they are considered equal, the first argument is chosen
 *
 * @since 2.0.0
 */
var min = function (O) {
    return function (first, second) {
        return first === second || O.compare(first, second) < 1 ? first : second;
    };
};
// TODO: curry in v3
/**
 * Take the maximum of two values. If they are considered equal, the first argument is chosen
 *
 * @since 2.0.0
 */
var max = function (O) {
    return function (first, second) {
        return first === second || O.compare(first, second) > -1 ? first : second;
    };
};
/**
 * Clamp a value between a minimum and a maximum
 *
 * @since 2.0.0
 */
var clamp = function (O) {
    var minO = min(O);
    var maxO = max(O);
    return function (low, hi) { return function (a) { return maxO(minO(a, hi), low); }; };
};
/**
 * Test whether a value is between a minimum and a maximum (inclusive)
 *
 * @since 2.0.0
 */
var between = function (O) {
    var ltO = lt(O);
    var gtO = gt(O);
    return function (low, hi) { return function (a) { return ltO(a, low) || gtO(a, hi) ? false : true; }; };
};
// -------------------------------------------------------------------------------------
// deprecated
// -------------------------------------------------------------------------------------
/**
 * Use [`tuple`](#tuple) instead.
 *
 * @category zone of death
 * @since 2.0.0
 * @deprecated
 */
var getTupleOrd = tuple;
/**
 * Use [`reverse`](#reverse) instead.
 *
 * @category zone of death
 * @since 2.0.0
 * @deprecated
 */
var getDualOrd = reverse;
/**
 * Use [`Contravariant`](#contravariant) instead.
 *
 * @category zone of death
 * @since 2.0.0
 * @deprecated
 */
var ord = Contravariant;
// default compare for primitive types
function compare(first, second) {
    return first < second ? -1 : first > second ? 1 : 0;
}
var strictOrd = {
    equals: _Eq__WEBPACK_IMPORTED_MODULE_1__.eqStrict.equals,
    compare: compare
};
/**
 * Use [`Ord`](./boolean.ts.html#ord) instead.
 *
 * @category zone of death
 * @since 2.0.0
 * @deprecated
 */
var ordBoolean = strictOrd;
/**
 * Use [`Ord`](./string.ts.html#ord) instead.
 *
 * @category zone of death
 * @since 2.0.0
 * @deprecated
 */
var ordString = strictOrd;
/**
 * Use [`Ord`](./number.ts.html#ord) instead.
 *
 * @category zone of death
 * @since 2.0.0
 * @deprecated
 */
var ordNumber = strictOrd;
/**
 * Use [`Ord`](./Date.ts.html#ord) instead.
 *
 * @category zone of death
 * @since 2.0.0
 * @deprecated
 */
var ordDate = /*#__PURE__*/ (0,_function__WEBPACK_IMPORTED_MODULE_0__.pipe)(ordNumber, 
/*#__PURE__*/
contramap(function (date) { return date.valueOf(); }));


/***/ }),

/***/ "./node_modules/fp-ts/es6/Predicate.js":
/*!*********************************************!*\
  !*** ./node_modules/fp-ts/es6/Predicate.js ***!
  \*********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Contravariant: () => (/* binding */ Contravariant),
/* harmony export */   URI: () => (/* binding */ URI),
/* harmony export */   and: () => (/* binding */ and),
/* harmony export */   contramap: () => (/* binding */ contramap),
/* harmony export */   getMonoidAll: () => (/* binding */ getMonoidAll),
/* harmony export */   getMonoidAny: () => (/* binding */ getMonoidAny),
/* harmony export */   getSemigroupAll: () => (/* binding */ getSemigroupAll),
/* harmony export */   getSemigroupAny: () => (/* binding */ getSemigroupAny),
/* harmony export */   not: () => (/* binding */ not),
/* harmony export */   or: () => (/* binding */ or)
/* harmony export */ });
/* harmony import */ var _function__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./function */ "./node_modules/fp-ts/es6/function.js");

var contramap_ = function (predicate, f) { return (0,_function__WEBPACK_IMPORTED_MODULE_0__.pipe)(predicate, contramap(f)); };
/**
 * @since 2.11.0
 */
var contramap = function (f) {
    return function (predicate) {
        return (0,_function__WEBPACK_IMPORTED_MODULE_0__.flow)(f, predicate);
    };
};
/**
 * @category type lambdas
 * @since 2.11.0
 */
var URI = 'Predicate';
/**
 * @category instances
 * @since 2.11.0
 */
var getSemigroupAny = function () { return ({
    concat: function (first, second) { return (0,_function__WEBPACK_IMPORTED_MODULE_0__.pipe)(first, or(second)); }
}); };
/**
 * @category instances
 * @since 2.11.0
 */
var getMonoidAny = function () { return ({
    concat: getSemigroupAny().concat,
    empty: _function__WEBPACK_IMPORTED_MODULE_0__.constFalse
}); };
/**
 * @category instances
 * @since 2.11.0
 */
var getSemigroupAll = function () { return ({
    concat: function (first, second) { return (0,_function__WEBPACK_IMPORTED_MODULE_0__.pipe)(first, and(second)); }
}); };
/**
 * @category instances
 * @since 2.11.0
 */
var getMonoidAll = function () { return ({
    concat: getSemigroupAll().concat,
    empty: _function__WEBPACK_IMPORTED_MODULE_0__.constTrue
}); };
/**
 * @category instances
 * @since 2.11.0
 */
var Contravariant = {
    URI: URI,
    contramap: contramap_
};
// -------------------------------------------------------------------------------------
// utils
// -------------------------------------------------------------------------------------
/**
 * @since 2.11.0
 */
var not = function (predicate) {
    return function (a) {
        return !predicate(a);
    };
};
/**
 * @since 2.11.0
 */
var or = function (second) {
    return function (first) {
        return function (a) {
            return first(a) || second(a);
        };
    };
};
/**
 * @since 2.11.0
 */
var and = function (second) {
    return function (first) {
        return function (a) {
            return first(a) && second(a);
        };
    };
};


/***/ }),

/***/ "./node_modules/fp-ts/es6/ReadonlyArray.js":
/*!*************************************************!*\
  !*** ./node_modules/fp-ts/es6/ReadonlyArray.js ***!
  \*************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Alt: () => (/* binding */ Alt),
/* harmony export */   Alternative: () => (/* binding */ Alternative),
/* harmony export */   Applicative: () => (/* binding */ Applicative),
/* harmony export */   Apply: () => (/* binding */ Apply),
/* harmony export */   Chain: () => (/* binding */ Chain),
/* harmony export */   ChainRecBreadthFirst: () => (/* binding */ ChainRecBreadthFirst),
/* harmony export */   ChainRecDepthFirst: () => (/* binding */ ChainRecDepthFirst),
/* harmony export */   Compactable: () => (/* binding */ Compactable),
/* harmony export */   Do: () => (/* binding */ Do),
/* harmony export */   Extend: () => (/* binding */ Extend),
/* harmony export */   Filterable: () => (/* binding */ Filterable),
/* harmony export */   FilterableWithIndex: () => (/* binding */ FilterableWithIndex),
/* harmony export */   Foldable: () => (/* binding */ Foldable),
/* harmony export */   FoldableWithIndex: () => (/* binding */ FoldableWithIndex),
/* harmony export */   FromEither: () => (/* binding */ FromEither),
/* harmony export */   Functor: () => (/* binding */ Functor),
/* harmony export */   FunctorWithIndex: () => (/* binding */ FunctorWithIndex),
/* harmony export */   Monad: () => (/* binding */ Monad),
/* harmony export */   Pointed: () => (/* binding */ Pointed),
/* harmony export */   Traversable: () => (/* binding */ Traversable),
/* harmony export */   TraversableWithIndex: () => (/* binding */ TraversableWithIndex),
/* harmony export */   URI: () => (/* binding */ URI),
/* harmony export */   Unfoldable: () => (/* binding */ Unfoldable),
/* harmony export */   Witherable: () => (/* binding */ Witherable),
/* harmony export */   Zero: () => (/* binding */ Zero),
/* harmony export */   _chainRecBreadthFirst: () => (/* binding */ _chainRecBreadthFirst),
/* harmony export */   _chainRecDepthFirst: () => (/* binding */ _chainRecDepthFirst),
/* harmony export */   alt: () => (/* binding */ alt),
/* harmony export */   altW: () => (/* binding */ altW),
/* harmony export */   ap: () => (/* binding */ ap),
/* harmony export */   apFirst: () => (/* binding */ apFirst),
/* harmony export */   apS: () => (/* binding */ apS),
/* harmony export */   apSecond: () => (/* binding */ apSecond),
/* harmony export */   append: () => (/* binding */ append),
/* harmony export */   appendW: () => (/* binding */ appendW),
/* harmony export */   bind: () => (/* binding */ bind),
/* harmony export */   bindTo: () => (/* binding */ bindTo),
/* harmony export */   chain: () => (/* binding */ chain),
/* harmony export */   chainFirst: () => (/* binding */ chainFirst),
/* harmony export */   chainRecBreadthFirst: () => (/* binding */ chainRecBreadthFirst),
/* harmony export */   chainRecDepthFirst: () => (/* binding */ chainRecDepthFirst),
/* harmony export */   chainWithIndex: () => (/* binding */ chainWithIndex),
/* harmony export */   chop: () => (/* binding */ chop),
/* harmony export */   chunksOf: () => (/* binding */ chunksOf),
/* harmony export */   compact: () => (/* binding */ compact),
/* harmony export */   comprehension: () => (/* binding */ comprehension),
/* harmony export */   concat: () => (/* binding */ concat),
/* harmony export */   concatW: () => (/* binding */ concatW),
/* harmony export */   cons: () => (/* binding */ cons),
/* harmony export */   deleteAt: () => (/* binding */ deleteAt),
/* harmony export */   difference: () => (/* binding */ difference),
/* harmony export */   dropLeft: () => (/* binding */ dropLeft),
/* harmony export */   dropLeftWhile: () => (/* binding */ dropLeftWhile),
/* harmony export */   dropRight: () => (/* binding */ dropRight),
/* harmony export */   duplicate: () => (/* binding */ duplicate),
/* harmony export */   elem: () => (/* binding */ elem),
/* harmony export */   empty: () => (/* binding */ empty),
/* harmony export */   every: () => (/* binding */ every),
/* harmony export */   exists: () => (/* binding */ exists),
/* harmony export */   extend: () => (/* binding */ extend),
/* harmony export */   filter: () => (/* binding */ filter),
/* harmony export */   filterE: () => (/* binding */ filterE),
/* harmony export */   filterMap: () => (/* binding */ filterMap),
/* harmony export */   filterMapWithIndex: () => (/* binding */ filterMapWithIndex),
/* harmony export */   filterWithIndex: () => (/* binding */ filterWithIndex),
/* harmony export */   findFirst: () => (/* binding */ findFirst),
/* harmony export */   findFirstMap: () => (/* binding */ findFirstMap),
/* harmony export */   findIndex: () => (/* binding */ findIndex),
/* harmony export */   findLast: () => (/* binding */ findLast),
/* harmony export */   findLastIndex: () => (/* binding */ findLastIndex),
/* harmony export */   findLastMap: () => (/* binding */ findLastMap),
/* harmony export */   flap: () => (/* binding */ flap),
/* harmony export */   flatMap: () => (/* binding */ flatMap),
/* harmony export */   flatten: () => (/* binding */ flatten),
/* harmony export */   foldLeft: () => (/* binding */ foldLeft),
/* harmony export */   foldMap: () => (/* binding */ foldMap),
/* harmony export */   foldMapWithIndex: () => (/* binding */ foldMapWithIndex),
/* harmony export */   foldRight: () => (/* binding */ foldRight),
/* harmony export */   fromArray: () => (/* binding */ fromArray),
/* harmony export */   fromEither: () => (/* binding */ fromEither),
/* harmony export */   fromEitherK: () => (/* binding */ fromEitherK),
/* harmony export */   fromOption: () => (/* binding */ fromOption),
/* harmony export */   fromOptionK: () => (/* binding */ fromOptionK),
/* harmony export */   fromPredicate: () => (/* binding */ fromPredicate),
/* harmony export */   getDifferenceMagma: () => (/* binding */ getDifferenceMagma),
/* harmony export */   getEq: () => (/* binding */ getEq),
/* harmony export */   getIntersectionSemigroup: () => (/* binding */ getIntersectionSemigroup),
/* harmony export */   getMonoid: () => (/* binding */ getMonoid),
/* harmony export */   getOrd: () => (/* binding */ getOrd),
/* harmony export */   getSemigroup: () => (/* binding */ getSemigroup),
/* harmony export */   getShow: () => (/* binding */ getShow),
/* harmony export */   getUnionMonoid: () => (/* binding */ getUnionMonoid),
/* harmony export */   getUnionSemigroup: () => (/* binding */ getUnionSemigroup),
/* harmony export */   guard: () => (/* binding */ guard),
/* harmony export */   head: () => (/* binding */ head),
/* harmony export */   init: () => (/* binding */ init),
/* harmony export */   insertAt: () => (/* binding */ insertAt),
/* harmony export */   intercalate: () => (/* binding */ intercalate),
/* harmony export */   intersection: () => (/* binding */ intersection),
/* harmony export */   intersperse: () => (/* binding */ intersperse),
/* harmony export */   isEmpty: () => (/* binding */ isEmpty),
/* harmony export */   isNonEmpty: () => (/* binding */ isNonEmpty),
/* harmony export */   isOutOfBound: () => (/* binding */ isOutOfBound),
/* harmony export */   last: () => (/* binding */ last),
/* harmony export */   lefts: () => (/* binding */ lefts),
/* harmony export */   "let": () => (/* binding */ let_),
/* harmony export */   lookup: () => (/* binding */ lookup),
/* harmony export */   makeBy: () => (/* binding */ makeBy),
/* harmony export */   map: () => (/* binding */ map),
/* harmony export */   mapWithIndex: () => (/* binding */ mapWithIndex),
/* harmony export */   match: () => (/* binding */ match),
/* harmony export */   matchLeft: () => (/* binding */ matchLeft),
/* harmony export */   matchLeftW: () => (/* binding */ matchLeftW),
/* harmony export */   matchRight: () => (/* binding */ matchRight),
/* harmony export */   matchRightW: () => (/* binding */ matchRightW),
/* harmony export */   matchW: () => (/* binding */ matchW),
/* harmony export */   modifyAt: () => (/* binding */ modifyAt),
/* harmony export */   of: () => (/* binding */ of),
/* harmony export */   partition: () => (/* binding */ partition),
/* harmony export */   partitionMap: () => (/* binding */ partitionMap),
/* harmony export */   partitionMapWithIndex: () => (/* binding */ partitionMapWithIndex),
/* harmony export */   partitionWithIndex: () => (/* binding */ partitionWithIndex),
/* harmony export */   prepend: () => (/* binding */ prepend),
/* harmony export */   prependAll: () => (/* binding */ prependAll),
/* harmony export */   prependToAll: () => (/* binding */ prependToAll),
/* harmony export */   prependW: () => (/* binding */ prependW),
/* harmony export */   range: () => (/* binding */ range),
/* harmony export */   readonlyArray: () => (/* binding */ readonlyArray),
/* harmony export */   reduce: () => (/* binding */ reduce),
/* harmony export */   reduceRight: () => (/* binding */ reduceRight),
/* harmony export */   reduceRightWithIndex: () => (/* binding */ reduceRightWithIndex),
/* harmony export */   reduceWithIndex: () => (/* binding */ reduceWithIndex),
/* harmony export */   replicate: () => (/* binding */ replicate),
/* harmony export */   reverse: () => (/* binding */ reverse),
/* harmony export */   rights: () => (/* binding */ rights),
/* harmony export */   rotate: () => (/* binding */ rotate),
/* harmony export */   scanLeft: () => (/* binding */ scanLeft),
/* harmony export */   scanRight: () => (/* binding */ scanRight),
/* harmony export */   separate: () => (/* binding */ separate),
/* harmony export */   sequence: () => (/* binding */ sequence),
/* harmony export */   size: () => (/* binding */ size),
/* harmony export */   snoc: () => (/* binding */ snoc),
/* harmony export */   some: () => (/* binding */ some),
/* harmony export */   sort: () => (/* binding */ sort),
/* harmony export */   sortBy: () => (/* binding */ sortBy),
/* harmony export */   spanLeft: () => (/* binding */ spanLeft),
/* harmony export */   splitAt: () => (/* binding */ splitAt),
/* harmony export */   tail: () => (/* binding */ tail),
/* harmony export */   takeLeft: () => (/* binding */ takeLeft),
/* harmony export */   takeLeftWhile: () => (/* binding */ takeLeftWhile),
/* harmony export */   takeRight: () => (/* binding */ takeRight),
/* harmony export */   toArray: () => (/* binding */ toArray),
/* harmony export */   traverse: () => (/* binding */ traverse),
/* harmony export */   traverseWithIndex: () => (/* binding */ traverseWithIndex),
/* harmony export */   unfold: () => (/* binding */ unfold),
/* harmony export */   union: () => (/* binding */ union),
/* harmony export */   uniq: () => (/* binding */ uniq),
/* harmony export */   unsafeDeleteAt: () => (/* binding */ unsafeDeleteAt),
/* harmony export */   unsafeInsertAt: () => (/* binding */ unsafeInsertAt),
/* harmony export */   unsafeUpdateAt: () => (/* binding */ unsafeUpdateAt),
/* harmony export */   unzip: () => (/* binding */ unzip),
/* harmony export */   updateAt: () => (/* binding */ updateAt),
/* harmony export */   wilt: () => (/* binding */ wilt),
/* harmony export */   wither: () => (/* binding */ wither),
/* harmony export */   zero: () => (/* binding */ zero),
/* harmony export */   zip: () => (/* binding */ zip),
/* harmony export */   zipWith: () => (/* binding */ zipWith)
/* harmony export */ });
/* harmony import */ var _Apply__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./Apply */ "./node_modules/fp-ts/es6/Apply.js");
/* harmony import */ var _Chain__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./Chain */ "./node_modules/fp-ts/es6/Chain.js");
/* harmony import */ var _Eq__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./Eq */ "./node_modules/fp-ts/es6/Eq.js");
/* harmony import */ var _FromEither__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./FromEither */ "./node_modules/fp-ts/es6/FromEither.js");
/* harmony import */ var _function__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./function */ "./node_modules/fp-ts/es6/function.js");
/* harmony import */ var _Functor__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./Functor */ "./node_modules/fp-ts/es6/Functor.js");
/* harmony import */ var _internal__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./internal */ "./node_modules/fp-ts/es6/internal.js");
/* harmony import */ var _number__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./number */ "./node_modules/fp-ts/es6/number.js");
/* harmony import */ var _Ord__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./Ord */ "./node_modules/fp-ts/es6/Ord.js");
/* harmony import */ var _ReadonlyNonEmptyArray__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./ReadonlyNonEmptyArray */ "./node_modules/fp-ts/es6/ReadonlyNonEmptyArray.js");
/* harmony import */ var _Separated__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Separated */ "./node_modules/fp-ts/es6/Separated.js");
/* harmony import */ var _Witherable__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./Witherable */ "./node_modules/fp-ts/es6/Witherable.js");
/* harmony import */ var _Zero__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./Zero */ "./node_modules/fp-ts/es6/Zero.js");
var __spreadArray = (undefined && undefined.__spreadArray) || function (to, from, pack) {
    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
        }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
};













// -------------------------------------------------------------------------------------
// refinements
// -------------------------------------------------------------------------------------
/**
 * Test whether a `ReadonlyArray` is empty.
 *
 * @example
 * import { isEmpty } from 'fp-ts/ReadonlyArray'
 *
 * assert.strictEqual(isEmpty([]), true)
 *
 * @category refinements
 * @since 2.5.0
 */
var isEmpty = function (as) { return as.length === 0; };
/**
 * Test whether a `ReadonlyArray` is non empty.
 *
 * @category refinements
 * @since 2.5.0
 */
var isNonEmpty = _ReadonlyNonEmptyArray__WEBPACK_IMPORTED_MODULE_0__.isNonEmpty;
// -------------------------------------------------------------------------------------
// constructors
// -------------------------------------------------------------------------------------
/**
 * Prepend an element to the front of a `ReadonlyArray`, creating a new `ReadonlyNonEmptyArray`.
 *
 * @example
 * import { prepend } from 'fp-ts/ReadonlyArray'
 * import { pipe } from 'fp-ts/function'
 *
 * assert.deepStrictEqual(pipe([2, 3, 4], prepend(1)), [1, 2, 3, 4])
 *
 * @since 2.10.0
 */
var prepend = _ReadonlyNonEmptyArray__WEBPACK_IMPORTED_MODULE_0__.prepend;
/**
 * Less strict version of [`prepend`](#prepend).
 *
 * @since 2.11.0
 */
var prependW = _ReadonlyNonEmptyArray__WEBPACK_IMPORTED_MODULE_0__.prependW;
/**
 * Append an element to the end of a `ReadonlyArray`, creating a new `ReadonlyNonEmptyArray`.
 *
 * @example
 * import { append } from 'fp-ts/ReadonlyArray'
 * import { pipe } from 'fp-ts/function'
 *
 * assert.deepStrictEqual(pipe([1, 2, 3], append(4)), [1, 2, 3, 4])
 *
 * @since 2.10.0
 */
var append = _ReadonlyNonEmptyArray__WEBPACK_IMPORTED_MODULE_0__.append;
/**
 * Less strict version of [`append`](#append).
 *
 * @since 2.11.0
 */
var appendW = _ReadonlyNonEmptyArray__WEBPACK_IMPORTED_MODULE_0__.appendW;
/**
 * Return a `ReadonlyArray` of length `n` with element `i` initialized with `f(i)`.
 *
 * **Note**. `n` is normalized to a non negative integer.
 *
 * @example
 * import { makeBy } from 'fp-ts/ReadonlyArray'
 *
 * const double = (n: number): number => n * 2
 * assert.deepStrictEqual(makeBy(5, double), [0, 2, 4, 6, 8])
 *
 * @category constructors
 * @since 2.5.0
 */
var makeBy = function (n, f) { return (n <= 0 ? empty : _ReadonlyNonEmptyArray__WEBPACK_IMPORTED_MODULE_0__.makeBy(f)(n)); };
/**
 * Create a `ReadonlyArray` containing a value repeated the specified number of times.
 *
 * **Note**. `n` is normalized to a non negative integer.
 *
 * @example
 * import { replicate } from 'fp-ts/ReadonlyArray'
 *
 * assert.deepStrictEqual(replicate(3, 'a'), ['a', 'a', 'a'])
 *
 * @category constructors
 * @since 2.5.0
 */
var replicate = function (n, a) { return makeBy(n, function () { return a; }); };
function fromPredicate(predicate) {
    return function (a) { return (predicate(a) ? [a] : empty); };
}
// -------------------------------------------------------------------------------------
// conversions
// -------------------------------------------------------------------------------------
/**
 * @category conversions
 * @since 2.11.0
 */
var fromOption = function (ma) { return (_internal__WEBPACK_IMPORTED_MODULE_1__.isNone(ma) ? empty : [ma.value]); };
/**
 * Transforms an `Either` to a `ReadonlyArray`.
 *
 * @category conversions
 * @since 2.11.0
 */
var fromEither = function (e) { return (_internal__WEBPACK_IMPORTED_MODULE_1__.isLeft(e) ? empty : [e.right]); };
/**
 * Less strict version of [`match`](#match).
 *
 * The `W` suffix (short for **W**idening) means that the handler return types will be merged.
 *
 * @category pattern matching
 * @since 2.11.0
 */
var matchW = function (onEmpty, onNonEmpty) {
    return function (as) {
        return isNonEmpty(as) ? onNonEmpty(as) : onEmpty();
    };
};
/**
 * @category pattern matching
 * @since 2.11.0
 */
var match = matchW;
/**
 * Less strict version of [`matchLeft`](#matchleft).
 *
 * @category pattern matching
 * @since 2.11.0
 */
var matchLeftW = function (onEmpty, onNonEmpty) {
    return function (as) {
        return isNonEmpty(as) ? onNonEmpty(_ReadonlyNonEmptyArray__WEBPACK_IMPORTED_MODULE_0__.head(as), _ReadonlyNonEmptyArray__WEBPACK_IMPORTED_MODULE_0__.tail(as)) : onEmpty();
    };
};
/**
 * Break a `ReadonlyArray` into its first element and remaining elements.
 *
 * @example
 * import { matchLeft } from 'fp-ts/ReadonlyArray'
 *
 * const len: <A>(as: ReadonlyArray<A>) => number = matchLeft(() => 0, (_, tail) => 1 + len(tail))
 * assert.strictEqual(len([1, 2, 3]), 3)
 *
 * @category pattern matching
 * @since 2.10.0
 */
var matchLeft = matchLeftW;
/**
 * Alias of [`matchLeft`](#matchleft).
 *
 * @category pattern matching
 * @since 2.5.0
 */
var foldLeft = matchLeft;
/**
 * Less strict version of [`matchRight`](#matchright).
 *
 * @category pattern matching
 * @since 2.11.0
 */
var matchRightW = function (onEmpty, onNonEmpty) {
    return function (as) {
        return isNonEmpty(as) ? onNonEmpty(_ReadonlyNonEmptyArray__WEBPACK_IMPORTED_MODULE_0__.init(as), _ReadonlyNonEmptyArray__WEBPACK_IMPORTED_MODULE_0__.last(as)) : onEmpty();
    };
};
/**
 * Break a `ReadonlyArray` into its initial elements and the last element.
 *
 * @category pattern matching
 * @since 2.10.0
 */
var matchRight = matchRightW;
/**
 * Alias of [`matchRight`](#matchright).
 *
 * @category pattern matching
 * @since 2.5.0
 */
var foldRight = matchRight;
// -------------------------------------------------------------------------------------
// combinators
// -------------------------------------------------------------------------------------
/**
 * @category sequencing
 * @since 2.7.0
 */
var chainWithIndex = function (f) {
    return function (as) {
        if (isEmpty(as)) {
            return empty;
        }
        var out = [];
        for (var i = 0; i < as.length; i++) {
            var bs = f(i, as[i]);
            for (var j = 0; j < bs.length; j++) {
                out.push(bs[j]);
            }
        }
        return out;
    };
};
/**
 * Same as `reduce` but it carries over the intermediate steps.
 *
 * @example
 * import { scanLeft } from 'fp-ts/ReadonlyArray'
 *
 * assert.deepStrictEqual(scanLeft(10, (b, a: number) => b - a)([1, 2, 3]), [10, 9, 7, 4])
 *
 * @since 2.5.0
 */
var scanLeft = function (b, f) {
    return function (as) {
        var len = as.length;
        var out = new Array(len + 1);
        out[0] = b;
        for (var i = 0; i < len; i++) {
            out[i + 1] = f(out[i], as[i]);
        }
        return out;
    };
};
/**
 * Fold an array from the right, keeping all intermediate results instead of only the final result
 *
 * @example
 * import { scanRight } from 'fp-ts/ReadonlyArray'
 *
 * assert.deepStrictEqual(scanRight(10, (a: number, b) => b - a)([1, 2, 3]), [4, 5, 7, 10])
 *
 * @since 2.5.0
 */
var scanRight = function (b, f) {
    return function (as) {
        var len = as.length;
        var out = new Array(len + 1);
        out[len] = b;
        for (var i = len - 1; i >= 0; i--) {
            out[i] = f(as[i], out[i + 1]);
        }
        return out;
    };
};
/**
 * Calculate the number of elements in a `ReadonlyArray`.
 *
 * @since 2.10.0
 */
var size = function (as) { return as.length; };
/**
 * Test whether an array contains a particular index
 *
 * @since 2.5.0
 */
var isOutOfBound = _ReadonlyNonEmptyArray__WEBPACK_IMPORTED_MODULE_0__.isOutOfBound;
function lookup(i, as) {
    return as === undefined ? function (as) { return lookup(i, as); } : isOutOfBound(i, as) ? _internal__WEBPACK_IMPORTED_MODULE_1__.none : _internal__WEBPACK_IMPORTED_MODULE_1__.some(as[i]);
}
/**
 * Get the first element in an array, or `None` if the array is empty
 *
 * @example
 * import { head } from 'fp-ts/ReadonlyArray'
 * import { some, none } from 'fp-ts/Option'
 *
 * assert.deepStrictEqual(head([1, 2, 3]), some(1))
 * assert.deepStrictEqual(head([]), none)
 *
 * @since 2.5.0
 */
var head = function (as) { return (isNonEmpty(as) ? _internal__WEBPACK_IMPORTED_MODULE_1__.some(_ReadonlyNonEmptyArray__WEBPACK_IMPORTED_MODULE_0__.head(as)) : _internal__WEBPACK_IMPORTED_MODULE_1__.none); };
/**
 * Get the last element in an array, or `None` if the array is empty
 *
 * @example
 * import { last } from 'fp-ts/ReadonlyArray'
 * import { some, none } from 'fp-ts/Option'
 *
 * assert.deepStrictEqual(last([1, 2, 3]), some(3))
 * assert.deepStrictEqual(last([]), none)
 *
 * @since 2.5.0
 */
var last = function (as) { return (isNonEmpty(as) ? _internal__WEBPACK_IMPORTED_MODULE_1__.some(_ReadonlyNonEmptyArray__WEBPACK_IMPORTED_MODULE_0__.last(as)) : _internal__WEBPACK_IMPORTED_MODULE_1__.none); };
/**
 * Get all but the first element of an array, creating a new array, or `None` if the array is empty
 *
 * @example
 * import { tail } from 'fp-ts/ReadonlyArray'
 * import { some, none } from 'fp-ts/Option'
 *
 * assert.deepStrictEqual(tail([1, 2, 3]), some([2, 3]))
 * assert.deepStrictEqual(tail([]), none)
 *
 * @since 2.5.0
 */
var tail = function (as) {
    return isNonEmpty(as) ? _internal__WEBPACK_IMPORTED_MODULE_1__.some(_ReadonlyNonEmptyArray__WEBPACK_IMPORTED_MODULE_0__.tail(as)) : _internal__WEBPACK_IMPORTED_MODULE_1__.none;
};
/**
 * Get all but the last element of an array, creating a new array, or `None` if the array is empty
 *
 * @example
 * import { init } from 'fp-ts/ReadonlyArray'
 * import { some, none } from 'fp-ts/Option'
 *
 * assert.deepStrictEqual(init([1, 2, 3]), some([1, 2]))
 * assert.deepStrictEqual(init([]), none)
 *
 * @since 2.5.0
 */
var init = function (as) {
    return isNonEmpty(as) ? _internal__WEBPACK_IMPORTED_MODULE_1__.some(_ReadonlyNonEmptyArray__WEBPACK_IMPORTED_MODULE_0__.init(as)) : _internal__WEBPACK_IMPORTED_MODULE_1__.none;
};
/**
 * Keep only a max number of elements from the start of an `ReadonlyArray`, creating a new `ReadonlyArray`.
 *
 * **Note**. `n` is normalized to a non negative integer.
 *
 * @example
 * import * as RA from 'fp-ts/ReadonlyArray'
 * import { pipe } from 'fp-ts/function'
 *
 * const input: ReadonlyArray<number> = [1, 2, 3]
 * assert.deepStrictEqual(pipe(input, RA.takeLeft(2)), [1, 2])
 *
 * // out of bounds
 * assert.strictEqual(pipe(input, RA.takeLeft(4)), input)
 * assert.strictEqual(pipe(input, RA.takeLeft(-1)), input)
 *
 * @since 2.5.0
 */
var takeLeft = function (n) {
    return function (as) {
        return isOutOfBound(n, as) ? as : n === 0 ? empty : as.slice(0, n);
    };
};
/**
 * Keep only a max number of elements from the end of an `ReadonlyArray`, creating a new `ReadonlyArray`.
 *
 * **Note**. `n` is normalized to a non negative integer.
 *
 * @example
 * import * as RA from 'fp-ts/ReadonlyArray'
 * import { pipe } from 'fp-ts/function'
 *
 * const input: ReadonlyArray<number> = [1, 2, 3]
 * assert.deepStrictEqual(pipe(input, RA.takeRight(2)), [2, 3])
 *
 * // out of bounds
 * assert.strictEqual(pipe(input, RA.takeRight(4)), input)
 * assert.strictEqual(pipe(input, RA.takeRight(-1)), input)
 *
 * @since 2.5.0
 */
var takeRight = function (n) {
    return function (as) {
        return isOutOfBound(n, as) ? as : n === 0 ? empty : as.slice(-n);
    };
};
function takeLeftWhile(predicate) {
    return function (as) {
        var out = [];
        for (var _i = 0, as_1 = as; _i < as_1.length; _i++) {
            var a = as_1[_i];
            if (!predicate(a)) {
                break;
            }
            out.push(a);
        }
        var len = out.length;
        return len === as.length ? as : len === 0 ? empty : out;
    };
}
var spanLeftIndex = function (as, predicate) {
    var l = as.length;
    var i = 0;
    for (; i < l; i++) {
        if (!predicate(as[i])) {
            break;
        }
    }
    return i;
};
function spanLeft(predicate) {
    return function (as) {
        var _a = splitAt(spanLeftIndex(as, predicate))(as), init = _a[0], rest = _a[1];
        return { init: init, rest: rest };
    };
}
/**
 * Drop a max number of elements from the start of an `ReadonlyArray`, creating a new `ReadonlyArray`.
 *
 * **Note**. `n` is normalized to a non negative integer.
 *
 * @example
 * import * as RA from 'fp-ts/ReadonlyArray'
 * import { pipe } from 'fp-ts/function'
 *
 * const input: ReadonlyArray<number> = [1, 2, 3]
 * assert.deepStrictEqual(pipe(input, RA.dropLeft(2)), [3])
 * assert.strictEqual(pipe(input, RA.dropLeft(0)), input)
 * assert.strictEqual(pipe(input, RA.dropLeft(-1)), input)
 *
 * @since 2.5.0
 */
var dropLeft = function (n) {
    return function (as) {
        return n <= 0 || isEmpty(as) ? as : n >= as.length ? empty : as.slice(n, as.length);
    };
};
/**
 * Drop a max number of elements from the end of an `ReadonlyArray`, creating a new `ReadonlyArray`.
 *
 * **Note**. `n` is normalized to a non negative integer.
 *
 * @example
 * import * as RA from 'fp-ts/ReadonlyArray'
 * import { pipe } from 'fp-ts/function'
 *
 * const input: ReadonlyArray<number> = [1, 2, 3]
 * assert.deepStrictEqual(pipe(input, RA.dropRight(2)), [1])
 * assert.strictEqual(pipe(input, RA.dropRight(0)), input)
 * assert.strictEqual(pipe(input, RA.dropRight(-1)), input)
 *
 * @since 2.5.0
 */
var dropRight = function (n) {
    return function (as) {
        return n <= 0 || isEmpty(as) ? as : n >= as.length ? empty : as.slice(0, as.length - n);
    };
};
function dropLeftWhile(predicate) {
    return function (as) {
        var i = spanLeftIndex(as, predicate);
        return i === 0 ? as : i === as.length ? empty : as.slice(i);
    };
}
/**
 * Find the first index for which a predicate holds
 *
 * @example
 * import { findIndex } from 'fp-ts/ReadonlyArray'
 * import { some, none } from 'fp-ts/Option'
 *
 * assert.deepStrictEqual(findIndex((n: number) => n === 2)([1, 2, 3]), some(1))
 * assert.deepStrictEqual(findIndex((n: number) => n === 2)([]), none)
 *
 * @since 2.5.0
 */
var findIndex = function (predicate) {
    return function (as) {
        for (var i = 0; i < as.length; i++) {
            if (predicate(as[i])) {
                return _internal__WEBPACK_IMPORTED_MODULE_1__.some(i);
            }
        }
        return _internal__WEBPACK_IMPORTED_MODULE_1__.none;
    };
};
function findFirst(predicate) {
    return function (as) {
        for (var i = 0; i < as.length; i++) {
            if (predicate(as[i])) {
                return _internal__WEBPACK_IMPORTED_MODULE_1__.some(as[i]);
            }
        }
        return _internal__WEBPACK_IMPORTED_MODULE_1__.none;
    };
}
/**
 * Find the first element returned by an option based selector function
 *
 * @example
 * import { findFirstMap } from 'fp-ts/ReadonlyArray'
 * import { some, none } from 'fp-ts/Option'
 *
 * interface Person {
 *   readonly name: string
 *   readonly age?: number
 * }
 *
 * const persons: ReadonlyArray<Person> = [{ name: 'John' }, { name: 'Mary', age: 45 }, { name: 'Joey', age: 28 }]
 *
 * // returns the name of the first person that has an age
 * assert.deepStrictEqual(findFirstMap((p: Person) => (p.age === undefined ? none : some(p.name)))(persons), some('Mary'))
 *
 * @since 2.5.0
 */
var findFirstMap = function (f) {
    return function (as) {
        for (var i = 0; i < as.length; i++) {
            var out = f(as[i]);
            if (_internal__WEBPACK_IMPORTED_MODULE_1__.isSome(out)) {
                return out;
            }
        }
        return _internal__WEBPACK_IMPORTED_MODULE_1__.none;
    };
};
function findLast(predicate) {
    return function (as) {
        for (var i = as.length - 1; i >= 0; i--) {
            if (predicate(as[i])) {
                return _internal__WEBPACK_IMPORTED_MODULE_1__.some(as[i]);
            }
        }
        return _internal__WEBPACK_IMPORTED_MODULE_1__.none;
    };
}
/**
 * Find the last element returned by an option based selector function
 *
 * @example
 * import { findLastMap } from 'fp-ts/ReadonlyArray'
 * import { some, none } from 'fp-ts/Option'
 *
 * interface Person {
 *   readonly name: string
 *   readonly age?: number
 * }
 *
 * const persons: ReadonlyArray<Person> = [{ name: 'John' }, { name: 'Mary', age: 45 }, { name: 'Joey', age: 28 }]
 *
 * // returns the name of the last person that has an age
 * assert.deepStrictEqual(findLastMap((p: Person) => (p.age === undefined ? none : some(p.name)))(persons), some('Joey'))
 *
 * @since 2.5.0
 */
var findLastMap = function (f) {
    return function (as) {
        for (var i = as.length - 1; i >= 0; i--) {
            var out = f(as[i]);
            if (_internal__WEBPACK_IMPORTED_MODULE_1__.isSome(out)) {
                return out;
            }
        }
        return _internal__WEBPACK_IMPORTED_MODULE_1__.none;
    };
};
/**
 * Returns the index of the last element of the list which matches the predicate
 *
 * @example
 * import { findLastIndex } from 'fp-ts/ReadonlyArray'
 * import { some, none } from 'fp-ts/Option'
 *
 * interface X {
 *   readonly a: number
 *   readonly b: number
 * }
 * const xs: ReadonlyArray<X> = [{ a: 1, b: 0 }, { a: 1, b: 1 }]
 * assert.deepStrictEqual(findLastIndex((x: { readonly a: number }) => x.a === 1)(xs), some(1))
 * assert.deepStrictEqual(findLastIndex((x: { readonly a: number }) => x.a === 4)(xs), none)
 *
 *
 * @since 2.5.0
 */
var findLastIndex = function (predicate) {
    return function (as) {
        for (var i = as.length - 1; i >= 0; i--) {
            if (predicate(as[i])) {
                return _internal__WEBPACK_IMPORTED_MODULE_1__.some(i);
            }
        }
        return _internal__WEBPACK_IMPORTED_MODULE_1__.none;
    };
};
/**
 * Insert an element at the specified index, creating a new array, or returning `None` if the index is out of bounds
 *
 * @example
 * import { insertAt } from 'fp-ts/ReadonlyArray'
 * import { some } from 'fp-ts/Option'
 *
 * assert.deepStrictEqual(insertAt(2, 5)([1, 2, 3, 4]), some([1, 2, 5, 3, 4]))
 *
 * @since 2.5.0
 */
var insertAt = function (i, a) {
    return function (as) {
        return i < 0 || i > as.length ? _internal__WEBPACK_IMPORTED_MODULE_1__.none : _internal__WEBPACK_IMPORTED_MODULE_1__.some(_ReadonlyNonEmptyArray__WEBPACK_IMPORTED_MODULE_0__.unsafeInsertAt(i, a, as));
    };
};
/**
 * Change the element at the specified index, creating a new array, or returning `None` if the index is out of bounds
 *
 * @example
 * import { updateAt } from 'fp-ts/ReadonlyArray'
 * import { some, none } from 'fp-ts/Option'
 *
 * assert.deepStrictEqual(updateAt(1, 1)([1, 2, 3]), some([1, 1, 3]))
 * assert.deepStrictEqual(updateAt(1, 1)([]), none)
 *
 * @since 2.5.0
 */
var updateAt = function (i, a) {
    return modifyAt(i, function () { return a; });
};
/**
 * Delete the element at the specified index, creating a new array, or returning `None` if the index is out of bounds
 *
 * @example
 * import { deleteAt } from 'fp-ts/ReadonlyArray'
 * import { some, none } from 'fp-ts/Option'
 *
 * assert.deepStrictEqual(deleteAt(0)([1, 2, 3]), some([2, 3]))
 * assert.deepStrictEqual(deleteAt(1)([]), none)
 *
 * @since 2.5.0
 */
var deleteAt = function (i) {
    return function (as) {
        return isOutOfBound(i, as) ? _internal__WEBPACK_IMPORTED_MODULE_1__.none : _internal__WEBPACK_IMPORTED_MODULE_1__.some(unsafeDeleteAt(i, as));
    };
};
/**
 * Apply a function to the element at the specified index, creating a new array, or returning `None` if the index is out
 * of bounds
 *
 * @example
 * import { modifyAt } from 'fp-ts/ReadonlyArray'
 * import { some, none } from 'fp-ts/Option'
 *
 * const double = (x: number): number => x * 2
 * assert.deepStrictEqual(modifyAt(1, double)([1, 2, 3]), some([1, 4, 3]))
 * assert.deepStrictEqual(modifyAt(1, double)([]), none)
 *
 * @since 2.5.0
 */
var modifyAt = function (i, f) {
    return function (as) {
        return isOutOfBound(i, as) ? _internal__WEBPACK_IMPORTED_MODULE_1__.none : _internal__WEBPACK_IMPORTED_MODULE_1__.some(unsafeUpdateAt(i, f(as[i]), as));
    };
};
/**
 * Reverse an array, creating a new array
 *
 * @example
 * import { reverse } from 'fp-ts/ReadonlyArray'
 *
 * assert.deepStrictEqual(reverse([1, 2, 3]), [3, 2, 1])
 *
 * @since 2.5.0
 */
var reverse = function (as) { return (as.length <= 1 ? as : as.slice().reverse()); };
/**
 * Extracts from an array of `Either` all the `Right` elements. All the `Right` elements are extracted in order
 *
 * @example
 * import { rights } from 'fp-ts/ReadonlyArray'
 * import { right, left } from 'fp-ts/Either'
 *
 * assert.deepStrictEqual(rights([right(1), left('foo'), right(2)]), [1, 2])
 *
 * @since 2.5.0
 */
var rights = function (as) {
    var r = [];
    for (var i = 0; i < as.length; i++) {
        var a = as[i];
        if (a._tag === 'Right') {
            r.push(a.right);
        }
    }
    return r;
};
/**
 * Extracts from an array of `Either` all the `Left` elements. All the `Left` elements are extracted in order
 *
 * @example
 * import { lefts } from 'fp-ts/ReadonlyArray'
 * import { left, right } from 'fp-ts/Either'
 *
 * assert.deepStrictEqual(lefts([right(1), left('foo'), right(2)]), ['foo'])
 *
 * @since 2.5.0
 */
var lefts = function (as) {
    var r = [];
    for (var i = 0; i < as.length; i++) {
        var a = as[i];
        if (a._tag === 'Left') {
            r.push(a.left);
        }
    }
    return r;
};
/**
 * Sort the elements of an array in increasing order, creating a new array
 *
 * @example
 * import { sort } from 'fp-ts/ReadonlyArray'
 * import * as N from 'fp-ts/number'
 *
 * assert.deepStrictEqual(sort(N.Ord)([3, 2, 1]), [1, 2, 3])
 *
 * @since 2.5.0
 */
var sort = function (O) {
    return function (as) {
        return as.length <= 1 ? as : as.slice().sort(O.compare);
    };
};
// TODO: curry and make data-last in v3
/**
 * Apply a function to pairs of elements at the same index in two arrays, collecting the results in a new array. If one
 * input array is short, excess elements of the longer array are discarded.
 *
 * @example
 * import { zipWith } from 'fp-ts/ReadonlyArray'
 *
 * assert.deepStrictEqual(zipWith([1, 2, 3], ['a', 'b', 'c', 'd'], (n, s) => s + n), ['a1', 'b2', 'c3'])
 *
 * @since 2.5.0
 */
var zipWith = function (fa, fb, f) {
    var fc = [];
    var len = Math.min(fa.length, fb.length);
    for (var i = 0; i < len; i++) {
        fc[i] = f(fa[i], fb[i]);
    }
    return fc;
};
function zip(as, bs) {
    if (bs === undefined) {
        return function (bs) { return zip(bs, as); };
    }
    return zipWith(as, bs, function (a, b) { return [a, b]; });
}
/**
 * The function is reverse of `zip`. Takes an array of pairs and return two corresponding arrays
 *
 * @example
 * import { unzip } from 'fp-ts/ReadonlyArray'
 *
 * assert.deepStrictEqual(unzip([[1, 'a'], [2, 'b'], [3, 'c']]), [[1, 2, 3], ['a', 'b', 'c']])
 *
 * @since 2.5.0
 */
var unzip = function (as) {
    var fa = [];
    var fb = [];
    for (var i = 0; i < as.length; i++) {
        fa[i] = as[i][0];
        fb[i] = as[i][1];
    }
    return [fa, fb];
};
/**
 * Prepend an element to every member of an array
 *
 * @example
 * import { prependAll } from 'fp-ts/ReadonlyArray'
 *
 * assert.deepStrictEqual(prependAll(9)([1, 2, 3, 4]), [9, 1, 9, 2, 9, 3, 9, 4])
 *
 * @since 2.10.0
 */
var prependAll = function (middle) {
    var f = _ReadonlyNonEmptyArray__WEBPACK_IMPORTED_MODULE_0__.prependAll(middle);
    return function (as) { return (isNonEmpty(as) ? f(as) : as); };
};
/**
 * Places an element in between members of an array
 *
 * @example
 * import { intersperse } from 'fp-ts/ReadonlyArray'
 *
 * assert.deepStrictEqual(intersperse(9)([1, 2, 3, 4]), [1, 9, 2, 9, 3, 9, 4])
 *
 * @since 2.9.0
 */
var intersperse = function (middle) {
    var f = _ReadonlyNonEmptyArray__WEBPACK_IMPORTED_MODULE_0__.intersperse(middle);
    return function (as) { return (isNonEmpty(as) ? f(as) : as); };
};
/**
 * Rotate a `ReadonlyArray` by `n` steps.
 *
 * @example
 * import { rotate } from 'fp-ts/ReadonlyArray'
 *
 * assert.deepStrictEqual(rotate(2)([1, 2, 3, 4, 5]), [4, 5, 1, 2, 3])
 *
 * @since 2.5.0
 */
var rotate = function (n) {
    var f = _ReadonlyNonEmptyArray__WEBPACK_IMPORTED_MODULE_0__.rotate(n);
    return function (as) { return (isNonEmpty(as) ? f(as) : as); };
};
function elem(E) {
    return function (a, as) {
        if (as === undefined) {
            var elemE_1 = elem(E);
            return function (as) { return elemE_1(a, as); };
        }
        var predicate = function (element) { return E.equals(element, a); };
        var i = 0;
        for (; i < as.length; i++) {
            if (predicate(as[i])) {
                return true;
            }
        }
        return false;
    };
}
/**
 * Remove duplicates from an array, keeping the first occurrence of an element.
 *
 * @example
 * import { uniq } from 'fp-ts/ReadonlyArray'
 * import * as N from 'fp-ts/number'
 *
 * assert.deepStrictEqual(uniq(N.Eq)([1, 2, 1]), [1, 2])
 *
 * @since 2.5.0
 */
var uniq = function (E) {
    var f = _ReadonlyNonEmptyArray__WEBPACK_IMPORTED_MODULE_0__.uniq(E);
    return function (as) { return (isNonEmpty(as) ? f(as) : as); };
};
/**
 * Sort the elements of an array in increasing order, where elements are compared using first `ords[0]`, then `ords[1]`,
 * etc...
 *
 * @example
 * import { sortBy } from 'fp-ts/ReadonlyArray'
 * import { contramap } from 'fp-ts/Ord'
 * import * as S from 'fp-ts/string'
 * import * as N from 'fp-ts/number'
 * import { pipe } from 'fp-ts/function'
 *
 * interface Person {
 *   readonly name: string
 *   readonly age: number
 * }
 * const byName = pipe(S.Ord, contramap((p: Person) => p.name))
 * const byAge = pipe(N.Ord, contramap((p: Person) => p.age))
 *
 * const sortByNameByAge = sortBy([byName, byAge])
 *
 * const persons = [{ name: 'a', age: 1 }, { name: 'b', age: 3 }, { name: 'c', age: 2 }, { name: 'b', age: 2 }]
 * assert.deepStrictEqual(sortByNameByAge(persons), [
 *   { name: 'a', age: 1 },
 *   { name: 'b', age: 2 },
 *   { name: 'b', age: 3 },
 *   { name: 'c', age: 2 }
 * ])
 *
 * @since 2.5.0
 */
var sortBy = function (ords) {
    var f = _ReadonlyNonEmptyArray__WEBPACK_IMPORTED_MODULE_0__.sortBy(ords);
    return function (as) { return (isNonEmpty(as) ? f(as) : as); };
};
/**
 * A useful recursion pattern for processing a `ReadonlyArray` to produce a new `ReadonlyArray`, often used for "chopping" up the input
 * `ReadonlyArray`. Typically `chop` is called with some function that will consume an initial prefix of the `ReadonlyArray` and produce a
 * value and the tail of the `ReadonlyArray`.
 *
 * @example
 * import { Eq } from 'fp-ts/Eq'
 * import * as RA from 'fp-ts/ReadonlyArray'
 * import * as N from 'fp-ts/number'
 * import { pipe } from 'fp-ts/function'
 *
 * const group = <A>(S: Eq<A>): ((as: ReadonlyArray<A>) => ReadonlyArray<ReadonlyArray<A>>) => {
 *   return RA.chop(as => {
 *     const { init, rest } = pipe(as, RA.spanLeft((a: A) => S.equals(a, as[0])))
 *     return [init, rest]
 *   })
 * }
 * assert.deepStrictEqual(group(N.Eq)([1, 1, 2, 3, 3, 4]), [[1, 1], [2], [3, 3], [4]])
 *
 * @since 2.5.0
 */
var chop = function (f) {
    var g = _ReadonlyNonEmptyArray__WEBPACK_IMPORTED_MODULE_0__.chop(f);
    return function (as) { return (isNonEmpty(as) ? g(as) : empty); };
};
/**
 * Splits a `ReadonlyArray` into two pieces, the first piece has max `n` elements.
 *
 * @example
 * import { splitAt } from 'fp-ts/ReadonlyArray'
 *
 * assert.deepStrictEqual(splitAt(2)([1, 2, 3, 4, 5]), [[1, 2], [3, 4, 5]])
 *
 * @since 2.5.0
 */
var splitAt = function (n) {
    return function (as) {
        return n >= 1 && isNonEmpty(as) ? _ReadonlyNonEmptyArray__WEBPACK_IMPORTED_MODULE_0__.splitAt(n)(as) : isEmpty(as) ? [as, empty] : [empty, as];
    };
};
/**
 * Splits a `ReadonlyArray` into length-`n` pieces. The last piece will be shorter if `n` does not evenly divide the length of
 * the `ReadonlyArray`. Note that `chunksOf(n)([])` is `[]`, not `[[]]`. This is intentional, and is consistent with a recursive
 * definition of `chunksOf`; it satisfies the property that:
 *
 * ```ts
 * chunksOf(n)(xs).concat(chunksOf(n)(ys)) == chunksOf(n)(xs.concat(ys)))
 * ```
 *
 * whenever `n` evenly divides the length of `as`.
 *
 * @example
 * import { chunksOf } from 'fp-ts/ReadonlyArray'
 *
 * assert.deepStrictEqual(chunksOf(2)([1, 2, 3, 4, 5]), [[1, 2], [3, 4], [5]])
 *
 * @since 2.5.0
 */
var chunksOf = function (n) {
    var f = _ReadonlyNonEmptyArray__WEBPACK_IMPORTED_MODULE_0__.chunksOf(n);
    return function (as) { return (isNonEmpty(as) ? f(as) : empty); };
};
/**
 * @category lifting
 * @since 2.11.0
 */
var fromOptionK = function (f) {
    return function () {
        var a = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            a[_i] = arguments[_i];
        }
        return fromOption(f.apply(void 0, a));
    };
};
function comprehension(input, f, g) {
    if (g === void 0) { g = function () { return true; }; }
    var go = function (scope, input) {
        return isNonEmpty(input)
            ? flatMap(_ReadonlyNonEmptyArray__WEBPACK_IMPORTED_MODULE_0__.head(input), function (a) { return go((0,_function__WEBPACK_IMPORTED_MODULE_2__.pipe)(scope, append(a)), _ReadonlyNonEmptyArray__WEBPACK_IMPORTED_MODULE_0__.tail(input)); })
            : g.apply(void 0, scope) ? [f.apply(void 0, scope)]
                : empty;
    };
    return go(empty, input);
}
/**
 * @since 2.11.0
 */
var concatW = function (second) {
    return function (first) {
        return isEmpty(first) ? second : isEmpty(second) ? first : first.concat(second);
    };
};
/**
 * @since 2.11.0
 */
var concat = concatW;
function union(E) {
    var unionE = _ReadonlyNonEmptyArray__WEBPACK_IMPORTED_MODULE_0__.union(E);
    return function (first, second) {
        if (second === undefined) {
            var unionE_1 = union(E);
            return function (second) { return unionE_1(second, first); };
        }
        return isNonEmpty(first) && isNonEmpty(second) ? unionE(second)(first) : isNonEmpty(first) ? first : second;
    };
}
function intersection(E) {
    var elemE = elem(E);
    return function (xs, ys) {
        if (ys === undefined) {
            var intersectionE_1 = intersection(E);
            return function (ys) { return intersectionE_1(ys, xs); };
        }
        return xs.filter(function (a) { return elemE(a, ys); });
    };
}
function difference(E) {
    var elemE = elem(E);
    return function (xs, ys) {
        if (ys === undefined) {
            var differenceE_1 = difference(E);
            return function (ys) { return differenceE_1(ys, xs); };
        }
        return xs.filter(function (a) { return !elemE(a, ys); });
    };
}
var _map = function (fa, f) { return (0,_function__WEBPACK_IMPORTED_MODULE_2__.pipe)(fa, map(f)); };
var _mapWithIndex = function (fa, f) { return (0,_function__WEBPACK_IMPORTED_MODULE_2__.pipe)(fa, mapWithIndex(f)); };
var _ap = function (fab, fa) { return (0,_function__WEBPACK_IMPORTED_MODULE_2__.pipe)(fab, ap(fa)); };
var _filter = function (fa, predicate) {
    return (0,_function__WEBPACK_IMPORTED_MODULE_2__.pipe)(fa, filter(predicate));
};
var _filterMap = function (fa, f) { return (0,_function__WEBPACK_IMPORTED_MODULE_2__.pipe)(fa, filterMap(f)); };
var _partition = function (fa, predicate) {
    return (0,_function__WEBPACK_IMPORTED_MODULE_2__.pipe)(fa, partition(predicate));
};
var _partitionMap = function (fa, f) { return (0,_function__WEBPACK_IMPORTED_MODULE_2__.pipe)(fa, partitionMap(f)); };
var _partitionWithIndex = function (fa, predicateWithIndex) { return (0,_function__WEBPACK_IMPORTED_MODULE_2__.pipe)(fa, partitionWithIndex(predicateWithIndex)); };
var _partitionMapWithIndex = function (fa, f) { return (0,_function__WEBPACK_IMPORTED_MODULE_2__.pipe)(fa, partitionMapWithIndex(f)); };
var _alt = function (fa, that) { return (0,_function__WEBPACK_IMPORTED_MODULE_2__.pipe)(fa, alt(that)); };
var _reduce = function (fa, b, f) { return (0,_function__WEBPACK_IMPORTED_MODULE_2__.pipe)(fa, reduce(b, f)); };
var _foldMap = function (M) {
    var foldMapM = foldMap(M);
    return function (fa, f) { return (0,_function__WEBPACK_IMPORTED_MODULE_2__.pipe)(fa, foldMapM(f)); };
};
var _reduceRight = function (fa, b, f) { return (0,_function__WEBPACK_IMPORTED_MODULE_2__.pipe)(fa, reduceRight(b, f)); };
var _reduceWithIndex = function (fa, b, f) {
    return (0,_function__WEBPACK_IMPORTED_MODULE_2__.pipe)(fa, reduceWithIndex(b, f));
};
var _foldMapWithIndex = function (M) {
    var foldMapWithIndexM = foldMapWithIndex(M);
    return function (fa, f) { return (0,_function__WEBPACK_IMPORTED_MODULE_2__.pipe)(fa, foldMapWithIndexM(f)); };
};
var _reduceRightWithIndex = function (fa, b, f) {
    return (0,_function__WEBPACK_IMPORTED_MODULE_2__.pipe)(fa, reduceRightWithIndex(b, f));
};
var _filterMapWithIndex = function (fa, f) { return (0,_function__WEBPACK_IMPORTED_MODULE_2__.pipe)(fa, filterMapWithIndex(f)); };
var _filterWithIndex = function (fa, predicateWithIndex) { return (0,_function__WEBPACK_IMPORTED_MODULE_2__.pipe)(fa, filterWithIndex(predicateWithIndex)); };
var _extend = function (fa, f) { return (0,_function__WEBPACK_IMPORTED_MODULE_2__.pipe)(fa, extend(f)); };
var _traverse = function (F) {
    var traverseF = traverse(F);
    return function (ta, f) { return (0,_function__WEBPACK_IMPORTED_MODULE_2__.pipe)(ta, traverseF(f)); };
};
/* istanbul ignore next */
var _traverseWithIndex = function (F) {
    var traverseWithIndexF = traverseWithIndex(F);
    return function (ta, f) { return (0,_function__WEBPACK_IMPORTED_MODULE_2__.pipe)(ta, traverseWithIndexF(f)); };
};
/** @internal */
var _chainRecDepthFirst = function (a, f) { return (0,_function__WEBPACK_IMPORTED_MODULE_2__.pipe)(a, chainRecDepthFirst(f)); };
/** @internal */
var _chainRecBreadthFirst = function (a, f) { return (0,_function__WEBPACK_IMPORTED_MODULE_2__.pipe)(a, chainRecBreadthFirst(f)); };
/**
 * @category constructors
 * @since 2.5.0
 */
var of = _ReadonlyNonEmptyArray__WEBPACK_IMPORTED_MODULE_0__.of;
/**
 * @since 2.7.0
 */
var zero = function () { return empty; };
/**
 * Less strict version of [`alt`](#alt).
 *
 * The `W` suffix (short for **W**idening) means that the return types will be merged.
 *
 * @example
 * import * as RA from 'fp-ts/ReadonlyArray'
 * import { pipe } from 'fp-ts/function'
 *
 * assert.deepStrictEqual(
 *   pipe(
 *     [1, 2, 3],
 *     RA.altW(() => ['a', 'b'])
 *   ),
 *   [1, 2, 3, 'a', 'b']
 * )
 *
 * @category error handling
 * @since 2.9.0
 */
var altW = function (that) {
    return function (fa) {
        return fa.concat(that());
    };
};
/**
 * Identifies an associative operation on a type constructor. It is similar to `Semigroup`, except that it applies to
 * types of kind `* -> *`.
 *
 * In case of `ReadonlyArray` concatenates the inputs into a single array.
 *
 * @example
 * import * as RA from 'fp-ts/ReadonlyArray'
 * import { pipe } from 'fp-ts/function'
 *
 * assert.deepStrictEqual(
 *   pipe(
 *     [1, 2, 3],
 *     RA.alt(() => [4, 5])
 *   ),
 *   [1, 2, 3, 4, 5]
 * )
 *
 * @category error handling
 * @since 2.5.0
 */
var alt = altW;
/**
 * @since 2.5.0
 */
var ap = function (fa) {
    return flatMap(function (f) { return (0,_function__WEBPACK_IMPORTED_MODULE_2__.pipe)(fa, map(f)); });
};
/**
 * Composes computations in sequence, using the return value of one computation to determine the next computation.
 *
 * @example
 * import * as RA from 'fp-ts/ReadonlyArray'
 * import { pipe } from 'fp-ts/function'
 *
 * assert.deepStrictEqual(
 *   pipe(
 *     [1, 2, 3],
 *     RA.flatMap((n) => [`a${n}`, `b${n}`])
 *   ),
 *   ['a1', 'b1', 'a2', 'b2', 'a3', 'b3']
 * )
 * assert.deepStrictEqual(
 *   pipe(
 *     [1, 2, 3],
 *     RA.flatMap(() => [])
 *   ),
 *   []
 * )
 *
 * @category sequencing
 * @since 2.14.0
 */
var flatMap = /*#__PURE__*/ (0,_function__WEBPACK_IMPORTED_MODULE_2__.dual)(2, function (ma, f) {
    return (0,_function__WEBPACK_IMPORTED_MODULE_2__.pipe)(ma, chainWithIndex(function (i, a) { return f(a, i); }));
});
/**
 * @category sequencing
 * @since 2.5.0
 */
var flatten = /*#__PURE__*/ flatMap(_function__WEBPACK_IMPORTED_MODULE_2__.identity);
/**
 * `map` can be used to turn functions `(a: A) => B` into functions `(fa: F<A>) => F<B>` whose argument and return types
 * use the type constructor `F` to represent some computational context.
 *
 * @category mapping
 * @since 2.5.0
 */
var map = function (f) { return function (fa) {
    return fa.map(function (a) { return f(a); });
}; };
/**
 * @category mapping
 * @since 2.5.0
 */
var mapWithIndex = function (f) { return function (fa) {
    return fa.map(function (a, i) { return f(i, a); });
}; };
/**
 * @category filtering
 * @since 2.5.0
 */
var separate = function (fa) {
    var left = [];
    var right = [];
    for (var _i = 0, fa_1 = fa; _i < fa_1.length; _i++) {
        var e = fa_1[_i];
        if (e._tag === 'Left') {
            left.push(e.left);
        }
        else {
            right.push(e.right);
        }
    }
    return (0,_Separated__WEBPACK_IMPORTED_MODULE_3__.separated)(left, right);
};
/**
 * @category filtering
 * @since 2.5.0
 */
var filter = function (predicate) {
    return function (as) {
        return as.filter(predicate);
    };
};
/**
 * @category filtering
 * @since 2.5.0
 */
var filterMapWithIndex = function (f) {
    return function (fa) {
        var out = [];
        for (var i = 0; i < fa.length; i++) {
            var optionB = f(i, fa[i]);
            if (_internal__WEBPACK_IMPORTED_MODULE_1__.isSome(optionB)) {
                out.push(optionB.value);
            }
        }
        return out;
    };
};
/**
 * @category filtering
 * @since 2.5.0
 */
var filterMap = function (f) {
    return filterMapWithIndex(function (_, a) { return f(a); });
};
/**
 * @category filtering
 * @since 2.5.0
 */
var compact = /*#__PURE__*/ filterMap(_function__WEBPACK_IMPORTED_MODULE_2__.identity);
/**
 * @category filtering
 * @since 2.5.0
 */
var partition = function (predicate) {
    return partitionWithIndex(function (_, a) { return predicate(a); });
};
/**
 * @category filtering
 * @since 2.5.0
 */
var partitionWithIndex = function (predicateWithIndex) {
    return function (as) {
        var left = [];
        var right = [];
        for (var i = 0; i < as.length; i++) {
            var a = as[i];
            if (predicateWithIndex(i, a)) {
                right.push(a);
            }
            else {
                left.push(a);
            }
        }
        return (0,_Separated__WEBPACK_IMPORTED_MODULE_3__.separated)(left, right);
    };
};
/**
 * @category filtering
 * @since 2.5.0
 */
var partitionMap = function (f) {
    return partitionMapWithIndex(function (_, a) { return f(a); });
};
/**
 * @category filtering
 * @since 2.5.0
 */
var partitionMapWithIndex = function (f) {
    return function (fa) {
        var left = [];
        var right = [];
        for (var i = 0; i < fa.length; i++) {
            var e = f(i, fa[i]);
            if (e._tag === 'Left') {
                left.push(e.left);
            }
            else {
                right.push(e.right);
            }
        }
        return (0,_Separated__WEBPACK_IMPORTED_MODULE_3__.separated)(left, right);
    };
};
/**
 * @category filtering
 * @since 2.5.0
 */
var filterWithIndex = function (predicateWithIndex) {
    return function (as) {
        return as.filter(function (a, i) { return predicateWithIndex(i, a); });
    };
};
/**
 * @since 2.5.0
 */
var extend = function (f) { return function (wa) {
    return wa.map(function (_, i) { return f(wa.slice(i)); });
}; };
/**
 * @since 2.5.0
 */
var duplicate = /*#__PURE__*/ extend(_function__WEBPACK_IMPORTED_MODULE_2__.identity);
/**
 * @category folding
 * @since 2.5.0
 */
var foldMapWithIndex = function (M) {
    return function (f) {
        return function (fa) {
            return fa.reduce(function (b, a, i) { return M.concat(b, f(i, a)); }, M.empty);
        };
    };
};
/**
 * @category folding
 * @since 2.5.0
 */
var reduce = function (b, f) {
    return reduceWithIndex(b, function (_, b, a) { return f(b, a); });
};
/**
 * @category folding
 * @since 2.5.0
 */
var foldMap = function (M) {
    var foldMapWithIndexM = foldMapWithIndex(M);
    return function (f) { return foldMapWithIndexM(function (_, a) { return f(a); }); };
};
/**
 * @category folding
 * @since 2.5.0
 */
var reduceWithIndex = function (b, f) { return function (fa) {
    var len = fa.length;
    var out = b;
    for (var i = 0; i < len; i++) {
        out = f(i, out, fa[i]);
    }
    return out;
}; };
/**
 * @category folding
 * @since 2.5.0
 */
var reduceRight = function (b, f) {
    return reduceRightWithIndex(b, function (_, a, b) { return f(a, b); });
};
/**
 * @category folding
 * @since 2.5.0
 */
var reduceRightWithIndex = function (b, f) { return function (fa) {
    return fa.reduceRight(function (b, a, i) { return f(i, a, b); }, b);
}; };
/**
 * @category traversing
 * @since 2.6.3
 */
var traverse = function (F) {
    var traverseWithIndexF = traverseWithIndex(F);
    return function (f) { return traverseWithIndexF(function (_, a) { return f(a); }); };
};
/**
 * @category traversing
 * @since 2.6.3
 */
var sequence = function (F) {
    return function (ta) {
        return _reduce(ta, F.of(zero()), function (fas, fa) {
            return F.ap(F.map(fas, function (as) { return function (a) { return (0,_function__WEBPACK_IMPORTED_MODULE_2__.pipe)(as, append(a)); }; }), fa);
        });
    };
};
/**
 * @category sequencing
 * @since 2.6.3
 */
var traverseWithIndex = function (F) {
    return function (f) {
        return reduceWithIndex(F.of(zero()), function (i, fbs, a) {
            return F.ap(F.map(fbs, function (bs) { return function (b) { return (0,_function__WEBPACK_IMPORTED_MODULE_2__.pipe)(bs, append(b)); }; }), f(i, a));
        });
    };
};
/**
 * @category filtering
 * @since 2.6.5
 */
var wither = function (F) {
    var _witherF = _wither(F);
    return function (f) { return function (fa) { return _witherF(fa, f); }; };
};
/**
 * @category filtering
 * @since 2.6.5
 */
var wilt = function (F) {
    var _wiltF = _wilt(F);
    return function (f) { return function (fa) { return _wiltF(fa, f); }; };
};
/**
 * @since 2.6.6
 */
var unfold = function (b, f) {
    var out = [];
    var bb = b;
    // eslint-disable-next-line no-constant-condition
    while (true) {
        var mt = f(bb);
        if (_internal__WEBPACK_IMPORTED_MODULE_1__.isSome(mt)) {
            var _a = mt.value, a = _a[0], b_1 = _a[1];
            out.push(a);
            bb = b_1;
        }
        else {
            break;
        }
    }
    return out;
};
/**
 * @category type lambdas
 * @since 2.5.0
 */
var URI = 'ReadonlyArray';
/**
 * @category instances
 * @since 2.5.0
 */
var getShow = function (S) { return ({
    show: function (as) { return "[".concat(as.map(S.show).join(', '), "]"); }
}); };
/**
 * @category instances
 * @since 2.5.0
 */
var getSemigroup = function () { return ({
    concat: function (first, second) { return (isEmpty(first) ? second : isEmpty(second) ? first : first.concat(second)); }
}); };
/**
 * Returns a `Monoid` for `ReadonlyArray<A>`.
 *
 * @example
 * import { getMonoid } from 'fp-ts/ReadonlyArray'
 *
 * const M = getMonoid<number>()
 * assert.deepStrictEqual(M.concat([1, 2], [3, 4]), [1, 2, 3, 4])
 *
 * @category instances
 * @since 2.5.0
 */
var getMonoid = function () { return ({
    concat: getSemigroup().concat,
    empty: empty
}); };
/**
 * Derives an `Eq` over the `ReadonlyArray` of a given element type from the `Eq` of that type. The derived `Eq` defines two
 * arrays as equal if all elements of both arrays are compared equal pairwise with the given `E`. In case of arrays of
 * different lengths, the result is non equality.
 *
 * @example
 * import * as S from 'fp-ts/string'
 * import { getEq } from 'fp-ts/ReadonlyArray'
 *
 * const E = getEq(S.Eq)
 * assert.strictEqual(E.equals(['a', 'b'], ['a', 'b']), true)
 * assert.strictEqual(E.equals(['a'], []), false)
 *
 * @category instances
 * @since 2.5.0
 */
var getEq = function (E) {
    return (0,_Eq__WEBPACK_IMPORTED_MODULE_4__.fromEquals)(function (xs, ys) { return xs.length === ys.length && xs.every(function (x, i) { return E.equals(x, ys[i]); }); });
};
/**
 * Derives an `Ord` over the `ReadonlyArray` of a given element type from the `Ord` of that type. The ordering between two such
 * arrays is equal to: the first non equal comparison of each arrays elements taken pairwise in increasing order, in
 * case of equality over all the pairwise elements; the longest array is considered the greatest, if both arrays have
 * the same length, the result is equality.
 *
 * @example
 * import { getOrd } from 'fp-ts/ReadonlyArray'
 * import * as S from 'fp-ts/string'
 *
 * const O = getOrd(S.Ord)
 * assert.strictEqual(O.compare(['b'], ['a']), 1)
 * assert.strictEqual(O.compare(['a'], ['a']), 0)
 * assert.strictEqual(O.compare(['a'], ['b']), -1)
 *
 *
 * @category instances
 * @since 2.5.0
 */
var getOrd = function (O) {
    return (0,_Ord__WEBPACK_IMPORTED_MODULE_5__.fromCompare)(function (a, b) {
        var aLen = a.length;
        var bLen = b.length;
        var len = Math.min(aLen, bLen);
        for (var i = 0; i < len; i++) {
            var ordering = O.compare(a[i], b[i]);
            if (ordering !== 0) {
                return ordering;
            }
        }
        return _number__WEBPACK_IMPORTED_MODULE_6__.Ord.compare(aLen, bLen);
    });
};
/**
 * @category instances
 * @since 2.11.0
 */
var getUnionSemigroup = function (E) {
    var unionE = union(E);
    return {
        concat: function (first, second) { return unionE(second)(first); }
    };
};
/**
 * @category instances
 * @since 2.11.0
 */
var getUnionMonoid = function (E) { return ({
    concat: getUnionSemigroup(E).concat,
    empty: empty
}); };
/**
 * @category instances
 * @since 2.11.0
 */
var getIntersectionSemigroup = function (E) {
    var intersectionE = intersection(E);
    return {
        concat: function (first, second) { return intersectionE(second)(first); }
    };
};
/**
 * @category instances
 * @since 2.11.0
 */
var getDifferenceMagma = function (E) {
    var differenceE = difference(E);
    return {
        concat: function (first, second) { return differenceE(second)(first); }
    };
};
/**
 * @category instances
 * @since 2.7.0
 */
var Functor = {
    URI: URI,
    map: _map
};
/**
 * @category mapping
 * @since 2.10.0
 */
var flap = /*#__PURE__*/ (0,_Functor__WEBPACK_IMPORTED_MODULE_7__.flap)(Functor);
/**
 * @category instances
 * @since 2.10.0
 */
var Pointed = {
    URI: URI,
    of: of
};
/**
 * @category instances
 * @since 2.7.0
 */
var FunctorWithIndex = {
    URI: URI,
    map: _map,
    mapWithIndex: _mapWithIndex
};
/**
 * @category instances
 * @since 2.10.0
 */
var Apply = {
    URI: URI,
    map: _map,
    ap: _ap
};
/**
 * Combine two effectful actions, keeping only the result of the first.
 *
 * @since 2.5.0
 */
var apFirst = /*#__PURE__*/ (0,_Apply__WEBPACK_IMPORTED_MODULE_8__.apFirst)(Apply);
/**
 * Combine two effectful actions, keeping only the result of the second.
 *
 * @since 2.5.0
 */
var apSecond = /*#__PURE__*/ (0,_Apply__WEBPACK_IMPORTED_MODULE_8__.apSecond)(Apply);
/**
 * @category instances
 * @since 2.7.0
 */
var Applicative = {
    URI: URI,
    map: _map,
    ap: _ap,
    of: of
};
/**
 * @category instances
 * @since 2.10.0
 */
var Chain = {
    URI: URI,
    map: _map,
    ap: _ap,
    chain: flatMap
};
/**
 * @category instances
 * @since 2.7.0
 */
var Monad = {
    URI: URI,
    map: _map,
    ap: _ap,
    of: of,
    chain: flatMap
};
/**
 * Composes computations in sequence, using the return value of one computation to determine the next computation and
 * keeping only the result of the first.
 *
 * @example
 * import * as RA from 'fp-ts/ReadonlyArray'
 * import { pipe } from 'fp-ts/function'
 *
 * assert.deepStrictEqual(
 *   pipe(
 *     [1, 2, 3],
 *     RA.chainFirst(() => ['a', 'b'])
 *   ),
 *   [1, 1, 2, 2, 3, 3]
 * )
 * assert.deepStrictEqual(
 *   pipe(
 *     [1, 2, 3],
 *     RA.chainFirst(() => [])
 *   ),
 *   []
 * )
 *
 * @category sequencing
 * @since 2.5.0
 */
var chainFirst = 
/*#__PURE__*/ (0,_Chain__WEBPACK_IMPORTED_MODULE_9__.chainFirst)(Chain);
/**
 * @category instances
 * @since 2.7.0
 */
var Unfoldable = {
    URI: URI,
    unfold: unfold
};
/**
 * @category instances
 * @since 2.7.0
 */
var Alt = {
    URI: URI,
    map: _map,
    alt: _alt
};
/**
 * @category instances
 * @since 2.11.0
 */
var Zero = {
    URI: URI,
    zero: zero
};
/**
 * @category do notation
 * @since 2.11.0
 */
var guard = /*#__PURE__*/ (0,_Zero__WEBPACK_IMPORTED_MODULE_10__.guard)(Zero, Pointed);
/**
 * @category instances
 * @since 2.7.0
 */
var Alternative = {
    URI: URI,
    map: _map,
    ap: _ap,
    of: of,
    alt: _alt,
    zero: zero
};
/**
 * @category instances
 * @since 2.7.0
 */
var Extend = {
    URI: URI,
    map: _map,
    extend: _extend
};
/**
 * @category instances
 * @since 2.7.0
 */
var Compactable = {
    URI: URI,
    compact: compact,
    separate: separate
};
/**
 * @category instances
 * @since 2.7.0
 */
var Filterable = {
    URI: URI,
    map: _map,
    compact: compact,
    separate: separate,
    filter: _filter,
    filterMap: _filterMap,
    partition: _partition,
    partitionMap: _partitionMap
};
/**
 * @category instances
 * @since 2.7.0
 */
var FilterableWithIndex = {
    URI: URI,
    map: _map,
    mapWithIndex: _mapWithIndex,
    compact: compact,
    separate: separate,
    filter: _filter,
    filterMap: _filterMap,
    partition: _partition,
    partitionMap: _partitionMap,
    partitionMapWithIndex: _partitionMapWithIndex,
    partitionWithIndex: _partitionWithIndex,
    filterMapWithIndex: _filterMapWithIndex,
    filterWithIndex: _filterWithIndex
};
/**
 * @category instances
 * @since 2.7.0
 */
var Foldable = {
    URI: URI,
    reduce: _reduce,
    foldMap: _foldMap,
    reduceRight: _reduceRight
};
/**
 * @category instances
 * @since 2.7.0
 */
var FoldableWithIndex = {
    URI: URI,
    reduce: _reduce,
    foldMap: _foldMap,
    reduceRight: _reduceRight,
    reduceWithIndex: _reduceWithIndex,
    foldMapWithIndex: _foldMapWithIndex,
    reduceRightWithIndex: _reduceRightWithIndex
};
/**
 * @category instances
 * @since 2.7.0
 */
var Traversable = {
    URI: URI,
    map: _map,
    reduce: _reduce,
    foldMap: _foldMap,
    reduceRight: _reduceRight,
    traverse: _traverse,
    sequence: sequence
};
/**
 * @category instances
 * @since 2.7.0
 */
var TraversableWithIndex = {
    URI: URI,
    map: _map,
    mapWithIndex: _mapWithIndex,
    reduce: _reduce,
    foldMap: _foldMap,
    reduceRight: _reduceRight,
    reduceWithIndex: _reduceWithIndex,
    foldMapWithIndex: _foldMapWithIndex,
    reduceRightWithIndex: _reduceRightWithIndex,
    traverse: _traverse,
    sequence: sequence,
    traverseWithIndex: _traverseWithIndex
};
/**
 * @category sequencing
 * @since 2.11.0
 */
var chainRecDepthFirst = function (f) {
    return function (a) {
        var todo = __spreadArray([], f(a), true);
        var out = [];
        while (todo.length > 0) {
            var e = todo.shift();
            if (_internal__WEBPACK_IMPORTED_MODULE_1__.isLeft(e)) {
                todo.unshift.apply(todo, f(e.left));
            }
            else {
                out.push(e.right);
            }
        }
        return out;
    };
};
/**
 * @category instances
 * @since 2.11.0
 */
var ChainRecDepthFirst = {
    URI: URI,
    map: _map,
    ap: _ap,
    chain: flatMap,
    chainRec: _chainRecDepthFirst
};
/**
 * @category sequencing
 * @since 2.11.0
 */
var chainRecBreadthFirst = function (f) {
    return function (a) {
        var initial = f(a);
        var todo = [];
        var out = [];
        function go(e) {
            if (_internal__WEBPACK_IMPORTED_MODULE_1__.isLeft(e)) {
                f(e.left).forEach(function (v) { return todo.push(v); });
            }
            else {
                out.push(e.right);
            }
        }
        for (var _i = 0, initial_1 = initial; _i < initial_1.length; _i++) {
            var e = initial_1[_i];
            go(e);
        }
        while (todo.length > 0) {
            go(todo.shift());
        }
        return out;
    };
};
/**
 * @category instances
 * @since 2.11.0
 */
var ChainRecBreadthFirst = {
    URI: URI,
    map: _map,
    ap: _ap,
    chain: flatMap,
    chainRec: _chainRecBreadthFirst
};
var _wither = /*#__PURE__*/ (0,_Witherable__WEBPACK_IMPORTED_MODULE_11__.witherDefault)(Traversable, Compactable);
var _wilt = /*#__PURE__*/ (0,_Witherable__WEBPACK_IMPORTED_MODULE_11__.wiltDefault)(Traversable, Compactable);
/**
 * @category instances
 * @since 2.7.0
 */
var Witherable = {
    URI: URI,
    map: _map,
    compact: compact,
    separate: separate,
    filter: _filter,
    filterMap: _filterMap,
    partition: _partition,
    partitionMap: _partitionMap,
    reduce: _reduce,
    foldMap: _foldMap,
    reduceRight: _reduceRight,
    traverse: _traverse,
    sequence: sequence,
    wither: _wither,
    wilt: _wilt
};
/**
 * Filter values inside a context.
 *
 * @example
 * import { pipe } from 'fp-ts/function'
 * import * as RA from 'fp-ts/ReadonlyArray'
 * import * as T from 'fp-ts/Task'
 *
 * const filterE = RA.filterE(T.ApplicativePar)
 * async function test() {
 *   assert.deepStrictEqual(
 *     await pipe(
 *       [-1, 2, 3],
 *       filterE((n) => T.of(n > 0))
 *     )(),
 *     [2, 3]
 *   )
 * }
 * test()
 *
 * @since 2.11.0
 */
var filterE = /*#__PURE__*/ (0,_Witherable__WEBPACK_IMPORTED_MODULE_11__.filterE)(Witherable);
/**
 * @category instances
 * @since 2.11.0
 */
var FromEither = {
    URI: URI,
    fromEither: fromEither
};
/**
 * @category lifting
 * @since 2.11.0
 */
var fromEitherK = /*#__PURE__*/ (0,_FromEither__WEBPACK_IMPORTED_MODULE_12__.fromEitherK)(FromEither);
// -------------------------------------------------------------------------------------
// unsafe
// -------------------------------------------------------------------------------------
/**
 * @category unsafe
 * @since 2.5.0
 */
var unsafeInsertAt = _ReadonlyNonEmptyArray__WEBPACK_IMPORTED_MODULE_0__.unsafeInsertAt;
/**
 * @category unsafe
 * @since 2.5.0
 */
var unsafeUpdateAt = function (i, a, as) {
    return isNonEmpty(as) ? _ReadonlyNonEmptyArray__WEBPACK_IMPORTED_MODULE_0__.unsafeUpdateAt(i, a, as) : as;
};
/**
 * @category unsafe
 * @since 2.5.0
 */
var unsafeDeleteAt = function (i, as) {
    var xs = as.slice();
    xs.splice(i, 1);
    return xs;
};
/**
 * @category conversions
 * @since 2.5.0
 */
var toArray = function (as) { return as.slice(); };
/**
 * @category conversions
 * @since 2.5.0
 */
var fromArray = function (as) { return (isEmpty(as) ? empty : as.slice()); };
// -------------------------------------------------------------------------------------
// utils
// -------------------------------------------------------------------------------------
/**
 * An empty array
 *
 * @since 2.5.0
 */
var empty = _ReadonlyNonEmptyArray__WEBPACK_IMPORTED_MODULE_0__.empty;
function every(predicate) {
    return function (as) { return as.every(predicate); };
}
/**
 * Check if a predicate holds true for any array member.
 *
 * @example
 * import { some } from 'fp-ts/ReadonlyArray'
 * import { pipe } from 'fp-ts/function'
 *
 * const isPositive = (n: number): boolean => n > 0
 *
 * assert.deepStrictEqual(pipe([-1, -2, 3], some(isPositive)), true)
 * assert.deepStrictEqual(pipe([-1, -2, -3], some(isPositive)), false)
 *
 * @since 2.9.0
 */
var some = function (predicate) {
    return function (as) {
        return as.some(predicate);
    };
};
/**
 * Alias of [`some`](#some)
 *
 * @since 2.11.0
 */
var exists = some;
/**
 * Places an element in between members of a `ReadonlyArray`, then folds the results using the provided `Monoid`.
 *
 * @example
 * import * as S from 'fp-ts/string'
 * import { intercalate } from 'fp-ts/ReadonlyArray'
 *
 * assert.deepStrictEqual(intercalate(S.Monoid)('-')(['a', 'b', 'c']), 'a-b-c')
 *
 * @since 2.12.0
 */
var intercalate = function (M) {
    var intercalateM = _ReadonlyNonEmptyArray__WEBPACK_IMPORTED_MODULE_0__.intercalate(M);
    return function (middle) { return match(function () { return M.empty; }, intercalateM(middle)); };
};
// -------------------------------------------------------------------------------------
// do notation
// -------------------------------------------------------------------------------------
/**
 * @category do notation
 * @since 2.9.0
 */
var Do = /*#__PURE__*/ of(_internal__WEBPACK_IMPORTED_MODULE_1__.emptyRecord);
/**
 * @category do notation
 * @since 2.8.0
 */
var bindTo = /*#__PURE__*/ (0,_Functor__WEBPACK_IMPORTED_MODULE_7__.bindTo)(Functor);
var let_ = /*#__PURE__*/ (0,_Functor__WEBPACK_IMPORTED_MODULE_7__["let"])(Functor);

/**
 * @category do notation
 * @since 2.8.0
 */
var bind = /*#__PURE__*/ (0,_Chain__WEBPACK_IMPORTED_MODULE_9__.bind)(Chain);
/**
 * @category do notation
 * @since 2.8.0
 */
var apS = /*#__PURE__*/ (0,_Apply__WEBPACK_IMPORTED_MODULE_8__.apS)(Apply);
// -------------------------------------------------------------------------------------
// legacy
// -------------------------------------------------------------------------------------
/**
 * Alias of `flatMap`.
 *
 * @category legacy
 * @since 2.5.0
 */
var chain = flatMap;
// -------------------------------------------------------------------------------------
// deprecated
// -------------------------------------------------------------------------------------
/**
 * Use `ReadonlyNonEmptyArray` module instead.
 *
 * @category zone of death
 * @since 2.5.0
 * @deprecated
 */
var range = _ReadonlyNonEmptyArray__WEBPACK_IMPORTED_MODULE_0__.range;
/**
 * Use [`prepend`](#prepend) instead.
 *
 * @category zone of death
 * @since 2.5.0
 * @deprecated
 */
var cons = _ReadonlyNonEmptyArray__WEBPACK_IMPORTED_MODULE_0__.cons;
/**
 * Use [`append`](#append) instead.
 *
 * @category zone of death
 * @since 2.5.0
 * @deprecated
 */
var snoc = _ReadonlyNonEmptyArray__WEBPACK_IMPORTED_MODULE_0__.snoc;
/**
 * Use [`prependAll`](#prependall) instead.
 *
 * @category zone of death
 * @since 2.9.0
 * @deprecated
 */
var prependToAll = prependAll;
/**
 * This instance is deprecated, use small, specific instances instead.
 * For example if a function needs a `Functor` instance, pass `RA.Functor` instead of `RA.readonlyArray`
 * (where `RA` is from `import RA from 'fp-ts/ReadonlyArray'`)
 *
 * @category zone of death
 * @since 2.5.0
 * @deprecated
 */
var readonlyArray = {
    URI: URI,
    compact: compact,
    separate: separate,
    map: _map,
    ap: _ap,
    of: of,
    chain: flatMap,
    filter: _filter,
    filterMap: _filterMap,
    partition: _partition,
    partitionMap: _partitionMap,
    mapWithIndex: _mapWithIndex,
    partitionMapWithIndex: _partitionMapWithIndex,
    partitionWithIndex: _partitionWithIndex,
    filterMapWithIndex: _filterMapWithIndex,
    filterWithIndex: _filterWithIndex,
    alt: _alt,
    zero: zero,
    unfold: unfold,
    reduce: _reduce,
    foldMap: _foldMap,
    reduceRight: _reduceRight,
    traverse: _traverse,
    sequence: sequence,
    reduceWithIndex: _reduceWithIndex,
    foldMapWithIndex: _foldMapWithIndex,
    reduceRightWithIndex: _reduceRightWithIndex,
    traverseWithIndex: _traverseWithIndex,
    extend: _extend,
    wither: _wither,
    wilt: _wilt
};


/***/ }),

/***/ "./node_modules/fp-ts/es6/ReadonlyNonEmptyArray.js":
/*!*********************************************************!*\
  !*** ./node_modules/fp-ts/es6/ReadonlyNonEmptyArray.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Alt: () => (/* binding */ Alt),
/* harmony export */   Applicative: () => (/* binding */ Applicative),
/* harmony export */   Apply: () => (/* binding */ Apply),
/* harmony export */   Chain: () => (/* binding */ Chain),
/* harmony export */   Comonad: () => (/* binding */ Comonad),
/* harmony export */   Do: () => (/* binding */ Do),
/* harmony export */   Foldable: () => (/* binding */ Foldable),
/* harmony export */   FoldableWithIndex: () => (/* binding */ FoldableWithIndex),
/* harmony export */   Functor: () => (/* binding */ Functor),
/* harmony export */   FunctorWithIndex: () => (/* binding */ FunctorWithIndex),
/* harmony export */   Monad: () => (/* binding */ Monad),
/* harmony export */   Pointed: () => (/* binding */ Pointed),
/* harmony export */   Traversable: () => (/* binding */ Traversable),
/* harmony export */   TraversableWithIndex: () => (/* binding */ TraversableWithIndex),
/* harmony export */   URI: () => (/* binding */ URI),
/* harmony export */   alt: () => (/* binding */ alt),
/* harmony export */   altW: () => (/* binding */ altW),
/* harmony export */   ap: () => (/* binding */ ap),
/* harmony export */   apFirst: () => (/* binding */ apFirst),
/* harmony export */   apS: () => (/* binding */ apS),
/* harmony export */   apSecond: () => (/* binding */ apSecond),
/* harmony export */   append: () => (/* binding */ append),
/* harmony export */   appendW: () => (/* binding */ appendW),
/* harmony export */   bind: () => (/* binding */ bind),
/* harmony export */   bindTo: () => (/* binding */ bindTo),
/* harmony export */   chain: () => (/* binding */ chain),
/* harmony export */   chainFirst: () => (/* binding */ chainFirst),
/* harmony export */   chainWithIndex: () => (/* binding */ chainWithIndex),
/* harmony export */   chop: () => (/* binding */ chop),
/* harmony export */   chunksOf: () => (/* binding */ chunksOf),
/* harmony export */   concat: () => (/* binding */ concat),
/* harmony export */   concatAll: () => (/* binding */ concatAll),
/* harmony export */   concatW: () => (/* binding */ concatW),
/* harmony export */   cons: () => (/* binding */ cons),
/* harmony export */   duplicate: () => (/* binding */ duplicate),
/* harmony export */   empty: () => (/* binding */ empty),
/* harmony export */   extend: () => (/* binding */ extend),
/* harmony export */   extract: () => (/* binding */ extract),
/* harmony export */   filter: () => (/* binding */ filter),
/* harmony export */   filterWithIndex: () => (/* binding */ filterWithIndex),
/* harmony export */   flap: () => (/* binding */ flap),
/* harmony export */   flatMap: () => (/* binding */ flatMap),
/* harmony export */   flatten: () => (/* binding */ flatten),
/* harmony export */   fold: () => (/* binding */ fold),
/* harmony export */   foldMap: () => (/* binding */ foldMap),
/* harmony export */   foldMapWithIndex: () => (/* binding */ foldMapWithIndex),
/* harmony export */   fromArray: () => (/* binding */ fromArray),
/* harmony export */   fromReadonlyArray: () => (/* binding */ fromReadonlyArray),
/* harmony export */   getEq: () => (/* binding */ getEq),
/* harmony export */   getSemigroup: () => (/* binding */ getSemigroup),
/* harmony export */   getShow: () => (/* binding */ getShow),
/* harmony export */   getUnionSemigroup: () => (/* binding */ getUnionSemigroup),
/* harmony export */   group: () => (/* binding */ group),
/* harmony export */   groupBy: () => (/* binding */ groupBy),
/* harmony export */   groupSort: () => (/* binding */ groupSort),
/* harmony export */   head: () => (/* binding */ head),
/* harmony export */   init: () => (/* binding */ init),
/* harmony export */   insertAt: () => (/* binding */ insertAt),
/* harmony export */   intercalate: () => (/* binding */ intercalate),
/* harmony export */   intersperse: () => (/* binding */ intersperse),
/* harmony export */   isNonEmpty: () => (/* binding */ isNonEmpty),
/* harmony export */   isOutOfBound: () => (/* binding */ isOutOfBound),
/* harmony export */   last: () => (/* binding */ last),
/* harmony export */   "let": () => (/* binding */ let_),
/* harmony export */   makeBy: () => (/* binding */ makeBy),
/* harmony export */   map: () => (/* binding */ map),
/* harmony export */   mapWithIndex: () => (/* binding */ mapWithIndex),
/* harmony export */   matchLeft: () => (/* binding */ matchLeft),
/* harmony export */   matchRight: () => (/* binding */ matchRight),
/* harmony export */   max: () => (/* binding */ max),
/* harmony export */   min: () => (/* binding */ min),
/* harmony export */   modifyAt: () => (/* binding */ modifyAt),
/* harmony export */   modifyHead: () => (/* binding */ modifyHead),
/* harmony export */   modifyLast: () => (/* binding */ modifyLast),
/* harmony export */   of: () => (/* binding */ of),
/* harmony export */   prepend: () => (/* binding */ prepend),
/* harmony export */   prependAll: () => (/* binding */ prependAll),
/* harmony export */   prependToAll: () => (/* binding */ prependToAll),
/* harmony export */   prependW: () => (/* binding */ prependW),
/* harmony export */   range: () => (/* binding */ range),
/* harmony export */   readonlyNonEmptyArray: () => (/* binding */ readonlyNonEmptyArray),
/* harmony export */   reduce: () => (/* binding */ reduce),
/* harmony export */   reduceRight: () => (/* binding */ reduceRight),
/* harmony export */   reduceRightWithIndex: () => (/* binding */ reduceRightWithIndex),
/* harmony export */   reduceWithIndex: () => (/* binding */ reduceWithIndex),
/* harmony export */   replicate: () => (/* binding */ replicate),
/* harmony export */   reverse: () => (/* binding */ reverse),
/* harmony export */   rotate: () => (/* binding */ rotate),
/* harmony export */   sequence: () => (/* binding */ sequence),
/* harmony export */   snoc: () => (/* binding */ snoc),
/* harmony export */   sort: () => (/* binding */ sort),
/* harmony export */   sortBy: () => (/* binding */ sortBy),
/* harmony export */   splitAt: () => (/* binding */ splitAt),
/* harmony export */   tail: () => (/* binding */ tail),
/* harmony export */   traverse: () => (/* binding */ traverse),
/* harmony export */   traverseWithIndex: () => (/* binding */ traverseWithIndex),
/* harmony export */   unappend: () => (/* binding */ unappend),
/* harmony export */   uncons: () => (/* binding */ uncons),
/* harmony export */   union: () => (/* binding */ union),
/* harmony export */   uniq: () => (/* binding */ uniq),
/* harmony export */   unprepend: () => (/* binding */ unprepend),
/* harmony export */   unsafeInsertAt: () => (/* binding */ unsafeInsertAt),
/* harmony export */   unsafeUpdateAt: () => (/* binding */ unsafeUpdateAt),
/* harmony export */   unsnoc: () => (/* binding */ unsnoc),
/* harmony export */   unzip: () => (/* binding */ unzip),
/* harmony export */   updateAt: () => (/* binding */ updateAt),
/* harmony export */   updateHead: () => (/* binding */ updateHead),
/* harmony export */   updateLast: () => (/* binding */ updateLast),
/* harmony export */   zip: () => (/* binding */ zip),
/* harmony export */   zipWith: () => (/* binding */ zipWith)
/* harmony export */ });
/* harmony import */ var _Apply__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./Apply */ "./node_modules/fp-ts/es6/Apply.js");
/* harmony import */ var _Chain__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./Chain */ "./node_modules/fp-ts/es6/Chain.js");
/* harmony import */ var _Eq__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Eq */ "./node_modules/fp-ts/es6/Eq.js");
/* harmony import */ var _function__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./function */ "./node_modules/fp-ts/es6/function.js");
/* harmony import */ var _Functor__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./Functor */ "./node_modules/fp-ts/es6/Functor.js");
/* harmony import */ var _internal__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./internal */ "./node_modules/fp-ts/es6/internal.js");
/* harmony import */ var _Ord__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Ord */ "./node_modules/fp-ts/es6/Ord.js");
/* harmony import */ var _Semigroup__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./Semigroup */ "./node_modules/fp-ts/es6/Semigroup.js");
var __spreadArray = (undefined && undefined.__spreadArray) || function (to, from, pack) {
    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
        }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
};








// -------------------------------------------------------------------------------------
// internal
// -------------------------------------------------------------------------------------
/**
 * @internal
 */
var empty = _internal__WEBPACK_IMPORTED_MODULE_0__.emptyReadonlyArray;
/**
 * @internal
 */
var isNonEmpty = _internal__WEBPACK_IMPORTED_MODULE_0__.isNonEmpty;
/**
 * @internal
 */
var isOutOfBound = function (i, as) { return i < 0 || i >= as.length; };
/**
 * @internal
 */
var prependW = function (head) {
    return function (tail) {
        return __spreadArray([head], tail, true);
    };
};
/**
 * @internal
 */
var prepend = prependW;
/**
 * @internal
 */
var appendW = function (end) {
    return function (init) {
        return __spreadArray(__spreadArray([], init, true), [end], false);
    };
};
/**
 * @internal
 */
var append = appendW;
/**
 * @internal
 */
var unsafeInsertAt = function (i, a, as) {
    if (isNonEmpty(as)) {
        var xs = _internal__WEBPACK_IMPORTED_MODULE_0__.fromReadonlyNonEmptyArray(as);
        xs.splice(i, 0, a);
        return xs;
    }
    return [a];
};
/**
 * @internal
 */
var unsafeUpdateAt = function (i, a, as) {
    if (as[i] === a) {
        return as;
    }
    else {
        var xs = _internal__WEBPACK_IMPORTED_MODULE_0__.fromReadonlyNonEmptyArray(as);
        xs[i] = a;
        return xs;
    }
};
/**
 * Remove duplicates from a `ReadonlyNonEmptyArray`, keeping the first occurrence of an element.
 *
 * @example
 * import { uniq } from 'fp-ts/ReadonlyNonEmptyArray'
 * import * as N from 'fp-ts/number'
 *
 * assert.deepStrictEqual(uniq(N.Eq)([1, 2, 1]), [1, 2])
 *
 * @since 2.11.0
 */
var uniq = function (E) {
    return function (as) {
        if (as.length === 1) {
            return as;
        }
        var out = [head(as)];
        var rest = tail(as);
        var _loop_1 = function (a) {
            if (out.every(function (o) { return !E.equals(o, a); })) {
                out.push(a);
            }
        };
        for (var _i = 0, rest_1 = rest; _i < rest_1.length; _i++) {
            var a = rest_1[_i];
            _loop_1(a);
        }
        return out;
    };
};
/**
 * Sort the elements of a `ReadonlyNonEmptyArray` in increasing order, where elements are compared using first `ords[0]`, then `ords[1]`,
 * etc...
 *
 * @example
 * import * as RNEA from 'fp-ts/ReadonlyNonEmptyArray'
 * import { contramap } from 'fp-ts/Ord'
 * import * as S from 'fp-ts/string'
 * import * as N from 'fp-ts/number'
 * import { pipe } from 'fp-ts/function'
 *
 * interface Person {
 *   name: string
 *   age: number
 * }
 *
 * const byName = pipe(S.Ord, contramap((p: Person) => p.name))
 *
 * const byAge = pipe(N.Ord, contramap((p: Person) => p.age))
 *
 * const sortByNameByAge = RNEA.sortBy([byName, byAge])
 *
 * const persons: RNEA.ReadonlyNonEmptyArray<Person> = [
 *   { name: 'a', age: 1 },
 *   { name: 'b', age: 3 },
 *   { name: 'c', age: 2 },
 *   { name: 'b', age: 2 }
 * ]
 *
 * assert.deepStrictEqual(sortByNameByAge(persons), [
 *   { name: 'a', age: 1 },
 *   { name: 'b', age: 2 },
 *   { name: 'b', age: 3 },
 *   { name: 'c', age: 2 }
 * ])
 *
 * @since 2.11.0
 */
var sortBy = function (ords) {
    if (isNonEmpty(ords)) {
        var M = (0,_Ord__WEBPACK_IMPORTED_MODULE_1__.getMonoid)();
        return sort(ords.reduce(M.concat, M.empty));
    }
    return _function__WEBPACK_IMPORTED_MODULE_2__.identity;
};
/**
 * @since 2.11.0
 */
var union = function (E) {
    var uniqE = uniq(E);
    return function (second) { return function (first) { return uniqE((0,_function__WEBPACK_IMPORTED_MODULE_2__.pipe)(first, concat(second))); }; };
};
/**
 * Rotate a `ReadonlyNonEmptyArray` by `n` steps.
 *
 * @example
 * import { rotate } from 'fp-ts/ReadonlyNonEmptyArray'
 *
 * assert.deepStrictEqual(rotate(2)([1, 2, 3, 4, 5]), [4, 5, 1, 2, 3])
 * assert.deepStrictEqual(rotate(-2)([1, 2, 3, 4, 5]), [3, 4, 5, 1, 2])
 *
 * @since 2.11.0
 */
var rotate = function (n) {
    return function (as) {
        var len = as.length;
        var m = Math.round(n) % len;
        if (isOutOfBound(Math.abs(m), as) || m === 0) {
            return as;
        }
        if (m < 0) {
            var _a = splitAt(-m)(as), f = _a[0], s = _a[1];
            return (0,_function__WEBPACK_IMPORTED_MODULE_2__.pipe)(s, concat(f));
        }
        else {
            return rotate(m - len)(as);
        }
    };
};
// -------------------------------------------------------------------------------------
// constructors
// -------------------------------------------------------------------------------------
/**
 * Return a `ReadonlyNonEmptyArray` from a `ReadonlyArray` returning `none` if the input is empty.
 *
 * @category conversions
 * @since 2.5.0
 */
var fromReadonlyArray = function (as) {
    return isNonEmpty(as) ? _internal__WEBPACK_IMPORTED_MODULE_0__.some(as) : _internal__WEBPACK_IMPORTED_MODULE_0__.none;
};
/**
 * Return a `ReadonlyNonEmptyArray` of length `n` with element `i` initialized with `f(i)`.
 *
 * **Note**. `n` is normalized to a natural number.
 *
 * @example
 * import { makeBy } from 'fp-ts/ReadonlyNonEmptyArray'
 * import { pipe } from 'fp-ts/function'
 *
 * const double = (n: number): number => n * 2
 * assert.deepStrictEqual(pipe(5, makeBy(double)), [0, 2, 4, 6, 8])
 *
 * @category constructors
 * @since 2.11.0
 */
var makeBy = function (f) {
    return function (n) {
        var j = Math.max(0, Math.floor(n));
        var out = [f(0)];
        for (var i = 1; i < j; i++) {
            out.push(f(i));
        }
        return out;
    };
};
/**
 * Create a `ReadonlyNonEmptyArray` containing a value repeated the specified number of times.
 *
 * **Note**. `n` is normalized to a natural number.
 *
 * @example
 * import { replicate } from 'fp-ts/ReadonlyNonEmptyArray'
 * import { pipe } from 'fp-ts/function'
 *
 * assert.deepStrictEqual(pipe(3, replicate('a')), ['a', 'a', 'a'])
 *
 * @category constructors
 * @since 2.11.0
 */
var replicate = function (a) { return makeBy(function () { return a; }); };
/**
 * Create a `ReadonlyNonEmptyArray` containing a range of integers, including both endpoints.
 *
 * @example
 * import { range } from 'fp-ts/ReadonlyNonEmptyArray'
 *
 * assert.deepStrictEqual(range(1, 5), [1, 2, 3, 4, 5])
 *
 * @category constructors
 * @since 2.11.0
 */
var range = function (start, end) {
    return start <= end ? makeBy(function (i) { return start + i; })(end - start + 1) : [start];
};
/**
 * Return the tuple of the `head` and the `tail`.
 *
 * @example
 * import { unprepend } from 'fp-ts/ReadonlyNonEmptyArray'
 *
 * assert.deepStrictEqual(unprepend([1, 2, 3, 4]), [1, [2, 3, 4]])
 *
 * @since 2.9.0
 */
var unprepend = function (as) { return [head(as), tail(as)]; };
/**
 * Return the tuple of the `init` and the `last`.
 *
 * @example
 * import { unappend } from 'fp-ts/ReadonlyNonEmptyArray'
 *
 * assert.deepStrictEqual(unappend([1, 2, 3, 4]), [[1, 2, 3], 4])
 *
 * @since 2.9.0
 */
var unappend = function (as) { return [init(as), last(as)]; };
/**
 * @category conversions
 * @since 2.5.0
 */
var fromArray = function (as) { return fromReadonlyArray(as.slice()); };
function concatW(second) {
    return function (first) { return first.concat(second); };
}
function concat(x, y) {
    return y ? x.concat(y) : function (y) { return y.concat(x); };
}
/**
 * @since 2.5.0
 */
var reverse = function (as) {
    return as.length === 1 ? as : __spreadArray([last(as)], as.slice(0, -1).reverse(), true);
};
function group(E) {
    return function (as) {
        var len = as.length;
        if (len === 0) {
            return empty;
        }
        var out = [];
        var head = as[0];
        var nea = [head];
        for (var i = 1; i < len; i++) {
            var a = as[i];
            if (E.equals(a, head)) {
                nea.push(a);
            }
            else {
                out.push(nea);
                head = a;
                nea = [head];
            }
        }
        out.push(nea);
        return out;
    };
}
/**
 * Splits an array into sub-non-empty-arrays stored in an object, based on the result of calling a `string`-returning
 * function on each element, and grouping the results according to values returned
 *
 * @example
 * import { groupBy } from 'fp-ts/ReadonlyNonEmptyArray'
 *
 * assert.deepStrictEqual(groupBy((s: string) => String(s.length))(['a', 'b', 'ab']), {
 *   '1': ['a', 'b'],
 *   '2': ['ab']
 * })
 *
 * @since 2.5.0
 */
var groupBy = function (f) {
    return function (as) {
        var out = {};
        for (var _i = 0, as_1 = as; _i < as_1.length; _i++) {
            var a = as_1[_i];
            var k = f(a);
            if (_internal__WEBPACK_IMPORTED_MODULE_0__.has.call(out, k)) {
                out[k].push(a);
            }
            else {
                out[k] = [a];
            }
        }
        return out;
    };
};
/**
 * @since 2.5.0
 */
var sort = function (O) {
    return function (as) {
        return as.length === 1 ? as : as.slice().sort(O.compare);
    };
};
/**
 * @since 2.5.0
 */
var updateAt = function (i, a) {
    return modifyAt(i, function () { return a; });
};
/**
 * @since 2.5.0
 */
var modifyAt = function (i, f) {
    return function (as) {
        return isOutOfBound(i, as) ? _internal__WEBPACK_IMPORTED_MODULE_0__.none : _internal__WEBPACK_IMPORTED_MODULE_0__.some(unsafeUpdateAt(i, f(as[i]), as));
    };
};
/**
 * @since 2.5.1
 */
var zipWith = function (as, bs, f) {
    var cs = [f(as[0], bs[0])];
    var len = Math.min(as.length, bs.length);
    for (var i = 1; i < len; i++) {
        cs[i] = f(as[i], bs[i]);
    }
    return cs;
};
function zip(as, bs) {
    if (bs === undefined) {
        return function (bs) { return zip(bs, as); };
    }
    return zipWith(as, bs, function (a, b) { return [a, b]; });
}
/**
 * @since 2.5.1
 */
var unzip = function (abs) {
    var fa = [abs[0][0]];
    var fb = [abs[0][1]];
    for (var i = 1; i < abs.length; i++) {
        fa[i] = abs[i][0];
        fb[i] = abs[i][1];
    }
    return [fa, fb];
};
/**
 * Prepend an element to every member of a `ReadonlyNonEmptyArray`.
 *
 * @example
 * import { prependAll } from 'fp-ts/ReadonlyNonEmptyArray'
 *
 * assert.deepStrictEqual(prependAll(9)([1, 2, 3, 4]), [9, 1, 9, 2, 9, 3, 9, 4])
 *
 * @since 2.10.0
 */
var prependAll = function (middle) {
    return function (as) {
        var out = [middle, as[0]];
        for (var i = 1; i < as.length; i++) {
            out.push(middle, as[i]);
        }
        return out;
    };
};
/**
 * Places an element in between members of a `ReadonlyNonEmptyArray`.
 *
 * @example
 * import { intersperse } from 'fp-ts/ReadonlyNonEmptyArray'
 *
 * assert.deepStrictEqual(intersperse(9)([1, 2, 3, 4]), [1, 9, 2, 9, 3, 9, 4])
 *
 * @since 2.9.0
 */
var intersperse = function (middle) {
    return function (as) {
        var rest = tail(as);
        return isNonEmpty(rest) ? (0,_function__WEBPACK_IMPORTED_MODULE_2__.pipe)(rest, prependAll(middle), prepend(head(as))) : as;
    };
};
/**
 * @category sequencing
 * @since 2.10.0
 */
var chainWithIndex = function (f) {
    return function (as) {
        var out = _internal__WEBPACK_IMPORTED_MODULE_0__.fromReadonlyNonEmptyArray(f(0, head(as)));
        for (var i = 1; i < as.length; i++) {
            var bs = f(i, as[i]);
            for (var j = 0; j < bs.length; j++) {
                out.push(bs[j]);
            }
        }
        return out;
    };
};
/**
 * A useful recursion pattern for processing a `ReadonlyNonEmptyArray` to produce a new `ReadonlyNonEmptyArray`, often used for "chopping" up the input
 * `ReadonlyNonEmptyArray`. Typically `chop` is called with some function that will consume an initial prefix of the `ReadonlyNonEmptyArray` and produce a
 * value and the tail of the `ReadonlyNonEmptyArray`.
 *
 * @since 2.10.0
 */
var chop = function (f) {
    return function (as) {
        var _a = f(as), b = _a[0], rest = _a[1];
        var out = [b];
        var next = rest;
        while (isNonEmpty(next)) {
            var _b = f(next), b_1 = _b[0], rest_2 = _b[1];
            out.push(b_1);
            next = rest_2;
        }
        return out;
    };
};
/**
 * Splits a `ReadonlyNonEmptyArray` into two pieces, the first piece has max `n` elements.
 *
 * @since 2.10.0
 */
var splitAt = function (n) {
    return function (as) {
        var m = Math.max(1, n);
        return m >= as.length ? [as, empty] : [(0,_function__WEBPACK_IMPORTED_MODULE_2__.pipe)(as.slice(1, m), prepend(head(as))), as.slice(m)];
    };
};
/**
 * Splits a `ReadonlyNonEmptyArray` into length-`n` pieces. The last piece will be shorter if `n` does not evenly divide the length of
 * the `ReadonlyNonEmptyArray`.
 *
 * @since 2.10.0
 */
var chunksOf = function (n) { return chop(splitAt(n)); };
var _map = function (fa, f) { return (0,_function__WEBPACK_IMPORTED_MODULE_2__.pipe)(fa, map(f)); };
/* istanbul ignore next */
var _mapWithIndex = function (fa, f) { return (0,_function__WEBPACK_IMPORTED_MODULE_2__.pipe)(fa, mapWithIndex(f)); };
var _ap = function (fab, fa) { return (0,_function__WEBPACK_IMPORTED_MODULE_2__.pipe)(fab, ap(fa)); };
/* istanbul ignore next */
var _extend = function (wa, f) { return (0,_function__WEBPACK_IMPORTED_MODULE_2__.pipe)(wa, extend(f)); };
/* istanbul ignore next */
var _reduce = function (fa, b, f) { return (0,_function__WEBPACK_IMPORTED_MODULE_2__.pipe)(fa, reduce(b, f)); };
/* istanbul ignore next */
var _foldMap = function (M) {
    var foldMapM = foldMap(M);
    return function (fa, f) { return (0,_function__WEBPACK_IMPORTED_MODULE_2__.pipe)(fa, foldMapM(f)); };
};
/* istanbul ignore next */
var _reduceRight = function (fa, b, f) { return (0,_function__WEBPACK_IMPORTED_MODULE_2__.pipe)(fa, reduceRight(b, f)); };
/* istanbul ignore next */
var _traverse = function (F) {
    var traverseF = traverse(F);
    return function (ta, f) { return (0,_function__WEBPACK_IMPORTED_MODULE_2__.pipe)(ta, traverseF(f)); };
};
/* istanbul ignore next */
var _alt = function (fa, that) { return (0,_function__WEBPACK_IMPORTED_MODULE_2__.pipe)(fa, alt(that)); };
/* istanbul ignore next */
var _reduceWithIndex = function (fa, b, f) {
    return (0,_function__WEBPACK_IMPORTED_MODULE_2__.pipe)(fa, reduceWithIndex(b, f));
};
/* istanbul ignore next */
var _foldMapWithIndex = function (M) {
    var foldMapWithIndexM = foldMapWithIndex(M);
    return function (fa, f) { return (0,_function__WEBPACK_IMPORTED_MODULE_2__.pipe)(fa, foldMapWithIndexM(f)); };
};
/* istanbul ignore next */
var _reduceRightWithIndex = function (fa, b, f) {
    return (0,_function__WEBPACK_IMPORTED_MODULE_2__.pipe)(fa, reduceRightWithIndex(b, f));
};
/* istanbul ignore next */
var _traverseWithIndex = function (F) {
    var traverseWithIndexF = traverseWithIndex(F);
    return function (ta, f) { return (0,_function__WEBPACK_IMPORTED_MODULE_2__.pipe)(ta, traverseWithIndexF(f)); };
};
/**
 * @category constructors
 * @since 2.5.0
 */
var of = _internal__WEBPACK_IMPORTED_MODULE_0__.singleton;
/**
 * Less strict version of [`alt`](#alt).
 *
 * The `W` suffix (short for **W**idening) means that the return types will be merged.
 *
 * @example
 * import * as RNEA from 'fp-ts/ReadonlyNonEmptyArray'
 * import { pipe } from 'fp-ts/function'
 *
 * assert.deepStrictEqual(
 *   pipe(
 *     [1, 2, 3] as RNEA.ReadonlyNonEmptyArray<number>,
 *     RNEA.altW(() => ['a', 'b'])
 *   ),
 *   [1, 2, 3, 'a', 'b']
 * )
 *
 * @category error handling
 * @since 2.9.0
 */
var altW = function (that) {
    return function (as) {
        return (0,_function__WEBPACK_IMPORTED_MODULE_2__.pipe)(as, concatW(that()));
    };
};
/**
 * Identifies an associative operation on a type constructor. It is similar to `Semigroup`, except that it applies to
 * types of kind `* -> *`.
 *
 * In case of `ReadonlyNonEmptyArray` concatenates the inputs into a single array.
 *
 * @example
 * import * as RNEA from 'fp-ts/ReadonlyNonEmptyArray'
 * import { pipe } from 'fp-ts/function'
 *
 * assert.deepStrictEqual(
 *   pipe(
 *     [1, 2, 3],
 *     RNEA.alt(() => [4, 5])
 *   ),
 *   [1, 2, 3, 4, 5]
 * )
 *
 * @category error handling
 * @since 2.6.2
 */
var alt = altW;
/**
 * @since 2.5.0
 */
var ap = function (as) { return flatMap(function (f) { return (0,_function__WEBPACK_IMPORTED_MODULE_2__.pipe)(as, map(f)); }); };
/**
 * @example
 * import * as RNEA from 'fp-ts/ReadonlyNonEmptyArray'
 * import { pipe } from 'fp-ts/function'
 *
 * assert.deepStrictEqual(
 *   pipe(
 *     [1, 2, 3],
 *     RNEA.flatMap((n) => [`a${n}`, `b${n}`])
 *   ),
 *   ['a1', 'b1', 'a2', 'b2', 'a3', 'b3']
 * )
 *
 * @category sequencing
 * @since 2.14.0
 */
var flatMap = /*#__PURE__*/ (0,_function__WEBPACK_IMPORTED_MODULE_2__.dual)(2, function (ma, f) {
    return (0,_function__WEBPACK_IMPORTED_MODULE_2__.pipe)(ma, chainWithIndex(function (i, a) { return f(a, i); }));
});
/**
 * @since 2.5.0
 */
var extend = function (f) {
    return function (as) {
        var next = tail(as);
        var out = [f(as)];
        while (isNonEmpty(next)) {
            out.push(f(next));
            next = tail(next);
        }
        return out;
    };
};
/**
 * @since 2.5.0
 */
var duplicate = 
/*#__PURE__*/ extend(_function__WEBPACK_IMPORTED_MODULE_2__.identity);
/**
 * @category sequencing
 * @since 2.5.0
 */
var flatten = 
/*#__PURE__*/ flatMap(_function__WEBPACK_IMPORTED_MODULE_2__.identity);
/**
 * `map` can be used to turn functions `(a: A) => B` into functions `(fa: F<A>) => F<B>` whose argument and return types
 * use the type constructor `F` to represent some computational context.
 *
 * @category mapping
 * @since 2.5.0
 */
var map = function (f) {
    return mapWithIndex(function (_, a) { return f(a); });
};
/**
 * @category mapping
 * @since 2.5.0
 */
var mapWithIndex = function (f) {
    return function (as) {
        var out = [f(0, head(as))];
        for (var i = 1; i < as.length; i++) {
            out.push(f(i, as[i]));
        }
        return out;
    };
};
/**
 * @category folding
 * @since 2.5.0
 */
var reduce = function (b, f) {
    return reduceWithIndex(b, function (_, b, a) { return f(b, a); });
};
/**
 * **Note**. The constraint is relaxed: a `Semigroup` instead of a `Monoid`.
 *
 * @category folding
 * @since 2.5.0
 */
var foldMap = function (S) {
    return function (f) {
        return function (as) {
            return as.slice(1).reduce(function (s, a) { return S.concat(s, f(a)); }, f(as[0]));
        };
    };
};
/**
 * @category folding
 * @since 2.5.0
 */
var reduceRight = function (b, f) {
    return reduceRightWithIndex(b, function (_, b, a) { return f(b, a); });
};
/**
 * @category folding
 * @since 2.5.0
 */
var reduceWithIndex = function (b, f) {
    return function (as) {
        return as.reduce(function (b, a, i) { return f(i, b, a); }, b);
    };
};
/**
 * **Note**. The constraint is relaxed: a `Semigroup` instead of a `Monoid`.
 *
 * @category folding
 * @since 2.5.0
 */
var foldMapWithIndex = function (S) {
    return function (f) {
        return function (as) {
            return as.slice(1).reduce(function (s, a, i) { return S.concat(s, f(i + 1, a)); }, f(0, as[0]));
        };
    };
};
/**
 * @category folding
 * @since 2.5.0
 */
var reduceRightWithIndex = function (b, f) {
    return function (as) {
        return as.reduceRight(function (b, a, i) { return f(i, a, b); }, b);
    };
};
/**
 * @category traversing
 * @since 2.6.3
 */
var traverse = function (F) {
    var traverseWithIndexF = traverseWithIndex(F);
    return function (f) { return traverseWithIndexF(function (_, a) { return f(a); }); };
};
/**
 * @category traversing
 * @since 2.6.3
 */
var sequence = function (F) { return traverseWithIndex(F)(_function__WEBPACK_IMPORTED_MODULE_2__.SK); };
/**
 * @category sequencing
 * @since 2.6.3
 */
var traverseWithIndex = function (F) {
    return function (f) {
        return function (as) {
            var out = F.map(f(0, head(as)), of);
            for (var i = 1; i < as.length; i++) {
                out = F.ap(F.map(out, function (bs) { return function (b) { return (0,_function__WEBPACK_IMPORTED_MODULE_2__.pipe)(bs, append(b)); }; }), f(i, as[i]));
            }
            return out;
        };
    };
};
/**
 * @category Comonad
 * @since 2.6.3
 */
var extract = _internal__WEBPACK_IMPORTED_MODULE_0__.head;
/**
 * @category type lambdas
 * @since 2.5.0
 */
var URI = 'ReadonlyNonEmptyArray';
/**
 * @category instances
 * @since 2.5.0
 */
var getShow = function (S) { return ({
    show: function (as) { return "[".concat(as.map(S.show).join(', '), "]"); }
}); };
/**
 * Builds a `Semigroup` instance for `ReadonlyNonEmptyArray`
 *
 * @category instances
 * @since 2.5.0
 */
var getSemigroup = function () { return ({
    concat: concat
}); };
/**
 * @example
 * import { getEq } from 'fp-ts/ReadonlyNonEmptyArray'
 * import * as N from 'fp-ts/number'
 *
 * const E = getEq(N.Eq)
 * assert.strictEqual(E.equals([1, 2], [1, 2]), true)
 * assert.strictEqual(E.equals([1, 2], [1, 3]), false)
 *
 * @category instances
 * @since 2.5.0
 */
var getEq = function (E) {
    return (0,_Eq__WEBPACK_IMPORTED_MODULE_3__.fromEquals)(function (xs, ys) { return xs.length === ys.length && xs.every(function (x, i) { return E.equals(x, ys[i]); }); });
};
/**
 * @since 2.11.0
 */
var getUnionSemigroup = function (E) {
    var unionE = union(E);
    return {
        concat: function (first, second) { return unionE(second)(first); }
    };
};
/**
 * @category instances
 * @since 2.7.0
 */
var Functor = {
    URI: URI,
    map: _map
};
/**
 * @category mapping
 * @since 2.10.0
 */
var flap = /*#__PURE__*/ (0,_Functor__WEBPACK_IMPORTED_MODULE_4__.flap)(Functor);
/**
 * @category instances
 * @since 2.10.0
 */
var Pointed = {
    URI: URI,
    of: of
};
/**
 * @category instances
 * @since 2.7.0
 */
var FunctorWithIndex = {
    URI: URI,
    map: _map,
    mapWithIndex: _mapWithIndex
};
/**
 * @category instances
 * @since 2.10.0
 */
var Apply = {
    URI: URI,
    map: _map,
    ap: _ap
};
/**
 * Combine two effectful actions, keeping only the result of the first.
 *
 * @since 2.5.0
 */
var apFirst = /*#__PURE__*/ (0,_Apply__WEBPACK_IMPORTED_MODULE_5__.apFirst)(Apply);
/**
 * Combine two effectful actions, keeping only the result of the second.
 *
 * @since 2.5.0
 */
var apSecond = /*#__PURE__*/ (0,_Apply__WEBPACK_IMPORTED_MODULE_5__.apSecond)(Apply);
/**
 * @category instances
 * @since 2.7.0
 */
var Applicative = {
    URI: URI,
    map: _map,
    ap: _ap,
    of: of
};
/**
 * @category instances
 * @since 2.10.0
 */
var Chain = {
    URI: URI,
    map: _map,
    ap: _ap,
    chain: flatMap
};
/**
 * Composes computations in sequence, using the return value of one computation to determine the next computation and
 * keeping only the result of the first.
 *
 * @example
 * import * as RA from 'fp-ts/ReadonlyArray'
 * import { pipe } from 'fp-ts/function'
 *
 * assert.deepStrictEqual(
 *   pipe(
 *     [1, 2, 3],
 *     RA.chainFirst(() => ['a', 'b'])
 *   ),
 *   [1, 1, 2, 2, 3, 3]
 * )
 *
 * @category sequencing
 * @since 2.5.0
 */
var chainFirst = /*#__PURE__*/ (0,_Chain__WEBPACK_IMPORTED_MODULE_6__.chainFirst)(Chain);
/**
 * @category instances
 * @since 2.7.0
 */
var Monad = {
    URI: URI,
    map: _map,
    ap: _ap,
    of: of,
    chain: flatMap
};
/**
 * @category instances
 * @since 2.7.0
 */
var Foldable = {
    URI: URI,
    reduce: _reduce,
    foldMap: _foldMap,
    reduceRight: _reduceRight
};
/**
 * @category instances
 * @since 2.7.0
 */
var FoldableWithIndex = {
    URI: URI,
    reduce: _reduce,
    foldMap: _foldMap,
    reduceRight: _reduceRight,
    reduceWithIndex: _reduceWithIndex,
    foldMapWithIndex: _foldMapWithIndex,
    reduceRightWithIndex: _reduceRightWithIndex
};
/**
 * @category instances
 * @since 2.7.0
 */
var Traversable = {
    URI: URI,
    map: _map,
    reduce: _reduce,
    foldMap: _foldMap,
    reduceRight: _reduceRight,
    traverse: _traverse,
    sequence: sequence
};
/**
 * @category instances
 * @since 2.7.0
 */
var TraversableWithIndex = {
    URI: URI,
    map: _map,
    mapWithIndex: _mapWithIndex,
    reduce: _reduce,
    foldMap: _foldMap,
    reduceRight: _reduceRight,
    traverse: _traverse,
    sequence: sequence,
    reduceWithIndex: _reduceWithIndex,
    foldMapWithIndex: _foldMapWithIndex,
    reduceRightWithIndex: _reduceRightWithIndex,
    traverseWithIndex: _traverseWithIndex
};
/**
 * @category instances
 * @since 2.7.0
 */
var Alt = {
    URI: URI,
    map: _map,
    alt: _alt
};
/**
 * @category instances
 * @since 2.7.0
 */
var Comonad = {
    URI: URI,
    map: _map,
    extend: _extend,
    extract: extract
};
// -------------------------------------------------------------------------------------
// do notation
// -------------------------------------------------------------------------------------
/**
 * @category do notation
 * @since 2.9.0
 */
var Do = /*#__PURE__*/ of(_internal__WEBPACK_IMPORTED_MODULE_0__.emptyRecord);
/**
 * @category do notation
 * @since 2.8.0
 */
var bindTo = /*#__PURE__*/ (0,_Functor__WEBPACK_IMPORTED_MODULE_4__.bindTo)(Functor);
var let_ = /*#__PURE__*/ (0,_Functor__WEBPACK_IMPORTED_MODULE_4__["let"])(Functor);

/**
 * @category do notation
 * @since 2.8.0
 */
var bind = /*#__PURE__*/ (0,_Chain__WEBPACK_IMPORTED_MODULE_6__.bind)(Chain);
/**
 * @category do notation
 * @since 2.8.0
 */
var apS = /*#__PURE__*/ (0,_Apply__WEBPACK_IMPORTED_MODULE_5__.apS)(Apply);
// -------------------------------------------------------------------------------------
// utils
// -------------------------------------------------------------------------------------
/**
 * @since 2.5.0
 */
var head = extract;
/**
 * @since 2.5.0
 */
var tail = _internal__WEBPACK_IMPORTED_MODULE_0__.tail;
/**
 * @since 2.5.0
 */
var last = function (as) { return as[as.length - 1]; };
/**
 * Get all but the last element of a non empty array, creating a new array.
 *
 * @example
 * import { init } from 'fp-ts/ReadonlyNonEmptyArray'
 *
 * assert.deepStrictEqual(init([1, 2, 3]), [1, 2])
 * assert.deepStrictEqual(init([1]), [])
 *
 * @since 2.5.0
 */
var init = function (as) { return as.slice(0, -1); };
/**
 * @since 2.5.0
 */
var min = function (O) {
    var S = _Semigroup__WEBPACK_IMPORTED_MODULE_7__.min(O);
    return function (as) { return as.reduce(S.concat); };
};
/**
 * @since 2.5.0
 */
var max = function (O) {
    var S = _Semigroup__WEBPACK_IMPORTED_MODULE_7__.max(O);
    return function (as) { return as.reduce(S.concat); };
};
/**
 * @since 2.10.0
 */
var concatAll = function (S) {
    return function (as) {
        return as.reduce(S.concat);
    };
};
/**
 * Break a `ReadonlyArray` into its first element and remaining elements.
 *
 * @category pattern matching
 * @since 2.11.0
 */
var matchLeft = function (f) {
    return function (as) {
        return f(head(as), tail(as));
    };
};
/**
 * Break a `ReadonlyArray` into its initial elements and the last element.
 *
 * @category pattern matching
 * @since 2.11.0
 */
var matchRight = function (f) {
    return function (as) {
        return f(init(as), last(as));
    };
};
/**
 * Apply a function to the head, creating a new `ReadonlyNonEmptyArray`.
 *
 * @since 2.11.0
 */
var modifyHead = function (f) {
    return function (as) {
        return __spreadArray([f(head(as))], tail(as), true);
    };
};
/**
 * Change the head, creating a new `ReadonlyNonEmptyArray`.
 *
 * @since 2.11.0
 */
var updateHead = function (a) { return modifyHead(function () { return a; }); };
/**
 * Apply a function to the last element, creating a new `ReadonlyNonEmptyArray`.
 *
 * @since 2.11.0
 */
var modifyLast = function (f) {
    return function (as) {
        return (0,_function__WEBPACK_IMPORTED_MODULE_2__.pipe)(init(as), append(f(last(as))));
    };
};
/**
 * Change the last element, creating a new `ReadonlyNonEmptyArray`.
 *
 * @since 2.11.0
 */
var updateLast = function (a) { return modifyLast(function () { return a; }); };
/**
 * Places an element in between members of a `ReadonlyNonEmptyArray`, then folds the results using the provided `Semigroup`.
 *
 * @example
 * import * as S from 'fp-ts/string'
 * import { intercalate } from 'fp-ts/ReadonlyNonEmptyArray'
 *
 * assert.deepStrictEqual(intercalate(S.Semigroup)('-')(['a', 'b', 'c']), 'a-b-c')
 *
 * @since 2.12.0
 */
var intercalate = function (S) {
    var concatAllS = concatAll(S);
    return function (middle) { return (0,_function__WEBPACK_IMPORTED_MODULE_2__.flow)(intersperse(middle), concatAllS); };
};
// -------------------------------------------------------------------------------------
// legacy
// -------------------------------------------------------------------------------------
/**
 * Alias of `flatMap`.
 *
 * @category legacy
 * @since 2.5.0
 */
var chain = flatMap;
function groupSort(O) {
    var sortO = sort(O);
    var groupO = group(O);
    return function (as) { return (isNonEmpty(as) ? groupO(sortO(as)) : empty); };
}
function filter(predicate) {
    return filterWithIndex(function (_, a) { return predicate(a); });
}
/**
 * Use [`filterWithIndex`](./ReadonlyArray.ts.html#filterwithindex) instead.
 *
 * @category zone of death
 * @since 2.5.0
 * @deprecated
 */
var filterWithIndex = function (predicate) {
    return function (as) {
        return fromReadonlyArray(as.filter(function (a, i) { return predicate(i, a); }));
    };
};
/**
 * Use [`unprepend`](#unprepend) instead.
 *
 * @category zone of death
 * @since 2.10.0
 * @deprecated
 */
var uncons = unprepend;
/**
 * Use [`unappend`](#unappend) instead.
 *
 * @category zone of death
 * @since 2.10.0
 * @deprecated
 */
var unsnoc = unappend;
function cons(head, tail) {
    return tail === undefined ? prepend(head) : (0,_function__WEBPACK_IMPORTED_MODULE_2__.pipe)(tail, prepend(head));
}
/**
 * Use [`append`](./ReadonlyArray.ts.html#append) instead.
 *
 * @category zone of death
 * @since 2.5.0
 * @deprecated
 */
var snoc = function (init, end) { return (0,_function__WEBPACK_IMPORTED_MODULE_2__.pipe)(init, concat([end])); };
/**
 * Use [`insertAt`](./ReadonlyArray.ts.html#insertat) instead.
 *
 * @category zone of death
 * @since 2.5.0
 * @deprecated
 */
var insertAt = function (i, a) {
    return function (as) {
        return i < 0 || i > as.length ? _internal__WEBPACK_IMPORTED_MODULE_0__.none : _internal__WEBPACK_IMPORTED_MODULE_0__.some(unsafeInsertAt(i, a, as));
    };
};
/**
 * Use [`prependAll`](#prependall) instead.
 *
 * @category zone of death
 * @since 2.9.0
 * @deprecated
 */
var prependToAll = prependAll;
/**
 * Use [`concatAll`](#concatall) instead.
 *
 * @category zone of death
 * @since 2.5.0
 * @deprecated
 */
var fold = concatAll;
/**
 * This instance is deprecated, use small, specific instances instead.
 * For example if a function needs a `Functor` instance, pass `RNEA.Functor` instead of `RNEA.readonlyNonEmptyArray`
 * (where `RNEA` is from `import RNEA from 'fp-ts/ReadonlyNonEmptyArray'`)
 *
 * @category zone of death
 * @since 2.5.0
 * @deprecated
 */
var readonlyNonEmptyArray = {
    URI: URI,
    of: of,
    map: _map,
    mapWithIndex: _mapWithIndex,
    ap: _ap,
    chain: flatMap,
    extend: _extend,
    extract: extract,
    reduce: _reduce,
    foldMap: _foldMap,
    reduceRight: _reduceRight,
    traverse: _traverse,
    sequence: sequence,
    reduceWithIndex: _reduceWithIndex,
    foldMapWithIndex: _foldMapWithIndex,
    reduceRightWithIndex: _reduceRightWithIndex,
    traverseWithIndex: _traverseWithIndex,
    alt: _alt
};


/***/ }),

/***/ "./node_modules/fp-ts/es6/ReadonlyRecord.js":
/*!**************************************************!*\
  !*** ./node_modules/fp-ts/es6/ReadonlyRecord.js ***!
  \**************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Compactable: () => (/* binding */ Compactable),
/* harmony export */   Filterable: () => (/* binding */ Filterable),
/* harmony export */   FilterableWithIndex: () => (/* binding */ FilterableWithIndex),
/* harmony export */   Foldable: () => (/* binding */ Foldable),
/* harmony export */   FoldableWithIndex: () => (/* binding */ FoldableWithIndex),
/* harmony export */   Functor: () => (/* binding */ Functor),
/* harmony export */   FunctorWithIndex: () => (/* binding */ FunctorWithIndex),
/* harmony export */   Traversable: () => (/* binding */ Traversable),
/* harmony export */   TraversableWithIndex: () => (/* binding */ TraversableWithIndex),
/* harmony export */   URI: () => (/* binding */ URI),
/* harmony export */   Witherable: () => (/* binding */ Witherable),
/* harmony export */   _filter: () => (/* binding */ _filter),
/* harmony export */   _filterMap: () => (/* binding */ _filterMap),
/* harmony export */   _filterMapWithIndex: () => (/* binding */ _filterMapWithIndex),
/* harmony export */   _filterWithIndex: () => (/* binding */ _filterWithIndex),
/* harmony export */   _foldMap: () => (/* binding */ _foldMap),
/* harmony export */   _foldMapWithIndex: () => (/* binding */ _foldMapWithIndex),
/* harmony export */   _map: () => (/* binding */ _map),
/* harmony export */   _mapWithIndex: () => (/* binding */ _mapWithIndex),
/* harmony export */   _partition: () => (/* binding */ _partition),
/* harmony export */   _partitionMap: () => (/* binding */ _partitionMap),
/* harmony export */   _partitionMapWithIndex: () => (/* binding */ _partitionMapWithIndex),
/* harmony export */   _partitionWithIndex: () => (/* binding */ _partitionWithIndex),
/* harmony export */   _reduce: () => (/* binding */ _reduce),
/* harmony export */   _reduceRight: () => (/* binding */ _reduceRight),
/* harmony export */   _reduceRightWithIndex: () => (/* binding */ _reduceRightWithIndex),
/* harmony export */   _reduceWithIndex: () => (/* binding */ _reduceWithIndex),
/* harmony export */   _sequence: () => (/* binding */ _sequence),
/* harmony export */   _traverse: () => (/* binding */ _traverse),
/* harmony export */   collect: () => (/* binding */ collect),
/* harmony export */   compact: () => (/* binding */ compact),
/* harmony export */   deleteAt: () => (/* binding */ deleteAt),
/* harmony export */   difference: () => (/* binding */ difference),
/* harmony export */   elem: () => (/* binding */ elem),
/* harmony export */   empty: () => (/* binding */ empty),
/* harmony export */   every: () => (/* binding */ every),
/* harmony export */   filter: () => (/* binding */ filter),
/* harmony export */   filterMap: () => (/* binding */ filterMap),
/* harmony export */   filterMapWithIndex: () => (/* binding */ filterMapWithIndex),
/* harmony export */   filterWithIndex: () => (/* binding */ filterWithIndex),
/* harmony export */   flap: () => (/* binding */ flap),
/* harmony export */   foldMap: () => (/* binding */ foldMap),
/* harmony export */   foldMapWithIndex: () => (/* binding */ foldMapWithIndex),
/* harmony export */   fromEntries: () => (/* binding */ fromEntries),
/* harmony export */   fromFoldable: () => (/* binding */ fromFoldable),
/* harmony export */   fromFoldableMap: () => (/* binding */ fromFoldableMap),
/* harmony export */   fromRecord: () => (/* binding */ fromRecord),
/* harmony export */   getDifferenceMagma: () => (/* binding */ getDifferenceMagma),
/* harmony export */   getEq: () => (/* binding */ getEq),
/* harmony export */   getFoldable: () => (/* binding */ getFoldable),
/* harmony export */   getFoldableWithIndex: () => (/* binding */ getFoldableWithIndex),
/* harmony export */   getIntersectionSemigroup: () => (/* binding */ getIntersectionSemigroup),
/* harmony export */   getMonoid: () => (/* binding */ getMonoid),
/* harmony export */   getShow: () => (/* binding */ getShow),
/* harmony export */   getTraversable: () => (/* binding */ getTraversable),
/* harmony export */   getTraversableWithIndex: () => (/* binding */ getTraversableWithIndex),
/* harmony export */   getUnionMonoid: () => (/* binding */ getUnionMonoid),
/* harmony export */   getUnionSemigroup: () => (/* binding */ getUnionSemigroup),
/* harmony export */   getWitherable: () => (/* binding */ getWitherable),
/* harmony export */   has: () => (/* binding */ has),
/* harmony export */   hasOwnProperty: () => (/* binding */ hasOwnProperty),
/* harmony export */   insertAt: () => (/* binding */ insertAt),
/* harmony export */   intersection: () => (/* binding */ intersection),
/* harmony export */   isEmpty: () => (/* binding */ isEmpty),
/* harmony export */   isSubrecord: () => (/* binding */ isSubrecord),
/* harmony export */   keys: () => (/* binding */ keys),
/* harmony export */   lookup: () => (/* binding */ lookup),
/* harmony export */   map: () => (/* binding */ map),
/* harmony export */   mapWithIndex: () => (/* binding */ mapWithIndex),
/* harmony export */   modifyAt: () => (/* binding */ modifyAt),
/* harmony export */   partition: () => (/* binding */ partition),
/* harmony export */   partitionMap: () => (/* binding */ partitionMap),
/* harmony export */   partitionMapWithIndex: () => (/* binding */ partitionMapWithIndex),
/* harmony export */   partitionWithIndex: () => (/* binding */ partitionWithIndex),
/* harmony export */   pop: () => (/* binding */ pop),
/* harmony export */   readonlyRecord: () => (/* binding */ readonlyRecord),
/* harmony export */   reduce: () => (/* binding */ reduce),
/* harmony export */   reduceRight: () => (/* binding */ reduceRight),
/* harmony export */   reduceRightWithIndex: () => (/* binding */ reduceRightWithIndex),
/* harmony export */   reduceWithIndex: () => (/* binding */ reduceWithIndex),
/* harmony export */   separate: () => (/* binding */ separate),
/* harmony export */   sequence: () => (/* binding */ sequence),
/* harmony export */   singleton: () => (/* binding */ singleton),
/* harmony export */   size: () => (/* binding */ size),
/* harmony export */   some: () => (/* binding */ some),
/* harmony export */   toEntries: () => (/* binding */ toEntries),
/* harmony export */   toReadonlyArray: () => (/* binding */ toReadonlyArray),
/* harmony export */   toRecord: () => (/* binding */ toRecord),
/* harmony export */   toUnfoldable: () => (/* binding */ toUnfoldable),
/* harmony export */   traverse: () => (/* binding */ traverse),
/* harmony export */   traverseWithIndex: () => (/* binding */ traverseWithIndex),
/* harmony export */   union: () => (/* binding */ union),
/* harmony export */   updateAt: () => (/* binding */ updateAt),
/* harmony export */   upsertAt: () => (/* binding */ upsertAt),
/* harmony export */   wilt: () => (/* binding */ wilt),
/* harmony export */   wither: () => (/* binding */ wither)
/* harmony export */ });
/* harmony import */ var _Eq__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./Eq */ "./node_modules/fp-ts/es6/Eq.js");
/* harmony import */ var _function__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./function */ "./node_modules/fp-ts/es6/function.js");
/* harmony import */ var _Functor__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./Functor */ "./node_modules/fp-ts/es6/Functor.js");
/* harmony import */ var _internal__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./internal */ "./node_modules/fp-ts/es6/internal.js");
/* harmony import */ var _Separated__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Separated */ "./node_modules/fp-ts/es6/Separated.js");
/* harmony import */ var _string__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./string */ "./node_modules/fp-ts/es6/string.js");
/* harmony import */ var _Witherable__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./Witherable */ "./node_modules/fp-ts/es6/Witherable.js");







/**
 * Builds a `ReadonlyRecord` by copying a `Record`.
 *
 * @example
 * import { ReadonlyRecord, fromRecord } from "fp-ts/ReadonlyRecord"
 *
 * const x: Record<string, number> = { a: 1, b: 2 };
 * const y: ReadonlyRecord<string, number> = fromRecord(x);
 * assert.deepStrictEqual(x,y);
 * // `y.a = 5` gives compiler error
 *
 * @category conversions
 * @since 2.5.0
 */
var fromRecord = function (r) { return Object.assign({}, r); };
/**
 * Builds a mutable `Record` from a `ReadonlyRecord`.
 *
 * @example
 * import { ReadonlyRecord, toRecord } from "fp-ts/ReadonlyRecord"
 *
 * const x: ReadonlyRecord<string, number> = { a: 1, b: 2 };
 * const y: Record<string, number> = toRecord(x);
 * assert.deepStrictEqual(x,y);
 * y.a = 5; // it's ok, y is mutable
 *
 * @category conversions
 * @since 2.5.0
 */
var toRecord = function (r) { return Object.assign({}, r); };
/**
 * Calculate the number of key/value pairs in a `ReadonlyRecord`,
 *
 * @example
 * import { size } from "fp-ts/ReadonlyRecord";
 *
 * assert.deepStrictEqual(size({ a: true, b: 2, c: "three" }), 3);
 *
 * @since 2.5.0
 */
var size = function (r) { return Object.keys(r).length; };
/**
 * Test whether a `ReadonlyRecord` is empty.
 *
 * @example
 * import { isEmpty } from "fp-ts/ReadonlyRecord"
 *
 * assert.deepStrictEqual(isEmpty({}), true);
 * assert.deepStrictEqual(isEmpty({ a: 3 }), false);
 * @since 2.5.0
 */
var isEmpty = function (r) {
    for (var k in r) {
        if (_internal__WEBPACK_IMPORTED_MODULE_0__.has.call(r, k)) {
            return false;
        }
    }
    return true;
};
var keys_ = function (O) {
    return function (r) {
        return Object.keys(r).sort(O.compare);
    };
};
/**
 * @since 2.5.0
 */
var keys = /*#__PURE__*/ keys_(_string__WEBPACK_IMPORTED_MODULE_1__.Ord);
function collect(O) {
    if (typeof O === 'function') {
        return collect(_string__WEBPACK_IMPORTED_MODULE_1__.Ord)(O);
    }
    var keysO = keys_(O);
    return function (f) {
        return function (r) {
            var out = [];
            for (var _i = 0, _a = keysO(r); _i < _a.length; _i++) {
                var key = _a[_i];
                out.push(f(key, r[key]));
            }
            return out;
        };
    };
}
/**
 * Get a sorted `ReadonlyArray` of the key/value pairs contained in a `ReadonlyRecord`.
 *
 * @example
 * import { toReadonlyArray } from 'fp-ts/ReadonlyRecord'
 *
 * const x = { c: 3, a: "foo", b: false };
 * assert.deepStrictEqual(toReadonlyArray(x), [
 *   ["a", "foo"],
 *   ["b", false],
 *   ["c", 3],
 * ]);
 *
 * @category conversions
 * @since 2.5.0
 */
var toReadonlyArray = 
/*#__PURE__*/ collect(_string__WEBPACK_IMPORTED_MODULE_1__.Ord)(function (k, a) { return [k, a]; });
function toUnfoldable(U) {
    return function (r) {
        var sas = toReadonlyArray(r);
        var len = sas.length;
        return U.unfold(0, function (b) { return (b < len ? _internal__WEBPACK_IMPORTED_MODULE_0__.some([sas[b], b + 1]) : _internal__WEBPACK_IMPORTED_MODULE_0__.none); });
    };
}
/**
 * Insert or replace a key/value pair in a `ReadonlyRecord`.
 *
 * @example
 * import { upsertAt } from 'fp-ts/ReadonlyRecord'
 *
 * assert.deepStrictEqual(upsertAt("a", 5)({ a: 1, b: 2 }), { a: 5, b: 2 });
 * assert.deepStrictEqual(upsertAt("c", 5)({ a: 1, b: 2 }), { a: 1, b: 2, c: 5 });
 *
 * @since 2.10.0
 */
var upsertAt = function (k, a) {
    return function (r) {
        if (_internal__WEBPACK_IMPORTED_MODULE_0__.has.call(r, k) && r[k] === a) {
            return r;
        }
        var out = Object.assign({}, r);
        out[k] = a;
        return out;
    };
};
/**
 * Test whether or not a key exists in a `ReadonlyRecord`.
 *
 * Note. This function is not pipeable because is a `Refinement`.
 *
 * @example
 * import { has } from 'fp-ts/ReadonlyRecord'
 *
 * assert.deepStrictEqual(has("a", { a: 1, b: 2 }), true);
 * assert.deepStrictEqual(has("c", { a: 1, b: 2 }), false);
 *
 * @since 2.10.0
 */
var has = function (k, r) { return _internal__WEBPACK_IMPORTED_MODULE_0__.has.call(r, k); };
function deleteAt(k) {
    return function (r) {
        if (!_internal__WEBPACK_IMPORTED_MODULE_0__.has.call(r, k)) {
            return r;
        }
        var out = Object.assign({}, r);
        delete out[k];
        return out;
    };
}
/**
 * Replace a key/value pair in a `ReadonlyRecord`.
 *
 * @returns If the specified key exists it returns an `Option` containing a new `Record`
 * with the entry updated, otherwise it returns `None`
 *
 * @example
 * import { updateAt } from 'fp-ts/ReadonlyRecord'
 * import { option } from 'fp-ts'
 *
 * assert.deepStrictEqual(updateAt("a", 3)({ a: 1, b: 2 }), option.some({ a: 3, b: 2 }));
 * assert.deepStrictEqual(updateAt("c", 3)({ a: 1, b: 2 }), option.none);
 *
 * @since 2.5.0
 */
var updateAt = function (k, a) {
    return function (r) {
        if (!has(k, r)) {
            return _internal__WEBPACK_IMPORTED_MODULE_0__.none;
        }
        if (r[k] === a) {
            return _internal__WEBPACK_IMPORTED_MODULE_0__.some(r);
        }
        var out = Object.assign({}, r);
        out[k] = a;
        return _internal__WEBPACK_IMPORTED_MODULE_0__.some(out);
    };
};
/**
 * Applies a mapping function to one specific key/value pair in a `ReadonlyRecord`.
 *
 * @returns If the specified key exists it returns an `Option` containing a new `Record`
 * with the entry updated, otherwise it returns `None`
 *
 * @example
 * import { modifyAt } from 'fp-ts/ReadonlyRecord'
 * import { option } from 'fp-ts'
 *
 * assert.deepStrictEqual(modifyAt("a", (x: number) => x * 3)({ a: 1, b: 2 }), option.some({ a: 3, b: 2 }));
 * assert.deepStrictEqual(modifyAt("c", (x: number) => x * 3)({ a: 1, b: 2 }), option.none);
 *
 * @since 2.5.0
 */
var modifyAt = function (k, f) {
    return function (r) {
        if (!has(k, r)) {
            return _internal__WEBPACK_IMPORTED_MODULE_0__.none;
        }
        var next = f(r[k]);
        if (next === r[k]) {
            return _internal__WEBPACK_IMPORTED_MODULE_0__.some(r);
        }
        var out = Object.assign({}, r);
        out[k] = next;
        return _internal__WEBPACK_IMPORTED_MODULE_0__.some(out);
    };
};
function pop(k) {
    var deleteAtk = deleteAt(k);
    return function (r) {
        var oa = lookup(k, r);
        return _internal__WEBPACK_IMPORTED_MODULE_0__.isNone(oa) ? _internal__WEBPACK_IMPORTED_MODULE_0__.none : _internal__WEBPACK_IMPORTED_MODULE_0__.some([oa.value, deleteAtk(r)]);
    };
}
function isSubrecord(E) {
    return function (me, that) {
        if (that === undefined) {
            var isSubrecordE_1 = isSubrecord(E);
            return function (that) { return isSubrecordE_1(that, me); };
        }
        for (var k in me) {
            if (!_internal__WEBPACK_IMPORTED_MODULE_0__.has.call(that, k) || !E.equals(me[k], that[k])) {
                return false;
            }
        }
        return true;
    };
}
function lookup(k, r) {
    if (r === undefined) {
        return function (r) { return lookup(k, r); };
    }
    return _internal__WEBPACK_IMPORTED_MODULE_0__.has.call(r, k) ? _internal__WEBPACK_IMPORTED_MODULE_0__.some(r[k]) : _internal__WEBPACK_IMPORTED_MODULE_0__.none;
}
/**
 * @since 2.5.0
 */
var empty = {};
function mapWithIndex(f) {
    return function (r) {
        var out = {};
        for (var k in r) {
            if (_internal__WEBPACK_IMPORTED_MODULE_0__.has.call(r, k)) {
                out[k] = f(k, r[k]);
            }
        }
        return out;
    };
}
function map(f) {
    return mapWithIndex(function (_, a) { return f(a); });
}
function reduceWithIndex() {
    var args = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
    }
    if (args.length === 2) {
        return reduceWithIndex(_string__WEBPACK_IMPORTED_MODULE_1__.Ord).apply(void 0, args);
    }
    var keysO = keys_(args[0]);
    return function (b, f) { return function (fa) {
        var out = b;
        var ks = keysO(fa);
        var len = ks.length;
        for (var i = 0; i < len; i++) {
            var k = ks[i];
            out = f(k, out, fa[k]);
        }
        return out;
    }; };
}
function foldMapWithIndex(O) {
    if ('compare' in O) {
        var keysO_1 = keys_(O);
        return function (M) {
            return function (f) {
                return function (fa) {
                    var out = M.empty;
                    var ks = keysO_1(fa);
                    var len = ks.length;
                    for (var i = 0; i < len; i++) {
                        var k = ks[i];
                        out = M.concat(out, f(k, fa[k]));
                    }
                    return out;
                };
            };
        };
    }
    return foldMapWithIndex(_string__WEBPACK_IMPORTED_MODULE_1__.Ord)(O);
}
function reduceRightWithIndex() {
    var args = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
    }
    if (args.length === 2) {
        return reduceRightWithIndex(_string__WEBPACK_IMPORTED_MODULE_1__.Ord).apply(void 0, args);
    }
    var keysO = keys_(args[0]);
    return function (b, f) { return function (fa) {
        var out = b;
        var ks = keysO(fa);
        var len = ks.length;
        for (var i = len - 1; i >= 0; i--) {
            var k = ks[i];
            out = f(k, fa[k], out);
        }
        return out;
    }; };
}
/**
 * Create a `ReadonlyRecord` with one key/value pair.
 *
 * @example
 * import { singleton } from "fp-ts/ReadonlyRecord";
 *
 * assert.deepStrictEqual(singleton("a", 1), { a: 1 });
 *
 * @category constructors
 * @since 2.5.0
 */
var singleton = function (k, a) {
    var _a;
    return (_a = {}, _a[k] = a, _a);
};
function traverseWithIndex(F) {
    var traverseWithIndexOF = _traverseWithIndex(_string__WEBPACK_IMPORTED_MODULE_1__.Ord)(F);
    return function (f) { return function (ta) { return traverseWithIndexOF(ta, f); }; };
}
function traverse(F) {
    var traverseOF = _traverse(_string__WEBPACK_IMPORTED_MODULE_1__.Ord)(F);
    return function (f) { return function (ta) { return traverseOF(ta, f); }; };
}
function sequence(F) {
    return _sequence(_string__WEBPACK_IMPORTED_MODULE_1__.Ord)(F);
}
/**
 * @category filtering
 * @since 2.6.5
 */
var wither = function (F) {
    var traverseF = traverse(F);
    return function (f) { return function (fa) { return F.map((0,_function__WEBPACK_IMPORTED_MODULE_2__.pipe)(fa, traverseF(f)), compact); }; };
};
/**
 * @category filtering
 * @since 2.6.5
 */
var wilt = function (F) {
    var traverseF = traverse(F);
    return function (f) { return function (fa) { return F.map((0,_function__WEBPACK_IMPORTED_MODULE_2__.pipe)(fa, traverseF(f)), separate); }; };
};
function partitionMapWithIndex(f) {
    return function (r) {
        var left = {};
        var right = {};
        for (var k in r) {
            if (_internal__WEBPACK_IMPORTED_MODULE_0__.has.call(r, k)) {
                var e = f(k, r[k]);
                switch (e._tag) {
                    case 'Left':
                        left[k] = e.left;
                        break;
                    case 'Right':
                        right[k] = e.right;
                        break;
                }
            }
        }
        return (0,_Separated__WEBPACK_IMPORTED_MODULE_3__.separated)(left, right);
    };
}
function partitionWithIndex(predicateWithIndex) {
    return function (r) {
        var left = {};
        var right = {};
        for (var k in r) {
            if (_internal__WEBPACK_IMPORTED_MODULE_0__.has.call(r, k)) {
                var a = r[k];
                if (predicateWithIndex(k, a)) {
                    right[k] = a;
                }
                else {
                    left[k] = a;
                }
            }
        }
        return (0,_Separated__WEBPACK_IMPORTED_MODULE_3__.separated)(left, right);
    };
}
function filterMapWithIndex(f) {
    return function (r) {
        var out = {};
        for (var k in r) {
            if (_internal__WEBPACK_IMPORTED_MODULE_0__.has.call(r, k)) {
                var ob = f(k, r[k]);
                if (_internal__WEBPACK_IMPORTED_MODULE_0__.isSome(ob)) {
                    out[k] = ob.value;
                }
            }
        }
        return out;
    };
}
function filterWithIndex(predicateWithIndex) {
    return function (fa) {
        var out = {};
        var changed = false;
        for (var key in fa) {
            if (_internal__WEBPACK_IMPORTED_MODULE_0__.has.call(fa, key)) {
                var a = fa[key];
                if (predicateWithIndex(key, a)) {
                    out[key] = a;
                }
                else {
                    changed = true;
                }
            }
        }
        return changed ? out : fa;
    };
}
function fromFoldable(M, F) {
    var fromFoldableMapM = fromFoldableMap(M, F);
    return function (fka) { return fromFoldableMapM(fka, _function__WEBPACK_IMPORTED_MODULE_2__.identity); };
}
function fromFoldableMap(M, F) {
    return function (ta, f) {
        return F.reduce(ta, {}, function (r, a) {
            var _a = f(a), k = _a[0], b = _a[1];
            r[k] = _internal__WEBPACK_IMPORTED_MODULE_0__.has.call(r, k) ? M.concat(r[k], b) : b;
            return r;
        });
    };
}
/**
 * Alias of [`toReadonlyArray`](#toreadonlyarray).
 *
 * @example
 * import { toEntries } from 'fp-ts/ReadonlyRecord'
 *
 * assert.deepStrictEqual(toEntries({ b: 2, a: 1 }), [['a', 1], ['b', 2]])
 *
 * @category conversions
 * @since 2.12.0
 */
var toEntries = toReadonlyArray;
/**
 * Converts a `ReadonlyArray` of `[key, value]` tuples into a `ReadonlyRecord`.
 *
 * @example
 * import { fromEntries } from 'fp-ts/ReadonlyRecord'
 *
 * assert.deepStrictEqual(fromEntries([['a', 1], ['b', 2], ['a', 3]]), { b: 2, a: 3 })
 *
 * @since 2.12.0
 * @category conversions
 */
var fromEntries = function (fa) {
    var out = {};
    for (var _i = 0, fa_1 = fa; _i < fa_1.length; _i++) {
        var a = fa_1[_i];
        out[a[0]] = a[1];
    }
    return out;
};
function every(predicate) {
    return function (r) {
        for (var k in r) {
            if (!predicate(r[k])) {
                return false;
            }
        }
        return true;
    };
}
/**
 * Test if at least one value in a `ReadonlyRecord` satisfies the predicate.
 *
 * @example
 * import { some } from "fp-ts/ReadonlyRecord"
 *
 * assert.deepStrictEqual(some((n: number) => n >= 0)({ a: 1, b: -2 }), true);
 * assert.deepStrictEqual(some((n: number) => n >= 0)({ a: -1, b: -2 }), false);
 *
 * @since 2.5.0
 */
function some(predicate) {
    return function (r) {
        for (var k in r) {
            if (predicate(r[k])) {
                return true;
            }
        }
        return false;
    };
}
function elem(E) {
    return function (a, fa) {
        if (fa === undefined) {
            var elemE_1 = elem(E);
            return function (fa) { return elemE_1(a, fa); };
        }
        for (var k in fa) {
            if (E.equals(fa[k], a)) {
                return true;
            }
        }
        return false;
    };
}
/**
 * Union of two `ReadonlyRecord`s.
 * Takes two `ReadonlyRecord`s and produces a `ReadonlyRecord` combining all the
 * entries of the two inputs.
 * It uses the `concat` function of the provided `Magma` to
 * combine the elements with the same key.
 *
 * @example
 * import { union } from "fp-ts/ReadonlyRecord";
 * import { Magma } from "fp-ts/Magma";
 *
 * const m1: Magma<number> = { concat: (x: number, y: number) => x + y };
 * assert.deepStrictEqual(union(m1)({ a: 3, c: 3 })({ a: 1, b: 2 }), { a: 4, b: 2, c: 3 });
 * const m2: Magma<number> = { concat: (x: number) => x };
 * assert.deepStrictEqual(union(m2)({ a: 3, c: 3 })({ a: 1, b: 2 }), { a: 1, b: 2, c: 3 });
 *
 * @since 2.11.0
 */
var union = function (M) {
    return function (second) {
        return function (first) {
            if (isEmpty(first)) {
                return second;
            }
            if (isEmpty(second)) {
                return first;
            }
            var out = {};
            for (var k in first) {
                if (has(k, second)) {
                    out[k] = M.concat(first[k], second[k]);
                }
                else {
                    out[k] = first[k];
                }
            }
            for (var k in second) {
                if (!has(k, out)) {
                    out[k] = second[k];
                }
            }
            return out;
        };
    };
};
/**
 * Intersection of two `ReadonlyRecord`s.
 * Takes two `ReadonlyRecord`s and produces a `ReadonlyRecord` combining only the
 * entries of the two inputswith the same key.
 * It uses the `concat` function of the provided `Magma` to
 * combine the elements.
 *
 * @example
 * import { intersection } from "fp-ts/ReadonlyRecord";
 * import { Magma } from "fp-ts/Magma";
 *
 * const m1: Magma<number> = { concat: (x: number, y: number) => x + y };
 * assert.deepStrictEqual(intersection(m1)({ a: 3, c: 3 })({ a: 1, b: 2 }), { a: 4});
 * const m2: Magma<number> = { concat: (x: number) => x };
 * assert.deepStrictEqual(intersection(m2)({ a: 3, c: 3 })({ a: 1, b: 2 }), { a: 1});
 *
 * @since 2.11.0
 */
var intersection = function (M) {
    return function (second) {
        return function (first) {
            if (isEmpty(first) || isEmpty(second)) {
                return empty;
            }
            var out = {};
            for (var k in first) {
                if (has(k, second)) {
                    out[k] = M.concat(first[k], second[k]);
                }
            }
            return out;
        };
    };
};
/**
 * Difference between two `ReadonlyRecord`s.
 * Takes two `ReadonlyRecord`s and produces a `ReadonlyRecord` composed by the
 * entries of the two inputs, removing the entries with the same
 * key in both inputs.
 *
 * @example
 * import { difference } from "fp-ts/ReadonlyRecord";
 *
 * assert.deepStrictEqual(difference({ a: 1 })({ a: 1, b: 2 }), { b: 2 });
 * assert.deepStrictEqual(difference({ a: 3 })({ a: 1, b: 2 }), { b: 2 });
 * assert.deepStrictEqual(difference({ a: 3, c: 3 })({ a: 1, b: 2 }), { b: 2, c: 3 });
 *
 * @since 2.11.0
 */
var difference = function (second) {
    return function (first) {
        if (isEmpty(first)) {
            return second;
        }
        if (isEmpty(second)) {
            return first;
        }
        var out = {};
        for (var k in first) {
            if (!has(k, second)) {
                out[k] = first[k];
            }
        }
        for (var k in second) {
            if (!has(k, first)) {
                out[k] = second[k];
            }
        }
        return out;
    };
};
/** @internal */
var _map = function (fa, f) { return (0,_function__WEBPACK_IMPORTED_MODULE_2__.pipe)(fa, map(f)); };
/** @internal */
/* istanbul ignore next */
var _mapWithIndex = function (fa, f) { return (0,_function__WEBPACK_IMPORTED_MODULE_2__.pipe)(fa, mapWithIndex(f)); };
/** @internal */
/* istanbul ignore next */
var _reduce = function (O) {
    var reduceO = reduce(O);
    return function (fa, b, f) { return (0,_function__WEBPACK_IMPORTED_MODULE_2__.pipe)(fa, reduceO(b, f)); };
};
/** @internal */
var _foldMap = function (O) { return function (M) {
    var foldMapM = foldMap(O)(M);
    return function (fa, f) { return (0,_function__WEBPACK_IMPORTED_MODULE_2__.pipe)(fa, foldMapM(f)); };
}; };
/** @internal */
/* istanbul ignore next */
var _reduceRight = function (O) {
    var reduceRightO = reduceRight(O);
    return function (fa, b, f) { return (0,_function__WEBPACK_IMPORTED_MODULE_2__.pipe)(fa, reduceRightO(b, f)); };
};
/** @internal */
/* istanbul ignore next */
var _filter = function (fa, predicate) {
    return (0,_function__WEBPACK_IMPORTED_MODULE_2__.pipe)(fa, filter(predicate));
};
/** @internal */
/* istanbul ignore next */
var _filterMap = function (fa, f) { return (0,_function__WEBPACK_IMPORTED_MODULE_2__.pipe)(fa, filterMap(f)); };
/** @internal */
/* istanbul ignore next */
var _partition = function (fa, predicate) { return (0,_function__WEBPACK_IMPORTED_MODULE_2__.pipe)(fa, partition(predicate)); };
/** @internal */
/* istanbul ignore next */
var _partitionMap = function (fa, f) { return (0,_function__WEBPACK_IMPORTED_MODULE_2__.pipe)(fa, partitionMap(f)); };
/** @internal */
/* istanbul ignore next */
var _reduceWithIndex = function (O) {
    var reduceWithIndexO = reduceWithIndex(O);
    return function (fa, b, f) { return (0,_function__WEBPACK_IMPORTED_MODULE_2__.pipe)(fa, reduceWithIndexO(b, f)); };
};
/** @internal */
var _foldMapWithIndex = function (O) {
    var foldMapWithIndexO = foldMapWithIndex(O);
    return function (M) {
        var foldMapWithIndexM = foldMapWithIndexO(M);
        return function (fa, f) { return (0,_function__WEBPACK_IMPORTED_MODULE_2__.pipe)(fa, foldMapWithIndexM(f)); };
    };
};
/** @internal */
/* istanbul ignore next */
var _reduceRightWithIndex = function (O) {
    var reduceRightWithIndexO = reduceRightWithIndex(O);
    return function (fa, b, f) { return (0,_function__WEBPACK_IMPORTED_MODULE_2__.pipe)(fa, reduceRightWithIndexO(b, f)); };
};
/** @internal */
/* istanbul ignore next */
var _partitionMapWithIndex = function (fa, f) { return (0,_function__WEBPACK_IMPORTED_MODULE_2__.pipe)(fa, partitionMapWithIndex(f)); };
/** @internal */
/* istanbul ignore next */
var _partitionWithIndex = function (fa, predicateWithIndex) {
    return (0,_function__WEBPACK_IMPORTED_MODULE_2__.pipe)(fa, partitionWithIndex(predicateWithIndex));
};
/** @internal */
/* istanbul ignore next */
var _filterMapWithIndex = function (fa, f) { return (0,_function__WEBPACK_IMPORTED_MODULE_2__.pipe)(fa, filterMapWithIndex(f)); };
/** @internal */
/* istanbul ignore next */
var _filterWithIndex = function (fa, predicateWithIndex) { return (0,_function__WEBPACK_IMPORTED_MODULE_2__.pipe)(fa, filterWithIndex(predicateWithIndex)); };
/** @internal */
var _traverse = function (O) {
    var traverseWithIndexO = _traverseWithIndex(O);
    return function (F) {
        var traverseWithIndexOF = traverseWithIndexO(F);
        return function (ta, f) { return traverseWithIndexOF(ta, (0,_function__WEBPACK_IMPORTED_MODULE_2__.flow)(_function__WEBPACK_IMPORTED_MODULE_2__.SK, f)); };
    };
};
/** @internal */
var _sequence = function (O) {
    var traverseO = _traverse(O);
    return function (F) {
        var traverseOF = traverseO(F);
        return function (ta) { return traverseOF(ta, _function__WEBPACK_IMPORTED_MODULE_2__.identity); };
    };
};
var _traverseWithIndex = function (O) {
    return function (F) {
        var keysO = keys_(O);
        return function (ta, f) {
            var ks = keysO(ta);
            if (ks.length === 0) {
                return F.of(empty);
            }
            var fr = F.of({});
            var _loop_1 = function (key) {
                fr = F.ap(F.map(fr, function (r) { return function (b) {
                    var _a;
                    return Object.assign({}, r, (_a = {}, _a[key] = b, _a));
                }; }), f(key, ta[key]));
            };
            for (var _i = 0, ks_1 = ks; _i < ks_1.length; _i++) {
                var key = ks_1[_i];
                _loop_1(key);
            }
            return fr;
        };
    };
};
/**
 * Given a `Predicate`, it produces a new `ReadonlyRecord` keeping only the entries with a
 * value that satisfies the provided predicate.
 *
 * @example
 * import { filter } from "fp-ts/ReadonlyRecord"
 *
 * assert.deepStrictEqual(filter((s: string) => s.length < 4)({ a: "foo", b: "bar", c: "verylong" }), {
 *   a: "foo",
 *   b: "bar",
 * });
 *
 * @category filtering
 * @since 2.5.0
 */
var filter = function (predicate) {
    return filterWithIndex(function (_, a) { return predicate(a); });
};
/**
 * Maps a `ReadonlyRecord` with an iterating function that returns an `Option`
 * and it keeps only the `Some` values discarding the `None`s.
 *
 * @example
 * import { filterMap } from "fp-ts/ReadonlyRecord"
 * import { option } from "fp-ts"
 *
 * const f = (s: string) => s.length < 4 ? option.some(`${s} is short`): option.none
 * assert.deepStrictEqual(filterMap(f)({ a: "foo", b: "bar", c: "verylong" }), {
 *   a: "foo is short",
 *   b: "bar is short",
 * });
 *
 * @category filtering
 * @since 2.5.0
 */
var filterMap = function (f) { return filterMapWithIndex(function (_, a) { return f(a); }); };
/**
 * Partition a `ReadonlyRecord` into two parts according to a `Predicate`.
 *
 * @example
 * import { partition } from "fp-ts/ReadonlyRecord"
 *
 * assert.deepStrictEqual(partition((s: string) => s.length < 4)({ a: "foo", b: "bar", c: "verylong" }), {
 *   left:{
 *     c: "verylong"
 *   },
 *   right: {
 *     a: "foo",
 *     b: "bar",
 *   },
 * });
 *
 * @category filtering
 * @since 2.5.0
 */
var partition = function (predicate) {
    return partitionWithIndex(function (_, a) { return predicate(a); });
};
/**
 * Maps a `ReadonlyRecord` with a function returning an `Either` and
 * partitions the resulting `ReadonlyRecord` into `Left`s and `Right`s.
 *
 * @example
 * import { partitionMap } from "fp-ts/ReadonlyRecord"
 * import { either } from "fp-ts"
 *
 * const f = (s: string) => (s.length < 4 ? either.right(`${s} is short`) : either.left(`${s} is not short`));
 * assert.deepStrictEqual(partitionMap(f)({ a: "foo", b: "bar", c: "verylong" }), {
 *   left: {
 *     c: "verylong is not short",
 *   },
 *   right: {
 *     a: "foo is short",
 *     b: "bar is short",
 *   },
 * });
 *
 * @category filtering
 * @since 2.5.0
 */
var partitionMap = function (f) {
    return partitionMapWithIndex(function (_, a) { return f(a); });
};
function reduce() {
    var args = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
    }
    if (args.length === 1) {
        var reduceWithIndexO_1 = reduceWithIndex(args[0]);
        return function (b, f) { return reduceWithIndexO_1(b, function (_, b, a) { return f(b, a); }); };
    }
    return reduce(_string__WEBPACK_IMPORTED_MODULE_1__.Ord).apply(void 0, args);
}
function foldMap(O) {
    if ('compare' in O) {
        var foldMapWithIndexO_1 = foldMapWithIndex(O);
        return function (M) {
            var foldMapWithIndexM = foldMapWithIndexO_1(M);
            return function (f) { return foldMapWithIndexM(function (_, a) { return f(a); }); };
        };
    }
    return foldMap(_string__WEBPACK_IMPORTED_MODULE_1__.Ord)(O);
}
function reduceRight() {
    var args = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
    }
    if (args.length === 1) {
        var reduceRightWithIndexO_1 = reduceRightWithIndex(args[0]);
        return function (b, f) { return reduceRightWithIndexO_1(b, function (_, b, a) { return f(b, a); }); };
    }
    return reduceRight(_string__WEBPACK_IMPORTED_MODULE_1__.Ord).apply(void 0, args);
}
/**
 * Compact a `ReadonlyRecord` of `Option`s discarding the `None` values and
 * keeping the `Some` values.
 *
 * @example
 * import { compact } from 'fp-ts/ReadonlyRecord'
 * import { option } from 'fp-ts'
 *
 * assert.deepStrictEqual(compact({ a: option.some("foo"), b: option.none, c: option.some("bar") }), {
 *   a: "foo",
 *   c: "bar",
 * });
 *
 * @category filtering
 * @since 2.5.0
 */
var compact = function (r) {
    var out = {};
    for (var k in r) {
        if (_internal__WEBPACK_IMPORTED_MODULE_0__.has.call(r, k)) {
            var oa = r[k];
            if (_internal__WEBPACK_IMPORTED_MODULE_0__.isSome(oa)) {
                out[k] = oa.value;
            }
        }
    }
    return out;
};
/**
 * Separate a `ReadonlyRecord` of `Either`s into `Left`s and `Right`s.
 *
 * @example
 * import { separate } from 'fp-ts/ReadonlyRecord'
 * import { either } from 'fp-ts'
 *
 * assert.deepStrictEqual(
 *   separate({ a: either.right("foo"), b: either.left("bar"), c: either.right("baz") }),
 *   {
 *     right: {
 *       a: "foo",
 *       c: "baz",
 *     },
 *     left: {
 *       b: "bar",
 *     },
 *   }
 * );
 *
 * @category filtering
 * @since 2.5.0
 */
var separate = function (r) {
    var left = {};
    var right = {};
    for (var k in r) {
        if (_internal__WEBPACK_IMPORTED_MODULE_0__.has.call(r, k)) {
            var e = r[k];
            if (_internal__WEBPACK_IMPORTED_MODULE_0__.isLeft(e)) {
                left[k] = e.left;
            }
            else {
                right[k] = e.right;
            }
        }
    }
    return (0,_Separated__WEBPACK_IMPORTED_MODULE_3__.separated)(left, right);
};
/**
 * @category type lambdas
 * @since 2.5.0
 */
var URI = 'ReadonlyRecord';
function getShow(O) {
    if ('compare' in O) {
        return function (S) { return ({
            show: function (r) {
                var elements = collect(O)(function (k, a) { return "".concat(JSON.stringify(k), ": ").concat(S.show(a)); })(r).join(', ');
                return elements === '' ? '{}' : "{ ".concat(elements, " }");
            }
        }); };
    }
    return getShow(_string__WEBPACK_IMPORTED_MODULE_1__.Ord)(O);
}
function getEq(E) {
    var isSubrecordE = isSubrecord(E);
    return (0,_Eq__WEBPACK_IMPORTED_MODULE_4__.fromEquals)(function (x, y) { return isSubrecordE(x)(y) && isSubrecordE(y)(x); });
}
function getMonoid(S) {
    return {
        concat: function (first, second) {
            if (isEmpty(first)) {
                return second;
            }
            if (isEmpty(second)) {
                return first;
            }
            var r = Object.assign({}, first);
            for (var k in second) {
                if (_internal__WEBPACK_IMPORTED_MODULE_0__.has.call(second, k)) {
                    r[k] = _internal__WEBPACK_IMPORTED_MODULE_0__.has.call(first, k) ? S.concat(first[k], second[k]) : second[k];
                }
            }
            return r;
        },
        empty: empty
    };
}
/**
 * @category instances
 * @since 2.7.0
 */
var Functor = {
    URI: URI,
    map: _map
};
/**
 * Takes a value and a `ReadonlyRecord` of functions and returns a
 * `ReadonlyRecord` by applying each function to the input value.
 *
 * @example
 * import { flap } from "fp-ts/ReadonlyRecord"
 *
 * const fab = { x: (n: number) => `${n} times 2`, y: (n: number) => `${n * 2}` };
 * assert.deepStrictEqual(flap(3)(fab), {
 *   x: "3 times 2",
 *   y: "6",
 * });
 *
 * @category mapping
 * @since 2.10.0
 */
var flap = /*#__PURE__*/ (0,_Functor__WEBPACK_IMPORTED_MODULE_5__.flap)(Functor);
/**
 * @category instances
 * @since 2.7.0
 */
var FunctorWithIndex = {
    URI: URI,
    map: _map,
    mapWithIndex: _mapWithIndex
};
/**
 * Produces a `Foldable` instance for a `ReadonlyRecord`, using the
 * provided `Ord` to sort the `ReadonlyRecord`'s entries by key.
 *
 * @category folding
 * @since 2.11.0
 */
var getFoldable = function (O) { return ({
    URI: URI,
    reduce: _reduce(O),
    foldMap: _foldMap(O),
    reduceRight: _reduceRight(O)
}); };
/**
 * Produces a `FoldableWithIndex1` instance for a `ReadonlyRecord`, using the
 * provided `Ord` to sort the `ReadonlyRecord`'s entries by key.
 *
 * @category folding
 * @since 2.11.0
 */
var getFoldableWithIndex = function (O) { return ({
    URI: URI,
    reduce: _reduce(O),
    foldMap: _foldMap(O),
    reduceRight: _reduceRight(O),
    reduceWithIndex: _reduceWithIndex(O),
    foldMapWithIndex: _foldMapWithIndex(O),
    reduceRightWithIndex: _reduceRightWithIndex(O)
}); };
/**
 * @category instances
 * @since 2.7.0
 */
var Compactable = {
    URI: URI,
    compact: compact,
    separate: separate
};
/**
 * @category instances
 * @since 2.7.0
 */
var Filterable = {
    URI: URI,
    map: _map,
    compact: compact,
    separate: separate,
    filter: _filter,
    filterMap: _filterMap,
    partition: _partition,
    partitionMap: _partitionMap
};
/**
 * @category instances
 * @since 2.7.0
 */
var FilterableWithIndex = {
    URI: URI,
    map: _map,
    mapWithIndex: _mapWithIndex,
    compact: compact,
    separate: separate,
    filter: _filter,
    filterMap: _filterMap,
    partition: _partition,
    partitionMap: _partitionMap,
    filterMapWithIndex: _filterMapWithIndex,
    filterWithIndex: _filterWithIndex,
    partitionMapWithIndex: _partitionMapWithIndex,
    partitionWithIndex: _partitionWithIndex
};
/**
 * Produces a `Traversable` instance for a `ReadonlyRecord`, using the
 * provided `Ord` to sort the `ReadonlyRecord`'s entries by key.
 *
 * @category traversing
 * @since 2.11.0
 */
var getTraversable = function (O) { return ({
    URI: URI,
    map: _map,
    reduce: _reduce(O),
    foldMap: _foldMap(O),
    reduceRight: _reduceRight(O),
    traverse: _traverse(O),
    sequence: _sequence(O)
}); };
/**
 * Produces a `TraversableWithIndex` instance for a `ReadonlyRecord`, using the
 * provided `Ord` to sort the `ReadonlyRecord`'s entries by key.
 *
 * @category traversing
 * @since 2.11.0
 */
var getTraversableWithIndex = function (O) { return ({
    URI: URI,
    map: _map,
    mapWithIndex: _mapWithIndex,
    reduce: _reduce(O),
    foldMap: _foldMap(O),
    reduceRight: _reduceRight(O),
    reduceWithIndex: _reduceWithIndex(O),
    foldMapWithIndex: _foldMapWithIndex(O),
    reduceRightWithIndex: _reduceRightWithIndex(O),
    traverse: _traverse(O),
    sequence: _sequence(O),
    traverseWithIndex: _traverseWithIndex(O)
}); };
/**
 * @category filtering
 * @since 2.11.0
 */
var getWitherable = function (O) {
    var T = getTraversable(O);
    return {
        URI: URI,
        map: _map,
        reduce: _reduce(O),
        foldMap: _foldMap(O),
        reduceRight: _reduceRight(O),
        traverse: T.traverse,
        sequence: T.sequence,
        compact: compact,
        separate: separate,
        filter: _filter,
        filterMap: _filterMap,
        partition: _partition,
        partitionMap: _partitionMap,
        wither: (0,_Witherable__WEBPACK_IMPORTED_MODULE_6__.witherDefault)(T, Compactable),
        wilt: (0,_Witherable__WEBPACK_IMPORTED_MODULE_6__.wiltDefault)(T, Compactable)
    };
};
/**
 * Given a `Semigroup` in the base type, it produces a `Semigroup`
 * in the `ReadonlyRecord` of the base type.
 * The resulting `Semigroup` concatenates two `ReadonlyRecord`s by
 * `union`.
 *
 * @example
 * import { getUnionSemigroup, ReadonlyRecord } from "fp-ts/ReadonlyRecord"
 * import { Semigroup } from "fp-ts/Semigroup"
 *
 * const sNumber: Semigroup<number> = { concat: (x, y) => x - y };
 * const sReadonlyRecord: Semigroup<ReadonlyRecord<string, number>> = getUnionSemigroup(sNumber);
 * assert.deepStrictEqual(sReadonlyRecord.concat({ a: 1, b: 2 }, { b: 3, c: 4 }), { a: 1, b: -1, c: 4 });
 *
 * @category instances
 * @since 2.11.0
 */
var getUnionSemigroup = function (S) {
    var unionS = union(S);
    return {
        concat: function (first, second) { return unionS(second)(first); }
    };
};
/**
 * Same as `getMonoid`.
 * Returns a `Monoid` instance for `ReadonlyRecord`s given a `Semigroup`
 * instance for the base type.
 * The `Monoid` makes the union of two `ReadonlyRecord`s combining the
 * entries that have the same key with the provided `Semigroup`.
 *
 * @example
 * import { SemigroupSum } from 'fp-ts/number'
 * import { getUnionMonoid } from 'fp-ts/ReadonlyRecord'
 *
 * const M = getUnionMonoid(SemigroupSum);
 * assert.deepStrictEqual(M.concat({ foo: 123, bar: 234 }, { foo: 456, baz: 567 }), { foo: 579 , bar: 234, baz: 567 });
 *
 * @category instances
 * @since 2.11.0
 */
var getUnionMonoid = function (S) { return ({
    concat: getUnionSemigroup(S).concat,
    empty: empty
}); };
/**
 * Given a `Semigroup` in the base type, it produces a `Semigroup`
 * in the `ReadonlyRecord` of the base type.
 * The resulting `Semigroup` concatenates two `ReadonlyRecord`s by
 * `intersection`.
 *
 * @example
 * import { getIntersectionSemigroup, ReadonlyRecord } from "fp-ts/ReadonlyRecord"
 * import { Semigroup } from "fp-ts/Semigroup"
 *
 * const sNumber: Semigroup<number> = { concat: (x, y) => x - y };
 * const sReadonlyRecord: Semigroup<ReadonlyRecord<string, number>> = getIntersectionSemigroup(sNumber);
 * assert.deepStrictEqual(sReadonlyRecord.concat({ a: 1, b: 2 }, { b: 3, c: 4 }), { b: -1 });
 *
 * @category instances
 * @since 2.11.0
 */
var getIntersectionSemigroup = function (S) {
    var intersectionS = intersection(S);
    return {
        concat: function (first, second) { return intersectionS(second)(first); }
    };
};
/**
 * Produces a `Magma` with a `concat` function that combines
 * two `ReadonlyRecord`s by making the `difference`.
 *
 * @example
 * import { getDifferenceMagma, difference, ReadonlyRecord } from "fp-ts/ReadonlyRecord"
 * import { Magma } from "fp-ts/Magma"
 *
 * const r1 = { a: 3, c: 3 };
 * const r2 = { a: 1, b: 2 };
 * const m: Magma<ReadonlyRecord<string, number>> = getDifferenceMagma<number>();
 * assert.deepStrictEqual(m.concat(r1, r2), difference(r2)(r1));
 * assert.deepStrictEqual(m.concat(r1, r2), { c: 3, b: 2 });
 *
 * @category instances
 * @since 2.11.0
 */
var getDifferenceMagma = function () { return ({
    concat: function (first, second) { return difference(second)(first); }
}); };
// -------------------------------------------------------------------------------------
// deprecated
// -------------------------------------------------------------------------------------
/**
 * Use `getFoldable` instead.
 *
 * @category zone of death
 * @since 2.7.0
 * @deprecated
 */
var Foldable = {
    URI: URI,
    reduce: /*#__PURE__*/ _reduce(_string__WEBPACK_IMPORTED_MODULE_1__.Ord),
    foldMap: /*#__PURE__*/ _foldMap(_string__WEBPACK_IMPORTED_MODULE_1__.Ord),
    reduceRight: /*#__PURE__*/ _reduceRight(_string__WEBPACK_IMPORTED_MODULE_1__.Ord)
};
/**
 * Use `getFoldableWithIndex` instead.
 *
 * @category zone of death
 * @since 2.7.0
 * @deprecated
 */
var FoldableWithIndex = {
    URI: URI,
    reduce: /*#__PURE__*/ _reduce(_string__WEBPACK_IMPORTED_MODULE_1__.Ord),
    foldMap: /*#__PURE__*/ _foldMap(_string__WEBPACK_IMPORTED_MODULE_1__.Ord),
    reduceRight: /*#__PURE__*/ _reduceRight(_string__WEBPACK_IMPORTED_MODULE_1__.Ord),
    reduceWithIndex: /*#__PURE__*/ _reduceWithIndex(_string__WEBPACK_IMPORTED_MODULE_1__.Ord),
    foldMapWithIndex: /*#__PURE__*/ _foldMapWithIndex(_string__WEBPACK_IMPORTED_MODULE_1__.Ord),
    reduceRightWithIndex: /*#__PURE__*/ _reduceRightWithIndex(_string__WEBPACK_IMPORTED_MODULE_1__.Ord)
};
/**
 * Use `getTraversable` instead.
 *
 * @category zone of death
 * @since 2.7.0
 * @deprecated
 */
var Traversable = {
    URI: URI,
    map: _map,
    reduce: /*#__PURE__*/ _reduce(_string__WEBPACK_IMPORTED_MODULE_1__.Ord),
    foldMap: /*#__PURE__*/ _foldMap(_string__WEBPACK_IMPORTED_MODULE_1__.Ord),
    reduceRight: /*#__PURE__*/ _reduceRight(_string__WEBPACK_IMPORTED_MODULE_1__.Ord),
    traverse: /*#__PURE__*/ _traverse(_string__WEBPACK_IMPORTED_MODULE_1__.Ord),
    sequence: sequence
};
/**
 * Use `getTraversableWithIndex` instead.
 *
 * @category zone of death
 * @since 2.7.0
 * @deprecated
 */
var TraversableWithIndex = {
    URI: URI,
    map: _map,
    mapWithIndex: _mapWithIndex,
    reduce: /*#__PURE__*/ _reduce(_string__WEBPACK_IMPORTED_MODULE_1__.Ord),
    foldMap: /*#__PURE__*/ _foldMap(_string__WEBPACK_IMPORTED_MODULE_1__.Ord),
    reduceRight: /*#__PURE__*/ _reduceRight(_string__WEBPACK_IMPORTED_MODULE_1__.Ord),
    reduceWithIndex: /*#__PURE__*/ _reduceWithIndex(_string__WEBPACK_IMPORTED_MODULE_1__.Ord),
    foldMapWithIndex: /*#__PURE__*/ _foldMapWithIndex(_string__WEBPACK_IMPORTED_MODULE_1__.Ord),
    reduceRightWithIndex: /*#__PURE__*/ _reduceRightWithIndex(_string__WEBPACK_IMPORTED_MODULE_1__.Ord),
    traverse: /*#__PURE__*/ _traverse(_string__WEBPACK_IMPORTED_MODULE_1__.Ord),
    sequence: sequence,
    traverseWithIndex: /*#__PURE__*/ _traverseWithIndex(_string__WEBPACK_IMPORTED_MODULE_1__.Ord)
};
var _wither = /*#__PURE__*/ (0,_Witherable__WEBPACK_IMPORTED_MODULE_6__.witherDefault)(Traversable, Compactable);
var _wilt = /*#__PURE__*/ (0,_Witherable__WEBPACK_IMPORTED_MODULE_6__.wiltDefault)(Traversable, Compactable);
/**
 * Use `getWitherable` instead.
 *
 * @category zone of death
 * @since 2.7.0
 * @deprecated
 */
var Witherable = {
    URI: URI,
    map: _map,
    reduce: /*#__PURE__*/ _reduce(_string__WEBPACK_IMPORTED_MODULE_1__.Ord),
    foldMap: /*#__PURE__*/ _foldMap(_string__WEBPACK_IMPORTED_MODULE_1__.Ord),
    reduceRight: /*#__PURE__*/ _reduceRight(_string__WEBPACK_IMPORTED_MODULE_1__.Ord),
    traverse: /*#__PURE__*/ _traverse(_string__WEBPACK_IMPORTED_MODULE_1__.Ord),
    sequence: sequence,
    compact: compact,
    separate: separate,
    filter: _filter,
    filterMap: _filterMap,
    partition: _partition,
    partitionMap: _partitionMap,
    wither: _wither,
    wilt: _wilt
};
/**
 * Use [`upsertAt`](#upsertat) instead.
 *
 * @category zone of death
 * @since 2.5.0
 * @deprecated
 */
var insertAt = upsertAt;
function hasOwnProperty(k, r) {
    return _internal__WEBPACK_IMPORTED_MODULE_0__.has.call(r === undefined ? this : r, k);
}
/**
 * This instance is deprecated, use small, specific instances instead.
 * For example if a function needs a `Functor` instance, pass `RR.Functor` instead of `RR.readonlyRecord`
 * (where `RR` is from `import RR from 'fp-ts/ReadonlyRecord'`)
 *
 * @category zone of death
 * @since 2.5.0
 * @deprecated
 */
var readonlyRecord = {
    URI: URI,
    map: _map,
    reduce: /*#__PURE__*/ _reduce(_string__WEBPACK_IMPORTED_MODULE_1__.Ord),
    foldMap: /*#__PURE__*/ _foldMap(_string__WEBPACK_IMPORTED_MODULE_1__.Ord),
    reduceRight: /*#__PURE__*/ _reduceRight(_string__WEBPACK_IMPORTED_MODULE_1__.Ord),
    traverse: /*#__PURE__*/ _traverse(_string__WEBPACK_IMPORTED_MODULE_1__.Ord),
    sequence: sequence,
    compact: compact,
    separate: separate,
    filter: _filter,
    filterMap: _filterMap,
    partition: _partition,
    partitionMap: _partitionMap,
    mapWithIndex: _mapWithIndex,
    reduceWithIndex: /*#__PURE__*/ _reduceWithIndex(_string__WEBPACK_IMPORTED_MODULE_1__.Ord),
    foldMapWithIndex: /*#__PURE__*/ _foldMapWithIndex(_string__WEBPACK_IMPORTED_MODULE_1__.Ord),
    reduceRightWithIndex: /*#__PURE__*/ _reduceRightWithIndex(_string__WEBPACK_IMPORTED_MODULE_1__.Ord),
    filterMapWithIndex: _filterMapWithIndex,
    filterWithIndex: _filterWithIndex,
    partitionMapWithIndex: _partitionMapWithIndex,
    partitionWithIndex: _partitionWithIndex,
    traverseWithIndex: /*#__PURE__*/ _traverseWithIndex(_string__WEBPACK_IMPORTED_MODULE_1__.Ord),
    wither: _wither,
    wilt: _wilt
};


/***/ }),

/***/ "./node_modules/fp-ts/es6/Record.js":
/*!******************************************!*\
  !*** ./node_modules/fp-ts/es6/Record.js ***!
  \******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Compactable: () => (/* binding */ Compactable),
/* harmony export */   Filterable: () => (/* binding */ Filterable),
/* harmony export */   FilterableWithIndex: () => (/* binding */ FilterableWithIndex),
/* harmony export */   Foldable: () => (/* binding */ Foldable),
/* harmony export */   FoldableWithIndex: () => (/* binding */ FoldableWithIndex),
/* harmony export */   Functor: () => (/* binding */ Functor),
/* harmony export */   FunctorWithIndex: () => (/* binding */ FunctorWithIndex),
/* harmony export */   Traversable: () => (/* binding */ Traversable),
/* harmony export */   TraversableWithIndex: () => (/* binding */ TraversableWithIndex),
/* harmony export */   URI: () => (/* binding */ URI),
/* harmony export */   Witherable: () => (/* binding */ Witherable),
/* harmony export */   collect: () => (/* binding */ collect),
/* harmony export */   compact: () => (/* binding */ compact),
/* harmony export */   deleteAt: () => (/* binding */ deleteAt),
/* harmony export */   difference: () => (/* binding */ difference),
/* harmony export */   elem: () => (/* binding */ elem),
/* harmony export */   empty: () => (/* binding */ empty),
/* harmony export */   every: () => (/* binding */ every),
/* harmony export */   filter: () => (/* binding */ filter),
/* harmony export */   filterMap: () => (/* binding */ filterMap),
/* harmony export */   filterMapWithIndex: () => (/* binding */ filterMapWithIndex),
/* harmony export */   filterWithIndex: () => (/* binding */ filterWithIndex),
/* harmony export */   flap: () => (/* binding */ flap),
/* harmony export */   foldMap: () => (/* binding */ foldMap),
/* harmony export */   foldMapWithIndex: () => (/* binding */ foldMapWithIndex),
/* harmony export */   fromEntries: () => (/* binding */ fromEntries),
/* harmony export */   fromFoldable: () => (/* binding */ fromFoldable),
/* harmony export */   fromFoldableMap: () => (/* binding */ fromFoldableMap),
/* harmony export */   getDifferenceMagma: () => (/* binding */ getDifferenceMagma),
/* harmony export */   getEq: () => (/* binding */ getEq),
/* harmony export */   getFoldable: () => (/* binding */ getFoldable),
/* harmony export */   getFoldableWithIndex: () => (/* binding */ getFoldableWithIndex),
/* harmony export */   getIntersectionSemigroup: () => (/* binding */ getIntersectionSemigroup),
/* harmony export */   getMonoid: () => (/* binding */ getMonoid),
/* harmony export */   getShow: () => (/* binding */ getShow),
/* harmony export */   getTraversable: () => (/* binding */ getTraversable),
/* harmony export */   getTraversableWithIndex: () => (/* binding */ getTraversableWithIndex),
/* harmony export */   getUnionMonoid: () => (/* binding */ getUnionMonoid),
/* harmony export */   getUnionSemigroup: () => (/* binding */ getUnionSemigroup),
/* harmony export */   getWitherable: () => (/* binding */ getWitherable),
/* harmony export */   has: () => (/* binding */ has),
/* harmony export */   hasOwnProperty: () => (/* binding */ hasOwnProperty),
/* harmony export */   insertAt: () => (/* binding */ insertAt),
/* harmony export */   intersection: () => (/* binding */ intersection),
/* harmony export */   isEmpty: () => (/* binding */ isEmpty),
/* harmony export */   isSubrecord: () => (/* binding */ isSubrecord),
/* harmony export */   keys: () => (/* binding */ keys),
/* harmony export */   lookup: () => (/* binding */ lookup),
/* harmony export */   map: () => (/* binding */ map),
/* harmony export */   mapWithIndex: () => (/* binding */ mapWithIndex),
/* harmony export */   modifyAt: () => (/* binding */ modifyAt),
/* harmony export */   partition: () => (/* binding */ partition),
/* harmony export */   partitionMap: () => (/* binding */ partitionMap),
/* harmony export */   partitionMapWithIndex: () => (/* binding */ partitionMapWithIndex),
/* harmony export */   partitionWithIndex: () => (/* binding */ partitionWithIndex),
/* harmony export */   pop: () => (/* binding */ pop),
/* harmony export */   record: () => (/* binding */ record),
/* harmony export */   reduce: () => (/* binding */ reduce),
/* harmony export */   reduceRight: () => (/* binding */ reduceRight),
/* harmony export */   reduceRightWithIndex: () => (/* binding */ reduceRightWithIndex),
/* harmony export */   reduceWithIndex: () => (/* binding */ reduceWithIndex),
/* harmony export */   separate: () => (/* binding */ separate),
/* harmony export */   sequence: () => (/* binding */ sequence),
/* harmony export */   singleton: () => (/* binding */ singleton),
/* harmony export */   size: () => (/* binding */ size),
/* harmony export */   some: () => (/* binding */ some),
/* harmony export */   toArray: () => (/* binding */ toArray),
/* harmony export */   toEntries: () => (/* binding */ toEntries),
/* harmony export */   toUnfoldable: () => (/* binding */ toUnfoldable),
/* harmony export */   traverse: () => (/* binding */ traverse),
/* harmony export */   traverseWithIndex: () => (/* binding */ traverseWithIndex),
/* harmony export */   union: () => (/* binding */ union),
/* harmony export */   updateAt: () => (/* binding */ updateAt),
/* harmony export */   upsertAt: () => (/* binding */ upsertAt),
/* harmony export */   wilt: () => (/* binding */ wilt),
/* harmony export */   wither: () => (/* binding */ wither)
/* harmony export */ });
/* harmony import */ var _Array__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./Array */ "./node_modules/fp-ts/es6/Array.js");
/* harmony import */ var _function__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./function */ "./node_modules/fp-ts/es6/function.js");
/* harmony import */ var _Functor__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./Functor */ "./node_modules/fp-ts/es6/Functor.js");
/* harmony import */ var _internal__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./internal */ "./node_modules/fp-ts/es6/internal.js");
/* harmony import */ var _ReadonlyRecord__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./ReadonlyRecord */ "./node_modules/fp-ts/es6/ReadonlyRecord.js");
/* harmony import */ var _Semigroup__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./Semigroup */ "./node_modules/fp-ts/es6/Semigroup.js");
/* harmony import */ var _string__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./string */ "./node_modules/fp-ts/es6/string.js");
/* harmony import */ var _Witherable__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./Witherable */ "./node_modules/fp-ts/es6/Witherable.js");
var __assign = (undefined && undefined.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};








// -------------------------------------------------------------------------------------
// model
// -------------------------------------------------------------------------------------
/**
 * Calculate the number of key/value pairs in a `Record`.
 *
 * @example
 * import { size } from "fp-ts/Record";
 *
 * assert.deepStrictEqual(size({ a: true, b: 2, c: "three" }), 3);
 *
 * @since 2.0.0
 */
var size = _ReadonlyRecord__WEBPACK_IMPORTED_MODULE_0__.size;
/**
 * Test whether a `Record` is empty.
 *
 * @example
 * import { isEmpty } from "fp-ts/Record";
 *
 * assert.deepStrictEqual(isEmpty({}), true);
 * assert.deepStrictEqual(isEmpty({ a: 3 }), false);
 *
 * @since 2.0.0
 */
var isEmpty = _ReadonlyRecord__WEBPACK_IMPORTED_MODULE_0__.isEmpty;
var keys_ = function (O) {
    return function (r) {
        return Object.keys(r).sort(O.compare);
    };
};
/**
 * The keys of a `Record`, sorted alphabetically.
 *
 * @example
 * import { keys } from "fp-ts/Record";
 *
 * assert.deepStrictEqual(keys({ c: 1, a: 2, b: 3 }), ["a", "b", "c"]);
 *
 * @since 2.0.0
 */
var keys = /*#__PURE__*/ keys_(_string__WEBPACK_IMPORTED_MODULE_1__.Ord);
function collect(O) {
    if (typeof O === 'function') {
        return collect(_string__WEBPACK_IMPORTED_MODULE_1__.Ord)(O);
    }
    var keysO = keys_(O);
    return function (f) {
        return function (r) {
            var out = [];
            for (var _i = 0, _a = keysO(r); _i < _a.length; _i++) {
                var key = _a[_i];
                out.push(f(key, r[key]));
            }
            return out;
        };
    };
}
/**
 * Get a sorted `Array` of the key/value pairs contained in a `Record`.
 * Sorted alphabetically by key.
 *
 * @example
 * import { toArray } from 'fp-ts/Record'
 *
 * const x = { c: 3, a: "foo", b: false };
 * assert.deepStrictEqual(toArray(x), [
 *   ["a", "foo"],
 *   ["b", false],
 *   ["c", 3],
 * ]);
 *
 * @category conversions
 * @since 2.0.0
 */
var toArray = /*#__PURE__*/ collect(_string__WEBPACK_IMPORTED_MODULE_1__.Ord)(function (k, a) { return [
    k,
    a
]; });
function toUnfoldable(U) {
    return function (r) {
        var sas = toArray(r);
        var len = sas.length;
        return U.unfold(0, function (b) { return (b < len ? _internal__WEBPACK_IMPORTED_MODULE_2__.some([sas[b], b + 1]) : _internal__WEBPACK_IMPORTED_MODULE_2__.none); });
    };
}
/**
 * Insert or replace a key/value pair in a `Record`.
 *
 * @example
 * import { upsertAt } from 'fp-ts/Record'
 *
 * assert.deepStrictEqual(upsertAt("a", 5)({ a: 1, b: 2 }), { a: 5, b: 2 });
 * assert.deepStrictEqual(upsertAt("c", 5)({ a: 1, b: 2 }), { a: 1, b: 2, c: 5 });
 *
 * @since 2.10.0
 */
var upsertAt = _ReadonlyRecord__WEBPACK_IMPORTED_MODULE_0__.upsertAt;
/**
 * Test whether or not a key exists in a `Record`.
 *
 * Note. This function is not pipeable because is a `Refinement`.
 *
 * @example
 * import { has } from 'fp-ts/Record'
 *
 * assert.deepStrictEqual(has("a", { a: 1, b: 2 }), true);
 * assert.deepStrictEqual(has("c", { a: 1, b: 2 }), false);
 *
 * @since 2.10.0
 */
var has = _ReadonlyRecord__WEBPACK_IMPORTED_MODULE_0__.has;
function deleteAt(k) {
    return function (r) {
        if (!_internal__WEBPACK_IMPORTED_MODULE_2__.has.call(r, k)) {
            return r;
        }
        var out = Object.assign({}, r);
        delete out[k];
        return out;
    };
}
/**
 * Replace a key/value pair in a `Record`.
 *
 * @returns If the specified key exists it returns an `Option` containing a new `Record`
 * with the entry updated, otherwise it returns `None`
 *
 * @example
 * import { updateAt } from 'fp-ts/Record'
 * import { option } from 'fp-ts'
 *
 * assert.deepStrictEqual(updateAt("a", 3)({ a: 1, b: 2 }), option.some({ a: 3, b: 2 }));
 * assert.deepStrictEqual(updateAt("c", 3)({ a: 1, b: 2 }), option.none);
 *
 * @since 2.0.0
 */
var updateAt = function (k, a) {
    return modifyAt(k, function () { return a; });
};
/**
 * Applies a mapping function to one spcific key/value pair in a `Record`.
 *
 * @returns If the specified key exists it returns an `Option` containing a new `Record`
 * with the entry updated, otherwise it returns `None`
 *
 * @example
 * import { modifyAt } from 'fp-ts/Record'
 * import { option } from 'fp-ts'
 *
 * assert.deepStrictEqual(modifyAt("a", (x: number) => x * 3)({ a: 1, b: 2 }), option.some({ a: 3, b: 2 }));
 * assert.deepStrictEqual(modifyAt("c", (x: number) => x * 3)({ a: 1, b: 2 }), option.none);
 *
 * @since 2.0.0
 */
var modifyAt = function (k, f) {
    return function (r) {
        if (!has(k, r)) {
            return _internal__WEBPACK_IMPORTED_MODULE_2__.none;
        }
        var out = Object.assign({}, r);
        out[k] = f(r[k]);
        return _internal__WEBPACK_IMPORTED_MODULE_2__.some(out);
    };
};
function pop(k) {
    var deleteAtk = deleteAt(k);
    return function (r) {
        var oa = lookup(k, r);
        return _internal__WEBPACK_IMPORTED_MODULE_2__.isNone(oa) ? _internal__WEBPACK_IMPORTED_MODULE_2__.none : _internal__WEBPACK_IMPORTED_MODULE_2__.some([oa.value, deleteAtk(r)]);
    };
}
// TODO: remove non-curried overloading in v3
/**
 * Test whether one `Record` contains all of the keys and values
 * contained in another `Record`.
 *
 * @example
 * import { isSubrecord } from 'fp-ts/Record'
 * import { string } from 'fp-ts'
 *
 * assert.deepStrictEqual(
 *   isSubrecord(string.Eq)({ a: "foo", b: "bar", c: "baz" })({ a: "foo", b: "bar", c: "baz" }),
 *   true
 * );
 * assert.deepStrictEqual(
 *   isSubrecord(string.Eq)({ a: "foo", b: "bar", c: "baz" })({ a: "foo", c: "baz" }),
 *   true
 * );
 * assert.deepStrictEqual(
 *   isSubrecord(string.Eq)({ a: "foo", b: "bar", c: "baz" })({ a: "foo", b: "not-bar", c: "baz" }),
 *   false
 * );
 * assert.deepStrictEqual(
 *   isSubrecord(string.Eq)({ a: "foo", b: "bar" })({ a: "foo", b: "bar", c: "baz" }),
 *   false
 * );
 *
 * @since 2.0.0
 */
var isSubrecord = _ReadonlyRecord__WEBPACK_IMPORTED_MODULE_0__.isSubrecord;
// TODO: remove non-curried overloading in v3
/**
 * Lookup the value for a key in a `Record`.
 *
 * @returns If the specified key exists it returns an `Option` containing the value,
 * otherwise it returns `None`
 *
 * @example
 * import { lookup } from 'fp-ts/Record'
 * import { option } from 'fp-ts'
 *
 * assert.deepStrictEqual(lookup("b")({ a: "foo", b: "bar" }), option.some("bar"));
 * assert.deepStrictEqual(lookup("c")({ a: "foo", b: "bar" }), option.none);
 *
 * @since 2.0.0
 */
var lookup = _ReadonlyRecord__WEBPACK_IMPORTED_MODULE_0__.lookup;
/**
 * Map a `Record` passing the key/value pairs to the iterating function.
 *
 * @example
 * import { mapWithIndex } from "fp-ts/Record";
 *
 * const f = (k: string, n: number) => `${k.toUpperCase()}-${n}`;
 * assert.deepStrictEqual(mapWithIndex(f)({ a: 3, b: 5 }), { a: "A-3", b: "B-5" });
 *
 * @since 2.0.0
 */
var mapWithIndex = _ReadonlyRecord__WEBPACK_IMPORTED_MODULE_0__.mapWithIndex;
/**
 * Map a `Record` passing the values to the iterating function.
 *
 * @example
 * import { map } from "fp-ts/Record";
 *
 * const f = (n: number) => `-${n}-`;
 * assert.deepStrictEqual(map(f)({ a: 3, b: 5 }), { a: "-3-", b: "-5-" });
 *
 * @category mapping
 * @since 2.0.0
 */
var map = _ReadonlyRecord__WEBPACK_IMPORTED_MODULE_0__.map;
function reduceWithIndex() {
    var args = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
    }
    return args.length === 1 ? _ReadonlyRecord__WEBPACK_IMPORTED_MODULE_0__.reduceWithIndex(args[0]) : _ReadonlyRecord__WEBPACK_IMPORTED_MODULE_0__.reduceWithIndex(_string__WEBPACK_IMPORTED_MODULE_1__.Ord).apply(void 0, args);
}
function foldMapWithIndex(O) {
    return 'compare' in O ? _ReadonlyRecord__WEBPACK_IMPORTED_MODULE_0__.foldMapWithIndex(O) : _ReadonlyRecord__WEBPACK_IMPORTED_MODULE_0__.foldMapWithIndex(_string__WEBPACK_IMPORTED_MODULE_1__.Ord)(O);
}
function reduceRightWithIndex() {
    var args = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
    }
    return args.length === 1 ? _ReadonlyRecord__WEBPACK_IMPORTED_MODULE_0__.reduceRightWithIndex(args[0]) : _ReadonlyRecord__WEBPACK_IMPORTED_MODULE_0__.reduceRightWithIndex(_string__WEBPACK_IMPORTED_MODULE_1__.Ord).apply(void 0, args);
}
/**
 * Create a `Record` with one key/value pair.
 *
 * @example
 * import { singleton } from "fp-ts/Record";
 *
 * assert.deepStrictEqual(singleton("a", 1), { a: 1 });
 *
 * @since 2.0.0
 */
var singleton = _ReadonlyRecord__WEBPACK_IMPORTED_MODULE_0__.singleton;
function traverseWithIndex(F) {
    return _ReadonlyRecord__WEBPACK_IMPORTED_MODULE_0__.traverseWithIndex(F);
}
function traverse(F) {
    return _ReadonlyRecord__WEBPACK_IMPORTED_MODULE_0__.traverse(F);
}
function sequence(F) {
    return _ReadonlyRecord__WEBPACK_IMPORTED_MODULE_0__.sequence(F);
}
/**
 * @category filtering
 * @since 2.6.5
 */
var wither = function (F) {
    var traverseF = traverse(F);
    return function (f) { return function (fa) { return F.map((0,_function__WEBPACK_IMPORTED_MODULE_3__.pipe)(fa, traverseF(f)), compact); }; };
};
/**
 * @category filtering
 * @since 2.6.5
 */
var wilt = function (F) {
    var traverseF = traverse(F);
    return function (f) { return function (fa) { return F.map((0,_function__WEBPACK_IMPORTED_MODULE_3__.pipe)(fa, traverseF(f)), separate); }; };
};
/**
 * Maps a `Record` with a function returning an `Either` and
 * partitions the resulting `Record` into `Left`s and `Right`s.
 *
 * @example
 * import { partitionMapWithIndex } from "fp-ts/Record"
 * import { either } from "fp-ts"
 *
 * const f = (key: string, a: number) =>
 *   a >= 0 ? either.right(`${key} is >= 0 (${a})`) : either.left(`${key} is < 0 (${a})`);
 * assert.deepStrictEqual(partitionMapWithIndex(f)({ a: -1, b: 2, c: 123 }), {
 *   left: {
 *     a: "a is < 0 (-1)",
 *   },
 *   right: {
 *     b: "b is >= 0 (2)",
 *     c: "c is >= 0 (123)",
 *   },
 * });
 *
 * @since 2.0.0
 */
var partitionMapWithIndex = _ReadonlyRecord__WEBPACK_IMPORTED_MODULE_0__.partitionMapWithIndex;
function partitionWithIndex(predicateWithIndex) {
    return _ReadonlyRecord__WEBPACK_IMPORTED_MODULE_0__.partitionWithIndex(predicateWithIndex);
}
/**
 * Maps a `Record` with an iterating function that takes key and value and
 * returns an `Option`, keeping only the `Some` values and discarding `None`s.
 *
 * @example
 * import { filterMapWithIndex } from "fp-ts/Record"
 * import { option } from "fp-ts"
 *
 * const f = (key: string, a: number) => (a >= 0 ? option.some(`${key}${a}`) : option.none);
 * assert.deepStrictEqual(filterMapWithIndex(f)({ a: -1, b: 2, c: 3 }), {
 *   b: "b2",
 *   c: "c3",
 * });
 *
 * @since 2.0.0
 */
var filterMapWithIndex = _ReadonlyRecord__WEBPACK_IMPORTED_MODULE_0__.filterMapWithIndex;
function filterWithIndex(predicateWithIndex) {
    return _ReadonlyRecord__WEBPACK_IMPORTED_MODULE_0__.filterWithIndex(predicateWithIndex);
}
function fromFoldable(M, F) {
    return _ReadonlyRecord__WEBPACK_IMPORTED_MODULE_0__.fromFoldable(M, F);
}
/**
 * Alias of [`toArray`](#toArray).
 *
 * @example
 * import { toEntries } from 'fp-ts/Record'
 *
 * assert.deepStrictEqual(toEntries({ b: 2, a: 1 }), [['a', 1], ['b', 2]])
 *
 * @since 2.12.0
 * @category conversions
 */
var toEntries = toArray;
/**
 * Converts an `Array` of `[key, value]` tuples into a `Record`.
 *
 * @example
 * import { fromEntries } from 'fp-ts/Record'
 *
 * assert.deepStrictEqual(fromEntries([['a', 1], ['b', 2], ['a', 3]]), { b: 2, a: 3 })
 *
 * @since 2.12.0
 * @category conversions
 */
var fromEntries = function (fa) { return fromFoldable(_Semigroup__WEBPACK_IMPORTED_MODULE_4__.last(), _Array__WEBPACK_IMPORTED_MODULE_5__.Foldable)(fa); };
function fromFoldableMap(M, F) {
    return _ReadonlyRecord__WEBPACK_IMPORTED_MODULE_0__.fromFoldableMap(M, F);
}
/**
 * Test if every value in a `Record` satisfies the predicate.
 *
 * @example
 * import { every } from "fp-ts/Record"
 *
 * assert.deepStrictEqual(every((n: number) => n >= 0)({ a: 1, b: 2 }), true);
 * assert.deepStrictEqual(every((n: number) => n >= 0)({ a: 1, b: -1 }), false);
 *
 * @since 2.0.0
 */
var every = _ReadonlyRecord__WEBPACK_IMPORTED_MODULE_0__.every;
/**
 * Test if at least one value in a `Record` satisfies the predicate.
 *
 * @example
 * import { some } from "fp-ts/Record"
 *
 * assert.deepStrictEqual(some((n: number) => n >= 0)({ a: 1, b: -2 }), true);
 * assert.deepStrictEqual(some((n: number) => n >= 0)({ a: -1, b: -2 }), false);
 *
 * @since 2.0.0
 */
var some = _ReadonlyRecord__WEBPACK_IMPORTED_MODULE_0__.some;
// TODO: remove non-curried overloading in v3
/**
 * Given an `Eq` checks if a `Record` contains an entry with
 * value equal to a provided value.
 *
 * @example
 * import { elem } from "fp-ts/Record"
 * import { number } from "fp-ts"
 *
 * assert.deepStrictEqual(elem(number.Eq)(123, { foo: 123, bar: 234 }), true);
 * assert.deepStrictEqual(elem(number.Eq)(-7, { foo: 123, bar: 234 }), false);
 *
 * @since 2.0.0
 */
var elem = _ReadonlyRecord__WEBPACK_IMPORTED_MODULE_0__.elem;
/**
 * Union of two `Record`s.
 * Takes two `Record`s and produces a `Record` combining all the
 * entries of the two inputs.
 * It uses the `concat` function of the provided `Magma` to
 * combine the elements with the same key.
 *
 * @example
 * import { union } from "fp-ts/Record";
 * import { Magma } from "fp-ts/Magma";
 *
 * const m1: Magma<number> = { concat: (x: number, y: number) => x + y };
 * assert.deepStrictEqual(union(m1)({ a: 3, c: 3 })({ a: 1, b: 2 }), { a: 4, b: 2, c: 3 });
 * const m2: Magma<number> = { concat: (x: number) => x };
 * assert.deepStrictEqual(union(m2)({ a: 3, c: 3 })({ a: 1, b: 2 }), { a: 1, b: 2, c: 3 });
 *
 * @since 2.11.0
 */
var union = function (M) {
    var unionM = _ReadonlyRecord__WEBPACK_IMPORTED_MODULE_0__.union(M);
    return function (second) { return function (first) {
        if (isEmpty(first)) {
            return __assign({}, second);
        }
        if (isEmpty(second)) {
            return __assign({}, first);
        }
        return unionM(second)(first);
    }; };
};
/**
 * Intersection of two `Record`s.
 * Takes two `Record`s and produces a `Record` combining only the
 * entries of the two inputswith the same key.
 * It uses the `concat` function of the provided `Magma` to
 * combine the elements.
 *
 * @example
 * import { intersection } from "fp-ts/Record";
 * import { Magma } from "fp-ts/Magma";
 *
 * const m1: Magma<number> = { concat: (x: number, y: number) => x + y };
 * assert.deepStrictEqual(intersection(m1)({ a: 3, c: 3 })({ a: 1, b: 2 }), { a: 4});
 * const m2: Magma<number> = { concat: (x: number) => x };
 * assert.deepStrictEqual(intersection(m2)({ a: 3, c: 3 })({ a: 1, b: 2 }), { a: 1});
 *
 * @since 2.11.0
 */
var intersection = function (M) {
    return function (second) {
        return function (first) {
            if (isEmpty(first) || isEmpty(second)) {
                return {};
            }
            return _ReadonlyRecord__WEBPACK_IMPORTED_MODULE_0__.intersection(M)(second)(first);
        };
    };
};
/**
 * Difference between two `Record`s.
 * Takes two `Record`s and produces a `Record` composed by the
 * entries of the two inputs, removing the entries with the same
 * key in both inputs.
 *
 * @example
 * import { difference } from "fp-ts/Record";
 *
 * assert.deepStrictEqual(difference({ a: 1 })({ a: 1, b: 2 }), { b: 2 });
 * assert.deepStrictEqual(difference({ a: 3 })({ a: 1, b: 2 }), { b: 2 });
 * assert.deepStrictEqual(difference({ a: 3, c: 3 })({ a: 1, b: 2 }), { b: 2, c: 3 });
 *
 * @since 2.11.0
 */
var difference = function (second) {
    return function (first) {
        if (isEmpty(first)) {
            return __assign({}, second);
        }
        if (isEmpty(second)) {
            return __assign({}, first);
        }
        return _ReadonlyRecord__WEBPACK_IMPORTED_MODULE_0__.difference(second)(first);
    };
};
var _map = _ReadonlyRecord__WEBPACK_IMPORTED_MODULE_0__._map;
var _mapWithIndex = _ReadonlyRecord__WEBPACK_IMPORTED_MODULE_0__._mapWithIndex;
var _reduce = _ReadonlyRecord__WEBPACK_IMPORTED_MODULE_0__._reduce;
var _foldMap = _ReadonlyRecord__WEBPACK_IMPORTED_MODULE_0__._foldMap;
var _reduceRight = _ReadonlyRecord__WEBPACK_IMPORTED_MODULE_0__._reduceRight;
var _filter = _ReadonlyRecord__WEBPACK_IMPORTED_MODULE_0__._filter;
var _filterMap = _ReadonlyRecord__WEBPACK_IMPORTED_MODULE_0__._filterMap;
var _partition = _ReadonlyRecord__WEBPACK_IMPORTED_MODULE_0__._partition;
var _partitionMap = _ReadonlyRecord__WEBPACK_IMPORTED_MODULE_0__._partitionMap;
var _reduceWithIndex = _ReadonlyRecord__WEBPACK_IMPORTED_MODULE_0__._reduceWithIndex;
var _foldMapWithIndex = _ReadonlyRecord__WEBPACK_IMPORTED_MODULE_0__._foldMapWithIndex;
var _reduceRightWithIndex = _ReadonlyRecord__WEBPACK_IMPORTED_MODULE_0__._reduceRightWithIndex;
var _partitionMapWithIndex = _ReadonlyRecord__WEBPACK_IMPORTED_MODULE_0__._partitionMapWithIndex;
var _partitionWithIndex = _ReadonlyRecord__WEBPACK_IMPORTED_MODULE_0__._partitionWithIndex;
var _filterMapWithIndex = _ReadonlyRecord__WEBPACK_IMPORTED_MODULE_0__._filterMapWithIndex;
var _filterWithIndex = _ReadonlyRecord__WEBPACK_IMPORTED_MODULE_0__._filterWithIndex;
var _traverse = _ReadonlyRecord__WEBPACK_IMPORTED_MODULE_0__._traverse;
var _sequence = _ReadonlyRecord__WEBPACK_IMPORTED_MODULE_0__._sequence;
var _traverseWithIndex = function (O) {
    return function (F) {
        var keysO = keys_(O);
        return function (ta, f) {
            var ks = keysO(ta);
            if (ks.length === 0) {
                return F.of({});
            }
            var fr = F.of({});
            var _loop_1 = function (key) {
                fr = F.ap(F.map(fr, function (r) { return function (b) {
                    r[key] = b;
                    return r;
                }; }), f(key, ta[key]));
            };
            for (var _i = 0, ks_1 = ks; _i < ks_1.length; _i++) {
                var key = ks_1[_i];
                _loop_1(key);
            }
            return fr;
        };
    };
};
/**
 * Given a `Predicate`, it produces a new `Record` keeping only the entries with a
 * value that satisfies the provided predicate.
 *
 * @example
 * import { filter } from "fp-ts/Record"
 *
 * assert.deepStrictEqual(filter((s: string) => s.length < 4)({ a: "foo", b: "bar", c: "verylong" }), {
 *   a: "foo",
 *   b: "bar",
 * });
 *
 * @category filtering
 * @since 2.0.0
 */
var filter = _ReadonlyRecord__WEBPACK_IMPORTED_MODULE_0__.filter;
/**
 * Maps a `Record` with an iterating function that returns an `Option`
 * and it keeps only the `Some` values discarding the `None`s.
 *
 * @example
 * import { filterMap } from "fp-ts/Record"
 * import { option } from "fp-ts"
 *
 * const f = (s: string) => s.length < 4 ? option.some(`${s} is short`): option.none
 * assert.deepStrictEqual(filterMap(f)({ a: "foo", b: "bar", c: "verylong" }), {
 *   a: "foo is short",
 *   b: "bar is short",
 * });
 *
 * @category filtering
 * @since 2.0.0
 */
var filterMap = _ReadonlyRecord__WEBPACK_IMPORTED_MODULE_0__.filterMap;
/**
 * Partition a `Record` into two parts according to a `Predicate`.
 *
 * @example
 * import { partition } from "fp-ts/Record"
 *
 * assert.deepStrictEqual(partition((s: string) => s.length < 4)({ a: "foo", b: "bar", c: "verylong" }), {
 *   left:{
 *     c: "verylong"
 *   },
 *   right: {
 *     a: "foo",
 *     b: "bar",
 *   },
 * });
 *
 * @category filtering
 * @since 2.0.0
 */
var partition = _ReadonlyRecord__WEBPACK_IMPORTED_MODULE_0__.partition;
/**
 * Maps a `Record` with a function returning an `Either` and
 * partitions the resulting `Record` into `Left`s and `Right`s.
 *
 * @example
 * import { partitionMap } from "fp-ts/Record"
 * import { either } from "fp-ts"
 *
 * const f = (s: string) => (s.length < 4 ? either.right(`${s} is short`) : either.left(`${s} is not short`));
 * assert.deepStrictEqual(partitionMap(f)({ a: "foo", b: "bar", c: "verylong" }), {
 *   left: {
 *     c: "verylong is not short",
 *   },
 *   right: {
 *     a: "foo is short",
 *     b: "bar is short",
 *   },
 * });
 *
 * @category filtering
 * @since 2.0.0
 */
var partitionMap = _ReadonlyRecord__WEBPACK_IMPORTED_MODULE_0__.partitionMap;
function reduce() {
    var args = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
    }
    return args.length === 1 ? _ReadonlyRecord__WEBPACK_IMPORTED_MODULE_0__.reduce(args[0]) : _ReadonlyRecord__WEBPACK_IMPORTED_MODULE_0__.reduce(_string__WEBPACK_IMPORTED_MODULE_1__.Ord).apply(void 0, args);
}
function foldMap(O) {
    return 'compare' in O ? _ReadonlyRecord__WEBPACK_IMPORTED_MODULE_0__.foldMap(O) : _ReadonlyRecord__WEBPACK_IMPORTED_MODULE_0__.foldMap(_string__WEBPACK_IMPORTED_MODULE_1__.Ord)(O);
}
function reduceRight() {
    var args = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
    }
    return args.length === 1 ? _ReadonlyRecord__WEBPACK_IMPORTED_MODULE_0__.reduceRight(args[0]) : _ReadonlyRecord__WEBPACK_IMPORTED_MODULE_0__.reduceRight(_string__WEBPACK_IMPORTED_MODULE_1__.Ord).apply(void 0, args);
}
/**
 * Compact a `Record` of `Option`s discarding the `None` values and
 * keeping the `Some` values.
 *
 * @example
 * import { compact } from 'fp-ts/Record'
 * import { option } from 'fp-ts'
 *
 * assert.deepStrictEqual(compact({ a: option.some("foo"), b: option.none, c: option.some("bar") }), {
 *   a: "foo",
 *   c: "bar",
 * });
 *
 * @category filtering
 * @since 2.0.0
 */
var compact = _ReadonlyRecord__WEBPACK_IMPORTED_MODULE_0__.compact;
/**
 * Separate a `Record` of `Either`s into `Left`s and `Right`s.
 *
 * @example
 * import { separate } from 'fp-ts/Record'
 * import { either } from 'fp-ts'
 *
 * assert.deepStrictEqual(
 *   separate({ a: either.right("foo"), b: either.left("bar"), c: either.right("baz") }),
 *   {
 *     right: {
 *       a: "foo",
 *       c: "baz",
 *     },
 *     left: {
 *       b: "bar",
 *     },
 *   }
 * );
 *
 * @category filtering
 * @since 2.0.0
 */
var separate = _ReadonlyRecord__WEBPACK_IMPORTED_MODULE_0__.separate;
/**
 * @category type lambdas
 * @since 2.0.0
 */
var URI = 'Record';
function getShow(O) {
    return 'compare' in O ? _ReadonlyRecord__WEBPACK_IMPORTED_MODULE_0__.getShow(O) : _ReadonlyRecord__WEBPACK_IMPORTED_MODULE_0__.getShow(_string__WEBPACK_IMPORTED_MODULE_1__.Ord)(O);
}
/**
 * Given an `Eq` for the base type, it produces an `Eq`
 * for a `Record` of that base type.
 *
 * @example
 * import { getEq } from "fp-ts/Record";
 * import { string } from "fp-ts";
 * import { Eq } from "fp-ts/Eq";
 *
 * const eq: Eq<Record<string, string>> = getEq(string.Eq);
 * assert.deepStrictEqual(eq.equals({ a: "foo" }, { b: "bar" }), false);
 * assert.deepStrictEqual(eq.equals({ a: "foo" }, { a: "foo" }), true);
 *
 * @category instances
 * @since 2.0.0
 */
var getEq = _ReadonlyRecord__WEBPACK_IMPORTED_MODULE_0__.getEq;
/**
 * Returns a `Monoid` instance for `Record`s, given a `Semigroup`
 * instance for the base type.
 * The `Monoid` makes the union of two `Record`s comining the
 * overlapping entries with the provided `Semigroup`.
 *
 * @example
 * import { SemigroupSum } from 'fp-ts/number'
 * import { getMonoid } from 'fp-ts/Record'
 *
 * const M = getMonoid(SemigroupSum);
 * assert.deepStrictEqual(M.concat({ foo: 123, bar: 234 }, { foo: 456, baz: 567 }), { foo: 579 , bar: 234, baz: 567 });
 *
 * @category instances
 * @since 2.0.0
 */
var getMonoid = _ReadonlyRecord__WEBPACK_IMPORTED_MODULE_0__.getMonoid;
/**
 * @category instances
 * @since 2.7.0
 */
var Functor = {
    URI: URI,
    map: _map
};
/**
 * Takes a value and a `Record` of functions and returns a
 * `Record` by applying each function to the input value.
 *
 * @example
 * import { flap } from "fp-ts/Record"
 *
 * const fab = { x: (n: number) => `${n} times 2`, y: (n: number) => `${n * 2}` };
 * assert.deepStrictEqual(flap(3)(fab), {
 *   x: "3 times 2",
 *   y: "6",
 * });
 *
 * @category mapping
 * @since 2.10.0
 */
var flap = /*#__PURE__*/ (0,_Functor__WEBPACK_IMPORTED_MODULE_6__.flap)(Functor);
/**
 * @category instances
 * @since 2.7.0
 */
var FunctorWithIndex = {
    URI: URI,
    map: _map,
    mapWithIndex: _mapWithIndex
};
/**
 * Produces a `Foldable` instance for a `Record`, using the
 * provided `Ord` to sort the `Record`'s entries by key.
 *
 * @category folding
 * @since 2.11.0
 */
var getFoldable = function (O) { return ({
    URI: URI,
    reduce: _reduce(O),
    foldMap: _foldMap(O),
    reduceRight: _reduceRight(O)
}); };
/**
 * Produces a `FoldableWithIndex1` instance for a `Record`, using the
 * provided `Ord` to sort the `Record`'s entries by key.
 *
 * @category folding
 * @since 2.11.0
 */
var getFoldableWithIndex = function (O) { return ({
    URI: URI,
    reduce: _reduce(O),
    foldMap: _foldMap(O),
    reduceRight: _reduceRight(O),
    reduceWithIndex: _reduceWithIndex(O),
    foldMapWithIndex: _foldMapWithIndex(O),
    reduceRightWithIndex: _reduceRightWithIndex(O)
}); };
/**
 * @category instances
 * @since 2.7.0
 */
var Compactable = {
    URI: URI,
    compact: compact,
    separate: separate
};
/**
 * @category instances
 * @since 2.7.0
 */
var Filterable = {
    URI: URI,
    map: _map,
    compact: compact,
    separate: separate,
    filter: _filter,
    filterMap: _filterMap,
    partition: _partition,
    partitionMap: _partitionMap
};
/**
 * @category instances
 * @since 2.7.0
 */
var FilterableWithIndex = {
    URI: URI,
    map: _map,
    mapWithIndex: _mapWithIndex,
    compact: compact,
    separate: separate,
    filter: _filter,
    filterMap: _filterMap,
    partition: _partition,
    partitionMap: _partitionMap,
    filterMapWithIndex: _filterMapWithIndex,
    filterWithIndex: _filterWithIndex,
    partitionMapWithIndex: _partitionMapWithIndex,
    partitionWithIndex: _partitionWithIndex
};
/**
 * Produces a `Traversable` instance for a `Record`, using the
 * provided `Ord` to sort the `Record`'s entries by key.
 *
 * @category traversing
 * @since 2.11.0
 */
var getTraversable = function (O) { return ({
    URI: URI,
    map: _map,
    reduce: _reduce(O),
    foldMap: _foldMap(O),
    reduceRight: _reduceRight(O),
    traverse: _traverse(O),
    sequence: _sequence(O)
}); };
/**
 * Produces a `TraversableWithIndex` instance for a `Record`, using the
 * provided `Ord` to sort the `Record`'s entries by key.
 *
 * @category traversing
 * @since 2.11.0
 */
var getTraversableWithIndex = function (O) { return ({
    URI: URI,
    map: _map,
    mapWithIndex: _mapWithIndex,
    reduce: _reduce(O),
    foldMap: _foldMap(O),
    reduceRight: _reduceRight(O),
    reduceWithIndex: _reduceWithIndex(O),
    foldMapWithIndex: _foldMapWithIndex(O),
    reduceRightWithIndex: _reduceRightWithIndex(O),
    traverse: _traverse(O),
    sequence: _sequence(O),
    traverseWithIndex: _traverseWithIndex(O)
}); };
/**
 * @category filtering
 * @since 2.11.0
 */
var getWitherable = function (O) {
    var T = getTraversable(O);
    return {
        URI: URI,
        map: _map,
        reduce: _reduce(O),
        foldMap: _foldMap(O),
        reduceRight: _reduceRight(O),
        traverse: T.traverse,
        sequence: T.sequence,
        compact: compact,
        separate: separate,
        filter: _filter,
        filterMap: _filterMap,
        partition: _partition,
        partitionMap: _partitionMap,
        wither: (0,_Witherable__WEBPACK_IMPORTED_MODULE_7__.witherDefault)(T, Compactable),
        wilt: (0,_Witherable__WEBPACK_IMPORTED_MODULE_7__.wiltDefault)(T, Compactable)
    };
};
/**
 * Given a `Semigroup` in the base type, it produces a `Semigroup`
 * in the `Record` of the base type.
 * The resulting `Semigroup` concatenates two `Record`s by
 * `union`.
 *
 * @example
 * import { getUnionSemigroup } from "fp-ts/Record"
 * import { Semigroup } from "fp-ts/Semigroup"
 *
 * const sNumber: Semigroup<number> = { concat: (x, y) => x - y };
 * const sRecord: Semigroup<Record<string, number>> = getUnionSemigroup(sNumber);
 * assert.deepStrictEqual(sRecord.concat({ a: 1, b: 2 }, { b: 3, c: 4 }), { a: 1, b: -1, c: 4 });
 *
 * @category instances
 * @since 2.11.0
 */
var getUnionSemigroup = function (S) {
    var unionS = union(S);
    return {
        concat: function (first, second) { return unionS(second)(first); }
    };
};
/**
 * Same as `getMonoid`.
 * Returns a `Monoid` instance for `Record`s given a `Semigroup`
 * instance for the base type.
 * The `Monoid` makes the union of two `Record`s combining the
 * entries that have the same key with the provided `Semigroup`.
 *
 * @example
 * import { SemigroupSum } from 'fp-ts/number'
 * import { getUnionMonoid } from 'fp-ts/Record'
 *
 * const M = getUnionMonoid(SemigroupSum);
 * assert.deepStrictEqual(M.concat({ foo: 123, bar: 234 }, { foo: 456, baz: 567 }), { foo: 579 , bar: 234, baz: 567 });
 *
 * @category instances
 * @since 2.11.0
 */
var getUnionMonoid = function (S) { return ({
    concat: getUnionSemigroup(S).concat,
    empty: {}
}); };
/**
 * Given a `Semigroup` in the base type, it produces a `Semigroup`
 * in the `Record` of the base type.
 * The resulting `Semigroup` concatenates two `Record`s by
 * `intersection`.
 *
 * @example
 * import { getIntersectionSemigroup } from "fp-ts/Record"
 * import { Semigroup } from "fp-ts/Semigroup"
 *
 * const sNumber: Semigroup<number> = { concat: (x, y) => x - y };
 * const sRecord: Semigroup<Record<string, number>> = getIntersectionSemigroup(sNumber);
 * assert.deepStrictEqual(sRecord.concat({ a: 1, b: 2 }, { b: 3, c: 4 }), { b: -1 });
 *
 * @category instances
 * @since 2.11.0
 */
var getIntersectionSemigroup = function (S) {
    var intersectionS = intersection(S);
    return {
        concat: function (first, second) { return intersectionS(second)(first); }
    };
};
/**
 * Produces a `Magma` with a `concat` function that combines
 * two `Record`s by making the `difference`.
 *
 * @example
 * import { getDifferenceMagma, difference } from "fp-ts/Record"
 * import { Magma } from "fp-ts/Magma"
 *
 * const r1 = { a: 3, c: 3 };
 * const r2 = { a: 1, b: 2 };
 * const m: Magma<Record<string, number>> = getDifferenceMagma<number>();
 * assert.deepStrictEqual(m.concat(r1, r2), difference(r2)(r1));
 * assert.deepStrictEqual(m.concat(r1, r2), { c: 3, b: 2 });
 *
 * @category instances
 * @since 2.11.0
 */
var getDifferenceMagma = function () { return ({
    concat: function (first, second) { return difference(second)(first); }
}); };
// -------------------------------------------------------------------------------------
// deprecated
// -------------------------------------------------------------------------------------
/**
 * Use `getFoldable` instead.
 *
 * @category zone of death
 * @since 2.7.0
 * @deprecated
 */
var Foldable = {
    URI: URI,
    reduce: /*#__PURE__*/ _reduce(_string__WEBPACK_IMPORTED_MODULE_1__.Ord),
    foldMap: /*#__PURE__*/ _foldMap(_string__WEBPACK_IMPORTED_MODULE_1__.Ord),
    reduceRight: /*#__PURE__*/ _reduceRight(_string__WEBPACK_IMPORTED_MODULE_1__.Ord)
};
/**
 * Use `getFoldableWithIndex` instead.
 *
 * @category zone of death
 * @since 2.7.0
 * @deprecated
 */
var FoldableWithIndex = {
    URI: URI,
    reduce: /*#__PURE__*/ _reduce(_string__WEBPACK_IMPORTED_MODULE_1__.Ord),
    foldMap: /*#__PURE__*/ _foldMap(_string__WEBPACK_IMPORTED_MODULE_1__.Ord),
    reduceRight: /*#__PURE__*/ _reduceRight(_string__WEBPACK_IMPORTED_MODULE_1__.Ord),
    reduceWithIndex: /*#__PURE__*/ _reduceWithIndex(_string__WEBPACK_IMPORTED_MODULE_1__.Ord),
    foldMapWithIndex: /*#__PURE__*/ _foldMapWithIndex(_string__WEBPACK_IMPORTED_MODULE_1__.Ord),
    reduceRightWithIndex: /*#__PURE__*/ _reduceRightWithIndex(_string__WEBPACK_IMPORTED_MODULE_1__.Ord)
};
/**
 * Use `getTraversable` instead.
 *
 * @category zone of death
 * @since 2.7.0
 * @deprecated
 */
var Traversable = {
    URI: URI,
    map: _map,
    reduce: /*#__PURE__*/ _reduce(_string__WEBPACK_IMPORTED_MODULE_1__.Ord),
    foldMap: /*#__PURE__*/ _foldMap(_string__WEBPACK_IMPORTED_MODULE_1__.Ord),
    reduceRight: /*#__PURE__*/ _reduceRight(_string__WEBPACK_IMPORTED_MODULE_1__.Ord),
    traverse: /*#__PURE__*/ _traverse(_string__WEBPACK_IMPORTED_MODULE_1__.Ord),
    sequence: sequence
};
/**
 * Use the `getTraversableWithIndex` instead.
 *
 * @category zone of death
 * @since 2.7.0
 * @deprecated
 */
var TraversableWithIndex = {
    URI: URI,
    map: _map,
    mapWithIndex: _mapWithIndex,
    reduce: /*#__PURE__*/ _reduce(_string__WEBPACK_IMPORTED_MODULE_1__.Ord),
    foldMap: /*#__PURE__*/ _foldMap(_string__WEBPACK_IMPORTED_MODULE_1__.Ord),
    reduceRight: /*#__PURE__*/ _reduceRight(_string__WEBPACK_IMPORTED_MODULE_1__.Ord),
    reduceWithIndex: /*#__PURE__*/ _reduceWithIndex(_string__WEBPACK_IMPORTED_MODULE_1__.Ord),
    foldMapWithIndex: /*#__PURE__*/ _foldMapWithIndex(_string__WEBPACK_IMPORTED_MODULE_1__.Ord),
    reduceRightWithIndex: /*#__PURE__*/ _reduceRightWithIndex(_string__WEBPACK_IMPORTED_MODULE_1__.Ord),
    traverse: /*#__PURE__*/ _traverse(_string__WEBPACK_IMPORTED_MODULE_1__.Ord),
    sequence: sequence,
    traverseWithIndex: /*#__PURE__*/ _traverseWithIndex(_string__WEBPACK_IMPORTED_MODULE_1__.Ord)
};
var _wither = /*#__PURE__*/ (0,_Witherable__WEBPACK_IMPORTED_MODULE_7__.witherDefault)(Traversable, Compactable);
var _wilt = /*#__PURE__*/ (0,_Witherable__WEBPACK_IMPORTED_MODULE_7__.wiltDefault)(Traversable, Compactable);
/**
 * Use `getWitherable` instead.
 *
 * @category zone of death
 * @since 2.7.0
 * @deprecated
 */
var Witherable = {
    URI: URI,
    map: _map,
    reduce: /*#__PURE__*/ _reduce(_string__WEBPACK_IMPORTED_MODULE_1__.Ord),
    foldMap: /*#__PURE__*/ _foldMap(_string__WEBPACK_IMPORTED_MODULE_1__.Ord),
    reduceRight: /*#__PURE__*/ _reduceRight(_string__WEBPACK_IMPORTED_MODULE_1__.Ord),
    traverse: /*#__PURE__*/ _traverse(_string__WEBPACK_IMPORTED_MODULE_1__.Ord),
    sequence: sequence,
    compact: compact,
    separate: separate,
    filter: _filter,
    filterMap: _filterMap,
    partition: _partition,
    partitionMap: _partitionMap,
    wither: _wither,
    wilt: _wilt
};
/**
 * Use a new `{}` instead.
 *
 * @category zone of death
 * @since 2.0.0
 * @deprecated
 */
var empty = {};
/**
 * Use [`upsertAt`](#upsertat) instead.
 *
 * @category zone of death
 * @since 2.0.0
 * @deprecated
 */
var insertAt = upsertAt;
/**
 * Use [`has`](#has) instead.
 *
 * @category zone of death
 * @since 2.0.0
 * @deprecated
 */
var hasOwnProperty = _ReadonlyRecord__WEBPACK_IMPORTED_MODULE_0__.hasOwnProperty;
/**
 * This instance is deprecated, use small, specific instances instead.
 * For example if a function needs a `Functor` instance, pass `R.Functor` instead of `R.record`
 * (where `R` is from `import R from 'fp-ts/Record'`)
 *
 * @category zone of death
 * @since 2.0.0
 * @deprecated
 */
var record = {
    URI: URI,
    map: _map,
    reduce: /*#__PURE__*/ _reduce(_string__WEBPACK_IMPORTED_MODULE_1__.Ord),
    foldMap: /*#__PURE__*/ _foldMap(_string__WEBPACK_IMPORTED_MODULE_1__.Ord),
    reduceRight: /*#__PURE__*/ _reduceRight(_string__WEBPACK_IMPORTED_MODULE_1__.Ord),
    traverse: /*#__PURE__*/ _traverse(_string__WEBPACK_IMPORTED_MODULE_1__.Ord),
    sequence: sequence,
    compact: compact,
    separate: separate,
    filter: _filter,
    filterMap: _filterMap,
    partition: _partition,
    partitionMap: _partitionMap,
    mapWithIndex: _mapWithIndex,
    reduceWithIndex: /*#__PURE__*/ _reduceWithIndex(_string__WEBPACK_IMPORTED_MODULE_1__.Ord),
    foldMapWithIndex: /*#__PURE__*/ _foldMapWithIndex(_string__WEBPACK_IMPORTED_MODULE_1__.Ord),
    reduceRightWithIndex: /*#__PURE__*/ _reduceRightWithIndex(_string__WEBPACK_IMPORTED_MODULE_1__.Ord),
    filterMapWithIndex: _filterMapWithIndex,
    filterWithIndex: _filterWithIndex,
    partitionMapWithIndex: _partitionMapWithIndex,
    partitionWithIndex: _partitionWithIndex,
    traverseWithIndex: /*#__PURE__*/ _traverseWithIndex(_string__WEBPACK_IMPORTED_MODULE_1__.Ord),
    wither: _wither,
    wilt: _wilt
};


/***/ }),

/***/ "./node_modules/fp-ts/es6/Semigroup.js":
/*!*********************************************!*\
  !*** ./node_modules/fp-ts/es6/Semigroup.js ***!
  \*********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   concatAll: () => (/* binding */ concatAll),
/* harmony export */   constant: () => (/* binding */ constant),
/* harmony export */   first: () => (/* binding */ first),
/* harmony export */   fold: () => (/* binding */ fold),
/* harmony export */   getDualSemigroup: () => (/* binding */ getDualSemigroup),
/* harmony export */   getFirstSemigroup: () => (/* binding */ getFirstSemigroup),
/* harmony export */   getFunctionSemigroup: () => (/* binding */ getFunctionSemigroup),
/* harmony export */   getIntercalateSemigroup: () => (/* binding */ getIntercalateSemigroup),
/* harmony export */   getJoinSemigroup: () => (/* binding */ getJoinSemigroup),
/* harmony export */   getLastSemigroup: () => (/* binding */ getLastSemigroup),
/* harmony export */   getMeetSemigroup: () => (/* binding */ getMeetSemigroup),
/* harmony export */   getObjectSemigroup: () => (/* binding */ getObjectSemigroup),
/* harmony export */   getStructSemigroup: () => (/* binding */ getStructSemigroup),
/* harmony export */   getTupleSemigroup: () => (/* binding */ getTupleSemigroup),
/* harmony export */   intercalate: () => (/* binding */ intercalate),
/* harmony export */   last: () => (/* binding */ last),
/* harmony export */   max: () => (/* binding */ max),
/* harmony export */   min: () => (/* binding */ min),
/* harmony export */   reverse: () => (/* binding */ reverse),
/* harmony export */   semigroupAll: () => (/* binding */ semigroupAll),
/* harmony export */   semigroupAny: () => (/* binding */ semigroupAny),
/* harmony export */   semigroupProduct: () => (/* binding */ semigroupProduct),
/* harmony export */   semigroupString: () => (/* binding */ semigroupString),
/* harmony export */   semigroupSum: () => (/* binding */ semigroupSum),
/* harmony export */   semigroupVoid: () => (/* binding */ semigroupVoid),
/* harmony export */   struct: () => (/* binding */ struct),
/* harmony export */   tuple: () => (/* binding */ tuple)
/* harmony export */ });
/* harmony import */ var _function__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./function */ "./node_modules/fp-ts/es6/function.js");
/* harmony import */ var _internal__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./internal */ "./node_modules/fp-ts/es6/internal.js");
/* harmony import */ var _Magma__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Magma */ "./node_modules/fp-ts/es6/Magma.js");
/* harmony import */ var _Ord__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Ord */ "./node_modules/fp-ts/es6/Ord.js");
/**
 * If a type `A` can form a `Semigroup` it has an **associative** binary operation.
 *
 * ```ts
 * interface Semigroup<A> {
 *   readonly concat: (x: A, y: A) => A
 * }
 * ```
 *
 * Associativity means the following equality must hold for any choice of `x`, `y`, and `z`.
 *
 * ```ts
 * concat(x, concat(y, z)) = concat(concat(x, y), z)
 * ```
 *
 * A common example of a semigroup is the type `string` with the operation `+`.
 *
 * ```ts
 * import { Semigroup } from 'fp-ts/Semigroup'
 *
 * const semigroupString: Semigroup<string> = {
 *   concat: (x, y) => x + y
 * }
 *
 * const x = 'x'
 * const y = 'y'
 * const z = 'z'
 *
 * semigroupString.concat(x, y) // 'xy'
 *
 * semigroupString.concat(x, semigroupString.concat(y, z)) // 'xyz'
 *
 * semigroupString.concat(semigroupString.concat(x, y), z) // 'xyz'
 * ```
 *
 * *Adapted from https://typelevel.org/cats*
 *
 * @since 2.0.0
 */




// -------------------------------------------------------------------------------------
// constructors
// -------------------------------------------------------------------------------------
/**
 * Get a semigroup where `concat` will return the minimum, based on the provided order.
 *
 * @example
 * import * as N from 'fp-ts/number'
 * import * as S from 'fp-ts/Semigroup'
 *
 * const S1 = S.min(N.Ord)
 *
 * assert.deepStrictEqual(S1.concat(1, 2), 1)
 *
 * @category constructors
 * @since 2.10.0
 */
var min = function (O) { return ({
    concat: _Ord__WEBPACK_IMPORTED_MODULE_0__.min(O)
}); };
/**
 * Get a semigroup where `concat` will return the maximum, based on the provided order.
 *
 * @example
 * import * as N from 'fp-ts/number'
 * import * as S from 'fp-ts/Semigroup'
 *
 * const S1 = S.max(N.Ord)
 *
 * assert.deepStrictEqual(S1.concat(1, 2), 2)
 *
 * @category constructors
 * @since 2.10.0
 */
var max = function (O) { return ({
    concat: _Ord__WEBPACK_IMPORTED_MODULE_0__.max(O)
}); };
/**
 * @category constructors
 * @since 2.10.0
 */
var constant = function (a) { return ({
    concat: function () { return a; }
}); };
// -------------------------------------------------------------------------------------
// combinators
// -------------------------------------------------------------------------------------
/**
 * The dual of a `Semigroup`, obtained by swapping the arguments of `concat`.
 *
 * @example
 * import { reverse } from 'fp-ts/Semigroup'
 * import * as S from 'fp-ts/string'
 *
 * assert.deepStrictEqual(reverse(S.Semigroup).concat('a', 'b'), 'ba')
 *
 * @since 2.10.0
 */
var reverse = _Magma__WEBPACK_IMPORTED_MODULE_1__.reverse;
/**
 * Given a struct of semigroups returns a semigroup for the struct.
 *
 * @example
 * import { struct } from 'fp-ts/Semigroup'
 * import * as N from 'fp-ts/number'
 *
 * interface Point {
 *   readonly x: number
 *   readonly y: number
 * }
 *
 * const S = struct<Point>({
 *   x: N.SemigroupSum,
 *   y: N.SemigroupSum
 * })
 *
 * assert.deepStrictEqual(S.concat({ x: 1, y: 2 }, { x: 3, y: 4 }), { x: 4, y: 6 })
 *
 * @since 2.10.0
 */
var struct = function (semigroups) { return ({
    concat: function (first, second) {
        var r = {};
        for (var k in semigroups) {
            if (_internal__WEBPACK_IMPORTED_MODULE_2__.has.call(semigroups, k)) {
                r[k] = semigroups[k].concat(first[k], second[k]);
            }
        }
        return r;
    }
}); };
/**
 * Given a tuple of semigroups returns a semigroup for the tuple.
 *
 * @example
 * import { tuple } from 'fp-ts/Semigroup'
 * import * as B from 'fp-ts/boolean'
 * import * as N from 'fp-ts/number'
 * import * as S from 'fp-ts/string'
 *
 * const S1 = tuple(S.Semigroup, N.SemigroupSum)
 * assert.deepStrictEqual(S1.concat(['a', 1], ['b', 2]), ['ab', 3])
 *
 * const S2 = tuple(S.Semigroup, N.SemigroupSum, B.SemigroupAll)
 * assert.deepStrictEqual(S2.concat(['a', 1, true], ['b', 2, false]), ['ab', 3, false])
 *
 * @since 2.10.0
 */
var tuple = function () {
    var semigroups = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        semigroups[_i] = arguments[_i];
    }
    return ({
        concat: function (first, second) { return semigroups.map(function (s, i) { return s.concat(first[i], second[i]); }); }
    });
};
/**
 * Between each pair of elements insert `middle`.
 *
 * @example
 * import { intercalate } from 'fp-ts/Semigroup'
 * import * as S from 'fp-ts/string'
 * import { pipe } from 'fp-ts/function'
 *
 * const S1 = pipe(S.Semigroup, intercalate(' + '))
 *
 * assert.strictEqual(S1.concat('a', 'b'), 'a + b')
 *
 * @since 2.10.0
 */
var intercalate = function (middle) {
    return function (S) { return ({
        concat: function (x, y) { return S.concat(x, S.concat(middle, y)); }
    }); };
};
// -------------------------------------------------------------------------------------
// instances
// -------------------------------------------------------------------------------------
/**
 * Always return the first argument.
 *
 * @example
 * import * as S from 'fp-ts/Semigroup'
 *
 * assert.deepStrictEqual(S.first<number>().concat(1, 2), 1)
 *
 * @category instances
 * @since 2.10.0
 */
var first = function () { return ({ concat: _function__WEBPACK_IMPORTED_MODULE_3__.identity }); };
/**
 * Always return the last argument.
 *
 * @example
 * import * as S from 'fp-ts/Semigroup'
 *
 * assert.deepStrictEqual(S.last<number>().concat(1, 2), 2)
 *
 * @category instances
 * @since 2.10.0
 */
var last = function () { return ({ concat: function (_, y) { return y; } }); };
// -------------------------------------------------------------------------------------
// utils
// -------------------------------------------------------------------------------------
/**
 * Given a sequence of `as`, concat them and return the total.
 *
 * If `as` is empty, return the provided `startWith` value.
 *
 * @example
 * import { concatAll } from 'fp-ts/Semigroup'
 * import * as N from 'fp-ts/number'
 *
 * const sum = concatAll(N.SemigroupSum)(0)
 *
 * assert.deepStrictEqual(sum([1, 2, 3]), 6)
 * assert.deepStrictEqual(sum([]), 0)
 *
 * @since 2.10.0
 */
var concatAll = _Magma__WEBPACK_IMPORTED_MODULE_1__.concatAll;
// -------------------------------------------------------------------------------------
// deprecated
// -------------------------------------------------------------------------------------
/**
 * Use `void` module instead.
 *
 * @category zone of death
 * @since 2.0.0
 * @deprecated
 */
var semigroupVoid = constant(undefined);
/**
 * Use [`getAssignSemigroup`](./struct.ts.html#getAssignSemigroup) instead.
 *
 * @category zone of death
 * @since 2.0.0
 * @deprecated
 */
var getObjectSemigroup = function () { return ({
    concat: function (first, second) { return Object.assign({}, first, second); }
}); };
/**
 * Use [`last`](#last) instead.
 *
 * @category zone of death
 * @since 2.0.0
 * @deprecated
 */
var getLastSemigroup = last;
/**
 * Use [`first`](#first) instead.
 *
 * @category zone of death
 * @since 2.0.0
 * @deprecated
 */
var getFirstSemigroup = first;
/**
 * Use [`tuple`](#tuple) instead.
 *
 * @category zone of death
 * @since 2.0.0
 * @deprecated
 */
var getTupleSemigroup = tuple;
/**
 * Use [`struct`](#struct) instead.
 *
 * @category zone of death
 * @since 2.0.0
 * @deprecated
 */
var getStructSemigroup = struct;
/**
 * Use [`reverse`](#reverse) instead.
 *
 * @category zone of death
 * @since 2.0.0
 * @deprecated
 */
var getDualSemigroup = reverse;
/**
 * Use [`max`](#max) instead.
 *
 * @category zone of death
 * @since 2.0.0
 * @deprecated
 */
var getJoinSemigroup = max;
/**
 * Use [`min`](#min) instead.
 *
 * @category zone of death
 * @since 2.0.0
 * @deprecated
 */
var getMeetSemigroup = min;
/**
 * Use [`intercalate`](#intercalate) instead.
 *
 * @category zone of death
 * @since 2.5.0
 * @deprecated
 */
var getIntercalateSemigroup = intercalate;
function fold(S) {
    var concatAllS = concatAll(S);
    return function (startWith, as) { return (as === undefined ? concatAllS(startWith) : concatAllS(startWith)(as)); };
}
/**
 * Use [`SemigroupAll`](./boolean.ts.html#SemigroupAll) instead.
 *
 * @category zone of death
 * @since 2.0.0
 * @deprecated
 */
var semigroupAll = {
    concat: function (x, y) { return x && y; }
};
/**
 * Use [`SemigroupAny`](./boolean.ts.html#SemigroupAny) instead.
 *
 * @category zone of death
 * @since 2.0.0
 * @deprecated
 */
var semigroupAny = {
    concat: function (x, y) { return x || y; }
};
/**
 * Use [`getSemigroup`](./function.ts.html#getSemigroup) instead.
 *
 * @category zone of death
 * @since 2.0.0
 * @deprecated
 */
var getFunctionSemigroup = _function__WEBPACK_IMPORTED_MODULE_3__.getSemigroup;
/**
 * Use [`Semigroup`](./string.ts.html#Semigroup) instead.
 *
 * @category zone of death
 * @since 2.0.0
 * @deprecated
 */
var semigroupString = {
    concat: function (x, y) { return x + y; }
};
/**
 * Use [`SemigroupSum`](./number.ts.html#SemigroupSum) instead.
 *
 * @category zone of death
 * @since 2.0.0
 * @deprecated
 */
var semigroupSum = {
    concat: function (x, y) { return x + y; }
};
/**
 * Use [`SemigroupProduct`](./number.ts.html#SemigroupProduct) instead.
 *
 * @category zone of death
 * @since 2.0.0
 * @deprecated
 */
var semigroupProduct = {
    concat: function (x, y) { return x * y; }
};


/***/ }),

/***/ "./node_modules/fp-ts/es6/Separated.js":
/*!*********************************************!*\
  !*** ./node_modules/fp-ts/es6/Separated.js ***!
  \*********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Bifunctor: () => (/* binding */ Bifunctor),
/* harmony export */   Functor: () => (/* binding */ Functor),
/* harmony export */   URI: () => (/* binding */ URI),
/* harmony export */   bimap: () => (/* binding */ bimap),
/* harmony export */   flap: () => (/* binding */ flap),
/* harmony export */   left: () => (/* binding */ left),
/* harmony export */   map: () => (/* binding */ map),
/* harmony export */   mapLeft: () => (/* binding */ mapLeft),
/* harmony export */   right: () => (/* binding */ right),
/* harmony export */   separated: () => (/* binding */ separated)
/* harmony export */ });
/* harmony import */ var _function__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./function */ "./node_modules/fp-ts/es6/function.js");
/* harmony import */ var _Functor__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Functor */ "./node_modules/fp-ts/es6/Functor.js");
/**
 * ```ts
 * interface Separated<E, A> {
 *    readonly left: E
 *    readonly right: A
 * }
 * ```
 *
 * Represents a result of separating a whole into two parts.
 *
 * @since 2.10.0
 */


// -------------------------------------------------------------------------------------
// constructors
// -------------------------------------------------------------------------------------
/**
 * @category constructors
 * @since 2.10.0
 */
var separated = function (left, right) { return ({ left: left, right: right }); };
var _map = function (fa, f) { return (0,_function__WEBPACK_IMPORTED_MODULE_0__.pipe)(fa, map(f)); };
var _mapLeft = function (fa, f) { return (0,_function__WEBPACK_IMPORTED_MODULE_0__.pipe)(fa, mapLeft(f)); };
var _bimap = function (fa, g, f) { return (0,_function__WEBPACK_IMPORTED_MODULE_0__.pipe)(fa, bimap(g, f)); };
/**
 * `map` can be used to turn functions `(a: A) => B` into functions `(fa: F<A>) => F<B>` whose argument and return types
 * use the type constructor `F` to represent some computational context.
 *
 * @category mapping
 * @since 2.10.0
 */
var map = function (f) {
    return function (fa) {
        return separated(left(fa), f(right(fa)));
    };
};
/**
 * Map a function over the first type argument of a bifunctor.
 *
 * @category error handling
 * @since 2.10.0
 */
var mapLeft = function (f) {
    return function (fa) {
        return separated(f(left(fa)), right(fa));
    };
};
/**
 * Map a pair of functions over the two type arguments of the bifunctor.
 *
 * @category mapping
 * @since 2.10.0
 */
var bimap = function (f, g) {
    return function (fa) {
        return separated(f(left(fa)), g(right(fa)));
    };
};
/**
 * @category type lambdas
 * @since 2.10.0
 */
var URI = 'Separated';
/**
 * @category instances
 * @since 2.10.0
 */
var Bifunctor = {
    URI: URI,
    mapLeft: _mapLeft,
    bimap: _bimap
};
/**
 * @category instances
 * @since 2.10.0
 */
var Functor = {
    URI: URI,
    map: _map
};
/**
 * @category mapping
 * @since 2.10.0
 */
var flap = /*#__PURE__*/ (0,_Functor__WEBPACK_IMPORTED_MODULE_1__.flap)(Functor);
// -------------------------------------------------------------------------------------
// utils
// -------------------------------------------------------------------------------------
/**
 * @since 2.10.0
 */
var left = function (s) { return s.left; };
/**
 * @since 2.10.0
 */
var right = function (s) { return s.right; };


/***/ }),

/***/ "./node_modules/fp-ts/es6/Witherable.js":
/*!**********************************************!*\
  !*** ./node_modules/fp-ts/es6/Witherable.js ***!
  \**********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   filterE: () => (/* binding */ filterE),
/* harmony export */   wiltDefault: () => (/* binding */ wiltDefault),
/* harmony export */   witherDefault: () => (/* binding */ witherDefault)
/* harmony export */ });
/* harmony import */ var _internal__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./internal */ "./node_modules/fp-ts/es6/internal.js");

function wiltDefault(T, C) {
    return function (F) {
        var traverseF = T.traverse(F);
        return function (wa, f) { return F.map(traverseF(wa, f), C.separate); };
    };
}
function witherDefault(T, C) {
    return function (F) {
        var traverseF = T.traverse(F);
        return function (wa, f) { return F.map(traverseF(wa, f), C.compact); };
    };
}
function filterE(W) {
    return function (F) {
        var witherF = W.wither(F);
        return function (predicate) { return function (ga) { return witherF(ga, function (a) { return F.map(predicate(a), function (b) { return (b ? _internal__WEBPACK_IMPORTED_MODULE_0__.some(a) : _internal__WEBPACK_IMPORTED_MODULE_0__.none); }); }); }; };
    };
}


/***/ }),

/***/ "./node_modules/fp-ts/es6/Zero.js":
/*!****************************************!*\
  !*** ./node_modules/fp-ts/es6/Zero.js ***!
  \****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   guard: () => (/* binding */ guard)
/* harmony export */ });
function guard(F, P) {
    return function (b) { return (b ? P.of(undefined) : F.zero()); };
}


/***/ }),

/***/ "./node_modules/fp-ts/es6/function.js":
/*!********************************************!*\
  !*** ./node_modules/fp-ts/es6/function.js ***!
  \********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   SK: () => (/* binding */ SK),
/* harmony export */   absurd: () => (/* binding */ absurd),
/* harmony export */   apply: () => (/* binding */ apply),
/* harmony export */   constFalse: () => (/* binding */ constFalse),
/* harmony export */   constNull: () => (/* binding */ constNull),
/* harmony export */   constTrue: () => (/* binding */ constTrue),
/* harmony export */   constUndefined: () => (/* binding */ constUndefined),
/* harmony export */   constVoid: () => (/* binding */ constVoid),
/* harmony export */   constant: () => (/* binding */ constant),
/* harmony export */   decrement: () => (/* binding */ decrement),
/* harmony export */   dual: () => (/* binding */ dual),
/* harmony export */   flip: () => (/* binding */ flip),
/* harmony export */   flow: () => (/* binding */ flow),
/* harmony export */   getBooleanAlgebra: () => (/* binding */ getBooleanAlgebra),
/* harmony export */   getEndomorphismMonoid: () => (/* binding */ getEndomorphismMonoid),
/* harmony export */   getMonoid: () => (/* binding */ getMonoid),
/* harmony export */   getRing: () => (/* binding */ getRing),
/* harmony export */   getSemigroup: () => (/* binding */ getSemigroup),
/* harmony export */   getSemiring: () => (/* binding */ getSemiring),
/* harmony export */   hole: () => (/* binding */ hole),
/* harmony export */   identity: () => (/* binding */ identity),
/* harmony export */   increment: () => (/* binding */ increment),
/* harmony export */   not: () => (/* binding */ not),
/* harmony export */   pipe: () => (/* binding */ pipe),
/* harmony export */   tuple: () => (/* binding */ tuple),
/* harmony export */   tupled: () => (/* binding */ tupled),
/* harmony export */   unsafeCoerce: () => (/* binding */ unsafeCoerce),
/* harmony export */   untupled: () => (/* binding */ untupled)
/* harmony export */ });
var __spreadArray = (undefined && undefined.__spreadArray) || function (to, from, pack) {
    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
        }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
};
// -------------------------------------------------------------------------------------
// instances
// -------------------------------------------------------------------------------------
/**
 * @category instances
 * @since 2.10.0
 */
var getBooleanAlgebra = function (B) {
    return function () { return ({
        meet: function (x, y) { return function (a) { return B.meet(x(a), y(a)); }; },
        join: function (x, y) { return function (a) { return B.join(x(a), y(a)); }; },
        zero: function () { return B.zero; },
        one: function () { return B.one; },
        implies: function (x, y) { return function (a) { return B.implies(x(a), y(a)); }; },
        not: function (x) { return function (a) { return B.not(x(a)); }; }
    }); };
};
/**
 * Unary functions form a semigroup as long as you can provide a semigroup for the codomain.
 *
 * @example
 * import { Predicate, getSemigroup } from 'fp-ts/function'
 * import * as B from 'fp-ts/boolean'
 *
 * const f: Predicate<number> = (n) => n <= 2
 * const g: Predicate<number> = (n) => n >= 0
 *
 * const S1 = getSemigroup(B.SemigroupAll)<number>()
 *
 * assert.deepStrictEqual(S1.concat(f, g)(1), true)
 * assert.deepStrictEqual(S1.concat(f, g)(3), false)
 *
 * const S2 = getSemigroup(B.SemigroupAny)<number>()
 *
 * assert.deepStrictEqual(S2.concat(f, g)(1), true)
 * assert.deepStrictEqual(S2.concat(f, g)(3), true)
 *
 * @category instances
 * @since 2.10.0
 */
var getSemigroup = function (S) {
    return function () { return ({
        concat: function (f, g) { return function (a) { return S.concat(f(a), g(a)); }; }
    }); };
};
/**
 * Unary functions form a monoid as long as you can provide a monoid for the codomain.
 *
 * @example
 * import { Predicate } from 'fp-ts/Predicate'
 * import { getMonoid } from 'fp-ts/function'
 * import * as B from 'fp-ts/boolean'
 *
 * const f: Predicate<number> = (n) => n <= 2
 * const g: Predicate<number> = (n) => n >= 0
 *
 * const M1 = getMonoid(B.MonoidAll)<number>()
 *
 * assert.deepStrictEqual(M1.concat(f, g)(1), true)
 * assert.deepStrictEqual(M1.concat(f, g)(3), false)
 *
 * const M2 = getMonoid(B.MonoidAny)<number>()
 *
 * assert.deepStrictEqual(M2.concat(f, g)(1), true)
 * assert.deepStrictEqual(M2.concat(f, g)(3), true)
 *
 * @category instances
 * @since 2.10.0
 */
var getMonoid = function (M) {
    var getSemigroupM = getSemigroup(M);
    return function () { return ({
        concat: getSemigroupM().concat,
        empty: function () { return M.empty; }
    }); };
};
/**
 * @category instances
 * @since 2.10.0
 */
var getSemiring = function (S) { return ({
    add: function (f, g) { return function (x) { return S.add(f(x), g(x)); }; },
    zero: function () { return S.zero; },
    mul: function (f, g) { return function (x) { return S.mul(f(x), g(x)); }; },
    one: function () { return S.one; }
}); };
/**
 * @category instances
 * @since 2.10.0
 */
var getRing = function (R) {
    var S = getSemiring(R);
    return {
        add: S.add,
        mul: S.mul,
        one: S.one,
        zero: S.zero,
        sub: function (f, g) { return function (x) { return R.sub(f(x), g(x)); }; }
    };
};
// -------------------------------------------------------------------------------------
// utils
// -------------------------------------------------------------------------------------
/**
 * @since 2.11.0
 */
var apply = function (a) {
    return function (f) {
        return f(a);
    };
};
/**
 * @since 2.0.0
 */
function identity(a) {
    return a;
}
/**
 * @since 2.0.0
 */
var unsafeCoerce = identity;
/**
 * @since 2.0.0
 */
function constant(a) {
    return function () { return a; };
}
/**
 * A thunk that returns always `true`.
 *
 * @since 2.0.0
 */
var constTrue = /*#__PURE__*/ constant(true);
/**
 * A thunk that returns always `false`.
 *
 * @since 2.0.0
 */
var constFalse = /*#__PURE__*/ constant(false);
/**
 * A thunk that returns always `null`.
 *
 * @since 2.0.0
 */
var constNull = /*#__PURE__*/ constant(null);
/**
 * A thunk that returns always `undefined`.
 *
 * @since 2.0.0
 */
var constUndefined = /*#__PURE__*/ constant(undefined);
/**
 * A thunk that returns always `void`.
 *
 * @since 2.0.0
 */
var constVoid = constUndefined;
function flip(f) {
    return function () {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        if (args.length > 1) {
            return f(args[1], args[0]);
        }
        return function (a) { return f(a)(args[0]); };
    };
}
function flow(ab, bc, cd, de, ef, fg, gh, hi, ij) {
    switch (arguments.length) {
        case 1:
            return ab;
        case 2:
            return function () {
                return bc(ab.apply(this, arguments));
            };
        case 3:
            return function () {
                return cd(bc(ab.apply(this, arguments)));
            };
        case 4:
            return function () {
                return de(cd(bc(ab.apply(this, arguments))));
            };
        case 5:
            return function () {
                return ef(de(cd(bc(ab.apply(this, arguments)))));
            };
        case 6:
            return function () {
                return fg(ef(de(cd(bc(ab.apply(this, arguments))))));
            };
        case 7:
            return function () {
                return gh(fg(ef(de(cd(bc(ab.apply(this, arguments)))))));
            };
        case 8:
            return function () {
                return hi(gh(fg(ef(de(cd(bc(ab.apply(this, arguments))))))));
            };
        case 9:
            return function () {
                return ij(hi(gh(fg(ef(de(cd(bc(ab.apply(this, arguments)))))))));
            };
    }
    return;
}
/**
 * @since 2.0.0
 */
function tuple() {
    var t = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        t[_i] = arguments[_i];
    }
    return t;
}
/**
 * @since 2.0.0
 */
function increment(n) {
    return n + 1;
}
/**
 * @since 2.0.0
 */
function decrement(n) {
    return n - 1;
}
/**
 * @since 2.0.0
 */
function absurd(_) {
    throw new Error('Called `absurd` function which should be uncallable');
}
/**
 * Creates a tupled version of this function: instead of `n` arguments, it accepts a single tuple argument.
 *
 * @example
 * import { tupled } from 'fp-ts/function'
 *
 * const add = tupled((x: number, y: number): number => x + y)
 *
 * assert.strictEqual(add([1, 2]), 3)
 *
 * @since 2.4.0
 */
function tupled(f) {
    return function (a) { return f.apply(void 0, a); };
}
/**
 * Inverse function of `tupled`
 *
 * @since 2.4.0
 */
function untupled(f) {
    return function () {
        var a = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            a[_i] = arguments[_i];
        }
        return f(a);
    };
}
function pipe(a, ab, bc, cd, de, ef, fg, gh, hi) {
    switch (arguments.length) {
        case 1:
            return a;
        case 2:
            return ab(a);
        case 3:
            return bc(ab(a));
        case 4:
            return cd(bc(ab(a)));
        case 5:
            return de(cd(bc(ab(a))));
        case 6:
            return ef(de(cd(bc(ab(a)))));
        case 7:
            return fg(ef(de(cd(bc(ab(a))))));
        case 8:
            return gh(fg(ef(de(cd(bc(ab(a)))))));
        case 9:
            return hi(gh(fg(ef(de(cd(bc(ab(a))))))));
        default: {
            var ret = arguments[0];
            for (var i = 1; i < arguments.length; i++) {
                ret = arguments[i](ret);
            }
            return ret;
        }
    }
}
/**
 * Type hole simulation
 *
 * @since 2.7.0
 */
var hole = absurd;
/**
 * @since 2.11.0
 */
var SK = function (_, b) { return b; };
/**
 * Use `Predicate` module instead.
 *
 * @category zone of death
 * @since 2.0.0
 * @deprecated
 */
function not(predicate) {
    return function (a) { return !predicate(a); };
}
/**
 * Use `Endomorphism` module instead.
 *
 * @category zone of death
 * @since 2.10.0
 * @deprecated
 */
var getEndomorphismMonoid = function () { return ({
    concat: function (first, second) { return flow(first, second); },
    empty: identity
}); };
/** @internal */
var dual = function (arity, body) {
    var isDataFirst = typeof arity === 'number' ? function (args) { return args.length >= arity; } : arity;
    return function () {
        var args = Array.from(arguments);
        if (isDataFirst(arguments)) {
            return body.apply(this, args);
        }
        return function (self) { return body.apply(void 0, __spreadArray([self], args, false)); };
    };
};


/***/ }),

/***/ "./node_modules/fp-ts/es6/internal.js":
/*!********************************************!*\
  !*** ./node_modules/fp-ts/es6/internal.js ***!
  \********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   emptyReadonlyArray: () => (/* binding */ emptyReadonlyArray),
/* harmony export */   emptyRecord: () => (/* binding */ emptyRecord),
/* harmony export */   flatMapEither: () => (/* binding */ flatMapEither),
/* harmony export */   flatMapIO: () => (/* binding */ flatMapIO),
/* harmony export */   flatMapNullable: () => (/* binding */ flatMapNullable),
/* harmony export */   flatMapOption: () => (/* binding */ flatMapOption),
/* harmony export */   flatMapReader: () => (/* binding */ flatMapReader),
/* harmony export */   flatMapTask: () => (/* binding */ flatMapTask),
/* harmony export */   fromReadonlyNonEmptyArray: () => (/* binding */ fromReadonlyNonEmptyArray),
/* harmony export */   has: () => (/* binding */ has),
/* harmony export */   head: () => (/* binding */ head),
/* harmony export */   isLeft: () => (/* binding */ isLeft),
/* harmony export */   isNonEmpty: () => (/* binding */ isNonEmpty),
/* harmony export */   isNone: () => (/* binding */ isNone),
/* harmony export */   isRight: () => (/* binding */ isRight),
/* harmony export */   isSome: () => (/* binding */ isSome),
/* harmony export */   left: () => (/* binding */ left),
/* harmony export */   liftNullable: () => (/* binding */ liftNullable),
/* harmony export */   liftOption: () => (/* binding */ liftOption),
/* harmony export */   none: () => (/* binding */ none),
/* harmony export */   right: () => (/* binding */ right),
/* harmony export */   singleton: () => (/* binding */ singleton),
/* harmony export */   some: () => (/* binding */ some),
/* harmony export */   tail: () => (/* binding */ tail)
/* harmony export */ });
/* harmony import */ var _function__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./function */ "./node_modules/fp-ts/es6/function.js");
var __spreadArray = (undefined && undefined.__spreadArray) || function (to, from, pack) {
    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
        }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
};

// -------------------------------------------------------------------------------------
// Option
// -------------------------------------------------------------------------------------
/** @internal */
var isNone = function (fa) { return fa._tag === 'None'; };
/** @internal */
var isSome = function (fa) { return fa._tag === 'Some'; };
/** @internal */
var none = { _tag: 'None' };
/** @internal */
var some = function (a) { return ({ _tag: 'Some', value: a }); };
// -------------------------------------------------------------------------------------
// Either
// -------------------------------------------------------------------------------------
/** @internal */
var isLeft = function (ma) { return ma._tag === 'Left'; };
/** @internal */
var isRight = function (ma) { return ma._tag === 'Right'; };
/** @internal */
var left = function (e) { return ({ _tag: 'Left', left: e }); };
/** @internal */
var right = function (a) { return ({ _tag: 'Right', right: a }); };
// -------------------------------------------------------------------------------------
// ReadonlyNonEmptyArray
// -------------------------------------------------------------------------------------
/** @internal */
var singleton = function (a) { return [a]; };
/** @internal */
var isNonEmpty = function (as) { return as.length > 0; };
/** @internal */
var head = function (as) { return as[0]; };
/** @internal */
var tail = function (as) { return as.slice(1); };
// -------------------------------------------------------------------------------------
// empty
// -------------------------------------------------------------------------------------
/** @internal */
var emptyReadonlyArray = [];
/** @internal */
var emptyRecord = {};
// -------------------------------------------------------------------------------------
// Record
// -------------------------------------------------------------------------------------
/** @internal */
var has = Object.prototype.hasOwnProperty;
// -------------------------------------------------------------------------------------
// NonEmptyArray
// -------------------------------------------------------------------------------------
/** @internal */
var fromReadonlyNonEmptyArray = function (as) { return __spreadArray([as[0]], as.slice(1), true); };
/** @internal */
var liftNullable = function (F) {
    return function (f, onNullable) {
        return function () {
            var a = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                a[_i] = arguments[_i];
            }
            var o = f.apply(void 0, a);
            return F.fromEither(o == null ? left(onNullable.apply(void 0, a)) : right(o));
        };
    };
};
/** @internal */
var liftOption = function (F) {
    return function (f, onNone) {
        return function () {
            var a = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                a[_i] = arguments[_i];
            }
            var o = f.apply(void 0, a);
            return F.fromEither(isNone(o) ? left(onNone.apply(void 0, a)) : right(o.value));
        };
    };
};
/** @internal */
var flatMapNullable = function (F, M) {
    return /*#__PURE__*/ (0,_function__WEBPACK_IMPORTED_MODULE_0__.dual)(3, function (self, f, onNullable) {
        return M.flatMap(self, liftNullable(F)(f, onNullable));
    });
};
/** @internal */
var flatMapOption = function (F, M) {
    return /*#__PURE__*/ (0,_function__WEBPACK_IMPORTED_MODULE_0__.dual)(3, function (self, f, onNone) { return M.flatMap(self, liftOption(F)(f, onNone)); });
};
/** @internal */
var flatMapEither = function (F, M) {
    return /*#__PURE__*/ (0,_function__WEBPACK_IMPORTED_MODULE_0__.dual)(2, function (self, f) {
        return M.flatMap(self, function (a) { return F.fromEither(f(a)); });
    });
};
/** @internal */
var flatMapIO = function (F, M) {
    return /*#__PURE__*/ (0,_function__WEBPACK_IMPORTED_MODULE_0__.dual)(2, function (self, f) {
        return M.flatMap(self, function (a) { return F.fromIO(f(a)); });
    });
};
/** @internal */
var flatMapTask = function (F, M) {
    return /*#__PURE__*/ (0,_function__WEBPACK_IMPORTED_MODULE_0__.dual)(2, function (self, f) {
        return M.flatMap(self, function (a) { return F.fromTask(f(a)); });
    });
};
/** @internal */
var flatMapReader = function (F, M) {
    return /*#__PURE__*/ (0,_function__WEBPACK_IMPORTED_MODULE_0__.dual)(2, function (self, f) {
        return M.flatMap(self, function (a) { return F.fromReader(f(a)); });
    });
};


/***/ }),

/***/ "./node_modules/fp-ts/es6/number.js":
/*!******************************************!*\
  !*** ./node_modules/fp-ts/es6/number.js ***!
  \******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Bounded: () => (/* binding */ Bounded),
/* harmony export */   Eq: () => (/* binding */ Eq),
/* harmony export */   Field: () => (/* binding */ Field),
/* harmony export */   MagmaSub: () => (/* binding */ MagmaSub),
/* harmony export */   MonoidProduct: () => (/* binding */ MonoidProduct),
/* harmony export */   MonoidSum: () => (/* binding */ MonoidSum),
/* harmony export */   Ord: () => (/* binding */ Ord),
/* harmony export */   SemigroupProduct: () => (/* binding */ SemigroupProduct),
/* harmony export */   SemigroupSum: () => (/* binding */ SemigroupSum),
/* harmony export */   Show: () => (/* binding */ Show),
/* harmony export */   isNumber: () => (/* binding */ isNumber)
/* harmony export */ });
// -------------------------------------------------------------------------------------
// refinements
// -------------------------------------------------------------------------------------
/**
 * @category refinements
 * @since 2.11.0
 */
var isNumber = function (u) { return typeof u === 'number'; };
// -------------------------------------------------------------------------------------
// instances
// -------------------------------------------------------------------------------------
/**
 * @category instances
 * @since 2.10.0
 */
var Eq = {
    equals: function (first, second) { return first === second; }
};
/**
 * @category instances
 * @since 2.10.0
 */
var Ord = {
    equals: Eq.equals,
    compare: function (first, second) { return (first < second ? -1 : first > second ? 1 : 0); }
};
/**
 * @category instances
 * @since 2.10.0
 */
var Bounded = {
    equals: Eq.equals,
    compare: Ord.compare,
    top: Infinity,
    bottom: -Infinity
};
/**
 * @category instances
 * @since 2.10.0
 */
var Show = {
    show: function (n) { return JSON.stringify(n); }
};
/**
 * @category instances
 * @since 2.11.0
 */
var MagmaSub = {
    concat: function (first, second) { return first - second; }
};
/**
 * `number` semigroup under addition.
 *
 * @example
 * import { SemigroupSum } from 'fp-ts/number'
 *
 * assert.deepStrictEqual(SemigroupSum.concat(2, 3), 5)
 *
 * @category instances
 * @since 2.10.0
 */
var SemigroupSum = {
    concat: function (first, second) { return first + second; }
};
/**
 * `number` semigroup under multiplication.
 *
 * @example
 * import { SemigroupProduct } from 'fp-ts/number'
 *
 * assert.deepStrictEqual(SemigroupProduct.concat(2, 3), 6)
 *
 * @category instances
 * @since 2.10.0
 */
var SemigroupProduct = {
    concat: function (first, second) { return first * second; }
};
/**
 * `number` monoid under addition.
 *
 * The `empty` value is `0`.
 *
 * @example
 * import { MonoidSum } from 'fp-ts/number'
 *
 * assert.deepStrictEqual(MonoidSum.concat(2, MonoidSum.empty), 2)
 *
 * @category instances
 * @since 2.10.0
 */
var MonoidSum = {
    concat: SemigroupSum.concat,
    empty: 0
};
/**
 * `number` monoid under multiplication.
 *
 * The `empty` value is `1`.
 *
 * @example
 * import { MonoidProduct } from 'fp-ts/number'
 *
 * assert.deepStrictEqual(MonoidProduct.concat(2, MonoidProduct.empty), 2)
 *
 * @category instances
 * @since 2.10.0
 */
var MonoidProduct = {
    concat: SemigroupProduct.concat,
    empty: 1
};
/**
 * @category instances
 * @since 2.10.0
 */
var Field = {
    add: SemigroupSum.concat,
    zero: 0,
    mul: SemigroupProduct.concat,
    one: 1,
    sub: MagmaSub.concat,
    degree: function (_) { return 1; },
    div: function (first, second) { return first / second; },
    mod: function (first, second) { return first % second; }
};


/***/ }),

/***/ "./node_modules/fp-ts/es6/pipeable.js":
/*!********************************************!*\
  !*** ./node_modules/fp-ts/es6/pipeable.js ***!
  \********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   alt: () => (/* binding */ alt),
/* harmony export */   ap: () => (/* binding */ ap),
/* harmony export */   bimap: () => (/* binding */ bimap),
/* harmony export */   chain: () => (/* binding */ chain),
/* harmony export */   compose: () => (/* binding */ compose),
/* harmony export */   contramap: () => (/* binding */ contramap),
/* harmony export */   extend: () => (/* binding */ extend),
/* harmony export */   filter: () => (/* binding */ filter),
/* harmony export */   filterMap: () => (/* binding */ filterMap),
/* harmony export */   filterMapWithIndex: () => (/* binding */ filterMapWithIndex),
/* harmony export */   filterWithIndex: () => (/* binding */ filterWithIndex),
/* harmony export */   foldMap: () => (/* binding */ foldMap),
/* harmony export */   foldMapWithIndex: () => (/* binding */ foldMapWithIndex),
/* harmony export */   map: () => (/* binding */ map),
/* harmony export */   mapLeft: () => (/* binding */ mapLeft),
/* harmony export */   mapWithIndex: () => (/* binding */ mapWithIndex),
/* harmony export */   partition: () => (/* binding */ partition),
/* harmony export */   partitionMap: () => (/* binding */ partitionMap),
/* harmony export */   partitionMapWithIndex: () => (/* binding */ partitionMapWithIndex),
/* harmony export */   partitionWithIndex: () => (/* binding */ partitionWithIndex),
/* harmony export */   pipe: () => (/* binding */ pipe),
/* harmony export */   pipeable: () => (/* binding */ pipeable),
/* harmony export */   promap: () => (/* binding */ promap),
/* harmony export */   reduce: () => (/* binding */ reduce),
/* harmony export */   reduceRight: () => (/* binding */ reduceRight),
/* harmony export */   reduceRightWithIndex: () => (/* binding */ reduceRightWithIndex),
/* harmony export */   reduceWithIndex: () => (/* binding */ reduceWithIndex)
/* harmony export */ });
/* harmony import */ var _Apply__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Apply */ "./node_modules/fp-ts/es6/Apply.js");
/* harmony import */ var _Chain__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Chain */ "./node_modules/fp-ts/es6/Chain.js");
/* harmony import */ var _function__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./function */ "./node_modules/fp-ts/es6/function.js");



function map(F) {
    return function (f) { return function (fa) { return F.map(fa, f); }; };
}
function contramap(F) {
    return function (f) { return function (fa) { return F.contramap(fa, f); }; };
}
function mapWithIndex(F) {
    return function (f) { return function (fa) { return F.mapWithIndex(fa, f); }; };
}
function ap(F) {
    return function (fa) { return function (fab) { return F.ap(fab, fa); }; };
}
function chain(F) {
    return function (f) { return function (fa) { return F.chain(fa, f); }; };
}
function bimap(F) {
    return function (f, g) { return function (fea) { return F.bimap(fea, f, g); }; };
}
function mapLeft(F) {
    return function (f) { return function (fea) { return F.mapLeft(fea, f); }; };
}
function extend(F) {
    return function (f) { return function (wa) { return F.extend(wa, f); }; };
}
function reduce(F) {
    return function (b, f) { return function (fa) { return F.reduce(fa, b, f); }; };
}
function foldMap(F) {
    return function (M) {
        var foldMapM = F.foldMap(M);
        return function (f) { return function (fa) { return foldMapM(fa, f); }; };
    };
}
function reduceRight(F) {
    return function (b, f) { return function (fa) { return F.reduceRight(fa, b, f); }; };
}
function reduceWithIndex(F) {
    return function (b, f) { return function (fa) { return F.reduceWithIndex(fa, b, f); }; };
}
function foldMapWithIndex(F) {
    return function (M) {
        var foldMapWithIndexM = F.foldMapWithIndex(M);
        return function (f) { return function (fa) { return foldMapWithIndexM(fa, f); }; };
    };
}
function reduceRightWithIndex(F) {
    return function (b, f) { return function (fa) { return F.reduceRightWithIndex(fa, b, f); }; };
}
function alt(F) {
    return function (that) { return function (fa) { return F.alt(fa, that); }; };
}
function filter(F) {
    return function (predicate) { return function (fa) { return F.filter(fa, predicate); }; };
}
function filterMap(F) {
    return function (f) { return function (fa) { return F.filterMap(fa, f); }; };
}
function partition(F) {
    return function (f) { return function (fa) { return F.partition(fa, f); }; };
}
function partitionMap(F) {
    return function (f) { return function (fa) { return F.partitionMap(fa, f); }; };
}
function filterWithIndex(F) {
    return function (predicate) { return function (fa) { return F.filterWithIndex(fa, predicate); }; };
}
function filterMapWithIndex(F) {
    return function (f) { return function (fa) { return F.filterMapWithIndex(fa, f); }; };
}
function partitionWithIndex(F) {
    return function (f) { return function (fa) { return F.partitionWithIndex(fa, f); }; };
}
function partitionMapWithIndex(F) {
    return function (f) { return function (fa) { return F.partitionMapWithIndex(fa, f); }; };
}
function promap(F) {
    return function (f, g) { return function (fbc) { return F.promap(fbc, f, g); }; };
}
function compose(F) {
    return function (ea) { return function (ab) { return F.compose(ab, ea); }; };
}
var isFunctor = function (I) { return typeof I.map === 'function'; };
var isContravariant = function (I) { return typeof I.contramap === 'function'; };
var isFunctorWithIndex = function (I) { return typeof I.mapWithIndex === 'function'; };
var isApply = function (I) { return typeof I.ap === 'function'; };
var isChain = function (I) { return typeof I.chain === 'function'; };
var isBifunctor = function (I) { return typeof I.bimap === 'function'; };
var isExtend = function (I) { return typeof I.extend === 'function'; };
var isFoldable = function (I) { return typeof I.reduce === 'function'; };
var isFoldableWithIndex = function (I) { return typeof I.reduceWithIndex === 'function'; };
var isAlt = function (I) { return typeof I.alt === 'function'; };
var isCompactable = function (I) { return typeof I.compact === 'function'; };
var isFilterable = function (I) { return typeof I.filter === 'function'; };
var isFilterableWithIndex = function (I) {
    return typeof I.filterWithIndex === 'function';
};
var isProfunctor = function (I) { return typeof I.promap === 'function'; };
var isSemigroupoid = function (I) { return typeof I.compose === 'function'; };
var isMonadThrow = function (I) { return typeof I.throwError === 'function'; };
/** @deprecated */
function pipeable(I) {
    var r = {};
    if (isFunctor(I)) {
        r.map = map(I);
    }
    if (isContravariant(I)) {
        r.contramap = contramap(I);
    }
    if (isFunctorWithIndex(I)) {
        r.mapWithIndex = mapWithIndex(I);
    }
    if (isApply(I)) {
        r.ap = ap(I);
        r.apFirst = (0,_Apply__WEBPACK_IMPORTED_MODULE_0__.apFirst)(I);
        r.apSecond = (0,_Apply__WEBPACK_IMPORTED_MODULE_0__.apSecond)(I);
    }
    if (isChain(I)) {
        r.chain = chain(I);
        r.chainFirst = (0,_Chain__WEBPACK_IMPORTED_MODULE_1__.chainFirst)(I);
        r.flatten = r.chain(_function__WEBPACK_IMPORTED_MODULE_2__.identity);
    }
    if (isBifunctor(I)) {
        r.bimap = bimap(I);
        r.mapLeft = mapLeft(I);
    }
    if (isExtend(I)) {
        r.extend = extend(I);
        r.duplicate = r.extend(_function__WEBPACK_IMPORTED_MODULE_2__.identity);
    }
    if (isFoldable(I)) {
        r.reduce = reduce(I);
        r.foldMap = foldMap(I);
        r.reduceRight = reduceRight(I);
    }
    if (isFoldableWithIndex(I)) {
        r.reduceWithIndex = reduceWithIndex(I);
        r.foldMapWithIndex = foldMapWithIndex(I);
        r.reduceRightWithIndex = reduceRightWithIndex(I);
    }
    if (isAlt(I)) {
        r.alt = alt(I);
    }
    if (isCompactable(I)) {
        r.compact = I.compact;
        r.separate = I.separate;
    }
    if (isFilterable(I)) {
        r.filter = filter(I);
        r.filterMap = filterMap(I);
        r.partition = partition(I);
        r.partitionMap = partitionMap(I);
    }
    if (isFilterableWithIndex(I)) {
        r.filterWithIndex = filterWithIndex(I);
        r.filterMapWithIndex = filterMapWithIndex(I);
        r.partitionWithIndex = partitionWithIndex(I);
        r.partitionMapWithIndex = partitionMapWithIndex(I);
    }
    if (isProfunctor(I)) {
        r.promap = promap(I);
    }
    if (isSemigroupoid(I)) {
        r.compose = compose(I);
    }
    if (isMonadThrow(I)) {
        var fromOption = function (onNone) { return function (ma) {
            return ma._tag === 'None' ? I.throwError(onNone()) : I.of(ma.value);
        }; };
        var fromEither = function (ma) {
            return ma._tag === 'Left' ? I.throwError(ma.left) : I.of(ma.right);
        };
        var fromPredicate = function (predicate, onFalse) {
            return function (a) {
                return predicate(a) ? I.of(a) : I.throwError(onFalse(a));
            };
        };
        var filterOrElse = function (predicate, onFalse) {
            return function (ma) {
                return I.chain(ma, function (a) { return (predicate(a) ? I.of(a) : I.throwError(onFalse(a))); });
            };
        };
        r.fromOption = fromOption;
        r.fromEither = fromEither;
        r.fromPredicate = fromPredicate;
        r.filterOrElse = filterOrElse;
    }
    return r;
}
/**
 * Use [`pipe`](https://gcanti.github.io/fp-ts/modules/function.ts.html#pipe) from `function` module instead.
 *
 * @since 2.0.0
 * @deprecated
 */
var pipe = _function__WEBPACK_IMPORTED_MODULE_2__.pipe;


/***/ }),

/***/ "./node_modules/fp-ts/es6/string.js":
/*!******************************************!*\
  !*** ./node_modules/fp-ts/es6/string.js ***!
  \******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Eq: () => (/* binding */ Eq),
/* harmony export */   Monoid: () => (/* binding */ Monoid),
/* harmony export */   Ord: () => (/* binding */ Ord),
/* harmony export */   Semigroup: () => (/* binding */ Semigroup),
/* harmony export */   Show: () => (/* binding */ Show),
/* harmony export */   empty: () => (/* binding */ empty),
/* harmony export */   endsWith: () => (/* binding */ endsWith),
/* harmony export */   includes: () => (/* binding */ includes),
/* harmony export */   isEmpty: () => (/* binding */ isEmpty),
/* harmony export */   isString: () => (/* binding */ isString),
/* harmony export */   replace: () => (/* binding */ replace),
/* harmony export */   size: () => (/* binding */ size),
/* harmony export */   slice: () => (/* binding */ slice),
/* harmony export */   split: () => (/* binding */ split),
/* harmony export */   startsWith: () => (/* binding */ startsWith),
/* harmony export */   toLowerCase: () => (/* binding */ toLowerCase),
/* harmony export */   toUpperCase: () => (/* binding */ toUpperCase),
/* harmony export */   trim: () => (/* binding */ trim),
/* harmony export */   trimLeft: () => (/* binding */ trimLeft),
/* harmony export */   trimRight: () => (/* binding */ trimRight)
/* harmony export */ });
/* harmony import */ var _ReadonlyNonEmptyArray__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./ReadonlyNonEmptyArray */ "./node_modules/fp-ts/es6/ReadonlyNonEmptyArray.js");

// -------------------------------------------------------------------------------------
// instances
// -------------------------------------------------------------------------------------
/**
 * @example
 * import * as S from 'fp-ts/string'
 *
 * assert.deepStrictEqual(S.Eq.equals('a', 'a'), true)
 * assert.deepStrictEqual(S.Eq.equals('a', 'b'), false)
 *
 * @category instances
 * @since 2.10.0
 */
var Eq = {
    equals: function (first, second) { return first === second; }
};
/**
 * `string` semigroup under concatenation.
 *
 * @example
 * import * as S from 'fp-ts/string'
 *
 * assert.deepStrictEqual(S.Semigroup.concat('a', 'b'), 'ab')
 *
 * @category instances
 * @since 2.10.0
 */
var Semigroup = {
    concat: function (first, second) { return first + second; }
};
/**
 * An empty `string`.
 *
 * @since 2.10.0
 */
var empty = '';
/**
 * `string` monoid under concatenation.
 *
 * The `empty` value is `''`.
 *
 * @example
 * import * as S from 'fp-ts/string'
 *
 * assert.deepStrictEqual(S.Monoid.concat('a', 'b'), 'ab')
 * assert.deepStrictEqual(S.Monoid.concat('a', S.Monoid.empty), 'a')
 *
 * @category instances
 * @since 2.10.0
 */
var Monoid = {
    concat: Semigroup.concat,
    empty: empty
};
/**
 * @example
 * import * as S from 'fp-ts/string'
 *
 * assert.deepStrictEqual(S.Ord.compare('a', 'a'), 0)
 * assert.deepStrictEqual(S.Ord.compare('a', 'b'), -1)
 * assert.deepStrictEqual(S.Ord.compare('b', 'a'), 1)
 *
 * @category instances
 * @since 2.10.0
 */
var Ord = {
    equals: Eq.equals,
    compare: function (first, second) { return (first < second ? -1 : first > second ? 1 : 0); }
};
/**
 * @example
 * import * as S from 'fp-ts/string'
 *
 * assert.deepStrictEqual(S.Show.show('a'), '"a"')
 *
 * @category instances
 * @since 2.10.0
 */
var Show = {
    show: function (s) { return JSON.stringify(s); }
};
// -------------------------------------------------------------------------------------
// refinements
// -------------------------------------------------------------------------------------
/**
 * @example
 * import * as S from 'fp-ts/string'
 *
 * assert.deepStrictEqual(S.isString('a'), true)
 * assert.deepStrictEqual(S.isString(1), false)
 *
 * @category refinements
 * @since 2.11.0
 */
var isString = function (u) { return typeof u === 'string'; };
// -------------------------------------------------------------------------------------
// combinators
// -------------------------------------------------------------------------------------
/**
 * @example
 * import * as S from 'fp-ts/string'
 * import { pipe } from 'fp-ts/function'
 *
 * assert.deepStrictEqual(pipe('a', S.toUpperCase), 'A')
 *
 * @since 2.11.0
 */
var toUpperCase = function (s) { return s.toUpperCase(); };
/**
 * @example
 * import * as S from 'fp-ts/string'
 * import { pipe } from 'fp-ts/function'
 *
 * assert.deepStrictEqual(pipe('A', S.toLowerCase), 'a')
 *
 * @since 2.11.0
 */
var toLowerCase = function (s) { return s.toLowerCase(); };
/**
 * @example
 * import * as S from 'fp-ts/string'
 * import { pipe } from 'fp-ts/function'
 *
 * assert.deepStrictEqual(pipe('abc', S.replace('b', 'd')), 'adc')
 *
 * @since 2.11.0
 */
var replace = function (searchValue, replaceValue) {
    return function (s) {
        return s.replace(searchValue, replaceValue);
    };
};
/**
 * @example
 * import * as S from 'fp-ts/string'
 * import { pipe } from 'fp-ts/function'
 *
 * assert.deepStrictEqual(pipe(' a ', S.trim), 'a')
 *
 * @since 2.11.0
 */
var trim = function (s) { return s.trim(); };
/**
 * @example
 * import * as S from 'fp-ts/string'
 * import { pipe } from 'fp-ts/function'
 *
 * assert.deepStrictEqual(pipe(' a ', S.trimLeft), 'a ')
 *
 * @since 2.11.0
 */
var trimLeft = function (s) { return s.trimLeft(); };
/**
 * @example
 * import * as S from 'fp-ts/string'
 * import { pipe } from 'fp-ts/function'
 *
 * assert.deepStrictEqual(pipe(' a ', S.trimRight), ' a')
 *
 * @since 2.11.0
 */
var trimRight = function (s) { return s.trimRight(); };
/**
 * @example
 * import * as S from 'fp-ts/string'
 * import { pipe } from 'fp-ts/function'
 *
 * assert.deepStrictEqual(pipe('abcd', S.slice(1, 3)), 'bc')
 *
 * @since 2.11.0
 */
var slice = function (start, end) {
    return function (s) {
        return s.slice(start, end);
    };
};
// -------------------------------------------------------------------------------------
// utils
// -------------------------------------------------------------------------------------
/**
 * Test whether a `string` is empty.
 *
 * @example
 * import * as S from 'fp-ts/string'
 * import { pipe } from 'fp-ts/function'
 *
 * assert.deepStrictEqual(pipe('', S.isEmpty), true)
 * assert.deepStrictEqual(pipe('a', S.isEmpty), false)
 *
 * @since 2.10.0
 */
var isEmpty = function (s) { return s.length === 0; };
/**
 * Calculate the number of characters in a `string`.
 *
 * @example
 * import * as S from 'fp-ts/string'
 * import { pipe } from 'fp-ts/function'
 *
 * assert.deepStrictEqual(pipe('abc', S.size), 3)
 *
 * @since 2.10.0
 */
var size = function (s) { return s.length; };
/**
 * @example
 * import * as S from 'fp-ts/string'
 * import { pipe } from 'fp-ts/function'
 *
 * assert.deepStrictEqual(pipe('abc', S.split('')), ['a', 'b', 'c'])
 * assert.deepStrictEqual(pipe('', S.split('')), [''])
 *
 * @since 2.11.0
 */
var split = function (separator) {
    return function (s) {
        var out = s.split(separator);
        return (0,_ReadonlyNonEmptyArray__WEBPACK_IMPORTED_MODULE_0__.isNonEmpty)(out) ? out : [s];
    };
};
/**
 * @example
 * import * as S from 'fp-ts/string'
 * import { pipe } from 'fp-ts/function'
 *
 * assert.deepStrictEqual(pipe('abc', S.includes('b')), true)
 * assert.deepStrictEqual(pipe('abc', S.includes('d')), false)
 *
 * @since 2.11.0
 */
var includes = function (searchString, position) {
    return function (s) {
        return s.includes(searchString, position);
    };
};
/**
 * @example
 * import * as S from 'fp-ts/string'
 * import { pipe } from 'fp-ts/function'
 *
 * assert.deepStrictEqual(pipe('abc', S.startsWith('a')), true)
 * assert.deepStrictEqual(pipe('bc', S.startsWith('a')), false)
 *
 * @since 2.11.0
 */
var startsWith = function (searchString, position) {
    return function (s) {
        return s.startsWith(searchString, position);
    };
};
/**
 * @example
 * import * as S from 'fp-ts/string'
 * import { pipe } from 'fp-ts/function'
 *
 * assert.deepStrictEqual(pipe('abc', S.endsWith('c')), true)
 * assert.deepStrictEqual(pipe('ab', S.endsWith('c')), false)
 *
 * @since 2.11.0
 */
var endsWith = function (searchString, position) {
    return function (s) {
        return s.endsWith(searchString, position);
    };
};


/***/ }),

/***/ "./node_modules/fp-ts/lib/Chain.js":
/*!*****************************************!*\
  !*** ./node_modules/fp-ts/lib/Chain.js ***!
  \*****************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.chainFirst = chainFirst;
exports.tap = tap;
exports.bind = bind;
function chainFirst(M) {
    var tapM = tap(M);
    return function (f) { return function (first) { return tapM(first, f); }; };
}
/** @internal */
function tap(M) {
    return function (first, f) { return M.chain(first, function (a) { return M.map(f(a), function () { return a; }); }); };
}
function bind(M) {
    return function (name, f) { return function (ma) { return M.chain(ma, function (a) { return M.map(f(a), function (b) {
        var _a;
        return Object.assign({}, a, (_a = {}, _a[name] = b, _a));
    }); }); }; };
}


/***/ }),

/***/ "./node_modules/fp-ts/lib/Eq.js":
/*!**************************************!*\
  !*** ./node_modules/fp-ts/lib/Eq.js ***!
  \**************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.eqDate = exports.eqNumber = exports.eqString = exports.eqBoolean = exports.eq = exports.strictEqual = exports.getStructEq = exports.getTupleEq = exports.Contravariant = exports.getMonoid = exports.getSemigroup = exports.eqStrict = exports.URI = exports.contramap = exports.tuple = exports.struct = exports.fromEquals = void 0;
var function_1 = __webpack_require__(/*! ./function */ "./node_modules/fp-ts/lib/function.js");
// -------------------------------------------------------------------------------------
// constructors
// -------------------------------------------------------------------------------------
/**
 * @category constructors
 * @since 2.0.0
 */
var fromEquals = function (equals) { return ({
    equals: function (x, y) { return x === y || equals(x, y); }
}); };
exports.fromEquals = fromEquals;
// -------------------------------------------------------------------------------------
// combinators
// -------------------------------------------------------------------------------------
/**
 * @since 2.10.0
 */
var struct = function (eqs) {
    return (0, exports.fromEquals)(function (first, second) {
        for (var key in eqs) {
            if (!eqs[key].equals(first[key], second[key])) {
                return false;
            }
        }
        return true;
    });
};
exports.struct = struct;
/**
 * Given a tuple of `Eq`s returns a `Eq` for the tuple
 *
 * @example
 * import { tuple } from 'fp-ts/Eq'
 * import * as S from 'fp-ts/string'
 * import * as N from 'fp-ts/number'
 * import * as B from 'fp-ts/boolean'
 *
 * const E = tuple(S.Eq, N.Eq, B.Eq)
 * assert.strictEqual(E.equals(['a', 1, true], ['a', 1, true]), true)
 * assert.strictEqual(E.equals(['a', 1, true], ['b', 1, true]), false)
 * assert.strictEqual(E.equals(['a', 1, true], ['a', 2, true]), false)
 * assert.strictEqual(E.equals(['a', 1, true], ['a', 1, false]), false)
 *
 * @since 2.10.0
 */
var tuple = function () {
    var eqs = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        eqs[_i] = arguments[_i];
    }
    return (0, exports.fromEquals)(function (first, second) { return eqs.every(function (E, i) { return E.equals(first[i], second[i]); }); });
};
exports.tuple = tuple;
/* istanbul ignore next */
var contramap_ = function (fa, f) { return (0, function_1.pipe)(fa, (0, exports.contramap)(f)); };
/**
 * A typical use case for `contramap` would be like, given some `User` type, to construct an `Eq<User>`.
 *
 * We can do so with a function from `User -> X` where `X` is some value that we know how to compare
 * for equality (meaning we have an `Eq<X>`)
 *
 * For example, given the following `User` type, we want to construct an `Eq<User>` that just looks at the `key` field
 * for each user (since it's known to be unique).
 *
 * If we have a way of comparing `UUID`s for equality (`eqUUID: Eq<UUID>`) and we know how to go from `User -> UUID`,
 * using `contramap` we can do this
 *
 * @example
 * import { contramap, Eq } from 'fp-ts/Eq'
 * import { pipe } from 'fp-ts/function'
 * import * as S from 'fp-ts/string'
 *
 * type UUID = string
 *
 * interface User {
 *   readonly key: UUID
 *   readonly firstName: string
 *   readonly lastName: string
 * }
 *
 * const eqUUID: Eq<UUID> = S.Eq
 *
 * const eqUserByKey: Eq<User> = pipe(
 *   eqUUID,
 *   contramap((user) => user.key)
 * )
 *
 * assert.deepStrictEqual(
 *   eqUserByKey.equals(
 *     { key: 'k1', firstName: 'a1', lastName: 'b1' },
 *     { key: 'k2', firstName: 'a1', lastName: 'b1' }
 *   ),
 *   false
 * )
 * assert.deepStrictEqual(
 *   eqUserByKey.equals(
 *     { key: 'k1', firstName: 'a1', lastName: 'b1' },
 *     { key: 'k1', firstName: 'a2', lastName: 'b1' }
 *   ),
 *   true
 * )
 *
 * @since 2.0.0
 */
var contramap = function (f) { return function (fa) {
    return (0, exports.fromEquals)(function (x, y) { return fa.equals(f(x), f(y)); });
}; };
exports.contramap = contramap;
/**
 * @category type lambdas
 * @since 2.0.0
 */
exports.URI = 'Eq';
/**
 * @category instances
 * @since 2.5.0
 */
exports.eqStrict = {
    equals: function (a, b) { return a === b; }
};
var empty = {
    equals: function () { return true; }
};
/**
 * @category instances
 * @since 2.10.0
 */
var getSemigroup = function () { return ({
    concat: function (x, y) { return (0, exports.fromEquals)(function (a, b) { return x.equals(a, b) && y.equals(a, b); }); }
}); };
exports.getSemigroup = getSemigroup;
/**
 * @category instances
 * @since 2.6.0
 */
var getMonoid = function () { return ({
    concat: (0, exports.getSemigroup)().concat,
    empty: empty
}); };
exports.getMonoid = getMonoid;
/**
 * @category instances
 * @since 2.7.0
 */
exports.Contravariant = {
    URI: exports.URI,
    contramap: contramap_
};
// -------------------------------------------------------------------------------------
// deprecated
// -------------------------------------------------------------------------------------
/**
 * Use [`tuple`](#tuple) instead.
 *
 * @category zone of death
 * @since 2.0.0
 * @deprecated
 */
exports.getTupleEq = exports.tuple;
/**
 * Use [`struct`](#struct) instead.
 *
 * @category zone of death
 * @since 2.0.0
 * @deprecated
 */
exports.getStructEq = exports.struct;
/**
 * Use [`eqStrict`](#eqstrict) instead
 *
 * @category zone of death
 * @since 2.0.0
 * @deprecated
 */
exports.strictEqual = exports.eqStrict.equals;
/**
 * This instance is deprecated, use small, specific instances instead.
 * For example if a function needs a `Contravariant` instance, pass `E.Contravariant` instead of `E.eq`
 * (where `E` is from `import E from 'fp-ts/Eq'`)
 *
 * @category zone of death
 * @since 2.0.0
 * @deprecated
 */
exports.eq = exports.Contravariant;
/**
 * Use [`Eq`](./boolean.ts.html#eq) instead.
 *
 * @category zone of death
 * @since 2.0.0
 * @deprecated
 */
exports.eqBoolean = exports.eqStrict;
/**
 * Use [`Eq`](./string.ts.html#eq) instead.
 *
 * @category zone of death
 * @since 2.0.0
 * @deprecated
 */
exports.eqString = exports.eqStrict;
/**
 * Use [`Eq`](./number.ts.html#eq) instead.
 *
 * @category zone of death
 * @since 2.0.0
 * @deprecated
 */
exports.eqNumber = exports.eqStrict;
/**
 * Use [`Eq`](./Date.ts.html#eq) instead.
 *
 * @category zone of death
 * @since 2.0.0
 * @deprecated
 */
exports.eqDate = {
    equals: function (first, second) { return first.valueOf() === second.valueOf(); }
};


/***/ }),

/***/ "./node_modules/fp-ts/lib/FromEither.js":
/*!**********************************************!*\
  !*** ./node_modules/fp-ts/lib/FromEither.js ***!
  \**********************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

/**
 * The `FromEither` type class represents those data types which support errors.
 *
 * @since 2.10.0
 */
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.fromOption = fromOption;
exports.fromPredicate = fromPredicate;
exports.fromOptionK = fromOptionK;
exports.chainOptionK = chainOptionK;
exports.fromEitherK = fromEitherK;
exports.chainEitherK = chainEitherK;
exports.chainFirstEitherK = chainFirstEitherK;
exports.filterOrElse = filterOrElse;
exports.tapEither = tapEither;
var Chain_1 = __webpack_require__(/*! ./Chain */ "./node_modules/fp-ts/lib/Chain.js");
var function_1 = __webpack_require__(/*! ./function */ "./node_modules/fp-ts/lib/function.js");
var _ = __importStar(__webpack_require__(/*! ./internal */ "./node_modules/fp-ts/lib/internal.js"));
function fromOption(F) {
    return function (onNone) { return function (ma) { return F.fromEither(_.isNone(ma) ? _.left(onNone()) : _.right(ma.value)); }; };
}
function fromPredicate(F) {
    return function (predicate, onFalse) {
        return function (a) {
            return F.fromEither(predicate(a) ? _.right(a) : _.left(onFalse(a)));
        };
    };
}
function fromOptionK(F) {
    var fromOptionF = fromOption(F);
    return function (onNone) {
        var from = fromOptionF(onNone);
        return function (f) { return (0, function_1.flow)(f, from); };
    };
}
function chainOptionK(F, M) {
    var fromOptionKF = fromOptionK(F);
    return function (onNone) {
        var from = fromOptionKF(onNone);
        return function (f) { return function (ma) { return M.chain(ma, from(f)); }; };
    };
}
function fromEitherK(F) {
    return function (f) { return (0, function_1.flow)(f, F.fromEither); };
}
function chainEitherK(F, M) {
    var fromEitherKF = fromEitherK(F);
    return function (f) { return function (ma) { return M.chain(ma, fromEitherKF(f)); }; };
}
function chainFirstEitherK(F, M) {
    var tapEitherM = tapEither(F, M);
    return function (f) { return function (ma) { return tapEitherM(ma, f); }; };
}
function filterOrElse(F, M) {
    return function (predicate, onFalse) {
        return function (ma) {
            return M.chain(ma, function (a) { return F.fromEither(predicate(a) ? _.right(a) : _.left(onFalse(a))); });
        };
    };
}
/** @internal */
function tapEither(F, M) {
    var fromEither = fromEitherK(F);
    var tapM = (0, Chain_1.tap)(M);
    return function (self, f) { return tapM(self, fromEither(f)); };
}


/***/ }),

/***/ "./node_modules/fp-ts/lib/Functor.js":
/*!*******************************************!*\
  !*** ./node_modules/fp-ts/lib/Functor.js ***!
  \*******************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.map = map;
exports.flap = flap;
exports.bindTo = bindTo;
exports["let"] = let_;
exports.getFunctorComposition = getFunctorComposition;
exports.as = as;
exports.asUnit = asUnit;
/**
 * A `Functor` is a type constructor which supports a mapping operation `map`.
 *
 * `map` can be used to turn functions `a -> b` into functions `f a -> f b` whose argument and return types use the type
 * constructor `f` to represent some computational context.
 *
 * Instances must satisfy the following laws:
 *
 * 1. Identity: `F.map(fa, a => a) <-> fa`
 * 2. Composition: `F.map(fa, a => bc(ab(a))) <-> F.map(F.map(fa, ab), bc)`
 *
 * @since 2.0.0
 */
var function_1 = __webpack_require__(/*! ./function */ "./node_modules/fp-ts/lib/function.js");
function map(F, G) {
    return function (f) { return function (fa) { return F.map(fa, function (ga) { return G.map(ga, f); }); }; };
}
function flap(F) {
    return function (a) { return function (fab) { return F.map(fab, function (f) { return f(a); }); }; };
}
function bindTo(F) {
    return function (name) { return function (fa) { return F.map(fa, function (a) {
        var _a;
        return (_a = {}, _a[name] = a, _a);
    }); }; };
}
function let_(F) {
    return function (name, f) { return function (fa) { return F.map(fa, function (a) {
        var _a;
        return Object.assign({}, a, (_a = {}, _a[name] = f(a), _a));
    }); }; };
}
/** @deprecated */
function getFunctorComposition(F, G) {
    var _map = map(F, G);
    return {
        map: function (fga, f) { return (0, function_1.pipe)(fga, _map(f)); }
    };
}
/** @internal */
function as(F) {
    return function (self, b) { return F.map(self, function () { return b; }); };
}
/** @internal */
function asUnit(F) {
    var asM = as(F);
    return function (self) { return asM(self, undefined); };
}


/***/ }),

/***/ "./node_modules/fp-ts/lib/These.js":
/*!*****************************************!*\
  !*** ./node_modules/fp-ts/lib/These.js ***!
  \*****************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.these = exports.traverseReadonlyArrayWithIndex = exports.traverseReadonlyNonEmptyArrayWithIndex = exports.ApT = exports.toTuple = exports.toTuple2 = exports.exists = exports.elem = exports.fromOptionK = exports.fromOption = exports.fromPredicate = exports.FromEither = exports.Traversable = exports.Foldable = exports.FromThese = exports.Bifunctor = exports.Pointed = exports.flap = exports.Functor = exports.URI = exports.of = exports.sequence = exports.traverse = exports.reduceRight = exports.foldMap = exports.reduce = exports.map = exports.mapLeft = exports.bimap = exports.fromOptions = exports.getApply = exports.swap = exports.fold = exports.match = exports.foldW = exports.matchW = exports.isRight = exports.isLeft = void 0;
exports.isBoth = isBoth;
exports.left = left;
exports.right = right;
exports.both = both;
exports.getShow = getShow;
exports.getEq = getEq;
exports.getSemigroup = getSemigroup;
exports.getApplicative = getApplicative;
exports.getChain = getChain;
exports.getMonad = getMonad;
exports.getLeft = getLeft;
exports.getRight = getRight;
exports.leftOrBoth = leftOrBoth;
exports.rightOrBoth = rightOrBoth;
exports.getLeftOnly = getLeftOnly;
exports.getRightOnly = getRightOnly;
var Eq_1 = __webpack_require__(/*! ./Eq */ "./node_modules/fp-ts/lib/Eq.js");
var FromEither_1 = __webpack_require__(/*! ./FromEither */ "./node_modules/fp-ts/lib/FromEither.js");
var function_1 = __webpack_require__(/*! ./function */ "./node_modules/fp-ts/lib/function.js");
var Functor_1 = __webpack_require__(/*! ./Functor */ "./node_modules/fp-ts/lib/Functor.js");
var _ = __importStar(__webpack_require__(/*! ./internal */ "./node_modules/fp-ts/lib/internal.js"));
// -------------------------------------------------------------------------------------
// refinements
// -------------------------------------------------------------------------------------
/**
 * Returns `true` if the these is an instance of `Left`, `false` otherwise
 *
 * @category refinements
 * @since 2.0.0
 */
var isLeft = function (fa) { return fa._tag === 'Left'; };
exports.isLeft = isLeft;
/**
 * Returns `true` if the these is an instance of `Right`, `false` otherwise
 *
 * @category refinements
 * @since 2.0.0
 */
var isRight = function (fa) { return fa._tag === 'Right'; };
exports.isRight = isRight;
/**
 * Returns `true` if the these is an instance of `Both`, `false` otherwise
 *
 * @category refinements
 * @since 2.0.0
 */
function isBoth(fa) {
    return fa._tag === 'Both';
}
// -------------------------------------------------------------------------------------
// constructors
// -------------------------------------------------------------------------------------
/**
 * @category constructors
 * @since 2.0.0
 */
function left(left) {
    return { _tag: 'Left', left: left };
}
/**
 * @category constructors
 * @since 2.0.0
 */
function right(right) {
    return { _tag: 'Right', right: right };
}
/**
 * @category constructors
 * @since 2.0.0
 */
function both(left, right) {
    return { _tag: 'Both', left: left, right: right };
}
/**
 * Less strict version of [`match`](#match).
 *
 * The `W` suffix (short for **W**idening) means that the handler return types will be merged.
 *
 * @category pattern matching
 * @since 2.10.0
 */
var matchW = function (onLeft, onRight, onBoth) {
    return function (fa) {
        switch (fa._tag) {
            case 'Left':
                return onLeft(fa.left);
            case 'Right':
                return onRight(fa.right);
            case 'Both':
                return onBoth(fa.left, fa.right);
        }
    };
};
exports.matchW = matchW;
/**
 * Alias of [`matchW`](#matchw).
 *
 * @category pattern matching
 * @since 2.10.0
 */
exports.foldW = exports.matchW;
/**
 * @category pattern matching
 * @since 2.10.0
 */
exports.match = exports.matchW;
/**
 * Alias of [`match`](#match).
 *
 * @category pattern matching
 * @since 2.0.0
 */
exports.fold = exports.match;
/**
 * @since 2.4.0
 */
exports.swap = (0, exports.match)(right, left, function (e, a) { return both(a, e); });
/**
 * @category instances
 * @since 2.0.0
 */
function getShow(SE, SA) {
    return {
        show: (0, exports.match)(function (l) { return "left(".concat(SE.show(l), ")"); }, function (a) { return "right(".concat(SA.show(a), ")"); }, function (l, a) { return "both(".concat(SE.show(l), ", ").concat(SA.show(a), ")"); })
    };
}
/**
 * @category instances
 * @since 2.0.0
 */
function getEq(EE, EA) {
    return (0, Eq_1.fromEquals)(function (x, y) {
        return (0, exports.isLeft)(x)
            ? (0, exports.isLeft)(y) && EE.equals(x.left, y.left)
            : (0, exports.isRight)(x)
                ? (0, exports.isRight)(y) && EA.equals(x.right, y.right)
                : isBoth(y) && EE.equals(x.left, y.left) && EA.equals(x.right, y.right);
    });
}
/**
 * @category instances
 * @since 2.0.0
 */
function getSemigroup(SE, SA) {
    return {
        concat: function (x, y) {
            return (0, exports.isLeft)(x)
                ? (0, exports.isLeft)(y)
                    ? left(SE.concat(x.left, y.left))
                    : (0, exports.isRight)(y)
                        ? both(x.left, y.right)
                        : both(SE.concat(x.left, y.left), y.right)
                : (0, exports.isRight)(x)
                    ? (0, exports.isLeft)(y)
                        ? both(y.left, x.right)
                        : (0, exports.isRight)(y)
                            ? right(SA.concat(x.right, y.right))
                            : both(y.left, SA.concat(x.right, y.right))
                    : (0, exports.isLeft)(y)
                        ? both(SE.concat(x.left, y.left), x.right)
                        : (0, exports.isRight)(y)
                            ? both(x.left, SA.concat(x.right, y.right))
                            : both(SE.concat(x.left, y.left), SA.concat(x.right, y.right));
        }
    };
}
/**
 * @category instances
 * @since 2.10.0
 */
var getApply = function (S) { return ({
    URI: exports.URI,
    _E: undefined,
    map: _map,
    ap: function (fab, fa) {
        return (0, exports.isLeft)(fab)
            ? (0, exports.isLeft)(fa)
                ? left(S.concat(fab.left, fa.left))
                : (0, exports.isRight)(fa)
                    ? left(fab.left)
                    : left(S.concat(fab.left, fa.left))
            : (0, exports.isRight)(fab)
                ? (0, exports.isLeft)(fa)
                    ? left(fa.left)
                    : (0, exports.isRight)(fa)
                        ? right(fab.right(fa.right))
                        : both(fa.left, fab.right(fa.right))
                : (0, exports.isLeft)(fa)
                    ? left(S.concat(fab.left, fa.left))
                    : (0, exports.isRight)(fa)
                        ? both(fab.left, fab.right(fa.right))
                        : both(S.concat(fab.left, fa.left), fab.right(fa.right));
    }
}); };
exports.getApply = getApply;
/**
 * @category instances
 * @since 2.7.0
 */
function getApplicative(S) {
    var A = (0, exports.getApply)(S);
    return {
        URI: exports.URI,
        _E: undefined,
        map: _map,
        ap: A.ap,
        of: exports.of
    };
}
/**
 * @category instances
 * @since 2.10.0
 */
function getChain(S) {
    var A = (0, exports.getApply)(S);
    var chain = function (ma, f) {
        if ((0, exports.isLeft)(ma)) {
            return ma;
        }
        if ((0, exports.isRight)(ma)) {
            return f(ma.right);
        }
        var fb = f(ma.right);
        return (0, exports.isLeft)(fb)
            ? left(S.concat(ma.left, fb.left))
            : (0, exports.isRight)(fb)
                ? both(ma.left, fb.right)
                : both(S.concat(ma.left, fb.left), fb.right);
    };
    return {
        URI: exports.URI,
        _E: undefined,
        map: _map,
        ap: A.ap,
        chain: chain
    };
}
/**
 * @category instances
 * @since 2.0.0
 */
function getMonad(S) {
    var C = getChain(S);
    return {
        URI: exports.URI,
        _E: undefined,
        map: _map,
        of: exports.of,
        ap: C.ap,
        chain: C.chain,
        throwError: left
    };
}
/**
 * Returns an `E` value if possible
 *
 * @example
 * import { getLeft, left, right, both } from 'fp-ts/These'
 * import { none, some } from 'fp-ts/Option'
 *
 * assert.deepStrictEqual(getLeft(left('a')), some('a'))
 * assert.deepStrictEqual(getLeft(right(1)), none)
 * assert.deepStrictEqual(getLeft(both('a', 1)), some('a'))
 *
 * @category conversions
 * @since 2.0.0
 */
function getLeft(fa) {
    return (0, exports.isLeft)(fa) ? _.some(fa.left) : (0, exports.isRight)(fa) ? _.none : _.some(fa.left);
}
/**
 * Returns an `A` value if possible
 *
 * @example
 * import { getRight, left, right, both } from 'fp-ts/These'
 * import { none, some } from 'fp-ts/Option'
 *
 * assert.deepStrictEqual(getRight(left('a')), none)
 * assert.deepStrictEqual(getRight(right(1)), some(1))
 * assert.deepStrictEqual(getRight(both('a', 1)), some(1))
 *
 * @category conversions
 * @since 2.0.0
 */
function getRight(fa) {
    return (0, exports.isLeft)(fa) ? _.none : (0, exports.isRight)(fa) ? _.some(fa.right) : _.some(fa.right);
}
// TODO: make lazy in v3
/**
 * @example
 * import { leftOrBoth, left, both } from 'fp-ts/These'
 * import { none, some } from 'fp-ts/Option'
 *
 * assert.deepStrictEqual(leftOrBoth('a')(none), left('a'))
 * assert.deepStrictEqual(leftOrBoth('a')(some(1)), both('a', 1))
 *
 * @category constructors
 * @since 2.0.0
 */
function leftOrBoth(e) {
    return function (ma) { return (_.isNone(ma) ? left(e) : both(e, ma.value)); };
}
// TODO: make lazy in v3
/**
 * @example
 * import { rightOrBoth, right, both } from 'fp-ts/These'
 * import { none, some } from 'fp-ts/Option'
 *
 * assert.deepStrictEqual(rightOrBoth(1)(none), right(1))
 * assert.deepStrictEqual(rightOrBoth(1)(some('a')), both('a', 1))
 *
 * @category constructors
 * @since 2.0.0
 */
function rightOrBoth(a) {
    return function (me) { return (_.isNone(me) ? right(a) : both(me.value, a)); };
}
/**
 * Returns the `E` value if and only if the value is constructed with `Left`
 *
 * @example
 * import { getLeftOnly, left, right, both } from 'fp-ts/These'
 * import { none, some } from 'fp-ts/Option'
 *
 * assert.deepStrictEqual(getLeftOnly(left('a')), some('a'))
 * assert.deepStrictEqual(getLeftOnly(right(1)), none)
 * assert.deepStrictEqual(getLeftOnly(both('a', 1)), none)
 *
 * @category conversions
 * @since 2.0.0
 */
function getLeftOnly(fa) {
    return (0, exports.isLeft)(fa) ? _.some(fa.left) : _.none;
}
/**
 * Returns the `A` value if and only if the value is constructed with `Right`
 *
 * @example
 * import { getRightOnly, left, right, both } from 'fp-ts/These'
 * import { none, some } from 'fp-ts/Option'
 *
 * assert.deepStrictEqual(getRightOnly(left('a')), none)
 * assert.deepStrictEqual(getRightOnly(right(1)), some(1))
 * assert.deepStrictEqual(getRightOnly(both('a', 1)), none)
 *
 * @category conversions
 * @since 2.0.0
 */
function getRightOnly(fa) {
    return (0, exports.isRight)(fa) ? _.some(fa.right) : _.none;
}
/**
 * Takes a pair of `Option`s and attempts to create a `These` from them
 *
 * @example
 * import { fromOptions, left, right, both } from 'fp-ts/These'
 * import { none, some } from 'fp-ts/Option'
 *
 * assert.deepStrictEqual(fromOptions(none, none), none)
 * assert.deepStrictEqual(fromOptions(some('a'), none), some(left('a')))
 * assert.deepStrictEqual(fromOptions(none, some(1)), some(right(1)))
 * assert.deepStrictEqual(fromOptions(some('a'), some(1)), some(both('a', 1)))
 *
 * @category conversions
 * @since 2.0.0
 */
var fromOptions = function (fe, fa) {
    return _.isNone(fe)
        ? _.isNone(fa)
            ? _.none
            : _.some(right(fa.value))
        : _.isNone(fa)
            ? _.some(left(fe.value))
            : _.some(both(fe.value, fa.value));
};
exports.fromOptions = fromOptions;
var _map = function (fa, f) { return (0, function_1.pipe)(fa, (0, exports.map)(f)); };
/* istanbul ignore next */
var _bimap = function (fa, f, g) { return (0, function_1.pipe)(fa, (0, exports.bimap)(f, g)); };
/* istanbul ignore next */
var _mapLeft = function (fa, f) { return (0, function_1.pipe)(fa, (0, exports.mapLeft)(f)); };
/* istanbul ignore next */
var _reduce = function (fa, b, f) { return (0, function_1.pipe)(fa, (0, exports.reduce)(b, f)); };
/* istanbul ignore next */
var _foldMap = function (M) {
    var foldMapM = (0, exports.foldMap)(M);
    return function (fa, f) { return (0, function_1.pipe)(fa, foldMapM(f)); };
};
/* istanbul ignore next */
var _reduceRight = function (fa, b, f) { return (0, function_1.pipe)(fa, (0, exports.reduceRight)(b, f)); };
/* istanbul ignore next */
var _traverse = function (F) {
    var traverseF = (0, exports.traverse)(F);
    return function (ta, f) { return (0, function_1.pipe)(ta, traverseF(f)); };
};
/**
 * Map a pair of functions over the two type arguments of the bifunctor.
 *
 * @category mapping
 * @since 2.0.0
 */
var bimap = function (f, g) { return function (fa) {
    return (0, exports.isLeft)(fa) ? left(f(fa.left)) : (0, exports.isRight)(fa) ? right(g(fa.right)) : both(f(fa.left), g(fa.right));
}; };
exports.bimap = bimap;
/**
 * Map a function over the first type argument of a bifunctor.
 *
 * @category error handling
 * @since 2.0.0
 */
var mapLeft = function (f) { return function (fa) {
    return (0, exports.isLeft)(fa) ? left(f(fa.left)) : isBoth(fa) ? both(f(fa.left), fa.right) : fa;
}; };
exports.mapLeft = mapLeft;
/**
 * `map` can be used to turn functions `(a: A) => B` into functions `(fa: F<A>) => F<B>` whose argument and return types
 * use the type constructor `F` to represent some computational context.
 *
 * @category mapping
 * @since 2.0.0
 */
var map = function (f) { return function (fa) {
    return (0, exports.isLeft)(fa) ? fa : (0, exports.isRight)(fa) ? right(f(fa.right)) : both(fa.left, f(fa.right));
}; };
exports.map = map;
/**
 * @category folding
 * @since 2.0.0
 */
var reduce = function (b, f) { return function (fa) {
    return (0, exports.isLeft)(fa) ? b : f(b, fa.right);
}; };
exports.reduce = reduce;
/**
 * @category folding
 * @since 2.0.0
 */
var foldMap = function (M) { return function (f) { return function (fa) {
    return (0, exports.isLeft)(fa) ? M.empty : f(fa.right);
}; }; };
exports.foldMap = foldMap;
/**
 * @category folding
 * @since 2.0.0
 */
var reduceRight = function (b, f) { return function (fa) {
    return (0, exports.isLeft)(fa) ? b : f(fa.right, b);
}; };
exports.reduceRight = reduceRight;
/**
 * @category traversing
 * @since 2.6.3
 */
var traverse = function (F) {
    return function (f) {
        return function (ta) {
            return (0, exports.isLeft)(ta) ? F.of(ta) : (0, exports.isRight)(ta) ? F.map(f(ta.right), right) : F.map(f(ta.right), function (b) { return both(ta.left, b); });
        };
    };
};
exports.traverse = traverse;
/**
 * @category traversing
 * @since 2.6.3
 */
var sequence = function (F) {
    return function (ta) {
        return (0, exports.isLeft)(ta) ? F.of(ta) : (0, exports.isRight)(ta) ? F.map(ta.right, right) : F.map(ta.right, function (b) { return both(ta.left, b); });
    };
};
exports.sequence = sequence;
/**
 * @category constructors
 * @since 2.0.0
 */
exports.of = right;
/**
 * @category type lambdas
 * @since 2.0.0
 */
exports.URI = 'These';
/**
 * @category instances
 * @since 2.7.0
 */
exports.Functor = {
    URI: exports.URI,
    map: _map
};
/**
 * @category mapping
 * @since 2.10.0
 */
exports.flap = (0, Functor_1.flap)(exports.Functor);
/**
 * @category instances
 * @since 2.10.0
 */
exports.Pointed = {
    URI: exports.URI,
    of: exports.of
};
/**
 * @category instances
 * @since 2.7.0
 */
exports.Bifunctor = {
    URI: exports.URI,
    bimap: _bimap,
    mapLeft: _mapLeft
};
/**
 * @category instances
 * @since 2.11.0
 */
exports.FromThese = {
    URI: exports.URI,
    fromThese: function_1.identity
};
/**
 * @category instances
 * @since 2.7.0
 */
exports.Foldable = {
    URI: exports.URI,
    reduce: _reduce,
    foldMap: _foldMap,
    reduceRight: _reduceRight
};
/**
 * @category instances
 * @since 2.7.0
 */
exports.Traversable = {
    URI: exports.URI,
    map: _map,
    reduce: _reduce,
    foldMap: _foldMap,
    reduceRight: _reduceRight,
    traverse: _traverse,
    sequence: exports.sequence
};
/**
 * @category instances
 * @since 2.10.0
 */
exports.FromEither = {
    URI: exports.URI,
    fromEither: function_1.identity
};
/**
 * @category lifting
 * @since 2.13.0
 */
exports.fromPredicate = (0, FromEither_1.fromPredicate)(exports.FromEither);
/**
 * @category conversions
 * @since 2.10.0
 */
exports.fromOption = 
/*#__PURE__*/ (0, FromEither_1.fromOption)(exports.FromEither);
/**
 * @category lifting
 * @since 2.10.0
 */
exports.fromOptionK = 
/*#__PURE__*/ (0, FromEither_1.fromOptionK)(exports.FromEither);
// -------------------------------------------------------------------------------------
// utils
// -------------------------------------------------------------------------------------
/**
 * @since 2.11.0
 */
var elem = function (E) {
    return function (a) {
        return function (ma) {
            return (0, exports.isLeft)(ma) ? false : E.equals(a, ma.right);
        };
    };
};
exports.elem = elem;
/**
 * @since 2.11.0
 */
var exists = function (predicate) {
    return function (ma) {
        return (0, exports.isLeft)(ma) ? false : predicate(ma.right);
    };
};
exports.exists = exists;
/**
 * @example
 * import { toTuple2, left, right, both } from 'fp-ts/These'
 *
 * assert.deepStrictEqual(toTuple2(() => 'a', () => 1)(left('b')), ['b', 1])
 * assert.deepStrictEqual(toTuple2(() => 'a', () => 1)(right(2)), ['a', 2])
 * assert.deepStrictEqual(toTuple2(() => 'a', () => 1)(both('b', 2)), ['b', 2])
 *
 * @category conversions
 * @since 2.10.0
 */
var toTuple2 = function (e, a) {
    return function (fa) {
        return (0, exports.isLeft)(fa) ? [fa.left, a()] : (0, exports.isRight)(fa) ? [e(), fa.right] : [fa.left, fa.right];
    };
};
exports.toTuple2 = toTuple2;
// -------------------------------------------------------------------------------------
// deprecated
// -------------------------------------------------------------------------------------
/**
 * Use [`toTuple2`](#totuple2) instead.
 *
 * @category zone of death
 * @since 2.0.0
 * @deprecated
 */
var toTuple = function (e, a) {
    return (0, exports.toTuple2)(function () { return e; }, function () { return a; });
};
exports.toTuple = toTuple;
/**
 * @since 2.11.0
 */
exports.ApT = (0, exports.of)(_.emptyReadonlyArray);
// -------------------------------------------------------------------------------------
// array utils
// -------------------------------------------------------------------------------------
/**
 * Equivalent to `ReadonlyNonEmptyArray#traverseWithIndex(getApplicative(S))`.
 *
 * @category traversing
 * @since 2.11.0
 */
var traverseReadonlyNonEmptyArrayWithIndex = function (S) {
    return function (f) {
        return function (as) {
            var e = _.none;
            var t = f(0, _.head(as));
            if ((0, exports.isLeft)(t)) {
                return t;
            }
            if (isBoth(t)) {
                e = _.some(t.left);
            }
            var out = [t.right];
            for (var i = 1; i < as.length; i++) {
                var t_1 = f(i, as[i]);
                if ((0, exports.isLeft)(t_1)) {
                    return t_1;
                }
                if (isBoth(t_1)) {
                    e = _.isNone(e) ? _.some(t_1.left) : _.some(S.concat(e.value, t_1.left));
                }
                out.push(t_1.right);
            }
            return _.isNone(e) ? right(out) : both(e.value, out);
        };
    };
};
exports.traverseReadonlyNonEmptyArrayWithIndex = traverseReadonlyNonEmptyArrayWithIndex;
/**
 * Equivalent to `ReadonlyArray#traverseWithIndex(getApplicative(S))`.
 *
 * @category traversing
 * @since 2.11.0
 */
var traverseReadonlyArrayWithIndex = function (S) {
    return function (f) {
        var g = (0, exports.traverseReadonlyNonEmptyArrayWithIndex)(S)(f);
        return function (as) { return (_.isNonEmpty(as) ? g(as) : exports.ApT); };
    };
};
exports.traverseReadonlyArrayWithIndex = traverseReadonlyArrayWithIndex;
// -------------------------------------------------------------------------------------
// deprecated
// -------------------------------------------------------------------------------------
/**
 * This instance is deprecated, use small, specific instances instead.
 * For example if a function needs a `Functor` instance, pass `T.Functor` instead of `T.these`
 * (where `T` is from `import T from 'fp-ts/These'`)
 *
 * @category zone of death
 * @since 2.0.0
 * @deprecated
 */
exports.these = {
    URI: exports.URI,
    map: _map,
    bimap: _bimap,
    mapLeft: _mapLeft,
    reduce: _reduce,
    foldMap: _foldMap,
    reduceRight: _reduceRight,
    traverse: _traverse,
    sequence: exports.sequence
};


/***/ }),

/***/ "./node_modules/fp-ts/lib/function.js":
/*!********************************************!*\
  !*** ./node_modules/fp-ts/lib/function.js ***!
  \********************************************/
/***/ (function(__unused_webpack_module, exports) {

"use strict";

var __spreadArray = (this && this.__spreadArray) || function (to, from, pack) {
    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
        }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.dual = exports.getEndomorphismMonoid = exports.SK = exports.hole = exports.constVoid = exports.constUndefined = exports.constNull = exports.constFalse = exports.constTrue = exports.unsafeCoerce = exports.apply = exports.getRing = exports.getSemiring = exports.getMonoid = exports.getSemigroup = exports.getBooleanAlgebra = void 0;
exports.identity = identity;
exports.constant = constant;
exports.flip = flip;
exports.flow = flow;
exports.tuple = tuple;
exports.increment = increment;
exports.decrement = decrement;
exports.absurd = absurd;
exports.tupled = tupled;
exports.untupled = untupled;
exports.pipe = pipe;
exports.not = not;
// -------------------------------------------------------------------------------------
// instances
// -------------------------------------------------------------------------------------
/**
 * @category instances
 * @since 2.10.0
 */
var getBooleanAlgebra = function (B) {
    return function () { return ({
        meet: function (x, y) { return function (a) { return B.meet(x(a), y(a)); }; },
        join: function (x, y) { return function (a) { return B.join(x(a), y(a)); }; },
        zero: function () { return B.zero; },
        one: function () { return B.one; },
        implies: function (x, y) { return function (a) { return B.implies(x(a), y(a)); }; },
        not: function (x) { return function (a) { return B.not(x(a)); }; }
    }); };
};
exports.getBooleanAlgebra = getBooleanAlgebra;
/**
 * Unary functions form a semigroup as long as you can provide a semigroup for the codomain.
 *
 * @example
 * import { Predicate, getSemigroup } from 'fp-ts/function'
 * import * as B from 'fp-ts/boolean'
 *
 * const f: Predicate<number> = (n) => n <= 2
 * const g: Predicate<number> = (n) => n >= 0
 *
 * const S1 = getSemigroup(B.SemigroupAll)<number>()
 *
 * assert.deepStrictEqual(S1.concat(f, g)(1), true)
 * assert.deepStrictEqual(S1.concat(f, g)(3), false)
 *
 * const S2 = getSemigroup(B.SemigroupAny)<number>()
 *
 * assert.deepStrictEqual(S2.concat(f, g)(1), true)
 * assert.deepStrictEqual(S2.concat(f, g)(3), true)
 *
 * @category instances
 * @since 2.10.0
 */
var getSemigroup = function (S) {
    return function () { return ({
        concat: function (f, g) { return function (a) { return S.concat(f(a), g(a)); }; }
    }); };
};
exports.getSemigroup = getSemigroup;
/**
 * Unary functions form a monoid as long as you can provide a monoid for the codomain.
 *
 * @example
 * import { Predicate } from 'fp-ts/Predicate'
 * import { getMonoid } from 'fp-ts/function'
 * import * as B from 'fp-ts/boolean'
 *
 * const f: Predicate<number> = (n) => n <= 2
 * const g: Predicate<number> = (n) => n >= 0
 *
 * const M1 = getMonoid(B.MonoidAll)<number>()
 *
 * assert.deepStrictEqual(M1.concat(f, g)(1), true)
 * assert.deepStrictEqual(M1.concat(f, g)(3), false)
 *
 * const M2 = getMonoid(B.MonoidAny)<number>()
 *
 * assert.deepStrictEqual(M2.concat(f, g)(1), true)
 * assert.deepStrictEqual(M2.concat(f, g)(3), true)
 *
 * @category instances
 * @since 2.10.0
 */
var getMonoid = function (M) {
    var getSemigroupM = (0, exports.getSemigroup)(M);
    return function () { return ({
        concat: getSemigroupM().concat,
        empty: function () { return M.empty; }
    }); };
};
exports.getMonoid = getMonoid;
/**
 * @category instances
 * @since 2.10.0
 */
var getSemiring = function (S) { return ({
    add: function (f, g) { return function (x) { return S.add(f(x), g(x)); }; },
    zero: function () { return S.zero; },
    mul: function (f, g) { return function (x) { return S.mul(f(x), g(x)); }; },
    one: function () { return S.one; }
}); };
exports.getSemiring = getSemiring;
/**
 * @category instances
 * @since 2.10.0
 */
var getRing = function (R) {
    var S = (0, exports.getSemiring)(R);
    return {
        add: S.add,
        mul: S.mul,
        one: S.one,
        zero: S.zero,
        sub: function (f, g) { return function (x) { return R.sub(f(x), g(x)); }; }
    };
};
exports.getRing = getRing;
// -------------------------------------------------------------------------------------
// utils
// -------------------------------------------------------------------------------------
/**
 * @since 2.11.0
 */
var apply = function (a) {
    return function (f) {
        return f(a);
    };
};
exports.apply = apply;
/**
 * @since 2.0.0
 */
function identity(a) {
    return a;
}
/**
 * @since 2.0.0
 */
exports.unsafeCoerce = identity;
/**
 * @since 2.0.0
 */
function constant(a) {
    return function () { return a; };
}
/**
 * A thunk that returns always `true`.
 *
 * @since 2.0.0
 */
exports.constTrue = constant(true);
/**
 * A thunk that returns always `false`.
 *
 * @since 2.0.0
 */
exports.constFalse = constant(false);
/**
 * A thunk that returns always `null`.
 *
 * @since 2.0.0
 */
exports.constNull = constant(null);
/**
 * A thunk that returns always `undefined`.
 *
 * @since 2.0.0
 */
exports.constUndefined = constant(undefined);
/**
 * A thunk that returns always `void`.
 *
 * @since 2.0.0
 */
exports.constVoid = exports.constUndefined;
function flip(f) {
    return function () {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        if (args.length > 1) {
            return f(args[1], args[0]);
        }
        return function (a) { return f(a)(args[0]); };
    };
}
function flow(ab, bc, cd, de, ef, fg, gh, hi, ij) {
    switch (arguments.length) {
        case 1:
            return ab;
        case 2:
            return function () {
                return bc(ab.apply(this, arguments));
            };
        case 3:
            return function () {
                return cd(bc(ab.apply(this, arguments)));
            };
        case 4:
            return function () {
                return de(cd(bc(ab.apply(this, arguments))));
            };
        case 5:
            return function () {
                return ef(de(cd(bc(ab.apply(this, arguments)))));
            };
        case 6:
            return function () {
                return fg(ef(de(cd(bc(ab.apply(this, arguments))))));
            };
        case 7:
            return function () {
                return gh(fg(ef(de(cd(bc(ab.apply(this, arguments)))))));
            };
        case 8:
            return function () {
                return hi(gh(fg(ef(de(cd(bc(ab.apply(this, arguments))))))));
            };
        case 9:
            return function () {
                return ij(hi(gh(fg(ef(de(cd(bc(ab.apply(this, arguments)))))))));
            };
    }
    return;
}
/**
 * @since 2.0.0
 */
function tuple() {
    var t = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        t[_i] = arguments[_i];
    }
    return t;
}
/**
 * @since 2.0.0
 */
function increment(n) {
    return n + 1;
}
/**
 * @since 2.0.0
 */
function decrement(n) {
    return n - 1;
}
/**
 * @since 2.0.0
 */
function absurd(_) {
    throw new Error('Called `absurd` function which should be uncallable');
}
/**
 * Creates a tupled version of this function: instead of `n` arguments, it accepts a single tuple argument.
 *
 * @example
 * import { tupled } from 'fp-ts/function'
 *
 * const add = tupled((x: number, y: number): number => x + y)
 *
 * assert.strictEqual(add([1, 2]), 3)
 *
 * @since 2.4.0
 */
function tupled(f) {
    return function (a) { return f.apply(void 0, a); };
}
/**
 * Inverse function of `tupled`
 *
 * @since 2.4.0
 */
function untupled(f) {
    return function () {
        var a = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            a[_i] = arguments[_i];
        }
        return f(a);
    };
}
function pipe(a, ab, bc, cd, de, ef, fg, gh, hi) {
    switch (arguments.length) {
        case 1:
            return a;
        case 2:
            return ab(a);
        case 3:
            return bc(ab(a));
        case 4:
            return cd(bc(ab(a)));
        case 5:
            return de(cd(bc(ab(a))));
        case 6:
            return ef(de(cd(bc(ab(a)))));
        case 7:
            return fg(ef(de(cd(bc(ab(a))))));
        case 8:
            return gh(fg(ef(de(cd(bc(ab(a)))))));
        case 9:
            return hi(gh(fg(ef(de(cd(bc(ab(a))))))));
        default: {
            var ret = arguments[0];
            for (var i = 1; i < arguments.length; i++) {
                ret = arguments[i](ret);
            }
            return ret;
        }
    }
}
/**
 * Type hole simulation
 *
 * @since 2.7.0
 */
exports.hole = absurd;
/**
 * @since 2.11.0
 */
var SK = function (_, b) { return b; };
exports.SK = SK;
/**
 * Use `Predicate` module instead.
 *
 * @category zone of death
 * @since 2.0.0
 * @deprecated
 */
function not(predicate) {
    return function (a) { return !predicate(a); };
}
/**
 * Use `Endomorphism` module instead.
 *
 * @category zone of death
 * @since 2.10.0
 * @deprecated
 */
var getEndomorphismMonoid = function () { return ({
    concat: function (first, second) { return flow(first, second); },
    empty: identity
}); };
exports.getEndomorphismMonoid = getEndomorphismMonoid;
/** @internal */
var dual = function (arity, body) {
    var isDataFirst = typeof arity === 'number' ? function (args) { return args.length >= arity; } : arity;
    return function () {
        var args = Array.from(arguments);
        if (isDataFirst(arguments)) {
            return body.apply(this, args);
        }
        return function (self) { return body.apply(void 0, __spreadArray([self], args, false)); };
    };
};
exports.dual = dual;


/***/ }),

/***/ "./node_modules/fp-ts/lib/internal.js":
/*!********************************************!*\
  !*** ./node_modules/fp-ts/lib/internal.js ***!
  \********************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __spreadArray = (this && this.__spreadArray) || function (to, from, pack) {
    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
        }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.flatMapReader = exports.flatMapTask = exports.flatMapIO = exports.flatMapEither = exports.flatMapOption = exports.flatMapNullable = exports.liftOption = exports.liftNullable = exports.fromReadonlyNonEmptyArray = exports.has = exports.emptyRecord = exports.emptyReadonlyArray = exports.tail = exports.head = exports.isNonEmpty = exports.singleton = exports.right = exports.left = exports.isRight = exports.isLeft = exports.some = exports.none = exports.isSome = exports.isNone = void 0;
var function_1 = __webpack_require__(/*! ./function */ "./node_modules/fp-ts/lib/function.js");
// -------------------------------------------------------------------------------------
// Option
// -------------------------------------------------------------------------------------
/** @internal */
var isNone = function (fa) { return fa._tag === 'None'; };
exports.isNone = isNone;
/** @internal */
var isSome = function (fa) { return fa._tag === 'Some'; };
exports.isSome = isSome;
/** @internal */
exports.none = { _tag: 'None' };
/** @internal */
var some = function (a) { return ({ _tag: 'Some', value: a }); };
exports.some = some;
// -------------------------------------------------------------------------------------
// Either
// -------------------------------------------------------------------------------------
/** @internal */
var isLeft = function (ma) { return ma._tag === 'Left'; };
exports.isLeft = isLeft;
/** @internal */
var isRight = function (ma) { return ma._tag === 'Right'; };
exports.isRight = isRight;
/** @internal */
var left = function (e) { return ({ _tag: 'Left', left: e }); };
exports.left = left;
/** @internal */
var right = function (a) { return ({ _tag: 'Right', right: a }); };
exports.right = right;
// -------------------------------------------------------------------------------------
// ReadonlyNonEmptyArray
// -------------------------------------------------------------------------------------
/** @internal */
var singleton = function (a) { return [a]; };
exports.singleton = singleton;
/** @internal */
var isNonEmpty = function (as) { return as.length > 0; };
exports.isNonEmpty = isNonEmpty;
/** @internal */
var head = function (as) { return as[0]; };
exports.head = head;
/** @internal */
var tail = function (as) { return as.slice(1); };
exports.tail = tail;
// -------------------------------------------------------------------------------------
// empty
// -------------------------------------------------------------------------------------
/** @internal */
exports.emptyReadonlyArray = [];
/** @internal */
exports.emptyRecord = {};
// -------------------------------------------------------------------------------------
// Record
// -------------------------------------------------------------------------------------
/** @internal */
exports.has = Object.prototype.hasOwnProperty;
// -------------------------------------------------------------------------------------
// NonEmptyArray
// -------------------------------------------------------------------------------------
/** @internal */
var fromReadonlyNonEmptyArray = function (as) { return __spreadArray([as[0]], as.slice(1), true); };
exports.fromReadonlyNonEmptyArray = fromReadonlyNonEmptyArray;
/** @internal */
var liftNullable = function (F) {
    return function (f, onNullable) {
        return function () {
            var a = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                a[_i] = arguments[_i];
            }
            var o = f.apply(void 0, a);
            return F.fromEither(o == null ? (0, exports.left)(onNullable.apply(void 0, a)) : (0, exports.right)(o));
        };
    };
};
exports.liftNullable = liftNullable;
/** @internal */
var liftOption = function (F) {
    return function (f, onNone) {
        return function () {
            var a = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                a[_i] = arguments[_i];
            }
            var o = f.apply(void 0, a);
            return F.fromEither((0, exports.isNone)(o) ? (0, exports.left)(onNone.apply(void 0, a)) : (0, exports.right)(o.value));
        };
    };
};
exports.liftOption = liftOption;
/** @internal */
var flatMapNullable = function (F, M) {
    return /*#__PURE__*/ (0, function_1.dual)(3, function (self, f, onNullable) {
        return M.flatMap(self, (0, exports.liftNullable)(F)(f, onNullable));
    });
};
exports.flatMapNullable = flatMapNullable;
/** @internal */
var flatMapOption = function (F, M) {
    return /*#__PURE__*/ (0, function_1.dual)(3, function (self, f, onNone) { return M.flatMap(self, (0, exports.liftOption)(F)(f, onNone)); });
};
exports.flatMapOption = flatMapOption;
/** @internal */
var flatMapEither = function (F, M) {
    return /*#__PURE__*/ (0, function_1.dual)(2, function (self, f) {
        return M.flatMap(self, function (a) { return F.fromEither(f(a)); });
    });
};
exports.flatMapEither = flatMapEither;
/** @internal */
var flatMapIO = function (F, M) {
    return /*#__PURE__*/ (0, function_1.dual)(2, function (self, f) {
        return M.flatMap(self, function (a) { return F.fromIO(f(a)); });
    });
};
exports.flatMapIO = flatMapIO;
/** @internal */
var flatMapTask = function (F, M) {
    return /*#__PURE__*/ (0, function_1.dual)(2, function (self, f) {
        return M.flatMap(self, function (a) { return F.fromTask(f(a)); });
    });
};
exports.flatMapTask = flatMapTask;
/** @internal */
var flatMapReader = function (F, M) {
    return /*#__PURE__*/ (0, function_1.dual)(2, function (self, f) {
        return M.flatMap(self, function (a) { return F.fromReader(f(a)); });
    });
};
exports.flatMapReader = flatMapReader;


/***/ }),

/***/ "./node_modules/html-entities/dist/commonjs/index.js":
/*!***********************************************************!*\
  !*** ./node_modules/html-entities/dist/commonjs/index.js ***!
  \***********************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.encode = encode;
exports.decodeEntity = decodeEntity;
exports.decode = decode;
var named_references_js_1 = __webpack_require__(/*! ./named-references.js */ "./node_modules/html-entities/dist/commonjs/named-references.js");
var numeric_unicode_map_js_1 = __webpack_require__(/*! ./numeric-unicode-map.js */ "./node_modules/html-entities/dist/commonjs/numeric-unicode-map.js");
var surrogate_pairs_js_1 = __webpack_require__(/*! ./surrogate-pairs.js */ "./node_modules/html-entities/dist/commonjs/surrogate-pairs.js");
var allNamedReferences = __assign(__assign({}, named_references_js_1.namedReferences), { all: named_references_js_1.namedReferences.html5 });
var encodeRegExps = {
    specialChars: /[<>'"&]/g,
    nonAscii: /[<>'"&\u0080-\uD7FF\uE000-\uFFFF\uDC00-\uDFFF]|[\uD800-\uDBFF][\uDC00-\uDFFF]?/g,
    nonAsciiPrintable: /[<>'"&\x01-\x08\x11-\x15\x17-\x1F\x7f-\uD7FF\uE000-\uFFFF\uDC00-\uDFFF]|[\uD800-\uDBFF][\uDC00-\uDFFF]?/g,
    nonAsciiPrintableOnly: /[\x01-\x08\x11-\x15\x17-\x1F\x7f-\uD7FF\uE000-\uFFFF\uDC00-\uDFFF]|[\uD800-\uDBFF][\uDC00-\uDFFF]?/g,
    extensive: /[\x01-\x0c\x0e-\x1f\x21-\x2c\x2e-\x2f\x3a-\x40\x5b-\x60\x7b-\x7d\x7f-\uD7FF\uE000-\uFFFF\uDC00-\uDFFF]|[\uD800-\uDBFF][\uDC00-\uDFFF]?/g
};
var defaultEncodeOptions = {
    mode: 'specialChars',
    level: 'all',
    numeric: 'decimal'
};
/** Encodes all the necessary (specified by `level`) characters in the text */
function encode(text, _a) {
    var _b = _a === void 0 ? defaultEncodeOptions : _a, _c = _b.mode, mode = _c === void 0 ? 'specialChars' : _c, _d = _b.numeric, numeric = _d === void 0 ? 'decimal' : _d, _e = _b.level, level = _e === void 0 ? 'all' : _e;
    if (!text) {
        return '';
    }
    var encodeRegExp = encodeRegExps[mode];
    var references = allNamedReferences[level].characters;
    var isHex = numeric === 'hexadecimal';
    return String.prototype.replace.call(text, encodeRegExp, function (input) {
        var result = references[input];
        if (!result) {
            var code = input.length > 1 ? (0, surrogate_pairs_js_1.getCodePoint)(input, 0) : input.charCodeAt(0);
            result = (isHex ? '&#x' + code.toString(16) : '&#' + code) + ';';
        }
        return result;
    });
}
var defaultDecodeOptions = {
    scope: 'body',
    level: 'all'
};
var strict = /&(?:#\d+|#[xX][\da-fA-F]+|[0-9a-zA-Z]+);/g;
var attribute = /&(?:#\d+|#[xX][\da-fA-F]+|[0-9a-zA-Z]+)[;=]?/g;
var baseDecodeRegExps = {
    xml: {
        strict: strict,
        attribute: attribute,
        body: named_references_js_1.bodyRegExps.xml
    },
    html4: {
        strict: strict,
        attribute: attribute,
        body: named_references_js_1.bodyRegExps.html4
    },
    html5: {
        strict: strict,
        attribute: attribute,
        body: named_references_js_1.bodyRegExps.html5
    }
};
var decodeRegExps = __assign(__assign({}, baseDecodeRegExps), { all: baseDecodeRegExps.html5 });
var fromCharCode = String.fromCharCode;
var outOfBoundsChar = fromCharCode(65533);
var defaultDecodeEntityOptions = {
    level: 'all'
};
function getDecodedEntity(entity, references, isAttribute, isStrict) {
    var decodeResult = entity;
    var decodeEntityLastChar = entity[entity.length - 1];
    if (isAttribute && decodeEntityLastChar === '=') {
        decodeResult = entity;
    }
    else if (isStrict && decodeEntityLastChar !== ';') {
        decodeResult = entity;
    }
    else {
        var decodeResultByReference = references[entity];
        if (decodeResultByReference) {
            decodeResult = decodeResultByReference;
        }
        else if (entity[0] === '&' && entity[1] === '#') {
            var decodeSecondChar = entity[2];
            var decodeCode = decodeSecondChar == 'x' || decodeSecondChar == 'X'
                ? parseInt(entity.substr(3), 16)
                : parseInt(entity.substr(2));
            decodeResult =
                decodeCode >= 0x10ffff
                    ? outOfBoundsChar
                    : decodeCode > 65535
                        ? (0, surrogate_pairs_js_1.fromCodePoint)(decodeCode)
                        : fromCharCode(numeric_unicode_map_js_1.numericUnicodeMap[decodeCode] || decodeCode);
        }
    }
    return decodeResult;
}
/** Decodes a single entity */
function decodeEntity(entity, _a) {
    var _b = _a === void 0 ? defaultDecodeEntityOptions : _a, _c = _b.level, level = _c === void 0 ? 'all' : _c;
    if (!entity) {
        return '';
    }
    return getDecodedEntity(entity, allNamedReferences[level].entities, false, false);
}
/** Decodes all entities in the text */
function decode(text, _a) {
    var _b = _a === void 0 ? defaultDecodeOptions : _a, _c = _b.level, level = _c === void 0 ? 'all' : _c, _d = _b.scope, scope = _d === void 0 ? level === 'xml' ? 'strict' : 'body' : _d;
    if (!text) {
        return '';
    }
    var decodeRegExp = decodeRegExps[level][scope];
    var references = allNamedReferences[level].entities;
    var isAttribute = scope === 'attribute';
    var isStrict = scope === 'strict';
    return text.replace(decodeRegExp, function (entity) { return getDecodedEntity(entity, references, isAttribute, isStrict); });
}
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/html-entities/dist/commonjs/named-references.js":
/*!**********************************************************************!*\
  !*** ./node_modules/html-entities/dist/commonjs/named-references.js ***!
  \**********************************************************************/
/***/ (function(__unused_webpack_module, exports) {

"use strict";

var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.namedReferences = exports.bodyRegExps = void 0;
// This file is autogenerated by tools/process-named-references.ts
var pairDivider = "~";
var blockDivider = "~~";
function generateNamedReferences(input, prev) {
    var entities = {};
    var characters = {};
    var blocks = input.split(blockDivider);
    var isOptionalBlock = false;
    for (var i = 0; blocks.length > i; i++) {
        var entries = blocks[i].split(pairDivider);
        for (var j = 0; j < entries.length; j += 2) {
            var entity = entries[j];
            var character = entries[j + 1];
            var fullEntity = '&' + entity + ';';
            entities[fullEntity] = character;
            if (isOptionalBlock) {
                entities['&' + entity] = character;
            }
            characters[character] = fullEntity;
        }
        isOptionalBlock = true;
    }
    return prev ?
        { entities: __assign(__assign({}, entities), prev.entities), characters: __assign(__assign({}, characters), prev.characters) } :
        { entities: entities, characters: characters };
}
exports.bodyRegExps = {
    xml: /&(?:#\d+|#[xX][\da-fA-F]+|[0-9a-zA-Z]+);?/g,
    html4: /&notin;|&(?:nbsp|iexcl|cent|pound|curren|yen|brvbar|sect|uml|copy|ordf|laquo|not|shy|reg|macr|deg|plusmn|sup2|sup3|acute|micro|para|middot|cedil|sup1|ordm|raquo|frac14|frac12|frac34|iquest|Agrave|Aacute|Acirc|Atilde|Auml|Aring|AElig|Ccedil|Egrave|Eacute|Ecirc|Euml|Igrave|Iacute|Icirc|Iuml|ETH|Ntilde|Ograve|Oacute|Ocirc|Otilde|Ouml|times|Oslash|Ugrave|Uacute|Ucirc|Uuml|Yacute|THORN|szlig|agrave|aacute|acirc|atilde|auml|aring|aelig|ccedil|egrave|eacute|ecirc|euml|igrave|iacute|icirc|iuml|eth|ntilde|ograve|oacute|ocirc|otilde|ouml|divide|oslash|ugrave|uacute|ucirc|uuml|yacute|thorn|yuml|quot|amp|lt|gt|#\d+|#[xX][\da-fA-F]+|[0-9a-zA-Z]+);?/g,
    html5: /&centerdot;|&copysr;|&divideontimes;|&gtcc;|&gtcir;|&gtdot;|&gtlPar;|&gtquest;|&gtrapprox;|&gtrarr;|&gtrdot;|&gtreqless;|&gtreqqless;|&gtrless;|&gtrsim;|&ltcc;|&ltcir;|&ltdot;|&lthree;|&ltimes;|&ltlarr;|&ltquest;|&ltrPar;|&ltri;|&ltrie;|&ltrif;|&notin;|&notinE;|&notindot;|&notinva;|&notinvb;|&notinvc;|&notni;|&notniva;|&notnivb;|&notnivc;|&parallel;|&timesb;|&timesbar;|&timesd;|&(?:AElig|AMP|Aacute|Acirc|Agrave|Aring|Atilde|Auml|COPY|Ccedil|ETH|Eacute|Ecirc|Egrave|Euml|GT|Iacute|Icirc|Igrave|Iuml|LT|Ntilde|Oacute|Ocirc|Ograve|Oslash|Otilde|Ouml|QUOT|REG|THORN|Uacute|Ucirc|Ugrave|Uuml|Yacute|aacute|acirc|acute|aelig|agrave|amp|aring|atilde|auml|brvbar|ccedil|cedil|cent|copy|curren|deg|divide|eacute|ecirc|egrave|eth|euml|frac12|frac14|frac34|gt|iacute|icirc|iexcl|igrave|iquest|iuml|laquo|lt|macr|micro|middot|nbsp|not|ntilde|oacute|ocirc|ograve|ordf|ordm|oslash|otilde|ouml|para|plusmn|pound|quot|raquo|reg|sect|shy|sup1|sup2|sup3|szlig|thorn|times|uacute|ucirc|ugrave|uml|uuml|yacute|yen|yuml|#\d+|#[xX][\da-fA-F]+|[0-9a-zA-Z]+);?/g
};
exports.namedReferences = {};
exports.namedReferences.xml = generateNamedReferences("lt~<~gt~>~quot~\"~apos~'~amp~&");
exports.namedReferences.html4 = generateNamedReferences("apos~'~OElig~~oelig~~Scaron~~scaron~~Yuml~~circ~~tilde~~ensp~~emsp~~thinsp~~zwnj~~zwj~~lrm~~rlm~~ndash~~mdash~~lsquo~~rsquo~~sbquo~~ldquo~~rdquo~~bdquo~~dagger~~Dagger~~permil~~lsaquo~~rsaquo~~euro~~fnof~~Alpha~~Beta~~Gamma~~Delta~~Epsilon~~Zeta~~Eta~~Theta~~Iota~~Kappa~~Lambda~~Mu~~Nu~~Xi~~Omicron~~Pi~~Rho~~Sigma~~Tau~~Upsilon~~Phi~~Chi~~Psi~~Omega~~alpha~~beta~~gamma~~delta~~epsilon~~zeta~~eta~~theta~~iota~~kappa~~lambda~~mu~~nu~~xi~~omicron~~pi~~rho~~sigmaf~~sigma~~tau~~upsilon~~phi~~chi~~psi~~omega~~thetasym~~upsih~~piv~~bull~~hellip~~prime~~Prime~~oline~~frasl~~weierp~~image~~real~~trade~~alefsym~~larr~~uarr~~rarr~~darr~~harr~~crarr~~lArr~~uArr~~rArr~~dArr~~hArr~~forall~~part~~exist~~empty~~nabla~~isin~~notin~~ni~~prod~~sum~~minus~~lowast~~radic~~prop~~infin~~ang~~and~~or~~cap~~cup~~int~~there4~~sim~~cong~~asymp~~ne~~equiv~~le~~ge~~sub~~sup~~nsub~~sube~~supe~~oplus~~otimes~~perp~~sdot~~lceil~~rceil~~lfloor~~rfloor~~lang~~rang~~loz~~spades~~clubs~~hearts~~diams~~~nbsp~~iexcl~~cent~~pound~~curren~~yen~~brvbar~~sect~~uml~~copy~~ordf~~laquo~~not~~shy~~reg~~macr~~deg~~plusmn~~sup2~~sup3~~acute~~micro~~para~~middot~~cedil~~sup1~~ordm~~raquo~~frac14~~frac12~~frac34~~iquest~~Agrave~~Aacute~~Acirc~~Atilde~~Auml~~Aring~~AElig~~Ccedil~~Egrave~~Eacute~~Ecirc~~Euml~~Igrave~~Iacute~~Icirc~~Iuml~~ETH~~Ntilde~~Ograve~~Oacute~~Ocirc~~Otilde~~Ouml~~times~~Oslash~~Ugrave~~Uacute~~Ucirc~~Uuml~~Yacute~~THORN~~szlig~~agrave~~aacute~~acirc~~atilde~~auml~~aring~~aelig~~ccedil~~egrave~~eacute~~ecirc~~euml~~igrave~~iacute~~icirc~~iuml~~eth~~ntilde~~ograve~~oacute~~ocirc~~otilde~~ouml~~divide~~oslash~~ugrave~~uacute~~ucirc~~uuml~~yacute~~thorn~~yuml~~quot~\"~amp~&~lt~<~gt~>");
exports.namedReferences.html5 = generateNamedReferences("Abreve~~Acy~~Afr~~Amacr~~And~~Aogon~~Aopf~~ApplyFunction~~Ascr~~Assign~~Backslash~~Barv~~Barwed~~Bcy~~Because~~Bernoullis~~Bfr~~Bopf~~Breve~~Bscr~~Bumpeq~~CHcy~~Cacute~~Cap~~CapitalDifferentialD~~Cayleys~~Ccaron~~Ccirc~~Cconint~~Cdot~~Cedilla~~CenterDot~~Cfr~~CircleDot~~CircleMinus~~CirclePlus~~CircleTimes~~ClockwiseContourIntegral~~CloseCurlyDoubleQuote~~CloseCurlyQuote~~Colon~~Colone~~Congruent~~Conint~~ContourIntegral~~Copf~~Coproduct~~CounterClockwiseContourIntegral~~Cross~~Cscr~~Cup~~CupCap~~DD~~DDotrahd~~DJcy~~DScy~~DZcy~~Darr~~Dashv~~Dcaron~~Dcy~~Del~~Dfr~~DiacriticalAcute~~DiacriticalDot~~DiacriticalDoubleAcute~~DiacriticalGrave~`~DiacriticalTilde~~Diamond~~DifferentialD~~Dopf~~Dot~~DotDot~~DotEqual~~DoubleContourIntegral~~DoubleDot~~DoubleDownArrow~~DoubleLeftArrow~~DoubleLeftRightArrow~~DoubleLeftTee~~DoubleLongLeftArrow~~DoubleLongLeftRightArrow~~DoubleLongRightArrow~~DoubleRightArrow~~DoubleRightTee~~DoubleUpArrow~~DoubleUpDownArrow~~DoubleVerticalBar~~DownArrow~~DownArrowBar~~DownArrowUpArrow~~DownBreve~~DownLeftRightVector~~DownLeftTeeVector~~DownLeftVector~~DownLeftVectorBar~~DownRightTeeVector~~DownRightVector~~DownRightVectorBar~~DownTee~~DownTeeArrow~~Downarrow~~Dscr~~Dstrok~~ENG~~Ecaron~~Ecy~~Edot~~Efr~~Element~~Emacr~~EmptySmallSquare~~EmptyVerySmallSquare~~Eogon~~Eopf~~Equal~~EqualTilde~~Equilibrium~~Escr~~Esim~~Exists~~ExponentialE~~Fcy~~Ffr~~FilledSmallSquare~~FilledVerySmallSquare~~Fopf~~ForAll~~Fouriertrf~~Fscr~~GJcy~~Gammad~~Gbreve~~Gcedil~~Gcirc~~Gcy~~Gdot~~Gfr~~Gg~~Gopf~~GreaterEqual~~GreaterEqualLess~~GreaterFullEqual~~GreaterGreater~~GreaterLess~~GreaterSlantEqual~~GreaterTilde~~Gscr~~Gt~~HARDcy~~Hacek~~Hat~^~Hcirc~~Hfr~~HilbertSpace~~Hopf~~HorizontalLine~~Hscr~~Hstrok~~HumpDownHump~~HumpEqual~~IEcy~~IJlig~~IOcy~~Icy~~Idot~~Ifr~~Im~~Imacr~~ImaginaryI~~Implies~~Int~~Integral~~Intersection~~InvisibleComma~~InvisibleTimes~~Iogon~~Iopf~~Iscr~~Itilde~~Iukcy~~Jcirc~~Jcy~~Jfr~~Jopf~~Jscr~~Jsercy~~Jukcy~~KHcy~~KJcy~~Kcedil~~Kcy~~Kfr~~Kopf~~Kscr~~LJcy~~Lacute~~Lang~~Laplacetrf~~Larr~~Lcaron~~Lcedil~~Lcy~~LeftAngleBracket~~LeftArrow~~LeftArrowBar~~LeftArrowRightArrow~~LeftCeiling~~LeftDoubleBracket~~LeftDownTeeVector~~LeftDownVector~~LeftDownVectorBar~~LeftFloor~~LeftRightArrow~~LeftRightVector~~LeftTee~~LeftTeeArrow~~LeftTeeVector~~LeftTriangle~~LeftTriangleBar~~LeftTriangleEqual~~LeftUpDownVector~~LeftUpTeeVector~~LeftUpVector~~LeftUpVectorBar~~LeftVector~~LeftVectorBar~~Leftarrow~~Leftrightarrow~~LessEqualGreater~~LessFullEqual~~LessGreater~~LessLess~~LessSlantEqual~~LessTilde~~Lfr~~Ll~~Lleftarrow~~Lmidot~~LongLeftArrow~~LongLeftRightArrow~~LongRightArrow~~Longleftarrow~~Longleftrightarrow~~Longrightarrow~~Lopf~~LowerLeftArrow~~LowerRightArrow~~Lscr~~Lsh~~Lstrok~~Lt~~Map~~Mcy~~MediumSpace~~Mellintrf~~Mfr~~MinusPlus~~Mopf~~Mscr~~NJcy~~Nacute~~Ncaron~~Ncedil~~Ncy~~NegativeMediumSpace~~NegativeThickSpace~~NegativeThinSpace~~NegativeVeryThinSpace~~NestedGreaterGreater~~NestedLessLess~~NewLine~\n~Nfr~~NoBreak~~NonBreakingSpace~~Nopf~~Not~~NotCongruent~~NotCupCap~~NotDoubleVerticalBar~~NotElement~~NotEqual~~NotEqualTilde~~NotExists~~NotGreater~~NotGreaterEqual~~NotGreaterFullEqual~~NotGreaterGreater~~NotGreaterLess~~NotGreaterSlantEqual~~NotGreaterTilde~~NotHumpDownHump~~NotHumpEqual~~NotLeftTriangle~~NotLeftTriangleBar~~NotLeftTriangleEqual~~NotLess~~NotLessEqual~~NotLessGreater~~NotLessLess~~NotLessSlantEqual~~NotLessTilde~~NotNestedGreaterGreater~~NotNestedLessLess~~NotPrecedes~~NotPrecedesEqual~~NotPrecedesSlantEqual~~NotReverseElement~~NotRightTriangle~~NotRightTriangleBar~~NotRightTriangleEqual~~NotSquareSubset~~NotSquareSubsetEqual~~NotSquareSuperset~~NotSquareSupersetEqual~~NotSubset~~NotSubsetEqual~~NotSucceeds~~NotSucceedsEqual~~NotSucceedsSlantEqual~~NotSucceedsTilde~~NotSuperset~~NotSupersetEqual~~NotTilde~~NotTildeEqual~~NotTildeFullEqual~~NotTildeTilde~~NotVerticalBar~~Nscr~~Ocy~~Odblac~~Ofr~~Omacr~~Oopf~~OpenCurlyDoubleQuote~~OpenCurlyQuote~~Or~~Oscr~~Otimes~~OverBar~~OverBrace~~OverBracket~~OverParenthesis~~PartialD~~Pcy~~Pfr~~PlusMinus~~Poincareplane~~Popf~~Pr~~Precedes~~PrecedesEqual~~PrecedesSlantEqual~~PrecedesTilde~~Product~~Proportion~~Proportional~~Pscr~~Qfr~~Qopf~~Qscr~~RBarr~~Racute~~Rang~~Rarr~~Rarrtl~~Rcaron~~Rcedil~~Rcy~~Re~~ReverseElement~~ReverseEquilibrium~~ReverseUpEquilibrium~~Rfr~~RightAngleBracket~~RightArrow~~RightArrowBar~~RightArrowLeftArrow~~RightCeiling~~RightDoubleBracket~~RightDownTeeVector~~RightDownVector~~RightDownVectorBar~~RightFloor~~RightTee~~RightTeeArrow~~RightTeeVector~~RightTriangle~~RightTriangleBar~~RightTriangleEqual~~RightUpDownVector~~RightUpTeeVector~~RightUpVector~~RightUpVectorBar~~RightVector~~RightVectorBar~~Rightarrow~~Ropf~~RoundImplies~~Rrightarrow~~Rscr~~Rsh~~RuleDelayed~~SHCHcy~~SHcy~~SOFTcy~~Sacute~~Sc~~Scedil~~Scirc~~Scy~~Sfr~~ShortDownArrow~~ShortLeftArrow~~ShortRightArrow~~ShortUpArrow~~SmallCircle~~Sopf~~Sqrt~~Square~~SquareIntersection~~SquareSubset~~SquareSubsetEqual~~SquareSuperset~~SquareSupersetEqual~~SquareUnion~~Sscr~~Star~~Sub~~Subset~~SubsetEqual~~Succeeds~~SucceedsEqual~~SucceedsSlantEqual~~SucceedsTilde~~SuchThat~~Sum~~Sup~~Superset~~SupersetEqual~~Supset~~TRADE~~TSHcy~~TScy~~Tab~\t~Tcaron~~Tcedil~~Tcy~~Tfr~~Therefore~~ThickSpace~~ThinSpace~~Tilde~~TildeEqual~~TildeFullEqual~~TildeTilde~~Topf~~TripleDot~~Tscr~~Tstrok~~Uarr~~Uarrocir~~Ubrcy~~Ubreve~~Ucy~~Udblac~~Ufr~~Umacr~~UnderBar~_~UnderBrace~~UnderBracket~~UnderParenthesis~~Union~~UnionPlus~~Uogon~~Uopf~~UpArrow~~UpArrowBar~~UpArrowDownArrow~~UpDownArrow~~UpEquilibrium~~UpTee~~UpTeeArrow~~Uparrow~~Updownarrow~~UpperLeftArrow~~UpperRightArrow~~Upsi~~Uring~~Uscr~~Utilde~~VDash~~Vbar~~Vcy~~Vdash~~Vdashl~~Vee~~Verbar~~Vert~~VerticalBar~~VerticalLine~|~VerticalSeparator~~VerticalTilde~~VeryThinSpace~~Vfr~~Vopf~~Vscr~~Vvdash~~Wcirc~~Wedge~~Wfr~~Wopf~~Wscr~~Xfr~~Xopf~~Xscr~~YAcy~~YIcy~~YUcy~~Ycirc~~Ycy~~Yfr~~Yopf~~Yscr~~ZHcy~~Zacute~~Zcaron~~Zcy~~Zdot~~ZeroWidthSpace~~Zfr~~Zopf~~Zscr~~abreve~~ac~~acE~~acd~~acy~~af~~afr~~aleph~~amacr~~amalg~~andand~~andd~~andslope~~andv~~ange~~angle~~angmsd~~angmsdaa~~angmsdab~~angmsdac~~angmsdad~~angmsdae~~angmsdaf~~angmsdag~~angmsdah~~angrt~~angrtvb~~angrtvbd~~angsph~~angst~~angzarr~~aogon~~aopf~~ap~~apE~~apacir~~ape~~apid~~approx~~approxeq~~ascr~~ast~*~asympeq~~awconint~~awint~~bNot~~backcong~~backepsilon~~backprime~~backsim~~backsimeq~~barvee~~barwed~~barwedge~~bbrk~~bbrktbrk~~bcong~~bcy~~becaus~~because~~bemptyv~~bepsi~~bernou~~beth~~between~~bfr~~bigcap~~bigcirc~~bigcup~~bigodot~~bigoplus~~bigotimes~~bigsqcup~~bigstar~~bigtriangledown~~bigtriangleup~~biguplus~~bigvee~~bigwedge~~bkarow~~blacklozenge~~blacksquare~~blacktriangle~~blacktriangledown~~blacktriangleleft~~blacktriangleright~~blank~~blk12~~blk14~~blk34~~block~~bne~=~bnequiv~~bnot~~bopf~~bot~~bottom~~bowtie~~boxDL~~boxDR~~boxDl~~boxDr~~boxH~~boxHD~~boxHU~~boxHd~~boxHu~~boxUL~~boxUR~~boxUl~~boxUr~~boxV~~boxVH~~boxVL~~boxVR~~boxVh~~boxVl~~boxVr~~boxbox~~boxdL~~boxdR~~boxdl~~boxdr~~boxh~~boxhD~~boxhU~~boxhd~~boxhu~~boxminus~~boxplus~~boxtimes~~boxuL~~boxuR~~boxul~~boxur~~boxv~~boxvH~~boxvL~~boxvR~~boxvh~~boxvl~~boxvr~~bprime~~breve~~bscr~~bsemi~~bsim~~bsime~~bsol~\\~bsolb~~bsolhsub~~bullet~~bump~~bumpE~~bumpe~~bumpeq~~cacute~~capand~~capbrcup~~capcap~~capcup~~capdot~~caps~~caret~~caron~~ccaps~~ccaron~~ccirc~~ccups~~ccupssm~~cdot~~cemptyv~~centerdot~~cfr~~chcy~~check~~checkmark~~cir~~cirE~~circeq~~circlearrowleft~~circlearrowright~~circledR~~circledS~~circledast~~circledcirc~~circleddash~~cire~~cirfnint~~cirmid~~cirscir~~clubsuit~~colon~:~colone~~coloneq~~comma~,~commat~@~comp~~compfn~~complement~~complexes~~congdot~~conint~~copf~~coprod~~copysr~~cross~~cscr~~csub~~csube~~csup~~csupe~~ctdot~~cudarrl~~cudarrr~~cuepr~~cuesc~~cularr~~cularrp~~cupbrcap~~cupcap~~cupcup~~cupdot~~cupor~~cups~~curarr~~curarrm~~curlyeqprec~~curlyeqsucc~~curlyvee~~curlywedge~~curvearrowleft~~curvearrowright~~cuvee~~cuwed~~cwconint~~cwint~~cylcty~~dHar~~daleth~~dash~~dashv~~dbkarow~~dblac~~dcaron~~dcy~~dd~~ddagger~~ddarr~~ddotseq~~demptyv~~dfisht~~dfr~~dharl~~dharr~~diam~~diamond~~diamondsuit~~die~~digamma~~disin~~div~~divideontimes~~divonx~~djcy~~dlcorn~~dlcrop~~dollar~$~dopf~~dot~~doteq~~doteqdot~~dotminus~~dotplus~~dotsquare~~doublebarwedge~~downarrow~~downdownarrows~~downharpoonleft~~downharpoonright~~drbkarow~~drcorn~~drcrop~~dscr~~dscy~~dsol~~dstrok~~dtdot~~dtri~~dtrif~~duarr~~duhar~~dwangle~~dzcy~~dzigrarr~~eDDot~~eDot~~easter~~ecaron~~ecir~~ecolon~~ecy~~edot~~ee~~efDot~~efr~~eg~~egs~~egsdot~~el~~elinters~~ell~~els~~elsdot~~emacr~~emptyset~~emptyv~~emsp13~~emsp14~~eng~~eogon~~eopf~~epar~~eparsl~~eplus~~epsi~~epsiv~~eqcirc~~eqcolon~~eqsim~~eqslantgtr~~eqslantless~~equals~=~equest~~equivDD~~eqvparsl~~erDot~~erarr~~escr~~esdot~~esim~~excl~!~expectation~~exponentiale~~fallingdotseq~~fcy~~female~~ffilig~~fflig~~ffllig~~ffr~~filig~~fjlig~fj~flat~~fllig~~fltns~~fopf~~fork~~forkv~~fpartint~~frac13~~frac15~~frac16~~frac18~~frac23~~frac25~~frac35~~frac38~~frac45~~frac56~~frac58~~frac78~~frown~~fscr~~gE~~gEl~~gacute~~gammad~~gap~~gbreve~~gcirc~~gcy~~gdot~~gel~~geq~~geqq~~geqslant~~ges~~gescc~~gesdot~~gesdoto~~gesdotol~~gesl~~gesles~~gfr~~gg~~ggg~~gimel~~gjcy~~gl~~glE~~gla~~glj~~gnE~~gnap~~gnapprox~~gne~~gneq~~gneqq~~gnsim~~gopf~~grave~`~gscr~~gsim~~gsime~~gsiml~~gtcc~~gtcir~~gtdot~~gtlPar~~gtquest~~gtrapprox~~gtrarr~~gtrdot~~gtreqless~~gtreqqless~~gtrless~~gtrsim~~gvertneqq~~gvnE~~hairsp~~half~~hamilt~~hardcy~~harrcir~~harrw~~hbar~~hcirc~~heartsuit~~hercon~~hfr~~hksearow~~hkswarow~~hoarr~~homtht~~hookleftarrow~~hookrightarrow~~hopf~~horbar~~hscr~~hslash~~hstrok~~hybull~~hyphen~~ic~~icy~~iecy~~iff~~ifr~~ii~~iiiint~~iiint~~iinfin~~iiota~~ijlig~~imacr~~imagline~~imagpart~~imath~~imof~~imped~~in~~incare~~infintie~~inodot~~intcal~~integers~~intercal~~intlarhk~~intprod~~iocy~~iogon~~iopf~~iprod~~iscr~~isinE~~isindot~~isins~~isinsv~~isinv~~it~~itilde~~iukcy~~jcirc~~jcy~~jfr~~jmath~~jopf~~jscr~~jsercy~~jukcy~~kappav~~kcedil~~kcy~~kfr~~kgreen~~khcy~~kjcy~~kopf~~kscr~~lAarr~~lAtail~~lBarr~~lE~~lEg~~lHar~~lacute~~laemptyv~~lagran~~langd~~langle~~lap~~larrb~~larrbfs~~larrfs~~larrhk~~larrlp~~larrpl~~larrsim~~larrtl~~lat~~latail~~late~~lates~~lbarr~~lbbrk~~lbrace~{~lbrack~[~lbrke~~lbrksld~~lbrkslu~~lcaron~~lcedil~~lcub~{~lcy~~ldca~~ldquor~~ldrdhar~~ldrushar~~ldsh~~leftarrow~~leftarrowtail~~leftharpoondown~~leftharpoonup~~leftleftarrows~~leftrightarrow~~leftrightarrows~~leftrightharpoons~~leftrightsquigarrow~~leftthreetimes~~leg~~leq~~leqq~~leqslant~~les~~lescc~~lesdot~~lesdoto~~lesdotor~~lesg~~lesges~~lessapprox~~lessdot~~lesseqgtr~~lesseqqgtr~~lessgtr~~lesssim~~lfisht~~lfr~~lg~~lgE~~lhard~~lharu~~lharul~~lhblk~~ljcy~~ll~~llarr~~llcorner~~llhard~~lltri~~lmidot~~lmoust~~lmoustache~~lnE~~lnap~~lnapprox~~lne~~lneq~~lneqq~~lnsim~~loang~~loarr~~lobrk~~longleftarrow~~longleftrightarrow~~longmapsto~~longrightarrow~~looparrowleft~~looparrowright~~lopar~~lopf~~loplus~~lotimes~~lowbar~_~lozenge~~lozf~~lpar~(~lparlt~~lrarr~~lrcorner~~lrhar~~lrhard~~lrtri~~lscr~~lsh~~lsim~~lsime~~lsimg~~lsqb~[~lsquor~~lstrok~~ltcc~~ltcir~~ltdot~~lthree~~ltimes~~ltlarr~~ltquest~~ltrPar~~ltri~~ltrie~~ltrif~~lurdshar~~luruhar~~lvertneqq~~lvnE~~mDDot~~male~~malt~~maltese~~map~~mapsto~~mapstodown~~mapstoleft~~mapstoup~~marker~~mcomma~~mcy~~measuredangle~~mfr~~mho~~mid~~midast~*~midcir~~minusb~~minusd~~minusdu~~mlcp~~mldr~~mnplus~~models~~mopf~~mp~~mscr~~mstpos~~multimap~~mumap~~nGg~~nGt~~nGtv~~nLeftarrow~~nLeftrightarrow~~nLl~~nLt~~nLtv~~nRightarrow~~nVDash~~nVdash~~nacute~~nang~~nap~~napE~~napid~~napos~~napprox~~natur~~natural~~naturals~~nbump~~nbumpe~~ncap~~ncaron~~ncedil~~ncong~~ncongdot~~ncup~~ncy~~neArr~~nearhk~~nearr~~nearrow~~nedot~~nequiv~~nesear~~nesim~~nexist~~nexists~~nfr~~ngE~~nge~~ngeq~~ngeqq~~ngeqslant~~nges~~ngsim~~ngt~~ngtr~~nhArr~~nharr~~nhpar~~nis~~nisd~~niv~~njcy~~nlArr~~nlE~~nlarr~~nldr~~nle~~nleftarrow~~nleftrightarrow~~nleq~~nleqq~~nleqslant~~nles~~nless~~nlsim~~nlt~~nltri~~nltrie~~nmid~~nopf~~notinE~~notindot~~notinva~~notinvb~~notinvc~~notni~~notniva~~notnivb~~notnivc~~npar~~nparallel~~nparsl~~npart~~npolint~~npr~~nprcue~~npre~~nprec~~npreceq~~nrArr~~nrarr~~nrarrc~~nrarrw~~nrightarrow~~nrtri~~nrtrie~~nsc~~nsccue~~nsce~~nscr~~nshortmid~~nshortparallel~~nsim~~nsime~~nsimeq~~nsmid~~nspar~~nsqsube~~nsqsupe~~nsubE~~nsube~~nsubset~~nsubseteq~~nsubseteqq~~nsucc~~nsucceq~~nsup~~nsupE~~nsupe~~nsupset~~nsupseteq~~nsupseteqq~~ntgl~~ntlg~~ntriangleleft~~ntrianglelefteq~~ntriangleright~~ntrianglerighteq~~num~#~numero~~numsp~~nvDash~~nvHarr~~nvap~~nvdash~~nvge~~nvgt~>~nvinfin~~nvlArr~~nvle~~nvlt~<~nvltrie~~nvrArr~~nvrtrie~~nvsim~~nwArr~~nwarhk~~nwarr~~nwarrow~~nwnear~~oS~~oast~~ocir~~ocy~~odash~~odblac~~odiv~~odot~~odsold~~ofcir~~ofr~~ogon~~ogt~~ohbar~~ohm~~oint~~olarr~~olcir~~olcross~~olt~~omacr~~omid~~ominus~~oopf~~opar~~operp~~orarr~~ord~~order~~orderof~~origof~~oror~~orslope~~orv~~oscr~~osol~~otimesas~~ovbar~~par~~parallel~~parsim~~parsl~~pcy~~percnt~%~period~.~pertenk~~pfr~~phiv~~phmmat~~phone~~pitchfork~~planck~~planckh~~plankv~~plus~+~plusacir~~plusb~~pluscir~~plusdo~~plusdu~~pluse~~plussim~~plustwo~~pm~~pointint~~popf~~pr~~prE~~prap~~prcue~~pre~~prec~~precapprox~~preccurlyeq~~preceq~~precnapprox~~precneqq~~precnsim~~precsim~~primes~~prnE~~prnap~~prnsim~~profalar~~profline~~profsurf~~propto~~prsim~~prurel~~pscr~~puncsp~~qfr~~qint~~qopf~~qprime~~qscr~~quaternions~~quatint~~quest~?~questeq~~rAarr~~rAtail~~rBarr~~rHar~~race~~racute~~raemptyv~~rangd~~range~~rangle~~rarrap~~rarrb~~rarrbfs~~rarrc~~rarrfs~~rarrhk~~rarrlp~~rarrpl~~rarrsim~~rarrtl~~rarrw~~ratail~~ratio~~rationals~~rbarr~~rbbrk~~rbrace~}~rbrack~]~rbrke~~rbrksld~~rbrkslu~~rcaron~~rcedil~~rcub~}~rcy~~rdca~~rdldhar~~rdquor~~rdsh~~realine~~realpart~~reals~~rect~~rfisht~~rfr~~rhard~~rharu~~rharul~~rhov~~rightarrow~~rightarrowtail~~rightharpoondown~~rightharpoonup~~rightleftarrows~~rightleftharpoons~~rightrightarrows~~rightsquigarrow~~rightthreetimes~~ring~~risingdotseq~~rlarr~~rlhar~~rmoust~~rmoustache~~rnmid~~roang~~roarr~~robrk~~ropar~~ropf~~roplus~~rotimes~~rpar~)~rpargt~~rppolint~~rrarr~~rscr~~rsh~~rsqb~]~rsquor~~rthree~~rtimes~~rtri~~rtrie~~rtrif~~rtriltri~~ruluhar~~rx~~sacute~~sc~~scE~~scap~~sccue~~sce~~scedil~~scirc~~scnE~~scnap~~scnsim~~scpolint~~scsim~~scy~~sdotb~~sdote~~seArr~~searhk~~searr~~searrow~~semi~;~seswar~~setminus~~setmn~~sext~~sfr~~sfrown~~sharp~~shchcy~~shcy~~shortmid~~shortparallel~~sigmav~~simdot~~sime~~simeq~~simg~~simgE~~siml~~simlE~~simne~~simplus~~simrarr~~slarr~~smallsetminus~~smashp~~smeparsl~~smid~~smile~~smt~~smte~~smtes~~softcy~~sol~/~solb~~solbar~~sopf~~spadesuit~~spar~~sqcap~~sqcaps~~sqcup~~sqcups~~sqsub~~sqsube~~sqsubset~~sqsubseteq~~sqsup~~sqsupe~~sqsupset~~sqsupseteq~~squ~~square~~squarf~~squf~~srarr~~sscr~~ssetmn~~ssmile~~sstarf~~star~~starf~~straightepsilon~~straightphi~~strns~~subE~~subdot~~subedot~~submult~~subnE~~subne~~subplus~~subrarr~~subset~~subseteq~~subseteqq~~subsetneq~~subsetneqq~~subsim~~subsub~~subsup~~succ~~succapprox~~succcurlyeq~~succeq~~succnapprox~~succneqq~~succnsim~~succsim~~sung~~supE~~supdot~~supdsub~~supedot~~suphsol~~suphsub~~suplarr~~supmult~~supnE~~supne~~supplus~~supset~~supseteq~~supseteqq~~supsetneq~~supsetneqq~~supsim~~supsub~~supsup~~swArr~~swarhk~~swarr~~swarrow~~swnwar~~target~~tbrk~~tcaron~~tcedil~~tcy~~tdot~~telrec~~tfr~~therefore~~thetav~~thickapprox~~thicksim~~thkap~~thksim~~timesb~~timesbar~~timesd~~tint~~toea~~top~~topbot~~topcir~~topf~~topfork~~tosa~~tprime~~triangle~~triangledown~~triangleleft~~trianglelefteq~~triangleq~~triangleright~~trianglerighteq~~tridot~~trie~~triminus~~triplus~~trisb~~tritime~~trpezium~~tscr~~tscy~~tshcy~~tstrok~~twixt~~twoheadleftarrow~~twoheadrightarrow~~uHar~~ubrcy~~ubreve~~ucy~~udarr~~udblac~~udhar~~ufisht~~ufr~~uharl~~uharr~~uhblk~~ulcorn~~ulcorner~~ulcrop~~ultri~~umacr~~uogon~~uopf~~uparrow~~updownarrow~~upharpoonleft~~upharpoonright~~uplus~~upsi~~upuparrows~~urcorn~~urcorner~~urcrop~~uring~~urtri~~uscr~~utdot~~utilde~~utri~~utrif~~uuarr~~uwangle~~vArr~~vBar~~vBarv~~vDash~~vangrt~~varepsilon~~varkappa~~varnothing~~varphi~~varpi~~varpropto~~varr~~varrho~~varsigma~~varsubsetneq~~varsubsetneqq~~varsupsetneq~~varsupsetneqq~~vartheta~~vartriangleleft~~vartriangleright~~vcy~~vdash~~vee~~veebar~~veeeq~~vellip~~verbar~|~vert~|~vfr~~vltri~~vnsub~~vnsup~~vopf~~vprop~~vrtri~~vscr~~vsubnE~~vsubne~~vsupnE~~vsupne~~vzigzag~~wcirc~~wedbar~~wedge~~wedgeq~~wfr~~wopf~~wp~~wr~~wreath~~wscr~~xcap~~xcirc~~xcup~~xdtri~~xfr~~xhArr~~xharr~~xlArr~~xlarr~~xmap~~xnis~~xodot~~xopf~~xoplus~~xotime~~xrArr~~xrarr~~xscr~~xsqcup~~xuplus~~xutri~~xvee~~xwedge~~yacy~~ycirc~~ycy~~yfr~~yicy~~yopf~~yscr~~yucy~~zacute~~zcaron~~zcy~~zdot~~zeetrf~~zfr~~zhcy~~zigrarr~~zopf~~zscr~~~AMP~&~COPY~~GT~>~LT~<~QUOT~\"~REG~", exports.namedReferences['html4']);
//# sourceMappingURL=named-references.js.map

/***/ }),

/***/ "./node_modules/html-entities/dist/commonjs/numeric-unicode-map.js":
/*!*************************************************************************!*\
  !*** ./node_modules/html-entities/dist/commonjs/numeric-unicode-map.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.numericUnicodeMap = void 0;
exports.numericUnicodeMap = {
    0: 65533,
    128: 8364,
    130: 8218,
    131: 402,
    132: 8222,
    133: 8230,
    134: 8224,
    135: 8225,
    136: 710,
    137: 8240,
    138: 352,
    139: 8249,
    140: 338,
    142: 381,
    145: 8216,
    146: 8217,
    147: 8220,
    148: 8221,
    149: 8226,
    150: 8211,
    151: 8212,
    152: 732,
    153: 8482,
    154: 353,
    155: 8250,
    156: 339,
    158: 382,
    159: 376
};
//# sourceMappingURL=numeric-unicode-map.js.map

/***/ }),

/***/ "./node_modules/html-entities/dist/commonjs/surrogate-pairs.js":
/*!*********************************************************************!*\
  !*** ./node_modules/html-entities/dist/commonjs/surrogate-pairs.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.highSurrogateTo = exports.highSurrogateFrom = exports.getCodePoint = exports.fromCodePoint = void 0;
exports.fromCodePoint = String.fromCodePoint ||
    function (astralCodePoint) {
        return String.fromCharCode(Math.floor((astralCodePoint - 0x10000) / 0x400) + 0xd800, ((astralCodePoint - 0x10000) % 0x400) + 0xdc00);
    };
// @ts-expect-error - String.prototype.codePointAt might not exist in older node versions
exports.getCodePoint = String.prototype.codePointAt
    ? function (input, position) {
        return input.codePointAt(position);
    }
    : function (input, position) {
        return (input.charCodeAt(position) - 0xd800) * 0x400 + input.charCodeAt(position + 1) - 0xdc00 + 0x10000;
    };
exports.highSurrogateFrom = 0xd800;
exports.highSurrogateTo = 0xdbff;
//# sourceMappingURL=surrogate-pairs.js.map

/***/ }),

/***/ "./node_modules/io-ts-reporters/target/src/index.js":
/*!**********************************************************!*\
  !*** ./node_modules/io-ts-reporters/target/src/index.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.reporter = exports.formatValidationErrors = exports.formatValidationError = exports.TYPE_MAX_LEN = void 0;
/**
 * An [io-ts Reporter](https://gcanti.github.io/io-ts/modules/Reporter.ts.html#reporter-interface).
 *
 * @example
 *
 * import * as t from 'io-ts';
 * import Reporter from 'io-ts-reporters';
 *
 * const User = t.interface({ name: t.string });
 *
 * assert.deepEqual(
 *   Reporter.report(User.decode({ nam: 'Jane' })),
 *   ['Expecting string at name but instead got: undefined'],
 * )
 * assert.deepEqual( Reporter.report(User.decode({ name: 'Jane' })), [])
 *
 * @since 1.2.0
 */
var A = __webpack_require__(/*! fp-ts/Array */ "./node_modules/fp-ts/es6/Array.js");
var E = __webpack_require__(/*! fp-ts/Either */ "./node_modules/fp-ts/es6/Either.js");
var NEA = __webpack_require__(/*! fp-ts/NonEmptyArray */ "./node_modules/fp-ts/es6/NonEmptyArray.js");
var O = __webpack_require__(/*! fp-ts/Option */ "./node_modules/fp-ts/es6/Option.js");
var R = __webpack_require__(/*! fp-ts/Record */ "./node_modules/fp-ts/es6/Record.js");
var pipeable_1 = __webpack_require__(/*! fp-ts/pipeable */ "./node_modules/fp-ts/es6/pipeable.js");
var t = __webpack_require__(/*! io-ts */ "./node_modules/io-ts/es6/index.js");
var utils_1 = __webpack_require__(/*! ./utils */ "./node_modules/io-ts-reporters/target/src/utils.js");
var isUnionType = function (_a) {
    var type = _a.type;
    return type instanceof t.UnionType;
};
var jsToString = function (value) {
    return value === undefined ? 'undefined' : JSON.stringify(value);
};
var keyPath = function (ctx) {
    // The context entry with an empty key is the original
    // type ("default context"), not a type error.
    return ctx
        .map(function (c) { return c.key; })
        .filter(Boolean)
        .join('.');
};
// The actual error is last in context
var getErrorFromCtx = function (validation) {
    // https://github.com/gcanti/fp-ts/pull/544/files
    return A.last(validation.context);
};
var getValidationContext = function (validation) {
    // https://github.com/gcanti/fp-ts/pull/544/files
    return validation.context;
};
/**
 * @category internals
 * @since 1.2.1
 */
exports.TYPE_MAX_LEN = 160; // Two lines of 80-col text
var truncateType = function (type, options) {
    if (options === void 0) { options = {}; }
    var _a = options.truncateLongTypes, truncateLongTypes = _a === void 0 ? true : _a;
    if (truncateLongTypes && type.length > exports.TYPE_MAX_LEN) {
        return type.slice(0, exports.TYPE_MAX_LEN - 3) + "...";
    }
    return type;
};
var errorMessageSimple = function (expectedType, path, error, options) {
    // https://github.com/elm-lang/core/blob/18c9e84e975ed22649888bfad15d1efdb0128ab2/src/Native/Json.js#L199
    return [
        "Expecting " + truncateType(expectedType, options),
        path === '' ? '' : "at " + path,
        "but instead got: " + jsToString(error.value),
        error.message ? "(" + error.message + ")" : '',
    ]
        .filter(Boolean)
        .join(' ');
};
var errorMessageUnion = function (expectedTypes, path, value, options) {
    // https://github.com/elm-lang/core/blob/18c9e84e975ed22649888bfad15d1efdb0128ab2/src/Native/Json.js#L199
    return [
        'Expecting one of:\n',
        expectedTypes
            .map(function (type) { return "    " + truncateType(type, options); })
            .join('\n'),
        path === '' ? '\n' : "\nat " + path + " ",
        "but instead got: " + jsToString(value),
    ]
        .filter(Boolean)
        .join('');
};
// Find the union type in the list of ContextEntry
// The next ContextEntry should be the type of this branch of the union
var findExpectedType = function (ctx) {
    return pipeable_1.pipe(ctx, A.findIndex(isUnionType), O.chain(function (n) { return A.lookup(n + 1, ctx); }));
};
var formatValidationErrorOfUnion = function (path, errors, options) {
    var expectedTypes = pipeable_1.pipe(errors, A.map(getValidationContext), A.map(findExpectedType), A.compact);
    var value = pipeable_1.pipe(expectedTypes, A.head, O.map(function (v) { return v.actual; }), O.getOrElse(function () { return undefined; }));
    var expected = expectedTypes.map(function (_a) {
        var type = _a.type;
        return type.name;
    });
    return expected.length > 0
        ? O.some(errorMessageUnion(expected, path, value, options))
        : O.none;
};
var formatValidationCommonError = function (path, error, options) {
    return pipeable_1.pipe(error, getErrorFromCtx, O.map(function (errorContext) {
        return errorMessageSimple(errorContext.type.name, path, error, options);
    }));
};
var groupByKey = NEA.groupBy(function (error) {
    return pipeable_1.pipe(error.context, utils_1.takeUntil(isUnionType), keyPath);
});
var format = function (path, errors, options) {
    return NEA.tail(errors).length > 0
        ? formatValidationErrorOfUnion(path, errors, options)
        : formatValidationCommonError(path, NEA.head(errors), options);
};
/**
 * Format a single validation error.
 *
 * @category formatters
 * @since 1.0.0
 */
var formatValidationError = function (error, options) { return formatValidationCommonError(keyPath(error.context), error, options); };
exports.formatValidationError = formatValidationError;
/**
 * Format validation errors (`t.Errors`).
 *
 * @example
 * import * as E from 'fp-ts/Either'
 * import * as t from 'io-ts'
 * import { formatValidationErrors } from 'io-ts-reporters'
 *
 * const result = t.string.decode(123)
 *
 * assert.deepEqual(
 *   E.mapLeft(formatValidationErrors)(result),
 *   E.left(['Expecting string but instead got: 123'])
 * )
 *
 * @category formatters
 * @since 1.2.0
 */
var formatValidationErrors = function (errors, options) {
    return pipeable_1.pipe(errors, groupByKey, R.mapWithIndex(function (path, errors) { return format(path, errors, options); }), R.compact, R.toArray, A.map(function (_a) {
        var _key = _a[0], error = _a[1];
        return error;
    }));
};
exports.formatValidationErrors = formatValidationErrors;
/**
 * Deprecated, use the default export instead.
 *
 * @category deprecated
 * @deprecated
 * @since 1.0.0
 */
var reporter = function (validation, options) {
    return pipeable_1.pipe(validation, E.mapLeft(function (errors) { return exports.formatValidationErrors(errors, options); }), E.fold(function (errors) { return errors; }, function () { return []; }));
};
exports.reporter = reporter;
var prettyReporter = { report: exports.reporter };
exports["default"] = prettyReporter;
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/io-ts-reporters/target/src/utils.js":
/*!**********************************************************!*\
  !*** ./node_modules/io-ts-reporters/target/src/utils.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.takeUntil = void 0;
/**
 * @since 1.1.0
 */
/* eslint-disable @typescript-eslint/array-type */
var takeUntil = function (predicate) {
    return function (as) {
        var init = [];
        // eslint-disable-next-line unicorn/no-for-loop
        for (var i = 0; i < as.length; i++) {
            init[i] = as[i];
            if (predicate(as[i])) {
                return init;
            }
        }
        return init;
    };
};
exports.takeUntil = takeUntil;
/* eslint-enable @typescript-eslint/array-type */
//# sourceMappingURL=utils.js.map

/***/ }),

/***/ "./node_modules/io-ts/es6/index.js":
/*!*****************************************!*\
  !*** ./node_modules/io-ts/es6/index.js ***!
  \*****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   AnyArrayType: () => (/* binding */ AnyArrayType),
/* harmony export */   AnyDictionaryType: () => (/* binding */ AnyDictionaryType),
/* harmony export */   AnyType: () => (/* binding */ AnyType),
/* harmony export */   Array: () => (/* binding */ UnknownArray),
/* harmony export */   ArrayType: () => (/* binding */ ArrayType),
/* harmony export */   BigIntType: () => (/* binding */ BigIntType),
/* harmony export */   BooleanType: () => (/* binding */ BooleanType),
/* harmony export */   Dictionary: () => (/* binding */ Dictionary),
/* harmony export */   DictionaryType: () => (/* binding */ DictionaryType),
/* harmony export */   ExactType: () => (/* binding */ ExactType),
/* harmony export */   Function: () => (/* binding */ Function),
/* harmony export */   FunctionType: () => (/* binding */ FunctionType),
/* harmony export */   Int: () => (/* binding */ Int),
/* harmony export */   Integer: () => (/* binding */ Integer),
/* harmony export */   InterfaceType: () => (/* binding */ InterfaceType),
/* harmony export */   IntersectionType: () => (/* binding */ IntersectionType),
/* harmony export */   KeyofType: () => (/* binding */ KeyofType),
/* harmony export */   LiteralType: () => (/* binding */ LiteralType),
/* harmony export */   NeverType: () => (/* binding */ NeverType),
/* harmony export */   NullType: () => (/* binding */ NullType),
/* harmony export */   NumberType: () => (/* binding */ NumberType),
/* harmony export */   ObjectType: () => (/* binding */ ObjectType),
/* harmony export */   PartialType: () => (/* binding */ PartialType),
/* harmony export */   ReadonlyArrayType: () => (/* binding */ ReadonlyArrayType),
/* harmony export */   ReadonlyType: () => (/* binding */ ReadonlyType),
/* harmony export */   RecursiveType: () => (/* binding */ RecursiveType),
/* harmony export */   RefinementType: () => (/* binding */ RefinementType),
/* harmony export */   StrictType: () => (/* binding */ StrictType),
/* harmony export */   StringType: () => (/* binding */ StringType),
/* harmony export */   TaggedUnionType: () => (/* binding */ TaggedUnionType),
/* harmony export */   TupleType: () => (/* binding */ TupleType),
/* harmony export */   Type: () => (/* binding */ Type),
/* harmony export */   UndefinedType: () => (/* binding */ UndefinedType),
/* harmony export */   UnionType: () => (/* binding */ UnionType),
/* harmony export */   UnknownArray: () => (/* binding */ UnknownArray),
/* harmony export */   UnknownRecord: () => (/* binding */ UnknownRecord),
/* harmony export */   UnknownType: () => (/* binding */ UnknownType),
/* harmony export */   VoidType: () => (/* binding */ VoidType),
/* harmony export */   alias: () => (/* binding */ alias),
/* harmony export */   any: () => (/* binding */ any),
/* harmony export */   appendContext: () => (/* binding */ appendContext),
/* harmony export */   array: () => (/* binding */ array),
/* harmony export */   bigint: () => (/* binding */ bigint),
/* harmony export */   boolean: () => (/* binding */ boolean),
/* harmony export */   brand: () => (/* binding */ brand),
/* harmony export */   clean: () => (/* binding */ clean),
/* harmony export */   dictionary: () => (/* binding */ dictionary),
/* harmony export */   emptyTags: () => (/* binding */ emptyTags),
/* harmony export */   exact: () => (/* binding */ exact),
/* harmony export */   failure: () => (/* binding */ failure),
/* harmony export */   failures: () => (/* binding */ failures),
/* harmony export */   getContextEntry: () => (/* binding */ getContextEntry),
/* harmony export */   getDefaultContext: () => (/* binding */ getDefaultContext),
/* harmony export */   getDomainKeys: () => (/* binding */ getDomainKeys),
/* harmony export */   getFunctionName: () => (/* binding */ getFunctionName),
/* harmony export */   getIndex: () => (/* binding */ getIndex),
/* harmony export */   getTags: () => (/* binding */ getTags),
/* harmony export */   getValidationError: () => (/* binding */ getValidationError),
/* harmony export */   identity: () => (/* binding */ identity),
/* harmony export */   "interface": () => (/* binding */ type),
/* harmony export */   intersection: () => (/* binding */ intersection),
/* harmony export */   keyof: () => (/* binding */ keyof),
/* harmony export */   literal: () => (/* binding */ literal),
/* harmony export */   mergeAll: () => (/* binding */ mergeAll),
/* harmony export */   never: () => (/* binding */ never),
/* harmony export */   "null": () => (/* binding */ nullType),
/* harmony export */   nullType: () => (/* binding */ nullType),
/* harmony export */   number: () => (/* binding */ number),
/* harmony export */   object: () => (/* binding */ object),
/* harmony export */   partial: () => (/* binding */ partial),
/* harmony export */   readonly: () => (/* binding */ readonly),
/* harmony export */   readonlyArray: () => (/* binding */ readonlyArray),
/* harmony export */   record: () => (/* binding */ record),
/* harmony export */   recursion: () => (/* binding */ recursion),
/* harmony export */   refinement: () => (/* binding */ refinement),
/* harmony export */   strict: () => (/* binding */ strict),
/* harmony export */   string: () => (/* binding */ string),
/* harmony export */   success: () => (/* binding */ success),
/* harmony export */   taggedUnion: () => (/* binding */ taggedUnion),
/* harmony export */   tuple: () => (/* binding */ tuple),
/* harmony export */   type: () => (/* binding */ type),
/* harmony export */   undefined: () => (/* binding */ undefinedType),
/* harmony export */   union: () => (/* binding */ union),
/* harmony export */   unknown: () => (/* binding */ unknown),
/* harmony export */   "void": () => (/* binding */ voidType),
/* harmony export */   voidType: () => (/* binding */ voidType)
/* harmony export */ });
/* harmony import */ var fp_ts_es6_Either__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! fp-ts/es6/Either */ "./node_modules/fp-ts/es6/Either.js");
var __extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __assign = (undefined && undefined.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __spreadArray = (undefined && undefined.__spreadArray) || function (to, from, pack) {
    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
        }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
};
/**
 * @since 1.0.0
 */

/**
 * @category Decode error
 * @since 1.0.0
 */
var failures = fp_ts_es6_Either__WEBPACK_IMPORTED_MODULE_0__.left;
/**
 * @category Decode error
 * @since 1.0.0
 */
var failure = function (value, context, message) {
    return failures([{ value: value, context: context, message: message }]);
};
/**
 * @category Decode error
 * @since 1.0.0
 */
var success = fp_ts_es6_Either__WEBPACK_IMPORTED_MODULE_0__.right;
/**
 * @category Codec
 * @since 1.0.0
 */
var Type = /** @class */ (function () {
    function Type(
    /** a unique name for this codec */
    name, 
    /** a custom type guard */
    is, 
    /** succeeds if a value of type I can be decoded to a value of type A */
    validate, 
    /** converts a value of type A to a value of type O */
    encode) {
        this.name = name;
        this.is = is;
        this.validate = validate;
        this.encode = encode;
        this.decode = this.decode.bind(this);
    }
    /**
     * @since 1.0.0
     */
    Type.prototype.pipe = function (ab, name) {
        var _this = this;
        if (name === void 0) { name = "pipe(".concat(this.name, ", ").concat(ab.name, ")"); }
        return new Type(name, ab.is, function (i, c) {
            var e = _this.validate(i, c);
            if ((0,fp_ts_es6_Either__WEBPACK_IMPORTED_MODULE_0__.isLeft)(e)) {
                return e;
            }
            return ab.validate(e.right, c);
        }, this.encode === identity && ab.encode === identity ? identity : function (b) { return _this.encode(ab.encode(b)); });
    };
    /**
     * @since 1.0.0
     */
    Type.prototype.asDecoder = function () {
        return this;
    };
    /**
     * @since 1.0.0
     */
    Type.prototype.asEncoder = function () {
        return this;
    };
    /**
     * a version of `validate` with a default context
     * @since 1.0.0
     */
    Type.prototype.decode = function (i) {
        return this.validate(i, [{ key: '', type: this, actual: i }]);
    };
    return Type;
}());

// -------------------------------------------------------------------------------------
// utils
// -------------------------------------------------------------------------------------
/**
 * @since 1.0.0
 */
var identity = function (a) { return a; };
/**
 * @since 1.0.0
 */
function getFunctionName(f) {
    return f.displayName || f.name || "<function".concat(f.length, ">");
}
/**
 * @since 1.0.0
 */
function getContextEntry(key, decoder) {
    return { key: key, type: decoder };
}
/**
 * @since 1.0.0
 */
function appendContext(c, key, decoder, actual) {
    var len = c.length;
    var r = Array(len + 1);
    for (var i = 0; i < len; i++) {
        r[i] = c[i];
    }
    r[len] = { key: key, type: decoder, actual: actual };
    return r;
}
function pushAll(xs, ys) {
    var l = ys.length;
    for (var i = 0; i < l; i++) {
        xs.push(ys[i]);
    }
}
var hasOwnProperty = Object.prototype.hasOwnProperty;
function getNameFromProps(props) {
    return Object.keys(props)
        .map(function (k) { return "".concat(k, ": ").concat(props[k].name); })
        .join(', ');
}
function useIdentity(codecs) {
    for (var i = 0; i < codecs.length; i++) {
        if (codecs[i].encode !== identity) {
            return false;
        }
    }
    return true;
}
function getInterfaceTypeName(props) {
    return "{ ".concat(getNameFromProps(props), " }");
}
function getPartialTypeName(inner) {
    return "Partial<".concat(inner, ">");
}
function enumerableRecord(keys, domain, codomain, name) {
    if (name === void 0) { name = "{ [K in ".concat(domain.name, "]: ").concat(codomain.name, " }"); }
    var len = keys.length;
    var props = {};
    for (var i = 0; i < len; i++) {
        props[keys[i]] = codomain;
    }
    var exactCodec = strict(props, name);
    return new DictionaryType(name, function (u) { return exactCodec.is(u); }, exactCodec.validate, exactCodec.encode, domain, codomain);
}
/**
 * @internal
 */
function getDomainKeys(domain) {
    var _a;
    if (isLiteralC(domain)) {
        var literal_1 = domain.value;
        if (string.is(literal_1)) {
            return _a = {}, _a[literal_1] = null, _a;
        }
    }
    else if (isKeyofC(domain)) {
        return domain.keys;
    }
    else if (isUnionC(domain)) {
        var keys = domain.types.map(function (type) { return getDomainKeys(type); });
        return keys.some(undefinedType.is) ? undefined : Object.assign.apply(Object, __spreadArray([{}], keys, false));
    }
    return undefined;
}
function stripNonDomainKeys(o, domain) {
    var keys = Object.keys(o);
    var len = keys.length;
    var shouldStrip = false;
    var r = {};
    for (var i = 0; i < len; i++) {
        var k = keys[i];
        if (domain.is(k)) {
            r[k] = o[k];
        }
        else {
            shouldStrip = true;
        }
    }
    return shouldStrip ? r : o;
}
function nonEnumerableRecord(domain, codomain, name) {
    if (name === void 0) { name = "{ [K in ".concat(domain.name, "]: ").concat(codomain.name, " }"); }
    return new DictionaryType(name, function (u) {
        if (UnknownRecord.is(u)) {
            return Object.keys(u).every(function (k) { return !domain.is(k) || codomain.is(u[k]); });
        }
        return isAnyC(codomain) && Array.isArray(u);
    }, function (u, c) {
        if (UnknownRecord.is(u)) {
            var a = {};
            var errors = [];
            var keys = Object.keys(u);
            var len = keys.length;
            var changed = false;
            for (var i = 0; i < len; i++) {
                var k = keys[i];
                var ok = u[k];
                var domainResult = domain.validate(k, appendContext(c, k, domain, k));
                if ((0,fp_ts_es6_Either__WEBPACK_IMPORTED_MODULE_0__.isLeft)(domainResult)) {
                    changed = true;
                }
                else {
                    var vk = domainResult.right;
                    changed = changed || vk !== k;
                    k = vk;
                    var codomainResult = codomain.validate(ok, appendContext(c, k, codomain, ok));
                    if ((0,fp_ts_es6_Either__WEBPACK_IMPORTED_MODULE_0__.isLeft)(codomainResult)) {
                        pushAll(errors, codomainResult.left);
                    }
                    else {
                        var vok = codomainResult.right;
                        changed = changed || vok !== ok;
                        a[k] = vok;
                    }
                }
            }
            return errors.length > 0 ? failures(errors) : success((changed ? a : u));
        }
        if (isAnyC(codomain) && Array.isArray(u)) {
            return success(u);
        }
        return failure(u, c);
    }, domain.encode === identity && codomain.encode === identity
        ? function (a) { return stripNonDomainKeys(a, domain); }
        : function (a) {
            var s = {};
            var keys = Object.keys(stripNonDomainKeys(a, domain));
            var len = keys.length;
            for (var i = 0; i < len; i++) {
                var k = keys[i];
                s[String(domain.encode(k))] = codomain.encode(a[k]);
            }
            return s;
        }, domain, codomain);
}
function getUnionName(codecs) {
    return '(' + codecs.map(function (type) { return type.name; }).join(' | ') + ')';
}
/**
 * @internal
 */
// eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types
function mergeAll(base, us) {
    var equal = true;
    var primitive = true;
    var baseIsNotADictionary = !UnknownRecord.is(base);
    for (var _i = 0, us_1 = us; _i < us_1.length; _i++) {
        var u = us_1[_i];
        if (u !== base) {
            equal = false;
        }
        if (UnknownRecord.is(u)) {
            primitive = false;
        }
    }
    if (equal) {
        return base;
    }
    else if (primitive) {
        return us[us.length - 1];
    }
    var r = {};
    for (var _a = 0, us_2 = us; _a < us_2.length; _a++) {
        var u = us_2[_a];
        for (var k in u) {
            if (!hasOwnProperty.call(r, k) || baseIsNotADictionary || u[k] !== base[k]) {
                r[k] = u[k];
            }
        }
    }
    return r;
}
function getProps(codec) {
    switch (codec._tag) {
        case 'RefinementType':
        case 'ReadonlyType':
            return getProps(codec.type);
        case 'InterfaceType':
        case 'StrictType':
        case 'PartialType':
            return codec.props;
        case 'IntersectionType':
            return codec.types.reduce(function (props, type) { return Object.assign(props, getProps(type)); }, {});
    }
}
function stripKeys(o, props) {
    var keys = Object.getOwnPropertyNames(o);
    var shouldStrip = false;
    var r = {};
    for (var i = 0; i < keys.length; i++) {
        var key = keys[i];
        if (!hasOwnProperty.call(props, key)) {
            shouldStrip = true;
        }
        else {
            r[key] = o[key];
        }
    }
    return shouldStrip ? r : o;
}
function getExactTypeName(codec) {
    if (isTypeC(codec)) {
        return "{| ".concat(getNameFromProps(codec.props), " |}");
    }
    else if (isPartialC(codec)) {
        return getPartialTypeName("{| ".concat(getNameFromProps(codec.props), " |}"));
    }
    return "Exact<".concat(codec.name, ">");
}
function isNonEmpty(as) {
    return as.length > 0;
}
/**
 * @internal
 */
var emptyTags = {};
function intersect(a, b) {
    var r = [];
    for (var _i = 0, a_1 = a; _i < a_1.length; _i++) {
        var v = a_1[_i];
        if (b.indexOf(v) !== -1) {
            r.push(v);
        }
    }
    return r;
}
function mergeTags(a, b) {
    if (a === emptyTags) {
        return b;
    }
    if (b === emptyTags) {
        return a;
    }
    var r = Object.assign({}, a);
    for (var k in b) {
        if (hasOwnProperty.call(a, k)) {
            var intersection_1 = intersect(a[k], b[k]);
            if (isNonEmpty(intersection_1)) {
                r[k] = intersection_1;
            }
            else {
                r = emptyTags;
                break;
            }
        }
        else {
            r[k] = b[k];
        }
    }
    return r;
}
function intersectTags(a, b) {
    if (a === emptyTags || b === emptyTags) {
        return emptyTags;
    }
    var r = emptyTags;
    for (var k in a) {
        if (hasOwnProperty.call(b, k)) {
            var intersection_2 = intersect(a[k], b[k]);
            if (intersection_2.length === 0) {
                if (r === emptyTags) {
                    r = {};
                }
                r[k] = a[k].concat(b[k]);
            }
        }
    }
    return r;
}
// tslint:disable-next-line: deprecation
function isAnyC(codec) {
    return codec._tag === 'AnyType';
}
function isLiteralC(codec) {
    return codec._tag === 'LiteralType';
}
function isKeyofC(codec) {
    return codec._tag === 'KeyofType';
}
function isTypeC(codec) {
    return codec._tag === 'InterfaceType';
}
function isPartialC(codec) {
    return codec._tag === 'PartialType';
}
// tslint:disable-next-line: deprecation
function isStrictC(codec) {
    return codec._tag === 'StrictType';
}
function isExactC(codec) {
    return codec._tag === 'ExactType';
}
// tslint:disable-next-line: deprecation
function isRefinementC(codec) {
    return codec._tag === 'RefinementType';
}
function isIntersectionC(codec) {
    return codec._tag === 'IntersectionType';
}
function isUnionC(codec) {
    return codec._tag === 'UnionType';
}
function isRecursiveC(codec) {
    return codec._tag === 'RecursiveType';
}
function isReadonlyC(codec) {
    return codec._tag === 'ReadonlyType';
}
var lazyCodecs = [];
/**
 * @internal
 */
function getTags(codec) {
    if (lazyCodecs.indexOf(codec) !== -1) {
        return emptyTags;
    }
    if (isTypeC(codec) || isStrictC(codec)) {
        var index = emptyTags;
        // tslint:disable-next-line: forin
        for (var k in codec.props) {
            var prop = codec.props[k];
            if (isLiteralC(prop)) {
                if (index === emptyTags) {
                    index = {};
                }
                index[k] = [prop.value];
            }
        }
        return index;
    }
    else if (isExactC(codec) || isRefinementC(codec) || isReadonlyC(codec)) {
        return getTags(codec.type);
    }
    else if (isIntersectionC(codec)) {
        return codec.types.reduce(function (tags, codec) { return mergeTags(tags, getTags(codec)); }, emptyTags);
    }
    else if (isUnionC(codec)) {
        return codec.types.slice(1).reduce(function (tags, codec) { return intersectTags(tags, getTags(codec)); }, getTags(codec.types[0]));
    }
    else if (isRecursiveC(codec)) {
        lazyCodecs.push(codec);
        var tags = getTags(codec.type);
        lazyCodecs.pop();
        return tags;
    }
    return emptyTags;
}
/**
 * @internal
 */
function getIndex(codecs) {
    var tags = getTags(codecs[0]);
    var keys = Object.keys(tags);
    var len = codecs.length;
    var _loop_1 = function (k) {
        var all = tags[k].slice();
        var index = [tags[k]];
        for (var i = 1; i < len; i++) {
            var codec = codecs[i];
            var ctags = getTags(codec);
            var values = ctags[k];
            // tslint:disable-next-line: strict-type-predicates
            if (values === undefined) {
                return "continue-keys";
            }
            else {
                if (values.some(function (v) { return all.indexOf(v) !== -1; })) {
                    return "continue-keys";
                }
                else {
                    all.push.apply(all, values);
                    index.push(values);
                }
            }
        }
        return { value: [k, index] };
    };
    keys: for (var _i = 0, keys_1 = keys; _i < keys_1.length; _i++) {
        var k = keys_1[_i];
        var state_1 = _loop_1(k);
        if (typeof state_1 === "object")
            return state_1.value;
        switch (state_1) {
            case "continue-keys": continue keys;
        }
    }
    return undefined;
}
// -------------------------------------------------------------------------------------
// primitives
// -------------------------------------------------------------------------------------
/**
 * @since 1.0.0
 */
var NullType = /** @class */ (function (_super) {
    __extends(NullType, _super);
    function NullType() {
        var _this = _super.call(this, 'null', function (u) { return u === null; }, function (u, c) { return (_this.is(u) ? success(u) : failure(u, c)); }, identity) || this;
        /**
         * @since 1.0.0
         */
        _this._tag = 'NullType';
        return _this;
    }
    return NullType;
}(Type));

/**
 * @category primitives
 * @since 1.0.0
 */
var nullType = new NullType();
/**
 * @since 1.0.0
 */
var UndefinedType = /** @class */ (function (_super) {
    __extends(UndefinedType, _super);
    function UndefinedType() {
        var _this = _super.call(this, 'undefined', function (u) { return u === void 0; }, function (u, c) { return (_this.is(u) ? success(u) : failure(u, c)); }, identity) || this;
        /**
         * @since 1.0.0
         */
        _this._tag = 'UndefinedType';
        return _this;
    }
    return UndefinedType;
}(Type));

var undefinedType = new UndefinedType();
/**
 * @since 1.2.0
 */
var VoidType = /** @class */ (function (_super) {
    __extends(VoidType, _super);
    function VoidType() {
        var _this = _super.call(this, 'void', undefinedType.is, undefinedType.validate, identity) || this;
        /**
         * @since 1.0.0
         */
        _this._tag = 'VoidType';
        return _this;
    }
    return VoidType;
}(Type));

/**
 * @category primitives
 * @since 1.2.0
 */
var voidType = new VoidType();
/**
 * @since 1.5.0
 */
var UnknownType = /** @class */ (function (_super) {
    __extends(UnknownType, _super);
    function UnknownType() {
        var _this = _super.call(this, 'unknown', function (_) { return true; }, success, identity) || this;
        /**
         * @since 1.0.0
         */
        _this._tag = 'UnknownType';
        return _this;
    }
    return UnknownType;
}(Type));

/**
 * @category primitives
 * @since 1.5.0
 */
var unknown = new UnknownType();
/**
 * @since 1.0.0
 */
var StringType = /** @class */ (function (_super) {
    __extends(StringType, _super);
    function StringType() {
        var _this = _super.call(this, 'string', function (u) { return typeof u === 'string'; }, function (u, c) { return (_this.is(u) ? success(u) : failure(u, c)); }, identity) || this;
        /**
         * @since 1.0.0
         */
        _this._tag = 'StringType';
        return _this;
    }
    return StringType;
}(Type));

/**
 * @category primitives
 * @since 1.0.0
 */
var string = new StringType();
/**
 * @since 1.0.0
 */
var NumberType = /** @class */ (function (_super) {
    __extends(NumberType, _super);
    function NumberType() {
        var _this = _super.call(this, 'number', function (u) { return typeof u === 'number'; }, function (u, c) { return (_this.is(u) ? success(u) : failure(u, c)); }, identity) || this;
        /**
         * @since 1.0.0
         */
        _this._tag = 'NumberType';
        return _this;
    }
    return NumberType;
}(Type));

/**
 * @category primitives
 * @since 1.0.0
 */
var number = new NumberType();
/**
 * @since 2.1.0
 */
var BigIntType = /** @class */ (function (_super) {
    __extends(BigIntType, _super);
    function BigIntType() {
        var _this = _super.call(this, 'bigint', 
        // tslint:disable-next-line: valid-typeof
        function (u) { return typeof u === 'bigint'; }, function (u, c) { return (_this.is(u) ? success(u) : failure(u, c)); }, identity) || this;
        /**
         * @since 1.0.0
         */
        _this._tag = 'BigIntType';
        return _this;
    }
    return BigIntType;
}(Type));

/**
 * @category primitives
 * @since 2.1.0
 */
var bigint = new BigIntType();
/**
 * @since 1.0.0
 */
var BooleanType = /** @class */ (function (_super) {
    __extends(BooleanType, _super);
    function BooleanType() {
        var _this = _super.call(this, 'boolean', function (u) { return typeof u === 'boolean'; }, function (u, c) { return (_this.is(u) ? success(u) : failure(u, c)); }, identity) || this;
        /**
         * @since 1.0.0
         */
        _this._tag = 'BooleanType';
        return _this;
    }
    return BooleanType;
}(Type));

/**
 * @category primitives
 * @since 1.0.0
 */
var boolean = new BooleanType();
/**
 * @since 1.0.0
 */
var AnyArrayType = /** @class */ (function (_super) {
    __extends(AnyArrayType, _super);
    function AnyArrayType() {
        var _this = _super.call(this, 'UnknownArray', Array.isArray, function (u, c) { return (_this.is(u) ? success(u) : failure(u, c)); }, identity) || this;
        /**
         * @since 1.0.0
         */
        _this._tag = 'AnyArrayType';
        return _this;
    }
    return AnyArrayType;
}(Type));

/**
 * @category primitives
 * @since 1.7.1
 */
var UnknownArray = new AnyArrayType();
/**
 * @since 1.0.0
 */
var AnyDictionaryType = /** @class */ (function (_super) {
    __extends(AnyDictionaryType, _super);
    function AnyDictionaryType() {
        var _this = _super.call(this, 'UnknownRecord', function (u) { return u !== null && typeof u === 'object' && !Array.isArray(u); }, function (u, c) { return (_this.is(u) ? success(u) : failure(u, c)); }, identity) || this;
        /**
         * @since 1.0.0
         */
        _this._tag = 'AnyDictionaryType';
        return _this;
    }
    return AnyDictionaryType;
}(Type));

/**
 * @category primitives
 * @since 1.7.1
 */
var UnknownRecord = new AnyDictionaryType();

/**
 * @since 1.0.0
 */
var LiteralType = /** @class */ (function (_super) {
    __extends(LiteralType, _super);
    function LiteralType(name, is, validate, encode, value) {
        var _this = _super.call(this, name, is, validate, encode) || this;
        _this.value = value;
        /**
         * @since 1.0.0
         */
        _this._tag = 'LiteralType';
        return _this;
    }
    return LiteralType;
}(Type));

/**
 * @category constructors
 * @since 1.0.0
 */
function literal(value, name) {
    if (name === void 0) { name = JSON.stringify(value); }
    var is = function (u) { return u === value; };
    return new LiteralType(name, is, function (u, c) { return (is(u) ? success(value) : failure(u, c)); }, identity, value);
}
/**
 * @since 1.0.0
 */
var KeyofType = /** @class */ (function (_super) {
    __extends(KeyofType, _super);
    function KeyofType(name, is, validate, encode, keys) {
        var _this = _super.call(this, name, is, validate, encode) || this;
        _this.keys = keys;
        /**
         * @since 1.0.0
         */
        _this._tag = 'KeyofType';
        return _this;
    }
    return KeyofType;
}(Type));

/**
 * @category constructors
 * @since 1.0.0
 */
function keyof(keys, name) {
    if (name === void 0) { name = Object.keys(keys)
        .map(function (k) { return JSON.stringify(k); })
        .join(' | '); }
    var is = function (u) { return string.is(u) && hasOwnProperty.call(keys, u); };
    return new KeyofType(name, is, function (u, c) { return (is(u) ? success(u) : failure(u, c)); }, identity, keys);
}
// -------------------------------------------------------------------------------------
// combinators
// -------------------------------------------------------------------------------------
/**
 * @since 1.0.0
 */
var RefinementType = /** @class */ (function (_super) {
    __extends(RefinementType, _super);
    function RefinementType(name, is, validate, encode, type, predicate) {
        var _this = _super.call(this, name, is, validate, encode) || this;
        _this.type = type;
        _this.predicate = predicate;
        /**
         * @since 1.0.0
         */
        _this._tag = 'RefinementType';
        return _this;
    }
    return RefinementType;
}(Type));

/**
 * @category combinators
 * @since 1.8.1
 */
function brand(codec, predicate, name) {
    return refinement(codec, predicate, name);
}
/**
 * A branded codec representing an integer
 *
 * @category primitives
 * @since 1.8.1
 */
var Int = brand(number, function (n) { return Number.isInteger(n); }, 'Int');
/**
 * @since 1.0.0
 */
var RecursiveType = /** @class */ (function (_super) {
    __extends(RecursiveType, _super);
    function RecursiveType(name, is, validate, encode, runDefinition) {
        var _this = _super.call(this, name, is, validate, encode) || this;
        _this.runDefinition = runDefinition;
        /**
         * @since 1.0.0
         */
        _this._tag = 'RecursiveType';
        return _this;
    }
    return RecursiveType;
}(Type));

Object.defineProperty(RecursiveType.prototype, 'type', {
    get: function () {
        return this.runDefinition();
    },
    enumerable: true,
    configurable: true
});
/**
 * @category combinators
 * @since 1.0.0
 */
function recursion(name, definition) {
    var cache;
    var runDefinition = function () {
        if (!cache) {
            cache = definition(Self);
            cache.name = name;
        }
        return cache;
    };
    var Self = new RecursiveType(name, function (u) { return runDefinition().is(u); }, function (u, c) { return runDefinition().validate(u, c); }, function (a) { return runDefinition().encode(a); }, runDefinition);
    return Self;
}
/**
 * @since 1.0.0
 */
var ArrayType = /** @class */ (function (_super) {
    __extends(ArrayType, _super);
    function ArrayType(name, is, validate, encode, type) {
        var _this = _super.call(this, name, is, validate, encode) || this;
        _this.type = type;
        /**
         * @since 1.0.0
         */
        _this._tag = 'ArrayType';
        return _this;
    }
    return ArrayType;
}(Type));

/**
 * @category combinators
 * @since 1.0.0
 */
function array(item, name) {
    if (name === void 0) { name = "Array<".concat(item.name, ">"); }
    return new ArrayType(name, function (u) { return UnknownArray.is(u) && u.every(item.is); }, function (u, c) {
        var e = UnknownArray.validate(u, c);
        if ((0,fp_ts_es6_Either__WEBPACK_IMPORTED_MODULE_0__.isLeft)(e)) {
            return e;
        }
        var us = e.right;
        var len = us.length;
        var as = us;
        var errors = [];
        for (var i = 0; i < len; i++) {
            var ui = us[i];
            var result = item.validate(ui, appendContext(c, String(i), item, ui));
            if ((0,fp_ts_es6_Either__WEBPACK_IMPORTED_MODULE_0__.isLeft)(result)) {
                pushAll(errors, result.left);
            }
            else {
                var ai = result.right;
                if (ai !== ui) {
                    if (as === us) {
                        as = us.slice();
                    }
                    as[i] = ai;
                }
            }
        }
        return errors.length > 0 ? failures(errors) : success(as);
    }, item.encode === identity ? identity : function (a) { return a.map(item.encode); }, item);
}
/**
 * @since 1.0.0
 */
var InterfaceType = /** @class */ (function (_super) {
    __extends(InterfaceType, _super);
    function InterfaceType(name, is, validate, encode, props) {
        var _this = _super.call(this, name, is, validate, encode) || this;
        _this.props = props;
        /**
         * @since 1.0.0
         */
        _this._tag = 'InterfaceType';
        return _this;
    }
    return InterfaceType;
}(Type));

/**
 * @category combinators
 * @since 1.0.0
 */
function type(props, name) {
    if (name === void 0) { name = getInterfaceTypeName(props); }
    var keys = Object.keys(props);
    var types = keys.map(function (key) { return props[key]; });
    var len = keys.length;
    return new InterfaceType(name, function (u) {
        if (UnknownRecord.is(u)) {
            for (var i = 0; i < len; i++) {
                var k = keys[i];
                var uk = u[k];
                if ((uk === undefined && !hasOwnProperty.call(u, k)) || !types[i].is(uk)) {
                    return false;
                }
            }
            return true;
        }
        return false;
    }, function (u, c) {
        var e = UnknownRecord.validate(u, c);
        if ((0,fp_ts_es6_Either__WEBPACK_IMPORTED_MODULE_0__.isLeft)(e)) {
            return e;
        }
        var o = e.right;
        var a = o;
        var errors = [];
        for (var i = 0; i < len; i++) {
            var k = keys[i];
            var ak = a[k];
            var type_1 = types[i];
            var result = type_1.validate(ak, appendContext(c, k, type_1, ak));
            if ((0,fp_ts_es6_Either__WEBPACK_IMPORTED_MODULE_0__.isLeft)(result)) {
                pushAll(errors, result.left);
            }
            else {
                var vak = result.right;
                if (vak !== ak || (vak === undefined && !hasOwnProperty.call(a, k))) {
                    /* istanbul ignore next */
                    if (a === o) {
                        a = __assign({}, o);
                    }
                    a[k] = vak;
                }
            }
        }
        return errors.length > 0 ? failures(errors) : success(a);
    }, useIdentity(types)
        ? identity
        : function (a) {
            var s = __assign({}, a);
            for (var i = 0; i < len; i++) {
                var k = keys[i];
                var encode = types[i].encode;
                if (encode !== identity) {
                    s[k] = encode(a[k]);
                }
            }
            return s;
        }, props);
}
/**
 * @since 1.0.0
 */
var PartialType = /** @class */ (function (_super) {
    __extends(PartialType, _super);
    function PartialType(name, is, validate, encode, props) {
        var _this = _super.call(this, name, is, validate, encode) || this;
        _this.props = props;
        /**
         * @since 1.0.0
         */
        _this._tag = 'PartialType';
        return _this;
    }
    return PartialType;
}(Type));

/**
 * @category combinators
 * @since 1.0.0
 */
function partial(props, name) {
    if (name === void 0) { name = getPartialTypeName(getInterfaceTypeName(props)); }
    var keys = Object.keys(props);
    var types = keys.map(function (key) { return props[key]; });
    var len = keys.length;
    return new PartialType(name, function (u) {
        if (UnknownRecord.is(u)) {
            for (var i = 0; i < len; i++) {
                var k = keys[i];
                var uk = u[k];
                if (uk !== undefined && !props[k].is(uk)) {
                    return false;
                }
            }
            return true;
        }
        return false;
    }, function (u, c) {
        var e = UnknownRecord.validate(u, c);
        if ((0,fp_ts_es6_Either__WEBPACK_IMPORTED_MODULE_0__.isLeft)(e)) {
            return e;
        }
        var o = e.right;
        var a = o;
        var errors = [];
        for (var i = 0; i < len; i++) {
            var k = keys[i];
            var ak = a[k];
            var type_2 = props[k];
            var result = type_2.validate(ak, appendContext(c, k, type_2, ak));
            if ((0,fp_ts_es6_Either__WEBPACK_IMPORTED_MODULE_0__.isLeft)(result)) {
                if (ak !== undefined) {
                    pushAll(errors, result.left);
                }
            }
            else {
                var vak = result.right;
                if (vak !== ak) {
                    /* istanbul ignore next */
                    if (a === o) {
                        a = __assign({}, o);
                    }
                    a[k] = vak;
                }
            }
        }
        return errors.length > 0 ? failures(errors) : success(a);
    }, useIdentity(types)
        ? identity
        : function (a) {
            var s = __assign({}, a);
            for (var i = 0; i < len; i++) {
                var k = keys[i];
                var ak = a[k];
                if (ak !== undefined) {
                    s[k] = types[i].encode(ak);
                }
            }
            return s;
        }, props);
}
/**
 * @since 1.0.0
 */
var DictionaryType = /** @class */ (function (_super) {
    __extends(DictionaryType, _super);
    function DictionaryType(name, is, validate, encode, domain, codomain) {
        var _this = _super.call(this, name, is, validate, encode) || this;
        _this.domain = domain;
        _this.codomain = codomain;
        /**
         * @since 1.0.0
         */
        _this._tag = 'DictionaryType';
        return _this;
    }
    return DictionaryType;
}(Type));

/**
 * @category combinators
 * @since 1.7.1
 */
function record(domain, codomain, name) {
    var keys = getDomainKeys(domain);
    return keys
        ? enumerableRecord(Object.keys(keys), domain, codomain, name)
        : nonEnumerableRecord(domain, codomain, name);
}
/**
 * @since 1.0.0
 */
var UnionType = /** @class */ (function (_super) {
    __extends(UnionType, _super);
    function UnionType(name, is, validate, encode, types) {
        var _this = _super.call(this, name, is, validate, encode) || this;
        _this.types = types;
        /**
         * @since 1.0.0
         */
        _this._tag = 'UnionType';
        return _this;
    }
    return UnionType;
}(Type));

/**
 * @category combinators
 * @since 1.0.0
 */
function union(codecs, name) {
    if (name === void 0) { name = getUnionName(codecs); }
    var index = getIndex(codecs);
    if (index !== undefined && codecs.length > 0) {
        var tag_1 = index[0], groups_1 = index[1];
        var len_1 = groups_1.length;
        var find_1 = function (value) {
            for (var i = 0; i < len_1; i++) {
                if (groups_1[i].indexOf(value) !== -1) {
                    return i;
                }
            }
            return undefined;
        };
        // tslint:disable-next-line: deprecation
        return new TaggedUnionType(name, function (u) {
            if (UnknownRecord.is(u)) {
                var i = find_1(u[tag_1]);
                return i !== undefined ? codecs[i].is(u) : false;
            }
            return false;
        }, function (u, c) {
            var e = UnknownRecord.validate(u, c);
            if ((0,fp_ts_es6_Either__WEBPACK_IMPORTED_MODULE_0__.isLeft)(e)) {
                return e;
            }
            var r = e.right;
            var i = find_1(r[tag_1]);
            if (i === undefined) {
                return failure(u, c);
            }
            var codec = codecs[i];
            return codec.validate(r, appendContext(c, String(i), codec, r));
        }, useIdentity(codecs)
            ? identity
            : function (a) {
                var i = find_1(a[tag_1]);
                if (i === undefined) {
                    // https://github.com/gcanti/io-ts/pull/305
                    throw new Error("no codec found to encode value in union codec ".concat(name));
                }
                else {
                    return codecs[i].encode(a);
                }
            }, codecs, tag_1);
    }
    else {
        return new UnionType(name, function (u) { return codecs.some(function (type) { return type.is(u); }); }, function (u, c) {
            var errors = [];
            for (var i = 0; i < codecs.length; i++) {
                var codec = codecs[i];
                var result = codec.validate(u, appendContext(c, String(i), codec, u));
                if ((0,fp_ts_es6_Either__WEBPACK_IMPORTED_MODULE_0__.isLeft)(result)) {
                    pushAll(errors, result.left);
                }
                else {
                    return success(result.right);
                }
            }
            return failures(errors);
        }, useIdentity(codecs)
            ? identity
            : function (a) {
                for (var _i = 0, codecs_1 = codecs; _i < codecs_1.length; _i++) {
                    var codec = codecs_1[_i];
                    if (codec.is(a)) {
                        return codec.encode(a);
                    }
                }
                // https://github.com/gcanti/io-ts/pull/305
                throw new Error("no codec found to encode value in union type ".concat(name));
            }, codecs);
    }
}
/**
 * @since 1.0.0
 */
var IntersectionType = /** @class */ (function (_super) {
    __extends(IntersectionType, _super);
    function IntersectionType(name, is, validate, encode, types) {
        var _this = _super.call(this, name, is, validate, encode) || this;
        _this.types = types;
        /**
         * @since 1.0.0
         */
        _this._tag = 'IntersectionType';
        return _this;
    }
    return IntersectionType;
}(Type));

function intersection(codecs, name) {
    if (name === void 0) { name = "(".concat(codecs.map(function (type) { return type.name; }).join(' & '), ")"); }
    var len = codecs.length;
    return new IntersectionType(name, function (u) { return codecs.every(function (type) { return type.is(u); }); }, codecs.length === 0
        ? success
        : function (u, c) {
            var us = [];
            var errors = [];
            for (var i = 0; i < len; i++) {
                var codec = codecs[i];
                var result = codec.validate(u, appendContext(c, String(i), codec, u));
                if ((0,fp_ts_es6_Either__WEBPACK_IMPORTED_MODULE_0__.isLeft)(result)) {
                    pushAll(errors, result.left);
                }
                else {
                    us.push(result.right);
                }
            }
            return errors.length > 0 ? failures(errors) : success(mergeAll(u, us));
        }, codecs.length === 0
        ? identity
        : function (a) {
            return mergeAll(a, codecs.map(function (codec) { return codec.encode(a); }));
        }, codecs);
}
/**
 * @since 1.0.0
 */
var TupleType = /** @class */ (function (_super) {
    __extends(TupleType, _super);
    function TupleType(name, is, validate, encode, types) {
        var _this = _super.call(this, name, is, validate, encode) || this;
        _this.types = types;
        /**
         * @since 1.0.0
         */
        _this._tag = 'TupleType';
        return _this;
    }
    return TupleType;
}(Type));

function tuple(codecs, name) {
    if (name === void 0) { name = "[".concat(codecs.map(function (type) { return type.name; }).join(', '), "]"); }
    var len = codecs.length;
    return new TupleType(name, function (u) { return UnknownArray.is(u) && u.length === len && codecs.every(function (type, i) { return type.is(u[i]); }); }, function (u, c) {
        var e = UnknownArray.validate(u, c);
        if ((0,fp_ts_es6_Either__WEBPACK_IMPORTED_MODULE_0__.isLeft)(e)) {
            return e;
        }
        var us = e.right;
        var as = us.length > len ? us.slice(0, len) : us; // strip additional components
        var errors = [];
        for (var i = 0; i < len; i++) {
            var a = us[i];
            var type_3 = codecs[i];
            var result = type_3.validate(a, appendContext(c, String(i), type_3, a));
            if ((0,fp_ts_es6_Either__WEBPACK_IMPORTED_MODULE_0__.isLeft)(result)) {
                pushAll(errors, result.left);
            }
            else {
                var va = result.right;
                if (va !== a) {
                    /* istanbul ignore next */
                    if (as === us) {
                        as = us.slice();
                    }
                    as[i] = va;
                }
            }
        }
        return errors.length > 0 ? failures(errors) : success(as);
    }, useIdentity(codecs) ? identity : function (a) { return codecs.map(function (type, i) { return type.encode(a[i]); }); }, codecs);
}
/**
 * @since 1.0.0
 */
var ReadonlyType = /** @class */ (function (_super) {
    __extends(ReadonlyType, _super);
    function ReadonlyType(name, is, validate, encode, type) {
        var _this = _super.call(this, name, is, validate, encode) || this;
        _this.type = type;
        /**
         * @since 1.0.0
         */
        _this._tag = 'ReadonlyType';
        return _this;
    }
    return ReadonlyType;
}(Type));

/**
 * @category combinators
 * @since 1.0.0
 */
function readonly(codec, name) {
    if (name === void 0) { name = "Readonly<".concat(codec.name, ">"); }
    return new ReadonlyType(name, codec.is, codec.validate, codec.encode, codec);
}
/**
 * @since 1.0.0
 */
var ReadonlyArrayType = /** @class */ (function (_super) {
    __extends(ReadonlyArrayType, _super);
    function ReadonlyArrayType(name, is, validate, encode, type) {
        var _this = _super.call(this, name, is, validate, encode) || this;
        _this.type = type;
        /**
         * @since 1.0.0
         */
        _this._tag = 'ReadonlyArrayType';
        return _this;
    }
    return ReadonlyArrayType;
}(Type));

/**
 * @category combinators
 * @since 1.0.0
 */
function readonlyArray(item, name) {
    if (name === void 0) { name = "ReadonlyArray<".concat(item.name, ">"); }
    var codec = array(item);
    return new ReadonlyArrayType(name, codec.is, codec.validate, codec.encode, item);
}
/**
 * Strips additional properties, equivalent to `exact(type(props))`.
 *
 * @category combinators
 * @since 1.0.0
 */
var strict = function (props, name) { return exact(type(props), name); };
/**
 * @since 1.1.0
 */
var ExactType = /** @class */ (function (_super) {
    __extends(ExactType, _super);
    function ExactType(name, is, validate, encode, type) {
        var _this = _super.call(this, name, is, validate, encode) || this;
        _this.type = type;
        /**
         * @since 1.0.0
         */
        _this._tag = 'ExactType';
        return _this;
    }
    return ExactType;
}(Type));

/**
 * Strips additional properties.
 *
 * @category combinators
 * @since 1.1.0
 */
function exact(codec, name) {
    if (name === void 0) { name = getExactTypeName(codec); }
    var props = getProps(codec);
    return new ExactType(name, codec.is, function (u, c) {
        var e = UnknownRecord.validate(u, c);
        if ((0,fp_ts_es6_Either__WEBPACK_IMPORTED_MODULE_0__.isLeft)(e)) {
            return e;
        }
        var ce = codec.validate(u, c);
        if ((0,fp_ts_es6_Either__WEBPACK_IMPORTED_MODULE_0__.isLeft)(ce)) {
            return ce;
        }
        return (0,fp_ts_es6_Either__WEBPACK_IMPORTED_MODULE_0__.right)(stripKeys(ce.right, props));
    }, function (a) { return codec.encode(stripKeys(a, props)); }, codec);
}
/**
 * @since 1.0.0
 */
var FunctionType = /** @class */ (function (_super) {
    __extends(FunctionType, _super);
    function FunctionType() {
        var _this = _super.call(this, 'Function', 
        // tslint:disable-next-line:strict-type-predicates
        function (u) { return typeof u === 'function'; }, function (u, c) { return (_this.is(u) ? success(u) : failure(u, c)); }, identity) || this;
        /**
         * @since 1.0.0
         */
        _this._tag = 'FunctionType';
        return _this;
    }
    return FunctionType;
}(Type));

/**
 * @category primitives
 * @since 1.0.0
 */
var Function = new FunctionType();
/**
 * @since 1.0.0
 */
var NeverType = /** @class */ (function (_super) {
    __extends(NeverType, _super);
    function NeverType() {
        var _this = _super.call(this, 'never', function (_) { return false; }, function (u, c) { return failure(u, c); }, 
        /* istanbul ignore next */
        function () {
            throw new Error('cannot encode never');
        }) || this;
        /**
         * @since 1.0.0
         */
        _this._tag = 'NeverType';
        return _this;
    }
    return NeverType;
}(Type));

/**
 * @category primitives
 * @since 1.0.0
 */
var never = new NeverType();
/**
 * @since 1.0.0
 */
var AnyType = /** @class */ (function (_super) {
    __extends(AnyType, _super);
    function AnyType() {
        var _this = _super.call(this, 'any', function (_) { return true; }, success, identity) || this;
        /**
         * @since 1.0.0
         */
        _this._tag = 'AnyType';
        return _this;
    }
    return AnyType;
}(Type));

/**
 * @category primitives
 * @since 1.0.0
 */
var any = new AnyType();
function refinement(codec, predicate, name) {
    if (name === void 0) { name = "(".concat(codec.name, " | ").concat(getFunctionName(predicate), ")"); }
    return new RefinementType(name, function (u) { return codec.is(u) && predicate(u); }, function (i, c) {
        var e = codec.validate(i, c);
        if ((0,fp_ts_es6_Either__WEBPACK_IMPORTED_MODULE_0__.isLeft)(e)) {
            return e;
        }
        var a = e.right;
        return predicate(a) ? success(a) : failure(a, c);
    }, codec.encode, codec, predicate);
}
/**
 * @category primitives
 * @since 1.0.0
 */
var Integer = refinement(number, Number.isInteger, 'Integer');
// -------------------------------------------------------------------------------------
// deprecated
// -------------------------------------------------------------------------------------
/**
 * @since 1.3.0
 * @deprecated
 */
var TaggedUnionType = /** @class */ (function (_super) {
    __extends(TaggedUnionType, _super);
    function TaggedUnionType(name, 
    // tslint:disable-next-line: deprecation
    is, 
    // tslint:disable-next-line: deprecation
    validate, 
    // tslint:disable-next-line: deprecation
    encode, codecs, tag) {
        var _this = _super.call(this, name, is, validate, encode, codecs) /* istanbul ignore next */ // <= workaround for https://github.com/Microsoft/TypeScript/issues/13455
         || this;
        _this.tag = tag;
        return _this;
    }
    return TaggedUnionType;
}(UnionType));

/**
 * Use `union` instead.
 *
 * @category combinators
 * @since 1.3.0
 * @deprecated
 */
var taggedUnion = function (tag, codecs, name
// tslint:disable-next-line: deprecation
) {
    if (name === void 0) { name = getUnionName(codecs); }
    var U = union(codecs, name);
    // tslint:disable-next-line: deprecation
    if (U instanceof TaggedUnionType) {
        return U;
    }
    else {
        console.warn("[io-ts] Cannot build a tagged union for ".concat(name, ", returning a de-optimized union"));
        // tslint:disable-next-line: deprecation
        return new TaggedUnionType(name, U.is, U.validate, U.encode, codecs, tag);
    }
};


/**
 * @since 1.0.0
 * @deprecated
 */
var getValidationError /* istanbul ignore next */ = function (value, context) { return ({
    value: value,
    context: context
}); };
/**
 * @since 1.0.0
 * @deprecated
 */
var getDefaultContext /* istanbul ignore next */ = function (decoder) { return [
    { key: '', type: decoder }
]; };
/**
 * Use `UnknownRecord` instead.
 *
 * @category primitives
 * @since 1.0.0
 * @deprecated
 */
var Dictionary = UnknownRecord;
/**
 * @since 1.0.0
 * @deprecated
 */
var ObjectType = /** @class */ (function (_super) {
    __extends(ObjectType, _super);
    function ObjectType() {
        var _this = _super.call(this, 'object', function (u) { return u !== null && typeof u === 'object'; }, function (u, c) { return (_this.is(u) ? success(u) : failure(u, c)); }, identity) || this;
        /**
         * @since 1.0.0
         */
        _this._tag = 'ObjectType';
        return _this;
    }
    return ObjectType;
}(Type));

/**
 * Use `UnknownRecord` instead.
 *
 * @category primitives
 * @since 1.0.0
 * @deprecated
 */
// tslint:disable-next-line: deprecation
var object = new ObjectType();
/**
 * Use `record` instead.
 *
 * @category combinators
 * @since 1.0.0
 * @deprecated
 */
var dictionary = record;
/**
 * @since 1.0.0
 * @deprecated
 */
var StrictType = /** @class */ (function (_super) {
    __extends(StrictType, _super);
    function StrictType(name, 
    // tslint:disable-next-line: deprecation
    is, 
    // tslint:disable-next-line: deprecation
    validate, 
    // tslint:disable-next-line: deprecation
    encode, props) {
        var _this = _super.call(this, name, is, validate, encode) || this;
        _this.props = props;
        /**
         * @since 1.0.0
         */
        _this._tag = 'StrictType';
        return _this;
    }
    return StrictType;
}(Type));

/**
 * Drops the codec "kind".
 *
 * @category combinators
 * @since 1.1.0
 * @deprecated
 */
function clean(codec) {
    return codec;
}
function alias(codec) {
    return function () { return codec; };
}


/***/ }),

/***/ "./node_modules/sprintf-js/src/sprintf.js":
/*!************************************************!*\
  !*** ./node_modules/sprintf-js/src/sprintf.js ***!
  \************************************************/
/***/ ((module, exports, __webpack_require__) => {

var __WEBPACK_AMD_DEFINE_RESULT__;/* global window, exports, define */

!function() {
    'use strict'

    var re = {
        not_string: /[^s]/,
        not_bool: /[^t]/,
        not_type: /[^T]/,
        not_primitive: /[^v]/,
        number: /[diefg]/,
        numeric_arg: /[bcdiefguxX]/,
        json: /[j]/,
        not_json: /[^j]/,
        text: /^[^\x25]+/,
        modulo: /^\x25{2}/,
        placeholder: /^\x25(?:([1-9]\d*)\$|\(([^)]+)\))?(\+)?(0|'[^$])?(-)?(\d+)?(?:\.(\d+))?([b-gijostTuvxX])/,
        key: /^([a-z_][a-z_\d]*)/i,
        key_access: /^\.([a-z_][a-z_\d]*)/i,
        index_access: /^\[(\d+)\]/,
        sign: /^[+-]/
    }

    function sprintf(key) {
        // `arguments` is not an array, but should be fine for this call
        return sprintf_format(sprintf_parse(key), arguments)
    }

    function vsprintf(fmt, argv) {
        return sprintf.apply(null, [fmt].concat(argv || []))
    }

    function sprintf_format(parse_tree, argv) {
        var cursor = 1, tree_length = parse_tree.length, arg, output = '', i, k, ph, pad, pad_character, pad_length, is_positive, sign
        for (i = 0; i < tree_length; i++) {
            if (typeof parse_tree[i] === 'string') {
                output += parse_tree[i]
            }
            else if (typeof parse_tree[i] === 'object') {
                ph = parse_tree[i] // convenience purposes only
                if (ph.keys) { // keyword argument
                    arg = argv[cursor]
                    for (k = 0; k < ph.keys.length; k++) {
                        if (arg == undefined) {
                            throw new Error(sprintf('[sprintf] Cannot access property "%s" of undefined value "%s"', ph.keys[k], ph.keys[k-1]))
                        }
                        arg = arg[ph.keys[k]]
                    }
                }
                else if (ph.param_no) { // positional argument (explicit)
                    arg = argv[ph.param_no]
                }
                else { // positional argument (implicit)
                    arg = argv[cursor++]
                }

                if (re.not_type.test(ph.type) && re.not_primitive.test(ph.type) && arg instanceof Function) {
                    arg = arg()
                }

                if (re.numeric_arg.test(ph.type) && (typeof arg !== 'number' && isNaN(arg))) {
                    throw new TypeError(sprintf('[sprintf] expecting number but found %T', arg))
                }

                if (re.number.test(ph.type)) {
                    is_positive = arg >= 0
                }

                switch (ph.type) {
                    case 'b':
                        arg = parseInt(arg, 10).toString(2)
                        break
                    case 'c':
                        arg = String.fromCharCode(parseInt(arg, 10))
                        break
                    case 'd':
                    case 'i':
                        arg = parseInt(arg, 10)
                        break
                    case 'j':
                        arg = JSON.stringify(arg, null, ph.width ? parseInt(ph.width) : 0)
                        break
                    case 'e':
                        arg = ph.precision ? parseFloat(arg).toExponential(ph.precision) : parseFloat(arg).toExponential()
                        break
                    case 'f':
                        arg = ph.precision ? parseFloat(arg).toFixed(ph.precision) : parseFloat(arg)
                        break
                    case 'g':
                        arg = ph.precision ? String(Number(arg.toPrecision(ph.precision))) : parseFloat(arg)
                        break
                    case 'o':
                        arg = (parseInt(arg, 10) >>> 0).toString(8)
                        break
                    case 's':
                        arg = String(arg)
                        arg = (ph.precision ? arg.substring(0, ph.precision) : arg)
                        break
                    case 't':
                        arg = String(!!arg)
                        arg = (ph.precision ? arg.substring(0, ph.precision) : arg)
                        break
                    case 'T':
                        arg = Object.prototype.toString.call(arg).slice(8, -1).toLowerCase()
                        arg = (ph.precision ? arg.substring(0, ph.precision) : arg)
                        break
                    case 'u':
                        arg = parseInt(arg, 10) >>> 0
                        break
                    case 'v':
                        arg = arg.valueOf()
                        arg = (ph.precision ? arg.substring(0, ph.precision) : arg)
                        break
                    case 'x':
                        arg = (parseInt(arg, 10) >>> 0).toString(16)
                        break
                    case 'X':
                        arg = (parseInt(arg, 10) >>> 0).toString(16).toUpperCase()
                        break
                }
                if (re.json.test(ph.type)) {
                    output += arg
                }
                else {
                    if (re.number.test(ph.type) && (!is_positive || ph.sign)) {
                        sign = is_positive ? '+' : '-'
                        arg = arg.toString().replace(re.sign, '')
                    }
                    else {
                        sign = ''
                    }
                    pad_character = ph.pad_char ? ph.pad_char === '0' ? '0' : ph.pad_char.charAt(1) : ' '
                    pad_length = ph.width - (sign + arg).length
                    pad = ph.width ? (pad_length > 0 ? pad_character.repeat(pad_length) : '') : ''
                    output += ph.align ? sign + arg + pad : (pad_character === '0' ? sign + pad + arg : pad + sign + arg)
                }
            }
        }
        return output
    }

    var sprintf_cache = Object.create(null)

    function sprintf_parse(fmt) {
        if (sprintf_cache[fmt]) {
            return sprintf_cache[fmt]
        }

        var _fmt = fmt, match, parse_tree = [], arg_names = 0
        while (_fmt) {
            if ((match = re.text.exec(_fmt)) !== null) {
                parse_tree.push(match[0])
            }
            else if ((match = re.modulo.exec(_fmt)) !== null) {
                parse_tree.push('%')
            }
            else if ((match = re.placeholder.exec(_fmt)) !== null) {
                if (match[2]) {
                    arg_names |= 1
                    var field_list = [], replacement_field = match[2], field_match = []
                    if ((field_match = re.key.exec(replacement_field)) !== null) {
                        field_list.push(field_match[1])
                        while ((replacement_field = replacement_field.substring(field_match[0].length)) !== '') {
                            if ((field_match = re.key_access.exec(replacement_field)) !== null) {
                                field_list.push(field_match[1])
                            }
                            else if ((field_match = re.index_access.exec(replacement_field)) !== null) {
                                field_list.push(field_match[1])
                            }
                            else {
                                throw new SyntaxError('[sprintf] failed to parse named argument key')
                            }
                        }
                    }
                    else {
                        throw new SyntaxError('[sprintf] failed to parse named argument key')
                    }
                    match[2] = field_list
                }
                else {
                    arg_names |= 2
                }
                if (arg_names === 3) {
                    throw new Error('[sprintf] mixing positional and named placeholders is not (yet) supported')
                }

                parse_tree.push(
                    {
                        placeholder: match[0],
                        param_no:    match[1],
                        keys:        match[2],
                        sign:        match[3],
                        pad_char:    match[4],
                        align:       match[5],
                        width:       match[6],
                        precision:   match[7],
                        type:        match[8]
                    }
                )
            }
            else {
                throw new SyntaxError('[sprintf] unexpected placeholder')
            }
            _fmt = _fmt.substring(match[0].length)
        }
        return sprintf_cache[fmt] = parse_tree
    }

    /**
     * export to either browser or node.js
     */
    /* eslint-disable quote-props */
    if (true) {
        exports.sprintf = sprintf
        exports.vsprintf = vsprintf
    }
    if (typeof window !== 'undefined') {
        window['sprintf'] = sprintf
        window['vsprintf'] = vsprintf

        if (true) {
            !(__WEBPACK_AMD_DEFINE_RESULT__ = (function() {
                return {
                    'sprintf': sprintf,
                    'vsprintf': vsprintf
                }
            }).call(exports, __webpack_require__, exports, module),
		__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))
        }
    }
    /* eslint-enable quote-props */
}(); // eslint-disable-line


/***/ }),

/***/ "./node_modules/strnum/strnum.js":
/*!***************************************!*\
  !*** ./node_modules/strnum/strnum.js ***!
  \***************************************/
/***/ ((module) => {

const hexRegex = /^[-+]?0x[a-fA-F0-9]+$/;
const numRegex = /^([\-\+])?(0*)([0-9]*(\.[0-9]*)?)$/;
// const octRegex = /^0x[a-z0-9]+/;
// const binRegex = /0x[a-z0-9]+/;

 
const consider = {
    hex :  true,
    // oct: false,
    leadingZeros: true,
    decimalPoint: "\.",
    eNotation: true,
    //skipLike: /regex/
};

function toNumber(str, options = {}){
    options = Object.assign({}, consider, options );
    if(!str || typeof str !== "string" ) return str;
    
    let trimmedStr  = str.trim();
    
    if(options.skipLike !== undefined && options.skipLike.test(trimmedStr)) return str;
    else if(str==="0") return 0;
    else if (options.hex && hexRegex.test(trimmedStr)) {
        return parse_int(trimmedStr, 16);
    // }else if (options.oct && octRegex.test(str)) {
    //     return Number.parseInt(val, 8);
    }else if (trimmedStr.search(/[eE]/)!== -1) { //eNotation
        const notation = trimmedStr.match(/^([-\+])?(0*)([0-9]*(\.[0-9]*)?[eE][-\+]?[0-9]+)$/); 
        // +00.123 => [ , '+', '00', '.123', ..
        if(notation){
            // console.log(notation)
            if(options.leadingZeros){ //accept with leading zeros
                trimmedStr = (notation[1] || "") + notation[3];
            }else{
                if(notation[2] === "0" && notation[3][0]=== "."){ //valid number
                }else{
                    return str;
                }
            }
            return options.eNotation ? Number(trimmedStr) : str;
        }else{
            return str;
        }
    // }else if (options.parseBin && binRegex.test(str)) {
    //     return Number.parseInt(val, 2);
    }else{
        //separate negative sign, leading zeros, and rest number
        const match = numRegex.exec(trimmedStr);
        // +00.123 => [ , '+', '00', '.123', ..
        if(match){
            const sign = match[1];
            const leadingZeros = match[2];
            let numTrimmedByZeros = trimZeros(match[3]); //complete num without leading zeros
            //trim ending zeros for floating number
            
            if(!options.leadingZeros && leadingZeros.length > 0 && sign && trimmedStr[2] !== ".") return str; //-0123
            else if(!options.leadingZeros && leadingZeros.length > 0 && !sign && trimmedStr[1] !== ".") return str; //0123
            else if(options.leadingZeros && leadingZeros===str) return 0; //00
            
            else{//no leading zeros or leading zeros are allowed
                const num = Number(trimmedStr);
                const numStr = "" + num;

                if(numStr.search(/[eE]/) !== -1){ //given number is long and parsed to eNotation
                    if(options.eNotation) return num;
                    else return str;
                }else if(trimmedStr.indexOf(".") !== -1){ //floating number
                    if(numStr === "0" && (numTrimmedByZeros === "") ) return num; //0.0
                    else if(numStr === numTrimmedByZeros) return num; //0.456. 0.79000
                    else if( sign && numStr === "-"+numTrimmedByZeros) return num;
                    else return str;
                }
                
                if(leadingZeros){
                    return (numTrimmedByZeros === numStr) || (sign+numTrimmedByZeros === numStr) ? num : str
                }else  {
                    return (trimmedStr === numStr) || (trimmedStr === sign+numStr) ? num : str
                }
            }
        }else{ //non-numeric string
            return str;
        }
    }
}

/**
 * 
 * @param {string} numStr without leading zeros
 * @returns 
 */
function trimZeros(numStr){
    if(numStr && numStr.indexOf(".") !== -1){//float
        numStr = numStr.replace(/0+$/, ""); //remove ending zeros
        if(numStr === ".")  numStr = "0";
        else if(numStr[0] === ".")  numStr = "0"+numStr;
        else if(numStr[numStr.length-1] === ".")  numStr = numStr.substr(0,numStr.length-1);
        return numStr;
    }
    return numStr;
}

function parse_int(numStr, base){
    //polyfill
    if(parseInt) return parseInt(numStr, base);
    else if(Number.parseInt) return Number.parseInt(numStr, base);
    else if(window && window.parseInt) return window.parseInt(numStr, base);
    else throw new Error("parseInt, Number.parseInt, window.parseInt are not supported")
}

module.exports = toNumber;

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module is referenced by other modules so it can't be inlined
/******/ 	var __webpack_exports__ = __webpack_require__("./build/index.js");
/******/ 	
/******/ 	return __webpack_exports__;
/******/ })()
;
});
//# sourceMappingURL=abap_adt_api.umd.map