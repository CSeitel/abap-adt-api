{"version":3,"file":"abap_adt_api.umd.js","mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD,O;;;;;;;;;;ACVa;AACb;AACA,6CAA6C;AAC7C;AACA,8CAA6C,EAAE,aAAa,EAAC;AAC7D,iBAAiB,GAAG,uBAAuB;AAC3C,uBAAuB,mBAAO,CAAC,+CAAgB;AAC/C,kBAAkB,mBAAO,CAAC,qCAAW;AACrC,cAAc,mBAAO,CAAC,mCAAO;AAC7B,oBAAoB,mBAAO,CAAC,yCAAa;AACzC,gCAAgC,mBAAO,CAAC,4CAAO;AAC/C;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,aAAa;AACb;AACA,uBAAuB;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2DAA2D;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6FAA6F;AAC7F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;;;;;;;;;;;;ACjnBJ;AACb;AACA,6CAA6C;AAC7C;AACA,8CAA6C,EAAE,aAAa,EAAC;AAC7D,0BAA0B,GAAG,2BAA2B,GAAG,wBAAwB,GAAG,yBAAyB,GAAG,oBAAoB,GAAG,qBAAqB,GAAG,iBAAiB,GAAG,oBAAoB,GAAG,oBAAoB,GAAG,sBAAsB,GAAG,mBAAmB,GAAG,mBAAmB,GAAG,kBAAkB,GAAG,yBAAyB,GAAG,aAAa;AACtW,oBAAoB,mBAAO,CAAC,yCAAa;AACzC,gCAAgC,mBAAO,CAAC,qCAAO;AAC/C,gBAAgB,mBAAO,CAAC,0DAAiB;AACzC,0CAA0C,mBAAO,CAAC,2EAAiB;AACnE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,4BAA4B,aAAa,KAAK;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA,mBAAmB;AACnB;AACA;AACA;AACA,mBAAmB;AACnB;AACA;AACA;AACA,sBAAsB;AACtB;AACA,oBAAoB;AACpB,wDAAwD,gBAAgB,GAAG,oBAAoB;AAC/F;AACA,gEAAgE;AAChE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,WAAW;AAC/C;AACA;AACA,KAAK;AACL;AACA;AACA,oBAAoB;AACpB,gCAAgC,QAAQ,6EAA6E,gBAAgB;AACrI;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gDAAgD;AAChD;AACA;AACA,2CAA2C,sBAAsB,MAAM,IAAI;AAC3E;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oDAAoD;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+CAA+C,sBAAsB,UAAU,IAAI;AACnF;AACA;AACA,qBAAqB;AACrB;AACA,2CAA2C;AAC3C;AACA,oBAAoB;AACpB;AACA;AACA,gBAAgB;AAChB,qCAAqC;AACrC;AACA,yBAAyB;AACzB;AACA;AACA;AACA,qCAAqC;AACrC;AACA,wBAAwB;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B;AAC3B,uCAAuC,EAAE;AACzC,0BAA0B;;;;;;;;;;;;ACxLb;AACb;AACA;AACA;AACA;AACA,eAAe,oCAAoC;AACnD;AACA;AACA,CAAC;AACD;AACA;AACA,CAAC;AACD;AACA,0CAA0C,4BAA4B;AACtE,CAAC;AACD;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA6C,EAAE,aAAa,EAAC;AAC7D,eAAe,GAAG,uBAAuB,GAAG,qBAAqB;AACjE,6BAA6B,mBAAO,CAAC,qCAAO;AAC5C,uBAAuB,mBAAO,CAAC,+CAAgB;AAC/C,WAAW,mBAAO,CAAC,2BAAG;AACtB,wBAAwB,mBAAO,CAAC,iDAAiB;AACjD,oBAAoB,mBAAO,CAAC,yCAAa;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,4CAA4C,qBAAqB,KAAK;AACvE;AACA;AACA;AACA;AACA,sCAAsC;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,WAAW;AAChD,8CAA8C,kBAAkB;AAChE;AACA;AACA;AACA;AACA,oBAAoB,yBAAyB;AAC7C,6EAA6E,KAAK;AAClF,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yEAAyE,iBAAiB;AAC1F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iDAAiD;AACjD;AACA;AACA;AACA,2DAA2D;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iEAAiE;AACjE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wDAAwD;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gEAAgE;AAChE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kDAAkD,YAAY;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;;;;;;;;;;;;AC5RF;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,wBAAwB,GAAG,sBAAsB,GAAG,iBAAiB,GAAG,gBAAgB,GAAG,iBAAiB,GAAG,kBAAkB,GAAG,gBAAgB,GAAG,kBAAkB,GAAG,wBAAwB,GAAG,gBAAgB;AACvN,oBAAoB,mBAAO,CAAC,0CAAc;AAC1C,uBAAuB,mBAAO,CAAC,gDAAiB;AAChD;AACA;AACA;AACA,2BAA2B;AAC3B;AACA;AACA;AACA;AACA,sBAAsB;AACtB,oEAAoE,SAAS;AAC7E;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,gBAAgB,sDAAsD;AACtE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,QAAQ;AACvC,gCAAgC,KAAK;AACrC,oCAAoC,SAAS;AAC7C;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,4DAA4D,sBAAsB;AAClF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,aAAa;AACb;AACA,wBAAwB;AACxB;AACA;AACA;AACA,gBAAgB,sDAAsD;AACtE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,YAAY;AACvC,uBAAuB,QAAQ;AAC/B,8BAA8B,OAAO;AACrC,oCAAoC,UAAU;AAC9C,8BAA8B,KAAK;AACnC,kCAAkC,SAAS;AAC3C;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA,wCAAwC,OAAO;AAC/C;AACA,2CAA2C,UAAU;AACrD;AACA,6CAA6C,KAAK;AAClD,yDAAyD,SAAS;AAClE;AACA,MAAM,OAAO,EAAE,UAAU,EAAE,KAAK,EAAE,SAAS;AAC3C,kEAAkE,OAAO;AACzE;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA,iDAAiD,OAAO;AACxD;AACA;AACA,KAAK;AACL;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,oBAAoB;AAC/C,KAAK;AACL;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,iBAAiB;AACjC,gDAAgD,yDAAyD,GAAG;AAC5G,2BAA2B,mDAAmD;AAC9E,sCAAsC,wCAAwC;AAC9E;AACA;AACA;AACA;AACA,gBAAgB,+BAA+B;AAC/C,gDAAgD,mDAAmD,wBAAwB,UAAU;AACrI,MAAM;AACN;AACA;AACA;AACA;AACA,uBAAuB,KAAK;AAC5B,mBAAmB,KAAK,GAAG,mCAAmC,IAAI,KAAK;AACvE;AACA;AACA;AACA;AACA,+EAA+E,UAAU;AACzF,gDAAgD,cAAc,0BAA0B,eAAe;AACvG,mDAAmD,iBAAiB,0BAA0B,kBAAkB;AAChH;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ,IAAI;AACJ,IAAI;AACJ,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,yBAAyB;AAC3D;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,+BAA+B;AAChE;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,SAAS;AACvD;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,SAAS;AAChB,QAAQ,KAAK;AACb,YAAY,SAAS;AACrB;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,YAAY,wBAAwB;AACpC;AACA;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA;AACA;AACA;AACA,iDAAiD,SAAS,YAAY,2BAA2B,UAAU,OAAO;AAClH;AACA;AACA,KAAK;AACL;AACA,wBAAwB;;;;;;;;;;;;AC3SX;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,uBAAuB,GAAG,gCAAgC,GAAG,oBAAoB,GAAG,gBAAgB;AACpG,uBAAuB,mBAAO,CAAC,gDAAiB;AAChD,oBAAoB,mBAAO,CAAC,0CAAc;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,gCAAgC;AAC/D,8DAA8D,uBAAuB,EAAE,KAAK,kBAAkB,oBAAoB;AAClI;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8EAA8E,iBAAiB,kBAAkB,kBAAkB,uBAAuB,uBAAuB,kBAAkB,kBAAkB;AACrN;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,aAAa;AACb;AACA,gBAAgB;AAChB;AACA;AACA,wCAAwC,WAAW;AACnD;AACA;AACA;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA,gBAAgB,yBAAyB;AACzC;AACA,KAAK;AACL;AACA,gCAAgC;AAChC;AACA;AACA,oFAAoF;AACpF;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,uBAAuB;;;;;;;;;;;;ACxGV;AACb;AACA;AACA;AACA;AACA,eAAe,oCAAoC;AACnD;AACA;AACA,CAAC;AACD;AACA;AACA,CAAC;AACD;AACA,0CAA0C,4BAA4B;AACtE,CAAC;AACD;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA6C,EAAE,aAAa,EAAC;AAC7D,wBAAwB,GAAG,qBAAqB,GAAG,2BAA2B,GAAG,yBAAyB,GAAG,gBAAgB,GAAG,oBAAoB,GAAG,oBAAoB,GAAG,uBAAuB,GAAG,sBAAsB,GAAG,yBAAyB;AAC1P,oBAAoB,mBAAO,CAAC,0CAAc;AAC1C,uBAAuB,mBAAO,CAAC,gDAAO;AACtC,YAAY,mBAAO,CAAC,4BAAI;AACxB,oBAAoB,mBAAO,CAAC,6CAAa;AACzC;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA,KAAK;AACL,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,SAAS;AACT,KAAK;AACL,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA,CAAC;AACD,yBAAyB;AACzB;AACA;AACA;AACA;AACA,sEAAsE,SAAS;AAC/E;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,qBAAqB;AACrB;AACA;AACA,sBAAsB;AACtB;AACA,sBAAsB;AACtB,+EAA+E,QAAQ,KAAK,yBAAyB;AACrH;AACA;AACA,uBAAuB;AACvB;AACA;AACA,4BAA4B,WAAW;AACvC;AACA;AACA;AACA,4CAA4C,QAAQ;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wEAAwE,QAAQ,KAAK,+BAA+B;AACpH;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA,oBAAoB;AACpB;AACA,sBAAsB;AACtB,iBAAiB;AACjB,kEAAkE,YAAY;AAC9E;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,aAAa;AAC3C;AACA;AACA,SAAS;AACT,iBAAiB;AACjB,KAAK;AACL;AACA,qBAAqB;AACrB;AACA;AACA,oBAAoB;AACpB;AACA,sBAAsB,8BAA8B;AACpD,mEAAmE,SAAS;AAC5E;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,YAAY,gBAAgB;AAC5B;AACA;AACA;AACA,wEAAwE,eAAe;AACvF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,0JAA0J;AACtK,YAAY,+BAA+B;AAC3C,YAAY,oCAAoC;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA,YAAY,wBAAwB,mBAAmB,qCAAqC,gBAAgB;AAC5G,iBAAiB;AACjB;AACA,+BAA+B,QAAQ;AACvC,+CAA+C,aAAa,kBAAkB,aAAa,iBAAiB,YAAY;AACxH,0BAA0B,gBAAgB,yBAAyB,iBAAiB,2BAA2B,kDAAkD;AACjK,oCAAoC,0BAA0B,8BAA8B,sBAAsB;AAClH,gCAAgC,sBAAsB;AACtD,2BAA2B,iBAAiB,0BAA0B,kBAAkB,6BAA6B,oDAAoD;AACzK,2BAA2B,iBAAiB,0BAA0B,kBAAkB,6BAA6B,qBAAqB;AAC1I;AACA;AACA;AACA;AACA,QAAQ;AACR,0BAA0B,iBAAiB;AAC3C,4BAA4B,mBAAmB;AAC/C,gCAAgC,uBAAuB;AACvD,qCAAqC,4BAA4B;AACjE,kCAAkC,yBAAyB;AAC3D;AACA,yCAAyC,oBAAoB,IAAI,0BAA0B;AAC3F,6CAA6C,oCAAoC;AACjF,+CAA+C,wBAAwB,aAAa,yBAAyB,eAAe,2BAA2B;AACvJ,YAAY,wBAAwB;AACpC,6CAA6C,sBAAsB,aAAa,wBAAwB;AACxG,YAAY,uBAAuB;AACnC;AACA;AACA,2BAA2B,kBAAkB;AAC7C,yBAAyB,gBAAgB;AACzC,gCAAgC,sDAAsD;AACtF,yBAAyB,gBAAgB;AACzC,6BAA6B,0BAA0B;AACvD,6BAA6B,0BAA0B;AACvD,6BAA6B,0BAA0B;AACvD;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,2BAA2B;AAC3B;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA,kDAAkD,WAAW;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL,YAAY,MAAM;AAClB;AACA;AACA,qBAAqB;AACrB;AACA,sBAAsB;AACtB;AACA;AACA,sCAAsC,QAAQ,0BAA0B,OAAO;AAC/E;AACA,+CAA+C,8BAA8B;AAC7E;AACA,wBAAwB;;;;;;;;;;;;ACvbX;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,+BAA+B,GAAG,6BAA6B,GAAG,4BAA4B,GAAG,mBAAmB,GAAG,6BAA6B,GAAG,sBAAsB;AAC7K,oBAAoB,mBAAO,CAAC,0CAAc;AAC1C,iBAAiB,mBAAO,CAAC,uCAAU;AACnC;AACA;AACA;AACA,mDAAmD,6BAA6B,QAAQ;AACxF,wBAAwB,+BAA+B;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,qCAAqC,IAAI,4BAA4B,UAAU;AAC/E;AACA,KAAK;AACL;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA;AACA,sFAAsF,SAAS;AAC/F;AACA;AACA;AACA,6BAA6B;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA,KAAK,IAAI;AACT,YAAY,+OAA+O;AAC3P;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+CAA+C;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,oDAAoD,GAAG;AACvD,4CAA4C,SAAS;AACrD;AACA;AACA;AACA,mBAAmB;AACnB;AACA,sBAAsB;AACtB;AACA,sCAAsC,2BAA2B;AACjE,wBAAwB,yBAAyB;AACjD,6DAA6D,GAAG;AAChE,4CAA4C,SAAS;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,4BAA4B;AAC5B;AACA,sBAAsB;AACtB,8BAA8B,yBAAyB,kBAAkB,QAAQ;AACjF,wDAAwD,KAAK,GAAG,GAAG;AACnE;AACA,2CAA2C,KAAK;AAChD;AACA,4CAA4C,+BAA+B;AAC3E;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,6BAA6B;AAC7B;AACA;AACA;AACA,+BAA+B;;;;;;;;;;;;AClJlB;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,gCAAgC,GAAG,4BAA4B,GAAG,yBAAyB,GAAG,oBAAoB,GAAG,yBAAyB,GAAG,8BAA8B,GAAG,2BAA2B,GAAG,qBAAqB,GAAG,4BAA4B,GAAG,sBAAsB,GAAG,iCAAiC,GAAG,8BAA8B,GAAG,4BAA4B,GAAG,8BAA8B,GAAG,sBAAsB,GAAG,yBAAyB,GAAG,kBAAkB,GAAG,4BAA4B,GAAG,0BAA0B;AACxiB,YAAY,mBAAO,CAAC,4BAAI;AACxB,oBAAoB,mBAAO,CAAC,0CAAc;AAC1C,oBAAoB,mBAAO,CAAC,6CAAa;AACzC;AACA,0BAA0B;AAC1B;AACA;AACA,mDAAmD,sBAAsB;AACzE;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA,mDAAmD,gGAAgG;AACnJ;AACA;AACA;AACA;AACA;AACA,mDAAmD,gGAAgG;AACnJ;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,mDAAmD,sBAAsB;AACzE;AACA;AACA,qBAAqB,6CAA6C;AAClE;AACA,aAAa;AACb;AACA;AACA,mDAAmD,sBAAsB;AACzE;AACA;AACA;AACA,mDAAmD,sBAAsB;AACzE;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,mDAAmD,sBAAsB;AACzE;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA,KAAK;AACL;AACA;AACA;AACA,gBAAgB,aAAa,mBAAmB,UAAU,cAAc,8BAA8B;AACtG,uCAAuC,qCAAqC;AAC5E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B;AAC5B;AACA,kBAAkB;AAClB;AACA;AACA;AACA,mDAAmD,sBAAsB;AACzE;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yEAAyE,IAAI;AAC7E;AACA;AACA,4DAA4D,sBAAsB;AAClF;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wDAAwD,sBAAsB;AAC9E;AACA,8BAA8B;AAC9B;AACA;AACA,gGAAgG,SAAS,+BAA+B,EAAE;AAC1I,gCAAgC,UAAU,SAAS,uBAAuB;AAC1E,kDAAkD,YAAY;AAC9D,4EAA4E,OAAO,cAAc,WAAW,kBAAkB,KAAK,EAAE,UAAU;AAC/I;AACA;AACA,4BAA4B;AAC5B;AACA;AACA,uHAAuH,aAAa;AACpI;AACA;AACA,8BAA8B,MAAM,mBAAmB,cAAc,iBAAiB,YAAY;AAClG,sBAAsB,WAAW,WAAW,MAAM,qBAAqB,gBAAgB,iBAAiB,YAAY;AACpH;AACA,UAAU;AACV,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,8BAA8B;AAC9B;AACA,sBAAsB;AACtB,iBAAiB;AACjB,wDAAwD,kCAAkC;AAC1F;AACA;AACA;AACA,KAAK;AACL;AACA,iCAAiC;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA;AACA;AACA,YAAY,8JAA8J;AAC1K;AACA;AACA,uBAAuB,gBAAgB,2BAA2B,sBAAsB;AACxF,qBAAqB,cAAc,2BAA2B,sBAAsB;AACpF,qBAAqB,cAAc,qBAAqB,gBAAgB;AACxE;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,4BAA4B;AAC5B;AACA,sBAAsB;AACtB,iBAAiB;AACjB;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,qBAAqB;AACrB;AACA,sBAAsB;AACtB,iBAAiB;AACjB,+DAA+D,6BAA6B;AAC5F;AACA;AACA,2BAA2B;AAC3B;AACA;AACA,4CAA4C,cAAc;AAC1D,qDAAqD,eAAe;AACpE;AACA,qFAAqF,iCAAiC;AACtH;AACA,mBAAmB,qBAAqB;AACxC;AACA,iBAAiB;AACjB,+DAA+D,mCAAmC;AAClG;AACA;AACA,8BAA8B;AAC9B;AACA;AACA,4CAA4C,cAAc;AAC1D,qDAAqD,eAAe;AACpE;AACA,iEAAiE,iCAAiC;AAClG;AACA,YAAY,SAAS;AACrB,iBAAiB;AACjB,+DAA+D,mCAAmC;AAClG;AACA;AACA,yBAAyB;AACzB;AACA,sBAAsB;AACtB,+DAA+D,+BAA+B,eAAe;AAC7G;AACA;AACA,oBAAoB;AACpB;AACA;AACA,0DAA0D,SAAS;AACnE,gCAAgC,eAAe;AAC/C;AACA,yBAAyB;AACzB;AACA,iBAAiB;AACjB,8CAA8C,oBAAoB;AAClE;AACA,4BAA4B;AAC5B;AACA,iBAAiB;AACjB,mFAAmF,iCAAiC;AACpH;AACA;AACA,gCAAgC;;;;;;;;;;;;AC1SnB;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,oBAAoB,GAAG,8BAA8B;AACrD,uBAAuB,mBAAO,CAAC,gDAAiB;AAChD,oBAAoB,mBAAO,CAAC,0CAAc;AAC1C;AACA;AACA;AACA,cAAc;AACd,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B;AAC9B;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA,iCAAiC,YAAY;AAC7C;AACA,oBAAoB;;;;;;;;;;;;AC5BP;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,mBAAmB,GAAG,6BAA6B,GAAG,wBAAwB,GAAG,oBAAoB;AACrG,oBAAoB,mBAAO,CAAC,0CAAc;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,KAAK;AACL;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,KAAK;AACL;AACA,wBAAwB;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,aAAa;AACb;AACA,6BAA6B;AAC7B;AACA,iBAAiB;AACjB,+FAA+F,IAAI;AACnG;AACA;AACA;AACA;AACA,oCAAoC;AACpC;AACA;AACA;AACA,SAAS,IAAI;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,mBAAmB;;;;;;;;;;;;AC7EN;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,aAAa,GAAG,aAAa;AAC7B,oBAAoB,mBAAO,CAAC,0CAAc;AAC1C;AACA,mDAAmD,sBAAsB;AACzE;AACA,gBAAgB,yBAAyB;AACzC;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA,sCAAsC,sDAAsD;AAC5F;AACA;AACA;AACA,gBAAgB,qBAAqB;AACrC,gBAAgB,qCAAqC;AACrD;AACA;AACA;AACA,gBAAgB,gCAAgC;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,yDAAyD,sBAAsB;AAC/E,YAAY,OAAO;AACnB,YAAY,iBAAiB;AAC7B;AACA,gBAAgB,wBAAwB,cAAc,aAAa,kCAAkC;AACrG;AACA,iBAAiB;AACjB,KAAK;AACL,aAAa;AACb;AACA;AACA,sBAAsB,8BAA8B;AACpD,4DAA4D,wBAAwB;AACpF;AACA;AACA,aAAa;AACb;AACA,sBAAsB,8BAA8B;AACpD;AACA;AACA;AACA,oEAAoE,4BAA4B;AAChG;AACA;AACA,aAAa;;;;;;;;;;;;AChEA;AACb;AACA;AACA;AACA;AACA,eAAe,oCAAoC;AACnD;AACA;AACA,CAAC;AACD;AACA;AACA,CAAC;AACD;AACA;AACA;AACA,8CAA6C,EAAE,aAAa,EAAC;AAC7D,aAAa,mBAAO,CAAC,iCAAO;AAC5B,aAAa,mBAAO,CAAC,iCAAO;AAC5B,aAAa,mBAAO,CAAC,uCAAU;AAC/B,aAAa,mBAAO,CAAC,6CAAa;AAClC,aAAa,mBAAO,CAAC,mDAAgB;AACrC,aAAa,mBAAO,CAAC,+CAAc;AACnC,aAAa,mBAAO,CAAC,qDAAiB;AACtC,aAAa,mBAAO,CAAC,yDAAmB;AACxC,aAAa,mBAAO,CAAC,2CAAY;AACjC,aAAa,mBAAO,CAAC,uDAAkB;AACvC,aAAa,mBAAO,CAAC,6CAAa;AAClC,aAAa,mBAAO,CAAC,2CAAY;AACjC,aAAa,mBAAO,CAAC,uCAAU;AAC/B,aAAa,mBAAO,CAAC,uCAAU;AAC/B,aAAa,mBAAO,CAAC,2CAAY;AACjC,aAAa,mBAAO,CAAC,6CAAa;AAClC,aAAa,mBAAO,CAAC,yCAAW;AAChC,aAAa,mBAAO,CAAC,qDAAiB;AACtC,aAAa,mBAAO,CAAC,qCAAS;AAC9B,aAAa,mBAAO,CAAC,2CAAY;AACjC,aAAa,mBAAO,CAAC,uCAAU;;;;;;;;;;;;ACpClB;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,oBAAoB,GAAG,oBAAoB;AAC3C,oBAAoB,mBAAO,CAAC,0CAAc;AAC1C;AACA;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA;AACA,oDAAoD,mBAAmB;AACvE,SAAS,IAAI;AACb,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF,qCAAqC,8BAA8B;AACnE;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB;;;;;;;;;;;;AC7EP;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,cAAc,GAAG,YAAY,GAAG,uBAAuB,GAAG,uBAAuB;AACjF,uBAAuB,mBAAO,CAAC,gDAAiB;AAChD,oBAAoB,mBAAO,CAAC,0CAAc;AAC1C;AACA;AACA;AACA,YAAY,gCAAgC;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA,uBAAuB;AACvB;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA,uBAAuB;AACvB;AACA;AACA;AACA;AACA,mBAAmB,uBAAuB;AAC1C;AACA;AACA,KAAK;AACL;AACA,uBAAuB;AACvB;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA,8DAA8D,cAAc;AAC5E,SAAS;AACT;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,cAAc;;;;;;;;;;;;ACnED;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,oBAAoB,GAAG,yBAAyB,GAAG,sBAAsB,GAAG,sBAAsB,GAAG,qBAAqB,GAAG,mBAAmB,GAAG,yBAAyB,GAAG,oBAAoB,GAAG,yBAAyB,GAAG,kBAAkB,GAAG,iBAAiB,GAAG,wBAAwB,GAAG,wBAAwB,GAAG,yBAAyB,GAAG,mBAAmB;AAChX,qBAAqB,mBAAO,CAAC,4DAAY;AACzC,uBAAuB,mBAAO,CAAC,gDAAiB;AAChD,oBAAoB,mBAAO,CAAC,0CAAc;AAC1C,mBAAmB;AACnB,MAAM,wEAAwE;AAC9E,MAAM;AACN;AACA;AACA,yBAAyB;AACzB;AACA,wBAAwB;AACxB;AACA;AACA;AACA,wBAAwB;AACxB,6CAA6C,IAAI,GAAG,qCAAqC,IAAI,IAAI,EAAE,QAAQ,IAAI;AAC/G,gDAAgD,IAAI,IAAI,qCAAqC;AAC7F;AACA,gDAAgD,oBAAoB;AACpE;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C;AAC9C,EAAE,SAAS,iDAAiD,YAAY;AACxE;AACA,kBAAkB,QAAQ;AAC1B,oBAAoB,OAAO;AAC3B;AACA;AACA,0BAA0B,SAAS;AACnC,iCAAiC,sDAAsD;AACvF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gDAAgD,oBAAoB;AACpE;AACA,KAAK,eAAe,EAAE;AACtB;AACA,yBAAyB,mDAAmD;AAC5E,kBAAkB,aAAa,kBAAkB,gBAAgB;AACjE,wCAAwC,mBAAmB;AAC3D;AACA,mBAAmB,mBAAmB;AACtC,IAAI,cAAc;AAClB;AACA;AACA,gDAAgD,oBAAoB;AACpE,wDAAwD,mBAAmB;AAC3E;AACA,WAAW,eAAe,EAAE;AAC5B;AACA,iCAAiC,mDAAmD;AACpF,0BAA0B,aAAa,kBAAkB,gBAAgB;AACzE,YAAY,aAAa,EAAE,iBAAiB;AAC5C,YAAY;AACZ,YAAY,cAAc;AAC1B;AACA;AACA,sDAAsD,mBAAmB;AACzE,kCAAkC,aAAa;AAC/C;AACA,sDAAsD,gBAAgB;AACtE;AACA;AACA,mDAAmD,oBAAoB;AACvE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,iBAAiB;AACjB,KAAK;AACL;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA,sFAAsF,IAAI,EAAE,gBAAgB;AAC5G;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,YAAY,qCAAqC;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,iCAAiC;AACpD;AACA;AACA,KAAK;AACL;AACA,oBAAoB;AACpB;AACA;AACA;AACA;AACA,8CAA8C,yBAAyB;AACvE;AACA,mBAAmB,iCAAiC;AACpD;AACA,cAAc;AACd,KAAK;AACL;AACA,yBAAyB;AACzB;AACA;AACA;AACA,mBAAmB;AACnB;AACA;AACA;AACA,qBAAqB;AACrB,sBAAsB;AACtB;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACnXa;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,uBAAuB,GAAG,wBAAwB,GAAG,uBAAuB;AAC5E,uBAAuB,mBAAO,CAAC,gDAAiB;AAChD,oBAAoB,mBAAO,CAAC,0CAAc;AAC1C;AACA;AACA;AACA,uBAAuB;AACvB;AACA;AACA;AACA,wBAAwB;AACxB;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,2BAA2B,UAAU;AACrC,kDAAkD,IAAI;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA,aAAa;AACb;AACA,uBAAuB;;;;;;;;;;;;ACpCV;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,4BAA4B,GAAG,4BAA4B,GAAG,6BAA6B,GAAG,qBAAqB,GAAG,qBAAqB,GAAG,sBAAsB,GAAG,gBAAgB,GAAG,oBAAoB;AAC9M,wBAAwB,mBAAO,CAAC,0EAAe;AAC/C,WAAW,mBAAO,CAAC,+BAAG;AACtB,uBAAuB,mBAAO,CAAC,gDAAiB;AAChD,oBAAoB,mBAAO,CAAC,0CAAc;AAC1C,oBAAoB,mBAAO,CAAC,6CAAa;AACzC;AACA,iBAAiB,QAAQ,IAAI,SAAS,KAAK,GAAG,OAAO;AACrD,sBAAsB;AACtB;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,4DAA4D,wBAAwB;AACpF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,sCAAsC;AACvD,8CAA8C,aAAa,SAAS,cAAc,GAAG,gBAAgB;AACrG;AACA,mBAAmB,oDAAoD;AACvE;AACA,sBAAsB;AACtB;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,gBAAgB,aAAa;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA,gBAAgB,6BAA6B;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,YAAY,uGAAuG;AACnH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mDAAmD,sBAAsB;AACzE;AACA,YAAY,uGAAuG,6EAA6E;AAChM;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,IAAI,SAAS,KAAK,GAAG,aAAa,MAAM,KAAK,GAAG,UAAU;AAC1E;AACA,sBAAsB;AACtB;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,sBAAsB;AACtB;AACA,mDAAmD,YAAY;AAC/D,oDAAoD,OAAO,IAAI,IAAI,gBAAgB,OAAO,iBAAiB,MAAM;AACjH;AACA,YAAY;AACZ;AACA;AACA,qCAAqC,uCAAuC;AAC5E,kCAAkC,4CAA4C;AAC9E,kCAAkC,4CAA4C;AAC9E;AACA,KAAK;AACL;AACA;AACA,+BAA+B,cAAc;AAC7C;AACA;AACA;AACA;AACA;AACA,mBAAmB,QAAQ;AAC3B,0BAA0B,kDAAkD;AAC5E;AACA,IAAI;AACJ;AACA,uBAAuB,YAAY;AACnC,uCAAuC,4BAA4B;AACnE,gCAAgC,qBAAqB;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,0BAA0B;AAC9C,oBAAoB,0BAA0B;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ,kCAAkC,MAAM;AACxC;AACA,8BAA8B,mCAAmC,EAAE,4DAA4D;AAC/H;AACA,UAAU;AACV;AACA,2BAA2B,yCAAyC;AACpE,2CAA2C,4CAA4C;AACvF,oCAAoC,qCAAqC;AACzE;AACA;AACA,MAAM,IAAI;AACV;AACA;AACA;AACA;AACA;AACA,0BAA0B,oCAAoC;AAC9D,4BAA4B,OAAO;AACnC,iCAAiC,YAAY;AAC7C,+BAA+B,UAAU;AACzC,gCAAgC,WAAW;AAC3C,4BAA4B,OAAO;AACnC,mCAAmC,6CAA6C;AAChF;AACA;AACA;AACA;AACA,4BAA4B,OAAO;AACnC,iCAAiC,YAAY;AAC7C,mCAAmC,cAAc;AACjD;AACA;AACA;AACA,uCAAuC,WAAW;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+EAA+E,gBAAgB,+CAA+C,4CAA4C,4CAA4C,4CAA4C;AAClR;AACA;AACA,4CAA4C,OAAO;AACnD;AACA,wDAAwD,OAAO,uBAAuB,YAAY,kBAAkB,OAAO,iBAAiB,MAAM;AAClJ,+BAA+B,cAAc;AAC7C,UAAU;AACV;AACA,KAAK;AACL;AACA;AACA;AACA,wBAAwB,cAAc;AACtC,4BAA4B,kBAAkB;AAC9C,8BAA8B,oBAAoB;AAClD,wCAAwC,8BAA8B;AACtE;AACA,IAAI;AACJ;AACA,IAAI;AACJ,2BAA2B,gDAAgD;AAC3E;AACA,qBAAqB,SAAS;AAC9B,4BAA4B,mDAAmD;AAC/E;AACA,MAAM;AACN;AACA,yBAAyB,aAAa;AACtC,yCAAyC,6BAA6B;AACtE,kCAAkC,sBAAsB;AACxD,2BAA2B,eAAe;AAC1C;AACA,oDAAoD,SAAS;AAC7D,kCAAkC,wBAAwB;AAC1D,2BAA2B,iBAAiB;AAC5C,+BAA+B,oDAAoD;AACnF,gCAAgC,sBAAsB;AACtD;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,YAAY,6GAA6G;AACzH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,aAAa;AACb;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,aAAa;AACb;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA,gBAAgB,IAAI,SAAS,iBAAiB,GAAG,oBAAoB,MAAM,eAAe,GAAG,iBAAiB;AAC9G;AACA,sBAAsB;AACtB,mBAAmB;AACnB;AACA;AACA;AACA,6BAA6B;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB;AACtB,mBAAmB;AACnB;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,4BAA4B;AAC5B;AACA;AACA,iBAAiB;AACjB,sBAAsB;AACtB,mBAAmB;AACnB;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,4BAA4B;;;;;;;;;;;;AChWf;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,iBAAiB,GAAG,uBAAuB;AAC3C,uBAAuB,mBAAO,CAAC,gDAAiB;AAChD,oBAAoB,mBAAO,CAAC,0CAAc;AAC1C,0BAA0B,mBAAO,CAAC,yDAAmB;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oFAAoF,KAAK;AACzF,sBAAsB,8BAA8B;AACpD;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB;AACA,KAAK;AACL;AACA;AACA,iBAAiB;;;;;;;;;;;;AC5DJ;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,yBAAyB,GAAG,yBAAyB,GAAG,sBAAsB,GAAG,oBAAoB;AACrG,uBAAuB,mBAAO,CAAC,gDAAiB;AAChD,oBAAoB,mBAAO,CAAC,0CAAc;AAC1C;AACA,iBAAiB;AACjB;AACA;AACA,0FAA0F,eAAe,2BAA2B;AACpI;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,oBAAoB;AACpB;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,UAAU,SAAS,KAAK,GAAG,OAAO;AACrD,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,yBAAyB;AACzB;AACA,sBAAsB;AACtB,iBAAiB;AACjB,mDAAmD,KAAK;AACxD,4CAA4C,aAAa;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,yBAAyB;;;;;;;;;;;;AClEZ;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,qBAAqB,GAAG,qBAAqB,GAAG,+BAA+B,GAAG,4BAA4B,GAAG,wBAAwB,GAAG,uBAAuB,GAAG,8BAA8B,GAAG,uBAAuB,GAAG,sBAAsB,GAAG,6BAA6B,GAAG,0BAA0B,GAAG,sBAAsB,GAAG,mBAAmB,GAAG,yBAAyB,GAAG,wBAAwB;AAC1Z,uBAAuB,mBAAO,CAAC,gDAAiB;AAChD,oBAAoB,mBAAO,CAAC,0CAAc;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,wBAAwB;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB;AACxB;AACA;AACA,KAAK;AACL;AACA;AACA,yBAAyB;AACzB;AACA;AACA,aAAa,UAAU,WAAW,gCAAgC;AAClE;AACA;AACA;AACA,qCAAqC,OAAO,oBAAoB,QAAQ;AACxE;AACA,uDAAuD,6BAA6B,QAAQ;AAC5F,0BAA0B,+BAA+B;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uFAAuF,+BAA+B;AACtH;AACA;AACA;AACA,mBAAmB;AACnB;AACA,mBAAmB,IAAI,SAAS,KAAK,GAAG,OAAO;AAC/C,iBAAiB;AACjB,sBAAsB;AACtB,yFAAyF,mCAAmC;AAC5H;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,sBAAsB;AACtB;AACA,mBAAmB,IAAI,SAAS,KAAK,GAAG,OAAO;AAC/C,iBAAiB;AACjB,sBAAsB;AACtB,0FAA0F,mCAAmC;AAC7H;AACA;AACA,0BAA0B;AAC1B;AACA;AACA;AACA;AACA;AACA,iBAAiB,QAAQ,IAAI,SAAS,KAAK,GAAG,OAAO;AACrD,sBAAsB;AACtB,4FAA4F,mCAAmC;AAC/H;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B;AACA,0CAA0C,gCAAgC;AAC1E;AACA,gBAAgB,IAAI,EAAE,IAAI,SAAS,KAAK,GAAG,SAAS,MAAM,KAAK,GAAG,OAAO;AACzE;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA,sBAAsB;AACtB,oCAAoC,IAAI,SAAS,KAAK,GAAG,OAAO;AAChE,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,0GAA0G;AAC1G,yIAAyI;AACzI;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,uBAAuB;AACvB;AACA;AACA,qBAAqB;AACrB;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA,qCAAqC;AACrC;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA,sCAAsC,KAAK,qDAAqD,yBAAyB;AACzH;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,iBAAiB;AACjB,KAAK;AACL;AACA;AACA,8BAA8B;AAC9B;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,mBAAmB,IAAI;AACvB,iBAAiB;AACjB,sBAAsB;AACtB,4CAA4C,aAAa;AACzD;AACA;AACA;AACA;AACA,uBAAuB;AACvB;AACA;AACA,iBAAiB,QAAQ,IAAI,QAAQ,MAAM,OAAO,KAAK;AACvD,sBAAsB;AACtB;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB;AACxB;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B;AAC5B;AACA,sBAAsB;AACtB;AACA;AACA,qCAAqC,OAAO,iCAAiC,MAAM;AACnF,wFAAwF,8BAA8B;AACtH;AACA;AACA,+BAA+B;AAC/B;AACA,sBAAsB;AACtB;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,qBAAqB;AACrB;AACA;AACA,gBAAgB,IAAI,SAAS,KAAK,GAAG,OAAO;AAC5C;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,qBAAqB;;;;;;;;;;;;ACtUR;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,sBAAsB,GAAG,gBAAgB,GAAG,qBAAqB,GAAG,yBAAyB,GAAG,2BAA2B,GAAG,0BAA0B,GAAG,yBAAyB,GAAG,2BAA2B,GAAG,2BAA2B,GAAG,iBAAiB;AACpQ,uBAAuB,mBAAO,CAAC,gDAAiB;AAChD,oBAAoB,mBAAO,CAAC,0CAAc;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,oCAAoC,iBAAiB,KAAK;AAC3D;AACA,gDAAgD,kDAAkD;AAClG;AACA;AACA,yBAAyB,WAAW;AACpC;AACA;AACA;AACA,gBAAgB,uDAAuD;AACvE;AACA,iBAAiB;AACjB;AACA,YAAY,wBAAwB;AACpC;AACA,mCAAmC,sDAAsD,qDAAqD;AAC9I;AACA,aAAa;AACb;AACA,2BAA2B;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,iEAAiE,mBAAmB;AACpG,wBAAwB;AACxB,iBAAiB;AACjB,KAAK;AACL;AACA,2BAA2B;AAC3B,2CAA2C,iBAAiB,GAAG,iBAAiB,GAAG,iBAAiB;AACpG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB;AACxB;AACA;AACA;AACA;AACA;AACA,YAAY,UAAU;AACtB;AACA;AACA;AACA;AACA;AACA,iDAAiD,mBAAmB,WAAW,IAAI;AACnF,KAAK;AACL,aAAa;AACb;AACA,yBAAyB;AACzB;AACA,YAAY,sMAAsM;AAClN;AACA,mBAAmB;AACnB,aAAa;AACb;AACA;AACA,mDAAmD,4CAA4C;AAC/F;AACA;AACA;AACA;AACA,iBAAiB;AACjB,KAAK,IAAI;AACT;AACA,aAAa;AACb;AACA,0BAA0B;AAC1B;AACA;AACA,gDAAgD,kDAAkD;AAClG;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA,kBAAkB,6BAA6B;AAC/C;AACA;AACA,aAAa;AACb;AACA,2BAA2B;AAC3B;AACA,YAAY,iCAAiC,mCAAmC;AAChF,0BAA0B,mBAAmB;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,QAAQ,uDAAuD,qCAAqC;AAClH;AACA,yBAAyB;AACzB;AACA,iBAAiB;AACjB,uEAAuE,eAAe,yBAAyB,kCAAkC;AACjJ;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA,iBAAiB;AACjB,4EAA4E,eAAe,yBAAyB,kCAAkC;AACtJ;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA,YAAY,iBAAiB;AAC7B;AACA;AACA,4CAA4C,eAAe,yBAAyB,iBAAiB;AACrG;AACA;AACA,sBAAsB;;;;;;;;;;;;ACzLT;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,oBAAoB,GAAG,iCAAiC,GAAG,iCAAiC,GAAG,2BAA2B,GAAG,wBAAwB,GAAG,sBAAsB,GAAG,qBAAqB,GAAG,0BAA0B,GAAG,kBAAkB,GAAG,2BAA2B;AACtR,qBAAqB,mBAAO,CAAC,+CAAc;AAC3C,YAAY,mBAAO,CAAC,4BAAI;AACxB,mBAAmB,mBAAO,CAAC,+CAAc;AACzC,uDAAsD,EAAE,qCAAqC,4CAA4C,EAAC;AAC1I;AACA,iBAAiB;AACjB;AACA;AACA,KAAK;AACL;AACA;AACA,kBAAkB;AAClB;AACA,iBAAiB;AACjB,yFAAyF,IAAI;AAC7F;AACA;AACA,0BAA0B;AAC1B;AACA;AACA,+CAA+C,GAAG;AAClD;AACA,mBAAmB,MAAM;AACzB,wCAAwC,YAAY;AACpD;AACA;AACA,qBAAqB;AACrB;AACA,mBAAmB,MAAM;AACzB,wCAAwC,YAAY;AACpD;AACA;AACA,sBAAsB;AACtB,mDAAmD;AACnD;AACA;AACA;AACA,mBAAmB;AACnB,wCAAwC,YAAY;AACpD;AACA;AACA,wBAAwB;AACxB;AACA,sBAAsB;AACtB;AACA;AACA,0CAA0C,iCAAiC;AAC3E,uCAAuC,8BAA8B;AACrE,2CAA2C,kCAAkC;AAC7E,oCAAoC,2BAA2B;AAC/D,gCAAgC,uBAAuB;AACvD,8BAA8B,qBAAqB;AACnD,kCAAkC,yBAAyB;AAC3D,mCAAmC,0BAA0B;AAC7D,0CAA0C,iCAAiC;AAC3E,6BAA6B,oBAAoB;AACjD,gCAAgC,uBAAuB;AACvD,wCAAwC,+BAA+B;AACvE,sCAAsC,6BAA6B;AACnE;AACA,mBAAmB;AACnB;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B;AAC3B;AACA;AACA,4DAA4D,oBAAoB,iBAAiB,kBAAkB;AACnH;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB;AACnB;AACA;AACA;AACA,iCAAiC;AACjC;AACA;AACA,gDAAgD,OAAO,GAAG,GAAG;AAC7D,2BAA2B,kBAAkB;AAC7C;AACA,iCAAiC;AACjC;AACA;AACA,gDAAgD,OAAO,GAAG,GAAG;AAC7D,2BAA2B,kBAAkB;AAC7C;AACA,oBAAoB;;;;;;;;;;;;AChGP;AACb;AACA;AACA;AACA;AACA,eAAe,oCAAoC;AACnD;AACA;AACA,CAAC;AACD;AACA;AACA,CAAC;AACD;AACA,0CAA0C,4BAA4B;AACtE,CAAC;AACD;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA6C,EAAE,aAAa,EAAC;AAC7D,6BAA6B,GAAG,4BAA4B,GAAG,0BAA0B,GAAG,yBAAyB,GAAG,yBAAyB,GAAG,2BAA2B,GAAG,2BAA2B,GAAG,4BAA4B;AAC5O,uBAAuB,mBAAO,CAAC,gDAAO;AACtC,oBAAoB,mBAAO,CAAC,0CAAc;AAC1C,uBAAuB,mBAAO,CAAC,gDAAiB;AAChD,kCAAkC,gBAAgB;AAClD;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,yCAAyC;AAChE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD,6BAA6B,+BAA+B;AAC5D;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD,8BAA8B,YAAY;AAC1C;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA,CAAC;AACD,+BAA+B,uBAAuB;AACtD;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA,CAAC;AACD,iCAAiC,kBAAkB;AACnD;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA,CAAC;AACD,sCAAsC,wBAAwB;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,CAAC;AACD;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,oCAAoC;AAC9D,qBAAqB,kCAAkC;AACvD;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA,CAAC;AACD;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,CAAC;AACD,mCAAmC,cAAc;AACjD,4BAA4B;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gEAAgE,sBAAsB;AACtF;AACA;AACA,gBAAgB,cAAc,8BAA8B,aAAa,8BAA8B,0BAA0B;AACjI;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,YAAY,UAAU,cAAc,iBAAiB,mBAAmB,UAAU;AAClF;AACA,aAAa;AACb;AACA,yBAAyB;AACzB;AACA,iHAAiH,sBAAsB;AACvI;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,aAAa;AACb;AACA,yBAAyB;AACzB;AACA,sDAAsD,sBAAsB;AAC5E;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB,KAAK;AACL;AACA;AACA;AACA,aAAa;AACb;AACA,0BAA0B;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wHAAwH,sBAAsB;AAC9I;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,aAAa;AACb;AACA,4BAA4B;AAC5B;AACA,2EAA2E,sBAAsB;AACjG;AACA,YAAY,eAAe,kDAAkD,UAAU;AACvF;AACA,gBAAgB,4BAA4B;AAC5C;AACA;AACA;AACA,0EAA0E,2BAA2B,QAAQ,iBAAiB;AAC9H,gBAAgB,6CAA6C;AAC7D,gBAAgB,4DAA4D;AAC5E;AACA;AACA;AACA,uFAAuF,sCAAsC,QAAQ,UAAU;AAC/I;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,aAAa;AACb;AACA,6BAA6B;;;;;;;;;;;;ACzdhB;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,iCAAiC,GAAG,+BAA+B,GAAG,0BAA0B,GAAG,mBAAmB,GAAG,wBAAwB,GAAG,yBAAyB,GAAG,wBAAwB,GAAG,uBAAuB,GAAG,2BAA2B,GAAG,8BAA8B,GAAG,0BAA0B,GAAG,sBAAsB,GAAG,uBAAuB,GAAG,qBAAqB,GAAG,2BAA2B;AACva,uBAAuB,mBAAO,CAAC,gDAAiB;AAChD,oBAAoB,mBAAO,CAAC,0CAAc;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,wDAAwD,2BAA2B,KAAK;AACzF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,4CAA4C,cAAc;AAC1D,qDAAqD,eAAe;AACpE;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,UAAU,uCAAuC;AACjD;AACA;AACA;AACA,kBAAkB,qBAAqB;AACvC;AACA;AACA,qBAAqB;AACrB,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA,aAAa;AACb;AACA,qBAAqB;AACrB;AACA;AACA;AACA,iDAAiD,wCAAwC;AACzF,kCAAkC,iBAAiB;AACnD;AACA;AACA;AACA;AACA;AACA,yDAAyD,eAAe;AACxE,SAAS;AACT;AACA,KAAK;AACL;AACA;AACA;AACA,uBAAuB;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA,cAAc;AACd,KAAK;AACL;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA,sBAAsB;AACtB;AACA;AACA,cAAc;AACd,KAAK;AACL;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA,0BAA0B;AAC1B;AACA,wDAAwD,EAAE,IAAI,EAAE;AAChE;AACA,yBAAyB,wCAAwC;AACjE;AACA,aAAa,gCAAgC,EAAE,4BAA4B;AAC3E;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA,4CAA4C,yBAAyB;AACrE;AACA;AACA,8BAA8B;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C,8BAA8B;AAC1E;AACA;AACA,2BAA2B;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB;AACnB,KAAK;AACL;AACA,uBAAuB;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0EAA0E,gBAAgB,GAAG,OAAO;AACpG;AACA,mBAAmB;AACnB,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,wBAAwB;AACxB;AACA;AACA,uHAAuH,gBAAgB,mBAAmB,WAAW;AACrK;AACA;AACA,mBAAmB,yBAAyB;AAC5C,cAAc,YAAY;AAC1B;AACA,KAAK;AACL;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA,iEAAiE,gBAAgB;AACjF,mBAAmB,KAAK;AACxB;AACA;AACA;AACA,mBAAmB;AACnB,KAAK;AACL;AACA;AACA;AACA,wBAAwB;AACxB;AACA;AACA,mBAAmB,8BAA8B;AACjD,KAAK;AACL;AACA,mFAAmF,0CAA0C;AAC7H;AACA,mBAAmB;AACnB;AACA;AACA;AACA,mBAAmB,yBAAyB;AAC5C,cAAc;AACd,KAAK;AACL;AACA;AACA;AACA;AACA,0BAA0B;AAC1B;AACA,mDAAmD,4BAA4B;AAC/E;AACA,gBAAgB,eAAe,gCAAgC,YAAY;AAC3E,gBAAgB,iCAAiC;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,sBAAsB;AACtB;AACA,4CAA4C,SAAS;AACrD;AACA;AACA,+BAA+B;AAC/B;AACA,gDAAgD,4BAA4B;AAC5E;AACA,iBAAiB;AACjB,KAAK;AACL;AACA,iBAAiB,aAAa;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA,sEAAsE,aAAa;AACnF,kEAAkE,WAAW;AAC7E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB;AACtB,4CAA4C,SAAS;AACrD;AACA;AACA,iCAAiC;;;;;;;;;;;;ACnSpB;AACb;AACA;AACA;AACA;AACA,eAAe,oCAAoC;AACnD;AACA;AACA,CAAC;AACD;AACA;AACA,CAAC;AACD;AACA,0CAA0C,4BAA4B;AACtE,CAAC;AACD;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA6C,EAAE,aAAa,EAAC;AAC7D,iCAAiC,GAAG,0BAA0B,GAAG,mBAAmB,GAAG,+BAA+B,GAAG,wBAAwB,GAAG,yBAAyB;AAC7K,uBAAuB,mBAAO,CAAC,gDAAO;AACtC,YAAY,mBAAO,CAAC,4BAAI;AACxB,oBAAoB,mBAAO,CAAC,0CAAc;AAC1C,oBAAoB,mBAAO,CAAC,6CAAa;AACzC;AACA;AACA;AACA;AACA;AACA,CAAC,oDAAoD,yBAAyB,KAAK;AACnF;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,kDAAkD,wBAAwB,KAAK;AAChF;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA,mCAAmC,aAAa;AAChD;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA,CAAC;AACD,+BAA+B;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,eAAe,eAAe,gBAAgB,cAAc,eAAe;AAC3G,4BAA4B,YAAY,YAAY,aAAa,UAAU,WAAW;AACtF;AACA;AACA;AACA;AACA;AACA,gDAAgD,IAAI;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,mBAAmB;AACnB;AACA,sBAAsB;AACtB;AACA,2DAA2D,iBAAiB;AAC5E;AACA;AACA;AACA;AACA,4BAA4B,aAAa;AACzC;AACA,sCAAsC,eAAe,eAAe,gBAAgB,cAAc,eAAe;AACjH,kCAAkC,YAAY,YAAY,aAAa,UAAU,WAAW;AAC5F;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,0BAA0B;AAC1B;AACA,sBAAsB;AACtB;AACA;AACA;AACA;AACA,cAAc;AACd,KAAK;AACL,4DAA4D,sBAAsB;AAClF;AACA,gBAAgB,oBAAoB;AACpC,gBAAgB,MAAM;AACtB,iBAAiB;AACjB,KAAK;AACL;AACA;AACA,iCAAiC;;;;;;;;;;;;ACnKpB;AACb;AACA;AACA;AACA;AACA,eAAe,oCAAoC;AACnD;AACA;AACA,CAAC;AACD;AACA;AACA,CAAC;AACD;AACA,0CAA0C,4BAA4B;AACtE,CAAC;AACD;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA6C,EAAE,aAAa,EAAC;AAC7D,gBAAgB,GAAG,wBAAwB,GAAG,qBAAqB,GAAG,gBAAgB;AACtF,oBAAoB,mBAAO,CAAC,0CAAc;AAC1C,uBAAuB,mBAAO,CAAC,gDAAO;AACtC;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA,CAAC;AACD,gBAAgB;AAChB;AACA;AACA;AACA;AACA,CAAC;AACD,2CAA2C,iBAAiB,GAAG,oBAAoB,MAAM,eAAe,GAAG,iBAAiB;AAC5H,qBAAqB;AACrB;AACA;AACA,wCAAwC,sBAAsB,GAAG,2BAA2B;AAC5F;AACA;AACA;AACA;AACA,sDAAsD;AACtD;AACA,oBAAoB,mBAAmB,EAAE,WAAW,UAAU,QAAQ,EAAE,MAAM,OAAO;AACrF,cAAc,UAAU,EAAE,YAAY,MAAM,OAAO,EAAE,KAAK;AAC1D;AACA,wBAAwB;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK,IAAI;AACT,YAAY,2BAA2B;AACvC,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA,KAAK,IAAI;AACT;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,gBAAgB;;;;;;;;;;;;ACrFH;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,gBAAgB;AAChB,kBAAe;;;;;;;;;;;;ACZF;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D;AACA;;;;;;;;;;;;ACHa;AACb;AACA;AACA;AACA;AACA,eAAe,oCAAoC;AACnD;AACA;AACA,CAAC;AACD;AACA;AACA,CAAC;AACD;AACA;AACA;AACA,8CAA6C,EAAE,aAAa,EAAC;AAC7D,2BAA2B,GAAG,yBAAyB,GAAG,2BAA2B,GAAG,oBAAoB,GAAG,kBAAkB,GAAG,4BAA4B,GAAG,kBAAkB,GAAG,4BAA4B,GAAG,qBAAqB,GAAG,wBAAwB,GAAG,sBAAsB,GAAG,oBAAoB,GAAG,mBAAmB,GAAG,yBAAyB,GAAG,wBAAwB,GAAG,uBAAuB,GAAG,wBAAwB,GAAG,gCAAgC,GAAG,yBAAyB,GAAG,0BAA0B,GAAG,wBAAwB,GAAG,wBAAwB,GAAG,yBAAyB,GAAG,iBAAiB,GAAG,2BAA2B,GAAG,sBAAsB,GAAG,mBAAmB,GAAG,qBAAqB;AAChuB,gBAAgB,mBAAO,CAAC,qCAAW;AACnC,iDAAgD,EAAE,qCAAqC,mCAAmC,EAAC;AAC3H,aAAa,mBAAO,CAAC,yCAAa;AAClC,aAAa,mBAAO,CAAC,+CAAgB;AACrC,YAAY,mBAAO,CAAC,mCAAO;AAC3B,+CAA8C,EAAE,qCAAqC,6BAA6B,EAAC;AACnH,kDAAiD,EAAE,qCAAqC,gCAAgC,EAAC;AACzH,uDAAsD,EAAE,qCAAqC,qCAAqC,EAAC;AACnI,6CAA4C,EAAE,qCAAqC,2BAA2B,EAAC;AAC/G,qDAAoD,EAAE,qCAAqC,mCAAmC,EAAC;AAC/H,oDAAmD,EAAE,qCAAqC,kCAAkC,EAAC;AAC7H,oDAAmD,EAAE,qCAAqC,kCAAkC,EAAC;AAC7H,sDAAqD,EAAE,qCAAqC,oCAAoC,EAAC;AACjI,qDAAoD,EAAE,qCAAqC,mCAAmC,EAAC;AAC/H,4DAA2D,EAAE,qCAAqC,0CAA0C,EAAC;AAC7I,oDAAmD,EAAE,qCAAqC,kCAAkC,EAAC;AAC7H,mDAAkD,EAAE,qCAAqC,iCAAiC,EAAC;AAC3H,oDAAmD,EAAE,qCAAqC,kCAAkC,EAAC;AAC7H,qDAAoD,EAAE,qCAAqC,mCAAmC,EAAC;AAC/H,+CAA8C,EAAE,qCAAqC,6BAA6B,EAAC;AACnH,gDAA+C,EAAE,qCAAqC,8BAA8B,EAAC;AACrH,kDAAiD,EAAE,qCAAqC,gCAAgC,EAAC;AACzH,oDAAmD,EAAE,qCAAqC,kCAAkC,EAAC;AAC7H,iDAAgD,EAAE,qCAAqC,+BAA+B,EAAC;AACvH,wDAAuD,EAAE,qCAAqC,sCAAsC,EAAC;AACrI,8CAA6C,EAAE,qCAAqC,4BAA4B,EAAC;AACjH,wDAAuD,EAAE,qCAAqC,sCAAsC,EAAC;AACrI,8CAA6C,EAAE,qCAAqC,4BAA4B,EAAC;AACjH,gDAA+C,EAAE,qCAAqC,8BAA8B,EAAC;AACrH,uDAAsD,EAAE,qCAAqC,qCAAqC,EAAC;AACnI,qDAAoD,EAAE,qCAAqC,mCAAmC,EAAC;AAC/H,uDAAsD,EAAE,qCAAqC,qCAAqC,EAAC;;;;;;;;;;;;AChDtH;AACb;AACA,6CAA6C;AAC7C;AACA,8CAA6C,EAAE,aAAa,EAAC;AAC7D,mBAAmB,GAAG,gBAAgB;AACtC,gCAAgC,mBAAO,CAAC,qCAAO;AAC/C,WAAW,mBAAO,CAAC,2BAAG;AACtB,oBAAoB,mBAAO,CAAC,yCAAa;AACzC;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,0BAA0B;AACtC;AACA,aAAa;AACb;AACA;AACA;AACA,iBAAiB,WAAW;AAC5B,YAAY,qCAAqC;AACjD;AACA;AACA;AACA,sDAAsD,YAAY,IAAI;AACtE,wDAAwD,aAAa,IAAI;AACzE;AACA;AACA;AACA;AACA;AACA,iBAAiB,WAAW;AAC5B,YAAY,oCAAoC;AAChD;AACA,6BAA6B,aAAa,IAAI;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,WAAW;AAC5B;AACA;AACA,uBAAuB;AACvB;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,oCAAoC;AACpD;AACA,iCAAiC,aAAa,IAAI;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB;;;;;;;;;;;;ACnGN;AACb;AACA;AACA;AACA;AACA,eAAe,oCAAoC;AACnD;AACA;AACA,CAAC;AACD;AACA;AACA,CAAC;AACD;AACA,0CAA0C,4BAA4B;AACtE,CAAC;AACD;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA6C,EAAE,aAAa,EAAC;AAC7D,aAAa,GAAG,mBAAmB,GAAG,uBAAuB,GAAG,gBAAgB,GAAG,oBAAoB,GAAG,iBAAiB,GAAG,aAAa,GAAG,YAAY,GAAG,qBAAqB,GAAG,iBAAiB,GAAG,oBAAoB,GAAG,aAAa,GAAG,aAAa,GAAG,iBAAiB,GAAG,0BAA0B,GAAG,WAAW,GAAG,qBAAqB,GAAG,mBAAmB,GAAG,eAAe,GAAG,eAAe,GAAG,gBAAgB,GAAG,oBAAoB,GAAG,eAAe,GAAG,uBAAuB,GAAG,oBAAoB,GAAG,oBAAoB,GAAG,mBAAmB,GAAG,qBAAqB,GAAG,gBAAgB,GAAG,gBAAgB,GAAG,eAAe,GAAG,gBAAgB,GAAG,oBAAoB;AAClqB,0BAA0B,mBAAO,CAAC,kEAAiB;AACnD,uBAAuB,mBAAO,CAAC,gDAAO;AACtC,sBAAsB,mBAAO,CAAC,0EAAe;AAC7C,gDAA+C,EAAE,qCAAqC,kCAAkC,EAAC;AACzH,wBAAwB,mBAAO,CAAC,0EAAe;AAC/C;AACA,gBAAgB;AAChB;AACA,eAAe;AACf;AACA,gBAAgB;AAChB;AACA,gBAAgB;AAChB;AACA,qBAAqB;AACrB;AACA,mBAAmB;AACnB;AACA;AACA;AACA;AACA;AACA,uBAAuB,MAAM,KAAK,IAAI,GAAG,iDAAiD,IAAI,IAAI;AAClG;AACA,uBAAuB,MAAM,KAAK,IAAI;AACtC;AACA;AACA,SAAS,KAAK;AACd,UAAU;AACV,UAAU,KAAK;AACf;AACA;AACA;AACA,oBAAoB;AACpB;AACA,oBAAoB;AACpB;AACA,uBAAuB;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,eAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA,eAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK,IAAI;AACT,eAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK,IAAI;AACT,mBAAmB;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK,IAAI;AACT,qBAAqB;AACrB,WAAW;AACX,0BAA0B;AAC1B;AACA;AACA;AACA;AACA,oCAAoC;AACpC;AACA;AACA;AACA;AACA,CAAC;AACD,iBAAiB;AACjB,gCAAgC;AAChC,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,2BAA2B;AAC3B;AACA;AACA;AACA,oBAAoB;AACpB;AACA,iBAAiB;AACjB;AACA,qBAAqB;AACrB;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA,oBAAoB;AACpB;AACA;AACA;AACA,aAAa,IAAI,GAAG,sBAAsB;AAC1C;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA,yBAAyB,OAAO,EAAE,IAAI,EAAE,qBAAqB,IAAI,KAAK;AACtE;AACA;AACA;AACA,uBAAuB;AACvB;AACA,mBAAmB;AACnB;AACA;AACA;AACA,aAAa;;;;;;;;;;;;AC5NA;;AAEb,kBAAkB,mBAAO,CAAC,oEAAa;AACvC,kBAAkB,mBAAO,CAAC,wFAAuB;AACjD,mBAAmB,mBAAO,CAAC,wFAAuB;;AAElD;AACA;AACA;AACA;AACA,C;;;;;;;;;;ACVA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,sC;;;;;;;;;;;ACnBa;;AAEb;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,aAAa;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,eAAe;AACf;AACA;;AAEA,qBAAqB;AACrB;AACA;;AAEA;AACA;AACA,WAAW,GAAG;AACd,WAAW,GAAG;AACd;AACA,aAAa;AACb;AACA,iCAAiC;AACjC,6BAA6B;AAC7B,oBAAoB,SAAS;AAC7B;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;;AAEF,gBAAgB;AAChB;AACA;AACA,IAAI;AACJ;AACA;AACA;;AAEA,iCAAiC;AACjC;;AAEA,cAAc;AACd,qBAAqB;AACrB,kBAAkB;;;;;;;;;;;;ACvEL;;AAEb,aAAa,mBAAO,CAAC,0DAAQ;;AAE7B;AACA;AACA;AACA;;AAEA;AACA,gBAAgB;AAChB,4BAA4B;;AAE5B,mDAAmD;AACnD,wDAAwD;AACxD,+EAA+E;AAC/E;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,kBAAkB,oBAAoB;;AAEtC;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA;AACA,+BAA+B;AAC/B;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB;AACxB,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA,YAAY;AACZ;AACA,YAAY;AACZ;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAY;AACZ;AACA,YAAY;AACZ,uBAAuB,qBAAqB;AAC5C;AACA;AACA;;AAEA;AACA;AACA,kBAAkB,oBAAoB;AACtC;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA,cAAc;AACd;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,GAAG;AACH;AACA,GAAG;AACH;AACA;AACA,uBAAuB,gBAAgB;AACvC;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,WAAW,GAAG;AACd,WAAW,GAAG;AACd;AACA;AACA;AACA,SAAS,oBAAoB;AAC7B;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,iBAAiB,oBAAoB;AACrC;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,oBAAoB;AACrC;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,oBAAoB;AACrC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB;AACA;AACA;AACA;AACA;AACA,SAAS,oBAAoB;AAC7B;AACA;AACA;AACA,QAAQ;AACR;AACA,QAAQ;AACR;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA,iDAAiD;;AAEjD;AACA;;AAEA,kBAAkB,oBAAoB;AACtC;AACA;AACA;AACA,MAAM;AACN;AACA,MAAM;AACN;AACA;AACA;AACA,4CAA4C;AAC5C,6BAA6B,OAAO;AACpC,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS,oBAAoB;AAC7B,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,uBAAuB;AACvB;AACA;AACA;AACA;AACA;AACA;AACA,SAAS,oBAAoB;AAC7B;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;;;;;;;;;;;ACxaa;AACb;AACA,2BAA2B,mBAAO,CAAC,uFAAiB;AACpD,8BAA8B,mBAAO,CAAC,mFAAqB;;AAE3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,MAAM,wCAAwC,GAAG;AACjD,MAAM,uCAAuC,GAAG;AAChD,MAAM,uCAAuC,GAAG;AAChD,MAAM,0CAA0C,GAAG;AACnD,MAAM,0CAA0C;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,iCAAiC;AACjC;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA,QAAQ;AACR;AACA,QAAQ;AACR;AACA,QAAQ;AACR;AACA;AACA;AACA,MAAM;AACN;AACA,MAAM;AACN;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA,sBAAsB,YAAY;AAClC;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA,wBAAwB,OAAO;AAC/B;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA,UAAU;AACV;;AAEA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;;AAEA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN,4CAA4C,IAAI;AAChD,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,qDAAqD;AACrD;AACA,GAAG,yCAAyC;AAC5C;AACA,GAAG;AACH,qBAAqB,IAAI;AACzB;AACA;AACA;;AAEA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,+CAA+C,IAAI;AACnD,GAAG;AACH,0CAA0C,IAAI;AAC9C,GAAG,yBAAyB;AAC5B;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,kBAAkB,gCAAgC;AAClD;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;;AAEA;;;;;;;;;;;AC7RA;;AAEA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,KAAK;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,oBAAoB,gBAAgB;AACpC;AACA;AACA;;AAEA;AACA;AACA,2BAA2B,MAAM,GAAG,QAAQ;;AAE5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA,kCAAkC,yCAAyC;AAC3E;AACA;AACA,UAAU;AACV,2CAA2C,yCAAyC;AACpF;AACA;AACA,UAAU;AACV;AACA;AACA;AACA,sFAAsF;AACtF,oCAAoC,QAAQ,EAAE,eAAe,EAAE,OAAO;AACtE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C,QAAQ,EAAE,OAAO;AAC5D;AACA;AACA;AACA;AACA,UAAU;AACV;AACA,UAAU;AACV,qCAAqC,SAAS,EAAE,YAAY,IAAI,QAAQ;AACxE,UAAU;AACV;AACA;AACA;AACA,cAAc;AACd;AACA;AACA,2BAA2B,QAAQ;AACnC;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,oBAAoB,iBAAiB;AACrC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,gDAAgD;AAC/E,cAAc;AACd,+BAA+B,gDAAgD,IAAI,QAAQ;AAC3F;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,wBAAwB,6BAA6B;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;ACtIA,aAAa,mBAAO,CAAC,2DAAS;;AAE9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,iBAAiB;AAC9B,kDAAkD;AAClD;AACA;AACA;AACA;AACA;AACA;AACA,+CAA+C,YAAY;AAC3D;AACA;AACA;AACA,mEAAmE;AACnE,mEAAmE;AACnE,mEAAmE;AACnE;AACA;;AAEA;AACA;AACA,cAAc,+BAA+B;AAC7C;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,YAAY;AACZ;;AAEA;AACA;AACA;;AAEA;AACA,+CAA+C;;AAE/C;AACA;AACA;AACA;AACA;AACA,WAAW,mEAAmE;AAC9E;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,iDAAiD;AAC5D;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,+CAA+C,KAAK;AACpD;;AAEA;;;;;;;;;;;;ACvJA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,2BAA2B;AAC3B;;AAEA,oBAAoB;AACpB,sBAAsB,kB;;;;;;;;;;;AC/CT;AACb;;AAEA,aAAa,mBAAO,CAAC,2DAAS;AAC9B,gBAAgB,mBAAO,CAAC,0EAAW;AACnC,oBAAoB,mBAAO,CAAC,sFAAiB;AAC7C,iBAAiB,mBAAO,CAAC,+CAAQ;AACjC,8BAA8B,mBAAO,CAAC,mFAAqB;;AAE3D;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,yBAAyB,cAAc;AACxD,eAAe,uBAAuB,cAAc;AACpD,eAAe,uBAAuB,cAAc;AACpD,iBAAiB,yBAAyB,eAAe;AACzD;AACA,uBAAuB,wBAAwB;AAC/C;AACA,iBAAiB,qBAAqB,cAAc;AACpD,kBAAkB,kBAAkB,cAAc;AAClD,kBAAkB,kBAAkB,cAAc;AAClD,mBAAmB,mBAAmB,cAAc;AACpD,oBAAoB,oBAAoB,eAAe;AACvD,oBAAoB,oBAAoB,cAAc;AACtD,iBAAiB,qBAAqB,cAAc;AACpD,kBAAkB,sBAAsB,cAAc;AACtD,gBAAgB,oBAAoB,cAAc;AAClD,iBAAiB,sBAAsB,cAAc;AACrD,sBAAsB,qBAAqB,cAAc;AACzD,gBAAgB,oBAAoB,cAAc;AAClD,gBAAgB,qBAAqB,cAAc;AACnD,mBAAmB,iBAAiB,IAAI,EAAE,qEAAqE;AAC/G,mBAAmB,wBAAwB,IAAI,EAAE,qEAAqE;AACtH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,kBAAkB,oBAAoB;AACtC;AACA;AACA,mCAAmC;AACnC;AACA;AACA;AACA;;AAEA;AACA,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,WAAW,SAAS;AACpB,WAAW,SAAS;AACpB,WAAW,SAAS;AACpB,WAAW,SAAS;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,OAAO;AACP;AACA,OAAO;AACP;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,gCAAgC;AAChC;AACA,oBAAoB,SAAS;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,6CAA6C;AAC7C;AACA;AACA;AACA;AACA,eAAe,mBAAmB,KAAK;AACvC;AACA;AACA;AACA;AACA,iCAAiC;AACjC;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,4EAA4E,QAAQ;AACpF;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;;AAEA,+CAA+C;AAC/C;AACA;AACA,QAAQ;;AAER;AACA;;AAEA;AACA;;AAEA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;AAGA;AACA,QAAQ;AACR;AACA;AACA;;AAEA;;AAEA,4DAA4D,wCAAwC;AACpG;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA,0DAA0D,uCAAuC;AACjG,SAAS;AACT;AACA;AACA;AACA;AACA,OAAO,MAAM;AACb;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qDAAqD;AACrD;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6DAA6D,WAAW;AACxE;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,qDAAqD;AACrD;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,UAAU;AACrB,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB;AACA;AACA;AACA;AACA;AACA,sBAAsB,wBAAwB;AAC9C;AACA;AACA,mDAAmD;AACnD,MAAM;AACN;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B;AAC5B;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB;AACA;AACA;AACA;AACA;;AAEA,SAAS,oBAAoB;AAC7B;AACA,iCAAiC;AACjC,kEAAkE,SAAS;AAC3E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA,UAAU;AACV;AACA;AACA,UAAU;AACV;AACA;AACA,UAAU;AACV;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;;;AAGA;;;;;;;;;;;AC7lBA,QAAQ,cAAc,EAAE,mBAAO,CAAC,wFAAkB;AAClD,yBAAyB,mBAAO,CAAC,4FAAoB;AACrD,QAAQ,UAAU,EAAE,mBAAO,CAAC,8EAAa;AACzC,kBAAkB,mBAAO,CAAC,qEAAc;;AAExC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,eAAe;AAC9B,eAAe,gBAAgB;AAC/B;AACA;AACA;AACA,SAAS;AACT;AACA,SAAS;AACT;AACA;AACA;AACA,iEAAiE;AACjE;AACA;AACA;AACA,8BAA8B,eAAe,GAAG,gBAAgB,GAAG,eAAe;AAClF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA,SAAS,iDAAiD;AAC1D,qEAAqE,2BAA2B;AAChG,SAAS;AACT;AACA,SAAS;AACT;AACA;AACA;AACA;;AAEA,2B;;;;;;;;;;;ACzDa;;AAEb;AACA;AACA,WAAW,OAAO;AAClB,WAAW,KAAK;AAChB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB;AACA;AACA;AACA;AACA;AACA,kBAAkB,gBAAgB;AAClC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA,OAAO;AACP;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA,kBAAkB,iBAAiB;AACnC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,6BAA6B;AAC7B,oBAAoB,SAAS;AAC7B;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;;AAEA;AACA,UAAU,eAAe;AACzB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,gBAAgB;;;;;;;;;;;;AChHH;;AAEb;AACA;AACA;AACA,qBAAqB;AACrB,qBAAqB;AACrB;AACA;AACA,yBAAyB,wCAAwC;AACjE;AACA,sBAAsB,YAAY;AAClC;AACA;AACA;AACA;AACA,yBAAyB,gDAAgD;AACzE,KAAK;AACL,yBAAyB,4BAA4B;AACrD;AACA;AACA;;;AAGA,yB;;;;;;;;;;;;;;;;;;;ACxBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACgD;AACd;AACgB;AAC3C;AACP,YAAY,yDAAiB;AAC7B,0BAA0B;AAC1B;AACA;AACA,KAAK;AACL;AACA;AACO;AACP,cAAc,+DAAqB;AACnC,cAAc,0CAAE;AAChB;AACA;AACA,2BAA2B,uBAAuB;AAClD,mCAAmC,OAAO,+CAAI;AAC9C;AACA;;;;;;;;;;;;;;;;;;;;;;;;ACtCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACmC;AACH;AACzB;AACP;AACA;AACA,oDAAoD,uBAAuB,0BAA0B;AACrG;AACA;AACA;AACO;AACP,+BAA+B;AAC/B,gDAAgD,qBAAqB,cAAc;AACnF;AACA;AACO;AACP;AACA;AACA,mDAAmD,sBAAsB,cAAc;AACvF;AACA;AACA;AACO;AACP;AACA;AACA,iDAAiD;AACjD;AACA,uCAAuC,aAAa;AACpD,gBAAgB;AAChB;AACA;AACA;AACO;AACP,0BAA0B;AAC1B;AACA,oDAAoD,sBAAsB,2BAA2B;AACrG;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,wBAAwB,gBAAgB;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,aAAa;AACnC,sBAAsB,sBAAsB,mBAAmB;AAC/D,sBAAsB,sBAAsB,sBAAsB,yBAAyB;AAC3F,sBAAsB,sBAAsB,sBAAsB,sBAAsB,+BAA+B;AACvH,sBAAsB,sBAAsB,sBAAsB,sBAAsB,sBAAsB;AAC9G;AACA;AACA,SAAS,0CAAK;AACd,yCAAyC,4CAAK;AAC9C;AACA;AACA;AACO;AACP;AACA;AACA,yBAAyB,uBAAuB;AAChD;AACA;AACA;AACA;AACA;AACA,wBAAwB,SAAS;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B;AAC/B;AACA;AACA,kCAAkC;AAClC;AACA,+BAA+B;AAC/B;AACA;AACA,kCAAkC,sBAAsB;AACxD;AACA,+BAA+B;AAC/B;AACA;AACA,kCAAkC,sBAAsB,sBAAsB;AAC9E;AACA,+BAA+B;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,sBAAsB,sBAAsB,sBAAsB;AACpG;AACA,+BAA+B;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,uBAAuB;AACxD;AACA;AACA;AACA,gCAAgC,SAAS;AACzC;AACA;AACA;AACA,aAAa;AACb;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA,wBAAwB,SAAS;AACjC;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACjLkF;AACf;AACR;AACT;AACyB;AAC3C;AACO;AACD;AACE;AACuC;AACtC;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,UAAU;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACO,8BAA8B;AACrC;AACA;AACA;AACA;AACA,YAAY,aAAa;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACO,iBAAiB,sDAAc;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,UAAU;AACtB,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;AACO,cAAc,mDAAW;AAChC;AACA;AACA;AACA;AACA,YAAY,WAAW;AACvB,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;AACO,eAAe,oDAAY;AAClC;AACA;AACA;AACA;AACA,YAAY,SAAS;AACrB,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;AACO,aAAa,kDAAU;AAC9B;AACA;AACA;AACA;AACA,YAAY,UAAU;AACtB,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;AACO,cAAc,mDAAW;AAChC;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,SAAS;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,+BAA+B,sBAAsB,kDAAU;AACtE;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,YAAY;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,kCAAkC,+BAA+B,WAAW;AAC5E;AACP,0BAA0B;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,aAAa;AACzB,YAAY,SAAS;AACrB,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACO,iCAAiC,QAAQ,6CAAQ;AACxD;AACA;AACA;AACA;AACA;AACA,YAAY,aAAa;AACzB,YAAY,SAAS;AACrB,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACO,gCAAgC,QAAQ,6CAAQ;AACvD;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,SAAS;AACrB,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,QAAQ;AACpB,YAAY,OAAO;AACnB;AACA;AACA;AACA,sBAAsB,WAAW;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA,YAAY,aAAa;AACzB;AACA;AACA;AACA,iDAAiD,KAAK,gBAAgB,aAAa;AACnF;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA,2CAA2C,gDAAQ,MAAM,gDAAQ;AACjE;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,YAAY;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA,YAAY,cAAc;AAC1B;AACA;AACA;AACA,gDAAgD,aAAa,yBAAyB,KAAK;AAC3F;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA,2CAA2C,gDAAQ,MAAM,gDAAQ;AACjE;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,aAAa;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,4BAA4B;AACxC,YAAY,OAAO;AACnB;AACA,2DAA2D,EAAE,EAAE,MAAM;AACrE;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA,wBAAwB,eAAe;AACvC;AACA,4BAA4B,eAAe;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,WAAW;AACvB;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA,wBAAwB,SAAS;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,YAAY;AACxB;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA,8BAA8B,QAAQ;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;AACO,2BAA2B;AAClC;AACA;AACA;AACA;AACA,YAAY,eAAe;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACO,mBAAmB,wDAAgB;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,SAAS;AACrB,YAAY,aAAa;AACzB,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;AACA;AACO,aAAa,kDAAS;AAC7B;AACA;AACA;AACA;AACA,YAAY,OAAO;AACnB,YAAY,aAAa;AACzB;AACA;AACA;AACA;AACA;AACA;AACO,WAAW,gDAAO;AACzB;AACA;AACA;AACA;AACA,YAAY,OAAO;AACnB,YAAY,aAAa;AACzB;AACA;AACA;AACA;AACA;AACA;AACO,WAAW,gDAAO;AACzB;AACA;AACA;AACA;AACA,YAAY,OAAO;AACnB,YAAY,aAAa;AACzB;AACA;AACA;AACA;AACA;AACA;AACO,2BAA2B,yBAAyB,2CAAM,CAAC,gDAAQ,QAAQ,2CAAM;AACxF;AACA;AACA;AACA;AACA,YAAY,OAAO;AACnB,YAAY,aAAa;AACzB;AACA;AACA;AACA;AACA;AACA;AACO,2BAA2B,yBAAyB,2CAAM,CAAC,gDAAQ,QAAQ,2CAAM;AACxF;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,WAAW;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,YAAY;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACO;AACP;AACA;AACA,oCAAoC,kBAAkB;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,WAAW;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,YAAY;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACO;AACP,2BAA2B;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,YAAY;AACxB,YAAY,aAAa;AACzB;AACA;AACA;AACA;AACA;AACA;AACO,gBAAgB,qDAAY;AAC5B;AACP,WAAW,qDAAY;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,eAAe;AAC3B,YAAY,aAAa;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,uBAAuB;AAC9B,OAAO,uBAAuB;AAC9B,OAAO,uBAAuB;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,mBAAmB,wDAAe;AAClC;AACP,WAAW,oDAAW;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,cAAc;AAC1B,YAAY,aAAa;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,uBAAuB;AAC9B,OAAO,uBAAuB;AAC9B,OAAO,uBAAuB;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,kBAAkB,uDAAc;AACvC;AACA;AACA;AACA;AACA;AACA,YAAY,gBAAgB;AAC5B,YAAY,aAAa;AACzB;AACA;AACA;AACA;AACA;AACA,2BAA2B,YAAY,IAAI,YAAY;AACvD,8CAA8C,oBAAoB;AAClE,8CAA8C,oBAAoB;AAClE;AACA;AACA;AACO,oBAAoB,yDAAgB;AAC3C;AACA;AACA;AACA;AACA;AACO,2BAA2B;AAClC;AACA;AACA;AACA;AACA;AACA,YAAY,WAAW;AACvB,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;AACO;AACP;AACA,wCAAwC,2CAAM,GAAG,2CAAM;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,WAAW;AACvB,YAAY,aAAa;AACzB;AACA;AACA;AACA;AACA;AACA;AACO,iCAAiC,iCAAiC,WAAW;AACpF;AACA;AACA;AACA;AACA,YAAY,WAAW;AACvB,YAAY,aAAa;AACzB;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA,qCAAqC,2CAAM,GAAG,2CAAM;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,WAAW;AACvB,YAAY,aAAa;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA,qCAAqC,2CAAM,GAAG,2CAAM;AACpD;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,UAAU;AACtB;AACA;AACA;AACA;AACA;AACO,8BAA8B;AACrC;AACA;AACA;AACA;AACA;AACA,YAAY,SAAS;AACrB,YAAY,cAAc;AAC1B;AACA;AACA;AACA;AACA;AACO;AACP;AACA,oBAAoB,eAAe;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,QAAQ;AACpB,YAAY,cAAc;AAC1B;AACA;AACA;AACA;AACA;AACO;AACP;AACA,oBAAoB,eAAe;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,UAAU;AACtB;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA,oBAAoB,SAAS;AAC7B;AACA;AACA;AACA;AACO;AACP;AACA,+BAA+B;AAC/B;AACA,6CAA6C,gBAAgB;AAC7D;AACA;AACA;AACA;AACA;AACA,YAAY,QAAQ;AACpB;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA,oBAAoB,eAAe;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,aAAa;AACzB;AACA;AACA;AACA;AACA;AACO;AACP,YAAY,sDAAc;AAC1B,2BAA2B;AAC3B;AACA;AACA;AACA;AACA;AACA,YAAY,cAAc;AAC1B;AACA;AACA;AACA;AACA;AACO;AACP,YAAY,uDAAe;AAC3B,2BAA2B;AAC3B;AACA;AACA;AACA;AACA;AACA,YAAY,SAAS;AACrB;AACA;AACA;AACA;AACA;AACO;AACP,YAAY,kDAAU;AACtB,2BAA2B;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,OAAO;AACnB;AACA,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;AACA;AACO,WAAW,gDAAO;AACzB;AACA;AACA;AACA;AACA;AACA,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;AACA;AACO;AACP,YAAY,gDAAQ;AACpB,2BAA2B;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,SAAS;AACrB,YAAY,YAAY;AACxB;AACA;AACA,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,mBAAmB,IAAI,mBAAmB,IAAI,mBAAmB,IAAI,mBAAmB;AAC9G;AACA,OAAO,mBAAmB;AAC1B,OAAO,mBAAmB;AAC1B,OAAO,mBAAmB;AAC1B,OAAO;AACP;AACA;AACA;AACA;AACO;AACP,YAAY,kDAAU;AACtB,2BAA2B;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,KAAK;AACjB;AACA;AACA,YAAY,OAAO;AACnB;AACA;AACA;AACA,eAAe,aAAa;AAC5B;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACO;AACP,YAAY,gDAAQ;AACpB,2BAA2B;AAC3B;AACA;AACA;AACA;AACA;AACA,YAAY,UAAU;AACtB;AACA;AACA;AACA;AACA;AACO;AACP;AACA,0CAA0C,mDAAW;AACrD;AACA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,WAAW;AACvB;AACA;AACA;AACA;AACA;AACO;AACP,YAAY,oDAAY;AACxB,2BAA2B;AAC3B;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA,yBAAyB,uBAAuB;AAChD;AACA;AACA;AACA;AACA;AACO;AACP,wBAAwB,kBAAkB;AAC1C;AACA;AACA,sBAAsB,gDAAQ,wBAAwB,UAAU,+CAAI,oBAAoB,gDAAQ,WAAW;AAC3G;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACA;AACP,iBAAiB,iDAAS;AAC1B;AACA;AACA;AACA,uCAAuC;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA,mCAAmC;AACnC;AACA,wCAAwC,sBAAsB;AAC9D;AACA;AACO;AACP;AACA;AACA;AACA;AACA,mCAAmC;AACnC;AACA,wCAAwC,uBAAuB;AAC/D;AACA;AACA,8BAA8B,OAAO,+CAAI;AACzC;AACA,uCAAuC,OAAO,+CAAI;AAClD,+BAA+B,OAAO,+CAAI;AAC1C;AACA,yCAAyC,OAAO,+CAAI;AACpD;AACA,oCAAoC,OAAO,+CAAI;AAC/C;AACA;AACA,WAAW,+CAAI;AACf;AACA;AACA,uCAAuC,OAAO,+CAAI;AAClD;AACA,8DAA8D,OAAO,+CAAI;AACzE;AACA,gDAAgD,OAAO,+CAAI;AAC3D;AACA,iCAAiC,OAAO,+CAAI;AAC5C,oCAAoC,OAAO,+CAAI;AAC/C;AACA;AACA;AACA,8BAA8B,OAAO,+CAAI;AACzC;AACA;AACA,yCAAyC,OAAO,+CAAI;AACpD;AACA;AACA,WAAW,+CAAI;AACf;AACA;AACA;AACA;AACA,8BAA8B,OAAO,+CAAI;AACzC;AACA;AACA;AACA,WAAW,+CAAI;AACf;AACA;AACA,6CAA6C,OAAO,+CAAI;AACxD;AACA,2DAA2D,OAAO,+CAAI;AACtE;AACA,iCAAiC,OAAO,+CAAI;AAC5C;AACA;AACA;AACA,8BAA8B,OAAO,+CAAI;AACzC;AACA;AACA;AACA;AACA,8BAA8B,OAAO,+CAAI;AACzC;AACA,0BAA0B,+DAAsB;AAChD,4BAA4B,iEAAwB;AACpD;AACA;AACA;AACA;AACA;AACA,YAAY,KAAK;AACjB;AACA;AACA;AACA;AACA;AACA;AACO,SAAS,8CAAM;AACtB;AACA;AACA;AACA;AACA;AACO,yBAAyB;AAChC;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,MAAM;AAClB,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACO,yBAAyB,uBAAuB,6BAA6B,cAAc;AAClG;AACA;AACA,YAAY,cAAc;AAC1B,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP,kCAAkC,OAAO,+CAAI,eAAe;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,0BAA0B;AACtC,YAAY,OAAO;AACnB;AACA,4CAA4C,EAAE;AAC9C;AACA;AACA;AACA;AACA;AACA;AACO,4BAA4B,+CAAI;AACvC,WAAW,+CAAI,sCAAsC,iBAAiB;AACtE,CAAC;AACD;AACA;AACA;AACA;AACA;AACA,YAAY,UAAU;AACtB;AACA;AACA;AACA;AACA;AACA;AACO,oCAAoC,+CAAQ;AACnD;AACA;AACA;AACA;AACA;AACA,YAAY,eAAe;AAC3B,YAAY,OAAO;AACnB;AACA,0CAA0C,GAAG,IAAI,EAAE;AACnD;AACA;AACA;AACA;AACA;AACO,kCAAkC;AACzC,oCAAoC,iBAAiB;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,qBAAqB;AACjC,YAAY,OAAO;AACnB,YAAY,SAAS;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA,wBAAwB,eAAe;AACvC;AACA,gBAAgB,6CAAQ;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,YAAY;AACxB,YAAY,OAAO;AACnB,YAAY,SAAS;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP,gDAAgD,cAAc;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,UAAU;AACtB,YAAY,SAAS;AACrB;AACA;AACA;AACA;AACA;AACA;AACO,sCAAsC,+CAAQ;AACrD;AACA;AACA;AACA;AACA;AACA,YAAY,WAAW;AACvB,YAAY,SAAS;AACrB;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACO;AACP;AACA;AACA,gCAAgC,kBAAkB;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,qDAAS;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,SAAS;AACrB,YAAY,WAAW;AACvB;AACA,sDAAsD;AACtD;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,YAAY;AACxB,YAAY,WAAW;AACvB;AACA,yDAAyD,cAAc,YAAY,yBAAyB;AAC5G,6EAA6E,+BAA+B;AAC5G;AACA;AACA;AACA;AACO;AACP,gDAAgD,sBAAsB;AACtE;AACA;AACA;AACA;AACA;AACA,YAAY,qBAAqB;AACjC;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA,wBAAwB,eAAe;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,qDAAS;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,eAAe;AAC3B,YAAY,sBAAsB;AAClC;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACO,kCAAkC,+CAA+C,cAAc;AACtG;AACA;AACA;AACA;AACA,YAAY,wBAAwB;AACpC,YAAY,sBAAsB;AAClC;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA,wBAAwB,eAAe;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,qDAAS;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA,YAAY,kBAAkB;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA,2CAA2C,kCAAkC;AAC7E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,SAAS;AACrB;AACA;AACA;AACA;AACA;AACA;AACO,4BAA4B;AACnC,oCAAoC,wBAAwB;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,YAAY;AACxB;AACA;AACA;AACA;AACA;AACO,qCAAqC,+CAAQ;AACpD;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,UAAU;AACtB;AACA,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA;AACO,cAAc,mDAAU;AAC/B;AACA;AACA;AACA;AACA,YAAY,mBAAmB;AAC/B;AACA,oBAAoB;AACpB,6CAA6C,gBAAgB,GAAG,MAAM;AACtE;AACA;AACA;AACA;AACA;AACO,uBAAuB,4DAAmB;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,SAAS;AACrB;AACA;AACA;AACA;AACA;AACA;AACO,aAAa,kDAAS;AAC7B;AACA;AACA;AACA;AACA,YAAY,kBAAkB;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,sBAAsB,2DAAkB;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,cAAc;AAC1B;AACA;AACA;AACA;AACA;AACA;AACO,kBAAkB,uDAAc;AACvC;AACA;AACA;AACA;AACA,YAAY,uBAAuB;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,2BAA2B,gEAAuB;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,WAAW;AACvB,YAAY,2BAA2B;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA,0BAA0B,4CAA4C,cAAc;AACpF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,WAAW;AACvB,YAAY,2BAA2B;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA,mDAAmD,sBAAsB,OAAO,+CAAI,qBAAqB;AACzG,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,oBAAoB;AAChC,YAAY,2BAA2B;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA,mDAAmD,sBAAsB,OAAO,+CAAI,qBAAqB;AACzG,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA,0BAA0B,uBAAuB;AACjD;AACA;AACA;AACA;AACA;AACO;AACP;AACA,0BAA0B,uBAAuB;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,SAAS;AACrB,YAAY,SAAS;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA,YAAY,6CAAQ;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA,YAAY,UAAU;AACtB;AACA,qBAAqB,kCAAkC,EAAE,QAAQ,GAAG;AACpE;AACA;AACA;AACA;AACA;AACO,cAAc,mDAAU;AAC/B;AACA;AACA;AACA;AACA;AACA,YAAY,eAAe;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACO,iCAAiC;AACxC,uCAAuC;AACvC,CAAC;AACD;AACA;AACA;AACA;AACA,YAAY,YAAY;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACO,8BAA8B;AACrC;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,QAAQ;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,YAAY,iDAAQ;AAC3B;AACA;AACA;AACA,oDAAoD;AACpD;AACA;AACA;AACA,YAAY,SAAS;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,aAAa,kDAAS;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,oBAAoB;AAChC,YAAY,KAAK;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA,2CAA2C;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,iBAAiB;AAC7B,YAAY,KAAK;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,oCAAoC;AAC3C;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,2BAA2B;AACvC,YAAY,KAAK;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA,2CAA2C;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,qBAAqB;AACjC,YAAY,KAAK;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA,2CAA2C;AAC3C;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,OAAO;AACnB;AACA;AACA,+BAA+B,MAAM;AACrC,+BAA+B,MAAM;AACrC,+BAA+B,MAAM;AACrC;AACA;AACA;AACA;AACA;AACA;AACO,yBAAyB,8CAAK;AACrC;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,4BAA4B,+CAAQ;AAC3C;AACA;AACA;AACA;AACA;AACO,6BAA6B,gDAAS;AAC7C;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP,cAAc,kDAAW;AACzB;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACO,0BAA0B,4CAAM;AACvC;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,0DAAa;AACzC,0BAA0B,wDAAW;AACrC;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,yBAAyB,8DAAqB;AACrD;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,2BAA2B,gEAAuB;AACzD;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,4BAA4B,oDAAQ;AAC3C;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACO,gCAAgC,yDAAY;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACO,qBAAqB,0DAAkB;AAC9C;AACA;AACA;AACA;AACO;AACP,4BAA4B,0DAAkB;AAC9C;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,QAAQ;AACpB;AACA;AACA;AACA;AACA;AACA;AACO,YAAY,iDAAQ;AAC3B;AACA;AACA;AACA;AACA,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA,YAAY,cAAc;AAC1B;AACA;AACA;AACA;AACA;AACO,kBAAkB,uDAAc;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACO,0BAA0B,kDAAa;AAC9C;AACA;AACA;AACA;AACO,2BAA2B,gDAAO;AACzC,yBAAyB,gDAAK;AAMhB;AACd;AACA;AACA;AACA;AACO,yBAAyB,4CAAK;AACrC;AACA;AACA;AACA;AACO,wBAAwB,2CAAI;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,YAAY,iDAAS;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACO,WAAW,gDAAQ;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACO,WAAW,gDAAQ;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;ACp9EO;AACP;AACA,0BAA0B,0BAA0B;AACpD;AACA;AACO;AACP,iCAAiC,qCAAqC,iCAAiC,WAAW,IAAI;AACtH;AACO;AACP,gCAAgC,uBAAuB,kCAAkC;AACzF;AACA,+BAA+B,aAAa;AAC5C,KAAK,IAAI;AACT;;;;;;;;;;;;;;;;ACbA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACTqD;AACsE;AACtF;AACA;AACgJ;AAC7H;AACiD;AACzE;AACQ;AACkB;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,WAAW,2CAAM;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACO,YAAY,4CAAO;AAC1B;AACA;AACA;AACA;AACO,4BAA4B,+CAAI,uBAAuB,yCAAyC;AACvG,8BAA8B,OAAO,+CAAI;AACzC,+BAA+B,OAAO,+CAAI;AAC1C;AACA,oCAAoC,OAAO,+CAAI;AAC/C;AACA,8BAA8B;AAC9B;AACA,WAAW,+CAAI;AACf;AACA;AACA,yCAAyC,OAAO,+CAAI;AACpD;AACA;AACA,8BAA8B,OAAO,+CAAI;AACzC;AACA,mCAAmC,OAAO,+CAAI;AAC9C,kCAAkC,OAAO,+CAAI;AAC7C;AACA,iCAAiC,OAAO,+CAAI;AAC5C;AACA,iCAAiC,OAAO,+CAAI;AAC5C;AACA,WAAW,kDAAO;AAClB;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACO,kCAAkC;AACzC,0BAA0B;AAC1B,CAAC;AACD;AACA;AACA;AACA;AACO,gCAAgC;AACvC;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA,YAAY,4BAA4B;AACxC,YAAY,eAAe;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,kCAAkC;AACzC,8BAA8B;AAC9B,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA,iCAAiC,sFAAsF;AACvH;AACA;AACA,kBAAkB,qDAAS;AAC3B;AACA,sBAAsB,qDAAS;AAC/B,sBAAsB,qDAAS;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,qDAAS;AACvB;AACA,kBAAkB,qDAAS;AAC3B,kBAAkB,qDAAS;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,uBAAuB,qDAAS;AAChC;AACA;AACA,+BAA+B,qDAAS,yBAAyB,qDAAS;AAC1E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,0DAAa;AAC7B,cAAc,wDAAW;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C;AAC3C;AACA;AACA;AACA;AACO,+CAA+C;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,uCAAuC;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACO,yBAAyB;AAChC;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,SAAS,+CAAI,IAAI,4CAAG;AAC3B;AACA;AACA;AACA;AACA;AACA;AACO,aAAa,gDAAO;AAC3B;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,0BAA0B;AACjC;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,OAAO;AACnB;AACA;AACA;AACA,+CAA+C,EAAE,GAAG,EAAE;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,+BAA+B;AACtC;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,OAAO;AACnB;AACA;AACA;AACA,kCAAkC,EAAE;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,6BAA6B,sBAAsB;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,OAAO;AACnB;AACA;AACA;AACA,+CAA+C,EAAE,GAAG,EAAE;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,oCAAoC;AAC3C;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,8BAA8B;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,6BAA6B;AACpC;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,6BAA6B;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACO,4BAA4B;AACnC;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA,gBAAgB,+CAAQ;AACxB;AACA;AACA;AACA,YAAY,6BAA6B;AACzC,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,kCAAkC,0DAAc;AACvD;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP,cAAc,uDAAW;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,aAAa,6CAAQ;AAC5B;AACA;AACA;AACA;AACA;AACA;AACO,cAAc,8CAAS;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA,YAAY,qBAAqB;AACjC,YAAY,OAAO;AACnB;AACA;AACA,uBAAuB,kBAAkB;AACzC;AACA;AACA;AACA,mBAAmB,MAAM;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,yBAAyB;AACrC,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACO,yBAAyB,8CAAK;AACrC;AACA;AACA;AACA;AACA;AACO,4BAA4B,+CAAQ;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACO,6BAA6B,gDAAS;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACO,wBAAwB,+CAAI,IAAI,uCAAa;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP,sBAAsB,+CAAQ;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACO,qCAAqC,+CAAQ;AACpD;AACA;AACA;AACA;AACA;AACA;AACO;AACP,cAAc,wDAAY;AAC1B;AACA;AACA;AACA;AACA;AACA;AACO,iCAAiC,yDAAa;AACrD;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,iCAAiC,mDAAc;AACtD;AACA;AACA;AACA;AACO,+BAA+B,iDAAY;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,oCAAoC,sDAAiB;AAC5D;AACA;AACA;AACA;AACO,kCAAkC,oDAAe;AACxD;AACA;AACA;AACA,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,iCAAiC,yDAAa;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACO,2BAA2B;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA,YAAY,4BAA4B;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA,yBAAyB,uBAAuB;AAChD;AACA;AACA,sCAAsC,4BAA4B;AAClE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA,0BAA0B,OAAO,+CAAI;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA,0BAA0B;AAC1B;AACA;AACA;AACA;AACA;AACO,kCAAkC,+CAAQ,EAAE,+CAAQ;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA,mCAAmC;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,sBAAsB;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,0BAA0B,kDAAa;AAC9C;AACA;AACA;AACA;AACO,2BAA2B,gDAAO;AACzC,yBAAyB,gDAAK;AAMhB;AACd;AACA;AACA;AACA;AACO,yBAAyB,wCAAc;AAC9C;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACO,wBAAwB,2CAAI;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACO,2BAA2B,yDAAoB;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA,qBAAqB,2CAAM;AAC3B;AACA;AACA;AACA;AACA,wBAAwB,eAAe;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA,2BAA2B,QAAQ,iDAAY;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACO,mCAAmC,wDAAwD,cAAc;AAChH;AACA;AACA;AACA;AACA;AACA;AACO;AACP,4BAA4B,+CAAQ;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP,kCAAkC,uBAAuB;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP,cAAc,yDAAkB;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP,cAAc,kEAAoB;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP,WAAW,yDAAkB;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP,WAAW,kEAAoB;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACv8CkC;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACO,qCAAqC;AAC5C,8BAA8B;AAC9B,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,YAAY,QAAQ;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA,qBAAqB,uBAAuB;AAC5C;AACA;AACA,iDAAiD,mCAAmC,uCAAuC,IAAI;AAC/H;AACA;AACA,oCAAoC,OAAO,+CAAI;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,gBAAgB;AAC5B,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS,4CAA4C;AACrD,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,SAAS,4CAA4C;AACrD,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACO,+BAA+B;AACtC,wCAAwC,+BAA+B;AACvE;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACO;AACP,8BAA8B;AAC9B;AACA;AACA,0BAA0B;AAC1B;AACA;AACA;AACA;AACA;AACO,iCAAiC;AACxC,8BAA8B,oCAAoC,0CAA0C;AAC5G,CAAC;AACD;AACA;AACA;AACA;AACO,8BAA8B;AACrC;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP,uCAAuC;AACvC;;;;;;;;;;;;;;;;;;;;;;;;;;;ACrNA;AACA;AACA;AACA;AACA;AAC8B;AACI;AACF;AACzB;AACP,+BAA+B,uBAAuB,oBAAoB,6CAAQ,OAAO,2CAAM,aAAa,4CAAO;AACnH;AACO;AACP;AACA;AACA,+CAA+C,4CAAO,MAAM,2CAAM;AAClE;AACA;AACA;AACO;AACP;AACA;AACA;AACA,8BAA8B,OAAO,+CAAI;AACzC;AACA;AACO;AACP;AACA;AACA;AACA,8BAA8B,uBAAuB;AACrD;AACA;AACO;AACP,0BAA0B,OAAO,+CAAI;AACrC;AACO;AACP;AACA,0BAA0B,uBAAuB;AACjD;AACO;AACP;AACA,0BAA0B,uBAAuB;AACjD;AACO;AACP;AACA;AACA,8CAA8C,mCAAmC,4CAAO,MAAM,2CAAM,gBAAgB;AACpH;AACA;AACA;AACA;AACO;AACP;AACA,eAAe,2CAAG;AAClB,gCAAgC;AAChC;;;;;;;;;;;;;;;;;;;;;;;ACvDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACkC;AAC3B;AACP,0BAA0B,uBAAuB,iCAAiC,sBAAsB;AACxG;AACO;AACP,0BAA0B,wBAAwB,iCAAiC,cAAc;AACjG;AACO;AACP,6BAA6B,uBAAuB;AACpD;AACA,uBAAuB;AACvB,KAAK;AACL;AACA;AACA,gCAAgC,uBAAuB;AACvD;AACA,+BAA+B,aAAa;AAC5C,KAAK;AACL;AAKc;AACd;AACO;AACP;AACA;AACA,iCAAiC,OAAO,+CAAI;AAC5C;AACA;AACA;AACO;AACP,gCAAgC,iCAAiC,WAAW;AAC5E;AACA;AACO;AACP;AACA,6BAA6B;AAC7B;;;;;;;;;;;;;;;;;;;;ACpDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,qBAAqB;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,6BAA6B;AACpC,uCAAuC;AACvC,CAAC;AACD;AACA;AACA;AACO;AACP,0BAA0B;AAC1B,2CAA2C;AAC3C,KAAK;AACL;AACA;AACA;AACA;AACO;AACP,0BAA0B;AAC1B,2CAA2C;AAC3C,KAAK;AACL;AACA;AACA;AACA;AACO;AACP,0BAA0B;AAC1B,2CAA2C;AAC3C,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,YAAY;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA,iDAAiD,0BAA0B;AAC3E;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AC1EA,qBAAqB,SAAI,IAAI,SAAI;AACjC,6EAA6E,OAAO;AACpF;AACA;AACA;AACA;AACA;AACA;AACA;AACkF;AACf;AACjB;AACyB;AAC3C;AACE;AACc;AAChD;AACA;AACA;AACA;AACA;AACA;AACO,iCAAiC;AACxC;AACA;AACA;AACO,sCAAsC;AAC7C;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC,yBAAyB;AAClE;AACA;AACA;AACA,wCAAwC,oBAAoB;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,YAAY;AACxB;AACA;AACA,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,mBAAmB;AAC1B,OAAO,mBAAmB;AAC1B,OAAO,mBAAmB;AAC1B,OAAO;AACP;AACA;AACA;AACA,OAAO,mBAAmB;AAC1B,OAAO,mBAAmB;AAC1B,OAAO,mBAAmB;AAC1B,OAAO;AACP;AACA;AACA;AACA;AACO;AACP;AACA,gBAAgB,+CAAS;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA,+BAA+B,0BAA0B,aAAa,+CAAI;AAC1E;AACA;AACA;AACA;AACA;AACA,YAAY,SAAS;AACrB;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,+CAAI;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,gCAAgC,gEAA2B;AAClE;AACA;AACA;AACA;AACA;AACA;AACO,gCAAgC,yBAAyB,2CAAM,OAAO,2CAAM;AACnF;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,SAAS;AACrB,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA,wBAAwB,OAAO;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,YAAY;AACxB,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;AACA;AACO,+BAA+B,4BAA4B,WAAW;AAC7E;AACA;AACA;AACA;AACA,YAAY,QAAQ;AACpB;AACA;AACA;AACA;AACA;AACA;AACO;AACP,gDAAgD,mBAAmB;AACnE;AACA;AACA;AACA;AACA;AACA,YAAY,YAAY;AACxB;AACA;AACA;AACA;AACA;AACO,gCAAgC;AACvC;AACA;AACA;AACA;AACA,YAAY,WAAW;AACvB;AACA;AACA;AACA;AACA;AACO,+BAA+B;AAC/B;AACP,8BAA8B;AAC9B;AACO;AACP,4CAA4C;AAC5C;AACA;AACA;AACA;AACO,8BAA8B;AAC9B;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,SAAS;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,UAAU;AACtB;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACO;AACP;AACA;AACA,oCAAoC,kBAAkB;AACtD;AACA;AACA,gBAAgB,0CAAK;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA,wCAAwC,2CAAM,GAAG,2CAAM;AACvD;AACA;AACA;AACA;AACA;AACO;AACP,qCAAqC,WAAW;AAChD;AACA;AACA;AACA;AACO;AACP;AACA,qCAAqC,2CAAM,GAAG,2CAAM;AACpD;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACO,wBAAwB;AAC/B;AACA;AACA;AACO;AACP;AACA;AACA,oBAAoB,SAAS;AAC7B;AACA;AACA;AACA;AACO;AACP;AACA,+BAA+B;AAC/B;AACA,6CAA6C,gBAAgB;AAC7D;AACA;AACA;AACA;AACO;AACP;AACA;AACA,oBAAoB,gBAAgB;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,aAAa;AACzB;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA,wBAAwB,eAAe;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,cAAc;AAC1B;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA,kCAAkC,+CAAI;AACtC;AACA;AACA;AACA;AACA;AACA;AACO,uBAAuB,oEAAqB;AACnD;AACA;AACA;AACA;AACO,cAAc,2DAAY;AACjC;AACA;AACA;AACA;AACO;AACP;AACA;AACA,wBAAwB,eAAe;AACvC;AACA,4BAA4B,eAAe;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA,kDAAkD,+CAAI;AACtD;AACA;AACA;AACA;AACA;AACO,8BAA8B;AACrC;AACA,8BAA8B,OAAO,+CAAI;AACzC;AACA,uCAAuC,OAAO,+CAAI;AAClD;AACA,+BAA+B,OAAO,+CAAI;AAC1C;AACA,iCAAiC,OAAO,+CAAI;AAC5C;AACA,oCAAoC,OAAO,+CAAI;AAC/C;AACA;AACA;AACA,8BAA8B,OAAO,+CAAI;AACzC;AACA;AACA,yCAAyC,OAAO,+CAAI;AACpD;AACA;AACA;AACA,8BAA8B,OAAO,+CAAI;AACzC;AACA;AACA,iCAAiC,OAAO,+CAAI;AAC5C;AACA;AACA,WAAW,+CAAI;AACf;AACA;AACA;AACA;AACA,8BAA8B,OAAO,+CAAI;AACzC;AACA;AACA;AACA,WAAW,+CAAI;AACf;AACA;AACA;AACA;AACA,8BAA8B,OAAO,+CAAI;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA,eAAe,+CAAI;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACO;AACP,kCAAkC,OAAO,+CAAI,eAAe;AAC5D;AACA;AACA;AACA;AACA,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA,+BAA+B,EAAE,OAAO,EAAE;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACO,4BAA4B,+CAAI;AACvC,WAAW,+CAAI,sCAAsC,iBAAiB;AACtE,CAAC;AACD;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,qCAAqC,+CAAQ;AACpD;AACA;AACA;AACA;AACO,oCAAoC,+CAAQ;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACO,yBAAyB,sCAAsC,cAAc;AACpF;AACA;AACA;AACA;AACO;AACP;AACA;AACA,wBAAwB,eAAe;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,aAAa,0DAAW;AAC/B;AACA;AACA;AACA;AACO,sBAAsB,mEAAoB;AACjD;AACA;AACA;AACA;AACO,kBAAkB,+DAAgB;AACzC;AACA;AACA;AACA;AACO,2BAA2B,wEAAyB;AAC3D;AACA;AACA;AACA;AACO;AACP;AACA,0BAA0B,4CAA4C,cAAc;AACpF;AACA;AACA;AACA;AACA;AACO,8BAA8B,8CAA8C,WAAW;AAC9F;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA,4BAA4B,eAAe;AAC3C,sDAAsD,sBAAsB,OAAO,+CAAI,qBAAqB;AAC5G;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,cAAc,wDAAS;AAC9B;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACO,cAAc,2DAAY;AACjC;AACA;AACA;AACA;AACA;AACA;AACO,iCAAiC;AACxC;AACA,CAAC;AACD;AACA;AACA,YAAY,QAAQ;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,YAAY,yDAAU;AAC7B;AACA;AACA;AACO;AACP;AACA;AACA,2CAA2C;AAC3C;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACO,yBAAyB,8CAAK;AACrC;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,4BAA4B,+CAAQ;AAC3C;AACA;AACA;AACA;AACA;AACO,6BAA6B,gDAAS;AAC7C;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP,cAAc,kDAAW;AACzB;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,0BAA0B,kDAAa;AAC9C;AACA;AACA;AACA;AACO,2BAA2B,gDAAO;AACzC,yBAAyB,gDAAK;AAMhB;AACd;AACA;AACA;AACA;AACO,yBAAyB,4CAAK;AACrC;AACA;AACA;AACA;AACO,wBAAwB,2CAAI;AACnC;AACA;AACA;AACA;AACA;AACA;AACO,WAAW,wDAAS;AAC3B;AACA;AACA;AACO,2BAA2B;AAClC;AACA;AACA;AACO,WAAW,wDAAS;AAC3B;AACA;AACA;AACA;AACA,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;AACA;AACO,2BAA2B;AAClC;AACA;AACA;AACO,UAAU,uDAAQ;AACzB;AACA;AACA;AACO,UAAU,uDAAQ;AACzB;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,gCAAgC,gCAAgC,WAAW;AAClF;AACA;AACA;AACA;AACA;AACO;AACP;AACA,eAAe,+CAAI;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACO,gCAAgC,gCAAgC,WAAW;AAClF;AACA;AACA;AACA;AACA;AACA,YAAY,cAAc;AAC1B;AACA;AACA;AACA;AACA;AACO,kBAAkB,+DAAgB;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACA;AACP;AACA;AACA,2BAA2B;AAC3B;AACO;AACP,6CAA6C,sBAAsB;AACnE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA,qDAAqD,yBAAyB;AAC9E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACA;AACP,gDAAgD,+CAAI;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,kCAAkC,OAAO,+CAAI;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACO,WAAW,6DAAc;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AC/nCqD;AACsE;AACtF;AAC8E;AAChC;AACsB;AACzE;AACE;AACQ;AACF;AACkB;AACjB;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,WAAW,2CAAM;AACxB;AACA;AACA;AACA;AACA;AACA;AACO,WAAW,2CAAM;AACjB;AACP,0BAA0B;AAC1B;AACA;AACA;AACA;AACA;AACA,YAAY,sBAAsB;AAClC,YAAY,cAAc;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACO,8BAA8B;AACrC;AACA;AACA;AACA;AACA,YAAY,uBAAuB;AACnC,YAAY,cAAc;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACO,+BAA+B;AACtC,8BAA8B,OAAO,+CAAI;AACzC,+BAA+B,OAAO,+CAAI;AAC1C,oCAAoC,OAAO,+CAAI;AAC/C;AACA;AACA,8BAA8B,OAAO,+CAAI;AACzC;AACA,yCAAyC,OAAO,+CAAI;AACpD;AACA;AACA,8BAA8B,OAAO,+CAAI;AACzC;AACA;AACA,iCAAiC,OAAO,+CAAI;AAC5C,yCAAyC,OAAO,+CAAI;AACpD;AACA,oCAAoC,OAAO,+CAAI;AAC/C;AACA,iCAAiC,OAAO,+CAAI;AAC5C;AACA;AACA,WAAW,+CAAI;AACf;AACA;AACA,uCAAuC,OAAO,+CAAI;AAClD;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACO,6BAA6B;AACpC,0BAA0B;AAC1B,CAAC;AACD;AACA;AACA,YAAY,oBAAoB;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,2BAA2B;AAClC,8BAA8B;AAC9B,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,qBAAqB;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,4BAA4B;AACnC;AACA,+BAA+B;AAC/B,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,wBAAwB;AACpC,YAAY,eAAe;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,+BAA+B;AACtC,8BAA8B,4EAA4E;AAC1G;AACA,CAAC;AACD;AACA;AACA;AACA;AACO,yBAAyB;AAChC;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,SAAS,+CAAI,IAAI,4CAAG;AAC3B;AACA;AACA;AACA;AACA;AACA;AACO,aAAa,gDAAO;AAC3B;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACO,yBAAyB;AAChC;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,4BAA4B,+CAAI,uBAAuB,2CAA2C;AACzG;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,+BAA+B;AACtC;AACA;AACA;AACA;AACA;AACA;AACO,6BAA6B,sBAAsB;AAC1D;AACA;AACA;AACA;AACA;AACA;AACO,oCAAoC;AAC3C;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,aAAa,+CAAI,4BAA4B,wCAAwC;AAC5F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACO,yBAAyB;AAChC;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACO,0BAA0B,4CAAM;AACvC;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,4BAA4B;AACnC;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,oCAAoC,+CAAQ;AACnD,qCAAqC,qDAAS;AAC9C;AACA;AACA;AACA;AACO;AACP,2CAA2C,qDAAS;AACpD;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,+BAA+B;AACtC;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA,eAAe,qDAAS,aAAa,+CAAG;AACxC;AACA;AACA;AACA;AACA;AACA;AACO,kCAAkC,OAAO,+CAAI;AACpD;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,0DAAa;AACzC,0BAA0B,wDAAW;AACrC;AACA;AACA;AACA;AACO;AACP;AACA,0BAA0B,uBAAuB;AACjD;AACA;AACA;AACA;AACA;AACO;AACP;AACA,0BAA0B,uBAAuB;AACjD;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,+BAA+B;AACtC;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,qBAAqB;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACO,aAAa,6CAAQ;AAC5B;AACA;AACA;AACA;AACA,YAAY,qBAAqB;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACO,6BAA6B;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA,YAAY,oBAAoB;AAChC,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA,uDAAuD,EAAE;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uDAAuD,EAAE;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,wBAAwB;AACpC,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACO,yBAAyB,8CAAK;AACrC;AACA;AACA;AACA;AACA;AACO,4BAA4B,+CAAQ;AAC3C;AACA;AACA;AACA;AACA;AACO,6BAA6B,gDAAS;AAC7C;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACO,wBAAwB,+CAAI,IAAI,uCAAa;AACpD;AACA;AACA;AACA;AACA;AACA,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,8BAA8B,+CAAI,IAAI,sDAAU;AACvD;AACA;AACA;AACO,qCAAqC,+CAAQ;AACpD;AACA;AACA;AACA;AACO,gCAAgC,wDAAY;AACnD;AACA;AACA;AACA;AACO;AACP,cAAc,yDAAa;AAC3B;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA,YAAY,2BAA2B;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,kCAAkC;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,uBAAuB;AACnC;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA,yBAAyB,uBAAuB;AAChD;AACA;AACA,sCAAsC,4BAA4B;AAClE;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,4BAA4B;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,mCAAmC,OAAO,+CAAI;AACrD;AACA;AACA;AACA;AACA,YAAY,2CAA2C;AACvD,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,WAAW,WAAW,UAAU;AACjE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,WAAW,WAAW;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,yBAAyB;AACrC,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,qCAAqC,gDAAS,EAAE,+CAAQ;AAC/D;AACA;AACA;AACA;AACA,YAAY,0BAA0B;AACtC,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,sCAAsC,qDAAc,EAAE,+CAAQ;AAC9D;AACP;AACA;AACA;AACA,mCAAmC;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,qBAAqB;AACjC,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,0BAA0B,kDAAa;AAC9C;AACA;AACA;AACA;AACO,2BAA2B,gDAAO;AACzC,yBAAyB,gDAAK;AAMhB;AACd;AACA;AACA;AACA;AACO,yBAAyB,wCAAc;AAC9C;AACA;AACA;AACA;AACO,wBAAwB,2CAAI;AACnC;AACA;AACA;AACO,2BAA2B,yDAAoB;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA,qBAAqB,2CAAM;AAC3B;AACA;AACA;AACA;AACA,wBAAwB,eAAe;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA,2BAA2B,QAAQ,iDAAY;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACO;AACP,4DAA4D,cAAc;AAC1E;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP,4BAA4B,+CAAQ;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP,0BAA0B;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,sCAAsC,yDAAkB;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA;AACO,mCAAmC,mEAAoB;AAC9D;AACA;AACA;AACA;AACA,YAAY,QAAQ;AACpB,YAAY,YAAY;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,6BAA6B;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,mCAAmC,iBAAiB,kDAAK;AAChE;AACA;AACA;AACA;AACA,YAAY,OAAO;AACnB,YAAY,YAAY;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,4BAA4B;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,kCAAkC,iBAAiB,iDAAI;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACvsC9B;AACuB;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,uCAAuC;AAC9C;AACA,wCAAwC;AACxC,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,QAAQ;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA,qBAAqB,uBAAuB;AAC5C;AACA;AACA;AACA;AACA,eAAe,qBAAqB;AACpC;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACO,6BAA6B,8CAA8C,kCAAkC;AACpH;AACA,oCAAoC,OAAO,+CAAI;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,OAAO;AACnB,YAAY,iBAAiB;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS,+BAA+B;AACxC,SAAS;AACT;AACA;AACA,SAAS,+BAA+B;AACxC,SAAS;AACT;AACA;AACA;AACA;AACA;AACO,+BAA+B;AACtC,kDAAkD,yCAAyC;AAC3F;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,OAAO;AACnB,YAAY,wCAAwC;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS,yDAAyD;AAClE,SAAS,yDAAyD;AAClE,SAAS;AACT;AACA;AACA,SAAS,yDAAyD;AAClE,SAAS,yDAAyD;AAClE,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACO,iCAAiC;AACxC;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,OAAO;AACnB,YAAY,gCAAgC;AAC5C;AACA;AACA,YAAY,OAAO;AACnB,YAAY,YAAY;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,kDAAkD;AACzD,OAAO,iDAAiD;AACxD,OAAO,mDAAmD;AAC1D,OAAO;AACP;AACA;AACA;AACA;AACA;AACA,OAAO,mDAAmD;AAC1D,OAAO,kDAAkD;AACzD,OAAO,iDAAiD;AACxD,OAAO;AACP;AACA;AACA;AACA;AACA;AACA,OAAO,kDAAkD;AACzD,OAAO,iDAAiD;AACxD,OAAO,mDAAmD;AAC1D,OAAO;AACP;AACA;AACA;AACA;AACA;AACO,8BAA8B;AACrC;AACA,qCAAqC,WAAW;AAChD,CAAC;AACD;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP,YAAY,gDAAS;AACrB,2BAA2B,mDAAQ;AACnC;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA,gCAAgC,sBAAsB;AACtD;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA,gCAAgC,sBAAsB;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA,YAAY,yCAAQ;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACO,4BAA4B,+CAAI;AACvC;AACA,4BAA4B,wBAAwB;;;;;;;;;;;;;;;;;;;;;;;;;;AC5aW;AAC/D,2CAA2C,OAAO,+CAAI;AACtD;AACA;AACA;AACO;AACP;AACA,eAAe,+CAAI;AACnB;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACO,oCAAoC;AAC3C,uCAAuC,OAAO,+CAAI;AAClD,CAAC;AACD;AACA;AACA;AACA;AACO,iCAAiC;AACxC;AACA,WAAW,iDAAU;AACrB,CAAC;AACD;AACA;AACA;AACA;AACO,oCAAoC;AAC3C,uCAAuC,OAAO,+CAAI;AAClD,CAAC;AACD;AACA;AACA;AACA;AACO,iCAAiC;AACxC;AACA,WAAW,gDAAS;AACpB,CAAC;AACD;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACnFA,qBAAqB,SAAI,IAAI,SAAI;AACjC,6EAA6E,OAAO;AACpF;AACA;AACA;AACA;AACA;AACA;AACA;AACkF;AACf;AACjC;AACyB;AACT;AACyB;AAC3C;AACF;AACM;AACY;AACR;AACuC;AACtC;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,UAAU;AACtB;AACA;AACA;AACA;AACA;AACA;AACO,8BAA8B;AACrC;AACA;AACA;AACA;AACA;AACA;AACO,iBAAiB,8DAAe;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,UAAU;AACtB,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;AACO,cAAc,2DAAY;AACjC;AACA;AACA;AACA;AACA;AACO,eAAe,4DAAa;AACnC;AACA;AACA;AACA;AACA,YAAY,SAAS;AACrB,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;AACO,aAAa,0DAAW;AAC/B;AACA;AACA;AACA;AACA;AACO,cAAc,2DAAY;AACjC;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,SAAS;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACO,+BAA+B,yBAAyB,0DAAW;AAC1E;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,YAAY;AACxB;AACA;AACA;AACA;AACA;AACA;AACO,kCAAkC,+BAA+B,WAAW;AAC5E;AACP,0BAA0B;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,iCAAiC,QAAQ,6CAAQ;AACxD;AACA;AACA;AACA;AACA;AACA;AACO,gCAAgC,QAAQ,6CAAQ;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA,2CAA2C,wDAAS,MAAM,wDAAS;AACnE;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,YAAY;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA,2CAA2C,wDAAS,MAAM,wDAAS;AACnE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA,wBAAwB,eAAe;AACvC;AACA,4BAA4B,eAAe;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,WAAW;AACvB;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA,wBAAwB,SAAS;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,YAAY;AACxB;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA,8BAA8B,QAAQ;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,2BAA2B;AAClC;AACA;AACA;AACA;AACA;AACO,mBAAmB,gEAAiB;AACpC;AACP,8CAA8C,wBAAwB,wBAAwB,2CAAM,GAAG,2CAAM;AAC7G;AACA;AACA;AACA;AACA;AACA,YAAY,OAAO;AACnB,YAAY,aAAa;AACzB;AACA;AACA;AACA;AACA;AACA;AACO,2BAA2B,yBAAyB,2CAAM,CAAC,wDAAS,QAAQ,2CAAM;AACzF;AACA;AACA;AACA;AACA,YAAY,OAAO;AACnB,YAAY,aAAa;AACzB;AACA;AACA;AACA;AACA;AACA;AACO,2BAA2B,yBAAyB,2CAAM,CAAC,wDAAS,QAAQ,2CAAM;AACzF;AACA;AACA;AACA;AACA,YAAY,OAAO;AACnB,YAAY,aAAa;AACzB;AACA;AACA;AACA;AACA;AACA;AACO;AACP,4BAA4B,2CAAM,CAAC,wDAAS,QAAQ,2CAAM;AAC1D;AACA;AACA;AACA;AACA;AACA,YAAY,OAAO;AACnB,YAAY,aAAa;AACzB;AACA;AACA;AACA;AACA;AACA;AACO;AACP,4BAA4B,2CAAM,CAAC,wDAAS,QAAQ,2CAAM;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACO;AACP;AACA;AACA,oCAAoC,kBAAkB;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,YAAY;AACxB,YAAY,aAAa;AACzB;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA,wBAAwB,eAAe;AACvC;AACA,uBAAuB,2CAAM;AAC7B;AACA;AACA,eAAe,2CAAM;AACrB;AACA;AACO;AACP;AACA,wBAAwB,eAAe;AACvC;AACA,uBAAuB,2CAAM;AAC7B;AACA;AACA,eAAe,2CAAM;AACrB;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,eAAe;AAC3B,YAAY,aAAa;AACzB;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C,cAAc,IAAI,uBAAuB,IAAI,uBAAuB;AACjH;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA,wBAAwB,eAAe;AACvC;AACA,gBAAgB,6CAAQ;AACxB;AACA;AACA;AACA,eAAe,2CAAM;AACrB;AACA;AACO;AACP;AACA,oCAAoC,QAAQ;AAC5C;AACA,uBAAuB,2CAAM;AAC7B;AACA;AACA,eAAe,2CAAM;AACrB;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,cAAc;AAC1B,YAAY,aAAa;AACzB;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C,cAAc,IAAI,uBAAuB,IAAI,uBAAuB;AACjH;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA,oCAAoC,QAAQ;AAC5C;AACA,gBAAgB,6CAAQ;AACxB;AACA;AACA;AACA,eAAe,2CAAM;AACrB;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,gBAAgB;AAC5B,YAAY,aAAa;AACzB;AACA;AACA;AACA;AACA;AACA,mCAAmC,YAAY,IAAI,YAAY;AAC/D,8CAA8C,oBAAoB;AAClE,8CAA8C,oBAAoB;AAClE;AACA;AACA;AACA;AACO;AACP;AACA,oCAAoC,QAAQ;AAC5C;AACA,uBAAuB,2CAAM;AAC7B;AACA;AACA,eAAe,2CAAM;AACrB;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,WAAW;AACvB,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;AACO;AACP;AACA,wCAAwC,2CAAM,GAAG,2CAAM,CAAC,kEAAmB;AAC3E;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,WAAW;AACvB,YAAY,aAAa;AACzB;AACA;AACA;AACA;AACA;AACA;AACO;AACP,qCAAqC,WAAW;AAChD;AACA;AACA;AACA;AACA;AACA,YAAY,WAAW;AACvB,YAAY,aAAa;AACzB;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA,qCAAqC,2CAAM,GAAG,2CAAM;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,WAAW;AACvB,YAAY,aAAa;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA,qCAAqC,2CAAM,GAAG,2CAAM;AACpD;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,UAAU;AACtB;AACA;AACA;AACA;AACA;AACO,8BAA8B;AACrC;AACA;AACA;AACA;AACA,YAAY,SAAS;AACrB,YAAY,cAAc;AAC1B;AACA;AACA;AACA;AACA;AACO;AACP;AACA,oBAAoB,eAAe;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,QAAQ;AACpB,YAAY,cAAc;AAC1B;AACA;AACA;AACA;AACA;AACO;AACP;AACA,oBAAoB,eAAe;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,UAAU;AACtB;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA,oBAAoB,SAAS;AAC7B;AACA;AACA;AACA;AACO;AACP;AACA,+BAA+B;AAC/B;AACA,6CAA6C,gBAAgB;AAC7D;AACA;AACA;AACA;AACA;AACA,YAAY,QAAQ;AACpB;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA,oBAAoB,eAAe;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,aAAa;AACzB;AACA;AACA;AACA;AACA;AACO;AACP,YAAY,8DAAe;AAC3B,2BAA2B;AAC3B;AACA;AACA;AACA;AACA;AACA,YAAY,cAAc;AAC1B;AACA;AACA;AACA;AACA;AACO;AACP,YAAY,+DAAgB;AAC5B,2BAA2B;AAC3B;AACA;AACA;AACA;AACA;AACA,YAAY,SAAS;AACrB;AACA;AACA;AACA;AACA;AACO;AACP,YAAY,0DAAW;AACvB,2BAA2B;AAC3B;AACO;AACP;AACA;AACA;AACA,mCAAmC;AACnC;AACA,6CAA6C;AAC7C;AACA,eAAe,eAAe;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;AACA;AACO;AACP,YAAY,wDAAS;AACrB,2BAA2B;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,SAAS;AACrB,YAAY,YAAY;AACxB;AACA;AACA,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,mBAAmB,IAAI,mBAAmB,IAAI,mBAAmB,IAAI,mBAAmB;AAC9G;AACA,OAAO,mBAAmB;AAC1B,OAAO,mBAAmB;AAC1B,OAAO,mBAAmB;AAC1B,OAAO;AACP;AACA;AACA;AACA;AACO;AACP,YAAY,0DAAW;AACvB,2BAA2B;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,KAAK;AACjB;AACA;AACA,YAAY,OAAO;AACnB;AACA;AACA;AACA,eAAe,aAAa;AAC5B;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACO;AACP,YAAY,wDAAS;AACrB,2BAA2B;AAC3B;AACA;AACA;AACA;AACA;AACA,YAAY,UAAU;AACtB;AACA;AACA;AACA;AACA;AACO;AACP;AACA,0CAA0C,2DAAY;AACtD;AACA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,WAAW;AACvB;AACA;AACA;AACA;AACA;AACO;AACP,YAAY,4DAAa;AACzB,2BAA2B;AAC3B;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA,yBAAyB,uBAAuB;AAChD;AACA;AACA;AACA;AACA;AACO;AACP,wBAAwB,kBAAkB;AAC1C;AACA;AACA,sBAAsB,wDAAS,wBAAwB,UAAU,+CAAI,oBAAoB,wDAAS,WAAW;AAC7G;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACA;AACP,iBAAiB,yDAAU;AAC3B;AACA;AACA;AACA,uCAAuC;AACvC;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA,mCAAmC;AACnC;AACA,wCAAwC,sBAAsB;AAC9D;AACA;AACO;AACP;AACA;AACA;AACA;AACA,mCAAmC;AACnC;AACA,wCAAwC,uBAAuB;AAC/D;AACA;AACA,8BAA8B,OAAO,+CAAI;AACzC,uCAAuC,OAAO,+CAAI;AAClD,+BAA+B,OAAO,+CAAI;AAC1C;AACA,WAAW,+CAAI;AACf;AACA,oCAAoC,OAAO,+CAAI;AAC/C;AACA,WAAW,+CAAI;AACf;AACA,uCAAuC,OAAO,+CAAI;AAClD,8DAA8D,OAAO,+CAAI;AACzE,gDAAgD,OAAO,+CAAI;AAC3D,iCAAiC,OAAO,+CAAI;AAC5C,oCAAoC,OAAO,+CAAI;AAC/C;AACA;AACA,8BAA8B,OAAO,+CAAI;AACzC;AACA,yCAAyC,OAAO,+CAAI;AACpD;AACA,WAAW,+CAAI;AACf;AACA;AACA;AACA,8BAA8B,OAAO,+CAAI;AACzC;AACA;AACA,WAAW,+CAAI;AACf;AACA,6CAA6C,OAAO,+CAAI;AACxD,2DAA2D,OAAO,+CAAI;AACtE,iCAAiC,OAAO,+CAAI;AAC5C;AACA;AACA,8BAA8B,OAAO,+CAAI;AACzC;AACA;AACA;AACA;AACA,8BAA8B,OAAO,+CAAI;AACzC;AACA;AACO,4CAA4C,OAAO,+CAAI;AAC9D;AACO,8CAA8C,OAAO,+CAAI;AAChE;AACA;AACA;AACA;AACO,SAAS,sDAAO;AACvB;AACA;AACA;AACO,yBAAyB;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACO;AACP,kCAAkC,OAAO,+CAAI,eAAe;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA,8BAA8B,EAAE,OAAO,EAAE;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,4BAA4B,+CAAI;AACvC,WAAW,+CAAI,sCAAsC,iBAAiB;AACtE,CAAC;AACD;AACA;AACA;AACA;AACO,oCAAoC,+CAAQ;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACO,yBAAyB;AAChC,iCAAiC,cAAc;AAC/C;AACA;AACA;AACA;AACA;AACO,kCAAkC;AACzC,oCAAoC,iBAAiB;AACrD;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA,gCAAgC,kBAAkB;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,qDAAS;AACpB;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA,wBAAwB,eAAe;AACvC;AACA,gBAAgB,6CAAQ;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP,gDAAgD,cAAc;AAC9D;AACA;AACA;AACA;AACA;AACO,sCAAsC,+CAAQ;AACrD;AACA;AACA;AACA;AACO;AACP,gDAAgD,sBAAsB;AACtE;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA,wBAAwB,eAAe;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,qDAAS;AACxB;AACA;AACA;AACA;AACA;AACA;AACO;AACP,mDAAmD,cAAc;AACjE;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA,wBAAwB,eAAe;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,qDAAS;AACxB;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA,2CAA2C,kCAAkC;AAC7E;AACA;AACA;AACA;AACA;AACO,4BAA4B;AACnC,oCAAoC,wBAAwB;AAC5D;AACA;AACA;AACA;AACO,qCAAqC,+CAAQ;AACpD;AACA;AACA;AACA;AACO;AACP;AACA;AACA,kDAAkD,8BAA8B;AAChF;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP,mDAAmD,iBAAiB;AACpE;AACA;AACA;AACA;AACA;AACO;AACP;AACA,0BAA0B,2CAA2C,cAAc;AACnF;AACA;AACA;AACA;AACA;AACO,wCAAwC;AAC/C;AACA;AACA,oBAAoB,SAAS;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP,wDAAwD,iBAAiB;AACzE;AACA;AACA;AACA;AACA;AACO,6CAA6C;AACpD,+CAA+C,oBAAoB;AACnE;AACA;AACA;AACA;AACA;AACO;AACP;AACA,0BAA0B,4CAA4C,cAAc;AACpF;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA,mDAAmD,sBAAsB,OAAO,+CAAI,qBAAqB;AACzG,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA,mDAAmD,sBAAsB,OAAO,+CAAI,qBAAqB;AACzG,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA,0BAA0B,uBAAuB;AACjD;AACA;AACA;AACA;AACA;AACO;AACP;AACA,0BAA0B,uBAAuB;AACjD;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA,YAAY,6CAAQ;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACO,6BAA6B;AACpC,0BAA0B;AAC1B,CAAC;AACD;AACA;AACA;AACA;AACO,iCAAiC;AACxC,uCAAuC;AACvC,CAAC;AACD;AACA;AACA;AACA;AACA,YAAY,YAAY;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACO,8BAA8B;AACrC;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,QAAQ;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP,WAAW,+CAAU,qBAAqB,6DAA6D,4BAA4B,IAAI;AACvI;AACA;AACA;AACA;AACA,oDAAoD;AACpD;AACA;AACA;AACA,YAAY,SAAS;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP,WAAW,iDAAW;AACtB;AACA;AACA;AACA,wBAAwB,SAAS;AACjC;AACA;AACA;AACA;AACA;AACA,eAAe,wCAAK;AACpB,KAAK;AACL;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA,2CAA2C;AAC3C;AACA;AACA;AACA;AACA;AACA;AACO,oCAAoC;AAC3C;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACO;AACP;AACA;AACA,2CAA2C;AAC3C;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA,2CAA2C;AAC3C;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACO,yBAAyB,8CAAK;AACrC;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,4BAA4B,+CAAQ;AAC3C;AACA;AACA;AACA;AACA;AACO,6BAA6B,gDAAS;AAC7C;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP,cAAc,kDAAW;AACzB;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACO,0BAA0B,6CAAM;AACvC;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA,gBAAgB,6CAAQ;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA,gBAAgB,6CAAQ;AACxB,iDAAiD,sBAAsB;AACvE;AACA;AACA;AACA;AACA;AACA,8CAA8C,uBAAuB;AACrE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,2DAAa;AACzC,0BAA0B,yDAAW;AACrC;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,4BAA4B,qDAAQ;AAC3C;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACO,gCAAgC,yDAAY;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACO,qBAAqB,kEAAmB;AAC/C;AACA;AACA;AACA;AACO;AACP,4BAA4B,kEAAmB;AAC/C;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,8BAA8B;AACrC;AACA;AACA;AACA;AACO,gCAAgC;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,YAAY,yDAAU;AACtB;AACP,2BAA2B;AAC3B;AACA;AACA;AACA;AACA;AACA,YAAY,OAAO;AACnB,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA,YAAY,cAAc;AAC1B;AACA;AACA;AACA;AACA;AACO;AACP,uBAAuB,+DAAgB;AACvC,+BAA+B,2BAA2B,iBAAiB;AAC3E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,0BAA0B,kDAAa;AAC9C;AACA;AACA;AACA;AACO,2BAA2B,gDAAO;AACzC,yBAAyB,gDAAK;AAMhB;AACd;AACA;AACA;AACA;AACO,yBAAyB,4CAAK;AACrC;AACA;AACA;AACA;AACO,wBAAwB,2CAAI;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,YAAY,yDAAU;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACO,WAAW,wDAAS;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACO,WAAW,wDAAS;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AC5kEA,qBAAqB,SAAI,IAAI,SAAI;AACjC,6EAA6E,OAAO;AACpF;AACA;AACA;AACA;AACA;AACA;AACA;AACkF;AACf;AACjC;AAC0B;AACe;AAC3C;AACE;AACA;AAClC;AACA;AACA;AACA;AACA;AACA;AACO,YAAY,yDAAoB;AACvC;AACA;AACA;AACO,iBAAiB,iDAAY;AACpC;AACA;AACA;AACO,sCAAsC;AAC7C;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACO;AACP;AACA,iBAAiB,gEAA2B;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA,iBAAiB,gEAA2B;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC,yBAAyB;AAClE;AACA;AACA;AACA,wCAAwC,oBAAoB;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,YAAY;AACxB;AACA;AACA,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,mBAAmB;AAC1B,OAAO,mBAAmB;AAC1B,OAAO,mBAAmB;AAC1B,OAAO;AACP;AACA;AACA;AACA,OAAO,mBAAmB;AAC1B,OAAO,mBAAmB;AAC1B,OAAO,mBAAmB;AAC1B,OAAO;AACP;AACA;AACA;AACA;AACO;AACP;AACA,gBAAgB,+CAAS;AACzB;AACA;AACA,WAAW,+CAAQ;AACnB;AACA;AACA;AACA;AACO;AACP;AACA,+BAA+B,0BAA0B,aAAa,+CAAI;AAC1E;AACA;AACA;AACA;AACA;AACA,YAAY,SAAS;AACrB;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,+CAAI;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP,4BAA4B,2CAAM,OAAO,2CAAM;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,SAAS;AACrB,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA,wBAAwB,OAAO;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,YAAY;AACxB,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;AACA;AACO,+BAA+B,4BAA4B,WAAW;AAC7E;AACA;AACA;AACA;AACA,YAAY,QAAQ;AACpB;AACA;AACA;AACA;AACA;AACA;AACO;AACP,gDAAgD,mBAAmB;AACnE;AACA;AACA;AACA;AACA;AACA,YAAY,YAAY;AACxB;AACA;AACA;AACA;AACA;AACO,gCAAgC;AACvC;AACA;AACA;AACA;AACA,YAAY,WAAW;AACvB;AACA;AACA;AACA;AACA;AACO,+BAA+B;AACtC;AACA;AACA;AACA;AACO,gCAAgC;AAChC;AACP,8BAA8B;AAC9B;AACO;AACP,4CAA4C;AAC5C;AACA;AACA;AACA;AACO;AACP;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,SAAS;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,UAAU;AACtB;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACO;AACP;AACA;AACA,oCAAoC,kBAAkB;AACtD;AACA;AACA,gBAAgB,0CAAK;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP,qCAAqC,WAAW;AAChD;AACA;AACA;AACA;AACO;AACP;AACA,qCAAqC,2CAAM,GAAG,2CAAM;AACpD;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA,oBAAoB,SAAS;AAC7B;AACA;AACA;AACA;AACO;AACP;AACA,+BAA+B;AAC/B;AACA,6CAA6C,gBAAgB;AAC7D;AACA;AACA;AACA;AACO;AACP;AACA;AACA,oBAAoB,gBAAgB;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,aAAa;AACzB;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA,wBAAwB,eAAe;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,cAAc;AAC1B;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA,kCAAkC,+CAAI;AACtC;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA,kBAAkB,gEAA2B;AAC7C,wBAAwB,eAAe;AACvC;AACA,4BAA4B,eAAe;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA,+CAA+C,+CAAI;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,8BAA8B;AACrC,8BAA8B,OAAO,+CAAI;AACzC;AACA,uCAAuC,OAAO,+CAAI;AAClD,+BAA+B,OAAO,+CAAI;AAC1C;AACA,iCAAiC,OAAO,+CAAI;AAC5C;AACA,oCAAoC,OAAO,+CAAI;AAC/C;AACA;AACA;AACA,8BAA8B,OAAO,+CAAI;AACzC;AACA;AACA,yCAAyC,OAAO,+CAAI;AACpD;AACA;AACA;AACA,8BAA8B,OAAO,+CAAI;AACzC;AACA;AACA,iCAAiC,OAAO,+CAAI;AAC5C;AACA;AACA,WAAW,+CAAI;AACf;AACA;AACA;AACA;AACA,8BAA8B,OAAO,+CAAI;AACzC;AACA;AACA;AACA,WAAW,+CAAI;AACf;AACA;AACA;AACA;AACA,8BAA8B,OAAO,+CAAI;AACzC;AACA;AACA;AACA;AACA;AACO,SAAS,gDAAW;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA,eAAe,+CAAI;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACO,yBAAyB,8BAA8B,OAAO,+CAAI,eAAe;AACxF;AACA;AACA;AACA,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA,gCAAgC,EAAE,OAAO,EAAE;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACO,4BAA4B,+CAAI;AACvC,WAAW,+CAAI,sCAAsC,iBAAiB;AACtE,CAAC;AACD;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP,qBAAqB,+CAAQ;AAC7B;AACA;AACA;AACA;AACO;AACP,sBAAsB,+CAAQ;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP,0CAA0C,cAAc;AACxD;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA,wBAAwB,eAAe;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP,mDAAmD,iBAAiB;AACpE;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA,wDAAwD,2BAA2B;AACnF;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP,wDAAwD,iBAAiB;AACzE;AACA;AACA;AACA;AACA;AACO;AACP;AACA,8CAA8C,oBAAoB;AAClE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA,2DAA2D,kCAAkC;AAC7F;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA,mDAAmD,oBAAoB;AACvE;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA,0BAA0B,4CAA4C,cAAc;AACpF;AACA;AACA;AACA;AACA;AACO,8BAA8B,4BAA4B,yCAAE;AACnE;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA,4BAA4B,eAAe;AAC3C,sDAAsD,sBAAsB,OAAO,+CAAI,qBAAqB;AAC5G;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,cAAc,2CAAM;AAC3B;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACO,6BAA6B;AACpC,0BAA0B;AAC1B,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACO,iCAAiC;AACxC;AACA,CAAC;AACD;AACA;AACA,YAAY,QAAQ;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP,WAAW,+CAAU,qBAAqB,6DAA6D,4BAA4B,IAAI;AACvI;AACA;AACA;AACA;AACO;AACP;AACA;AACA,2CAA2C;AAC3C;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACO,yBAAyB,8CAAK;AACrC;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,4BAA4B,+CAAQ;AAC3C;AACA;AACA;AACA;AACA;AACO,6BAA6B,gDAAS;AAC7C;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,+BAA+B,kDAAW;AACjD;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,0BAA0B,kDAAa;AAC9C;AACA;AACA;AACA;AACO,2BAA2B,gDAAO;AACzC,yBAAyB,gDAAK;AAMhB;AACd;AACA;AACA;AACA;AACO,yBAAyB,4CAAK;AACrC;AACA;AACA;AACA;AACO,wBAAwB,2CAAI;AACnC;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACO,WAAW,2CAAM;AACxB;AACA;AACA;AACO,2BAA2B;AAClC;AACA;AACA;AACA;AACA,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;AACA;AACO,2BAA2B;AAClC;AACA;AACA;AACO;AACP,YAAY,2CAAM;AAClB,2BAA2B;AAC3B;AACA;AACA;AACA;AACO;AACP,YAAY,2CAAM;AAClB,2BAA2B;AAC3B;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,gCAAgC,gCAAgC,WAAW;AAClF;AACA;AACA;AACA;AACA;AACO;AACP;AACA,eAAe,+CAAI;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACO,gCAAgC,gCAAgC,WAAW;AAClF;AACA;AACA;AACA;AACA;AACA,YAAY,cAAc;AAC1B;AACA;AACA;AACA;AACA;AACO;AACP;AACA,+BAA+B,OAAO,+CAAI;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACA;AACP;AACA;AACA,2BAA2B;AAC3B;AACO;AACP,6CAA6C,sBAAsB;AACnE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA,6DAA6D,yBAAyB;AACtF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACA;AACP,gDAAgD,+CAAI;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,kCAAkC,OAAO,+CAAI;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA,wCAAwC,2CAAM,GAAG,2CAAM;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACvsCkC;AACoB;AACZ;AACV;AACQ;AACV;AAC4B;AAC1D;AACA;AACA;AACA;AACA,YAAY,6BAA6B;AACzC;AACA,uCAAuC;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACO,gCAAgC,uBAAuB;AAC9D;AACA;AACA;AACA;AACA,YAAY,2BAA2B;AACvC;AACA,+CAA+C;AAC/C;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACO,8BAA8B,uBAAuB;AAC5D;AACA;AACA;AACA;AACA,YAAY,OAAO;AACnB;AACA,iCAAiC,2BAA2B;AAC5D;AACA;AACA;AACO,0BAA0B;AACjC;AACA;AACA;AACA;AACA,YAAY,UAAU;AACtB;AACA,oCAAoC;AACpC,oCAAoC,MAAM;AAC1C;AACA;AACO;AACP;AACA,YAAY,0CAAK;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,+BAA+B,wCAAK;AACpC;AACP;AACA,uBAAuB,wCAAK;AAC5B;AACA;AACA;AACA;AACA;AACA,4CAA4C,gBAAgB;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,kBAAkB;AAC9B;AACA,eAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP,sBAAsB,wCAAK,oBAAoB,gBAAgB;AACxD;AACP;AACA;AACA;AACA,0CAA0C,kBAAkB,2CAAM,oBAAoB,2CAAM,IAAI;AAChG;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,WAAW;AACvB;AACA,6CAA6C,YAAY,KAAK,YAAY;AAC1E,6CAA6C,YAAY,KAAK,kBAAkB;AAChF;AACA;AACA;AACO;AACP;AACA,YAAY,0CAAK;AACjB;AACA;AACA,kCAAkC;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,MAAM;AAClB;AACA,qCAAqC,YAAY;AACjD,qCAAqC,YAAY;AACjD;AACA;AACA;AACO,4BAA4B,OAAO,0CAAK;AACxC;AACP;AACA,aAAa,0CAAK;AAClB;AACA;AACA,kCAAkC;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,WAAW;AACvB,YAAY,SAAS;AACrB;AACA,6CAA6C,YAAY,iBAAiB,YAAY;AACtF,6CAA6C,YAAY;AACzD;AACA;AACA;AACO;AACP;AACA;AACA,mBAAmB,2CAAM;AACzB;AACA;AACA,mBAAmB,2CAAM;AACzB;AACA,kCAAkC;AAClC;AACA,eAAe,2CAAM;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,WAAW;AACvB,YAAY,SAAS;AACrB;AACA,gEAAgE,YAAY,iBAAiB,YAAY;AACzG,gEAAgE,YAAY;AAC5E;AACA;AACA;AACO;AACP;AACA;AACA,mBAAmB,2CAAM;AACzB;AACA;AACA;AACA,mBAAmB,2CAAM;AACzB;AACA,kCAAkC;AAClC;AACA,eAAe,2CAAM;AACrB;AACA;AACO;AACP;AACA;AACA;AACA,eAAe,6CAAQ,OAAO,2CAAM,GAAG,2CAAM;AAC7C;AACA;AACO;AACP;AACA;AACA;AACA,qCAAqC;AACrC;AACA;AACA,iBAAiB,0CAAK;AACtB;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA,8BAA8B;AAC9B;AACA,WAAW,0CAAK,cAAc,2CAAM,SAAS,2CAAM;AACnD;AACA;AACA;AACA;AACO;AACA;AACP;AACA;AACA;AACA,gBAAgB,0CAAK;AACrB;AACA;AACA;AACA;AACA;AACA;AACO;AACP,0CAA0C,cAAc;AACxD;AACO;AACP;AACA,qBAAqB,uBAAuB;AAC5C;AACA;AACA;AACA,+BAA+B,wCAAK;AACpC;AACA;AACA,6BAA6B;AAC7B;AACA;AACA;AACA,wBAAwB,SAAS;AACjC;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,SAAS;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,wCAAK;AACjC;AACO;AACP;AACA,qBAAqB,uBAAuB;AAC5C;AACA;AACA;AACA,oCAAoC,wCAAK;AACzC;AACA;AACA,6BAA6B;AAC7B;AACA;AACA;AACA,8BAA8B,QAAQ;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,YAAY;AACxB;AACA,+CAA+C,MAAM;AACrD;AACA;AACA;AACA;AACO;AACP;AACA,mBAAmB;AACnB;AACO;AACP,iDAAiD,wCAAK;AACtD,0BAA0B,uBAAuB;AACjD;AACO;AACP,+BAA+B,wCAAK;AACpC,0BAA0B,uBAAuB;AACjD;AACO;AACP,qBAAqB,wCAAK;AAC1B;AACA;AACA;AACA;AACA;AACO;AACP;AACA,0BAA0B,uBAAuB,aAAa,+CAAI;AAClE;AACA;AACA;AACA;AACA;AACO;AACP;AACA,0BAA0B,uBAAuB,aAAa,+CAAI;AAClE;AACO;AACP;AACA;AACA;AACA;AACA,gBAAgB,0CAAK;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,qDAAS;AACxB;AACA;AACO;AACP;AACA;AACA;AACA;AACA,gBAAgB,0CAAK;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,qDAAS;AACxB;AACA;AACO;AACP;AACA;AACA;AACA,gBAAgB,0CAAK;AACrB;AACA,oBAAoB,6CAAQ;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA,gBAAgB,0CAAK;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA,4BAA4B,6BAA6B,+CAAQ;AACjE;AACO;AACP;AACA,8BAA8B;AAC9B;AACA,mBAAmB,0CAAK;AACxB;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,YAAY;AACxB;AACA,sCAAsC,YAAY;AAClD;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA,YAAY,cAAc;AAC1B;AACA,yEAAyE,YAAY;AACrF;AACA;AACA;AACA;AACO;AACP;AACA,gCAAgC,kBAAkB;AAClD;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,OAAO;AACnB;AACA,wDAAwD,aAAa;AACrE,wDAAwD,cAAc;AACtE;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA,mCAAmC;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,QAAQ;AACpB,YAAY,QAAQ;AACpB;AACA,+BAA+B;AAC/B,sCAAsC,YAAY,IAAI,YAAY,KAAK,kBAAkB;AACzF,+BAA+B;AAC/B,sCAAsC,YAAY,IAAI,YAAY,KAAK,kBAAkB;AACzF;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,eAAe;AAC3B,YAAY,QAAQ;AACpB;AACA,+BAA+B;AAC/B,6CAA6C,YAAY,IAAI,YAAY,KAAK,KAAK;AACnF,+BAA+B;AAC/B,6CAA6C,YAAY,IAAI,YAAY,KAAK,KAAK;AACnF;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,aAAa;AACzB;AACA,uCAAuC,MAAM,IAAI,YAAY,KAAK,MAAM;AACxE,uCAAuC,MAAM,IAAI,YAAY,KAAK,MAAM;AACxE,uCAAuC,YAAY,IAAI,YAAY,KAAK,YAAY;AACpF;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,8BAA8B,OAAO,+CAAI;AAChD;AACA;AACO,uCAAuC,OAAO,+CAAI;AACzD;AACA;AACO;AACP;AACA,iCAAiC,OAAO,+CAAI;AAC5C;AACA;AACO,8BAA8B;AACrC;AACA,8BAA8B,OAAO,+CAAI;AACzC;AACA;AACA;AACO;AACP;AACA,iCAAiC,OAAO,+CAAI;AAC5C;AACA;AACA;AACO;AACP,WAAW,+CAAI;AACf;AACA;AACA;AACO,oCAAoC,OAAO,+CAAI;AACtD;AACA;AACO,4CAA4C,OAAO,+CAAI;AAC9D;AACA;AACO,uCAAuC,OAAO,+CAAI;AACzD;AACA;AACO;AACP;AACA,iCAAiC,OAAO,+CAAI;AAC5C;AACA;AACO;AACP;AACA;AACA;AACA,kCAAkC,OAAO,+CAAI;AAC7C;AACA;AACA;AACA;AACO;AACP;AACA,iCAAiC,OAAO,+CAAI;AAC5C;AACA;AACA;AACO,gDAAgD,OAAO,+CAAI;AAClE;AACA;AACO;AACP,WAAW,+CAAI;AACf;AACA;AACA;AACO,6CAA6C,OAAO,+CAAI;AAC/D;AACA;AACO,2DAA2D,OAAO,+CAAI;AAC7E;AACO;AACP;AACA;AACA;AACA,kCAAkC,+BAA+B,+CAAI,CAAC,yCAAE;AACxE;AACA;AACA;AACO;AACP;AACA;AACA;AACA,+BAA+B,sBAAsB,+CAAQ;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B;AAC5B;AACA,mDAAmD;AACnD;AACA,2CAA2C,aAAa;AACxD,oBAAoB;AACpB;AACA,wCAAwC,kBAAkB;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,SAAS;AACrB;AACA,gEAAgE,mCAAmC;AACnG;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACO;AACP,6CAA6C,sBAAsB;AACnE;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,YAAY;AACxB,YAAY,SAAS;AACrB;AACA,0DAA0D,GAAG;AAC7D,yCAAyC,mCAAmC;AAC5E;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACO,+BAA+B,4CAA4C,cAAc;AAChG;AACA;AACA;AACA;AACA,YAAY,YAAY;AACxB;AACA,mEAAmE,mCAAmC;AACtG;AACA;AACA,MAAM;AACN;AACA;AACA;AACA,MAAM;AACN,IAAI;AACJ;AACA;AACA;AACA;AACO;AACP,gDAAgD,sBAAsB;AACtE;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,eAAe;AAC3B,YAAY,SAAS;AACrB;AACA,4DAA4D,GAAG,4BAA4B,GAAG;AAC9F,4CAA4C,mCAAmC;AAC/E;AACA;AACA,MAAM;AACN;AACA;AACA;AACA,MAAM;AACN,IAAI;AACJ;AACA;AACA;AACA;AACO;AACP,mDAAmD,cAAc;AACjE;AACO;AACP;AACA,qBAAqB,uBAAuB;AAC5C;AACA;AACA;AACA;AACA,iCAAiC,kDAAkD,iBAAiB;AACpG;AACA,kBAAkB,wCAAK;AACvB;AACO;AACP;AACA;AACA;AACA;AACA,kCAAkC,2CAA2C,cAAc;AAC3F;AACA;AACA,mBAAmB,wCAAK;AACxB;AACO;AACP;AACA,qBAAqB,uBAAuB;AAC5C;AACA;AACA;AACA;AACA,iCAAiC,uDAAuD,iBAAiB;AACzG;AACA,uBAAuB,wCAAK;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,UAAU;AACtB,YAAY,SAAS;AACrB;AACA,oCAAoC,8DAA8D;AAClG;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACO;AACP;AACA;AACA,YAAY,0CAAK;AACjB;AACA,gBAAgB,6CAAQ;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,WAAW;AACvB,YAAY,SAAS;AACrB;AACA;AACA,gBAAgB,uEAAuE;AACvF;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA,YAAY,0CAAK;AACjB;AACA,gBAAgB,6CAAQ;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,qDAAS;AACpB;AACA;AACA;AACA;AACA;AACO;AACA;AACP;AACA,8BAA8B;AAC9B;AACA,4DAA4D,8DAA8D;AAC1H,4CAA4C,OAAO,sBAAsB;AACzE;AACA,SAAS;AACT;AACA,mBAAmB,wCAAK;AACxB;AACO;AACP;AACA,WAAW,+CAAU,mBAAmB,kDAAkD;AAC1F;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC;AACpC;AACA,oBAAoB,0CAAK;AACzB,2BAA2B,0CAAK;AAChC;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,OAAO;AACnB;AACA,iBAAiB,qBAAqB,GAAG,+BAA+B,MAAM;AAC9E;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACO,yBAAyB,8CAAK;AACrC;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,iCAAiC;AACxC;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACO,0CAA0C;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,oCAAoC;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACO,6CAA6C;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,0DAAa;AAC7B,cAAc,wDAAW;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,oCAAoC;AAChD,YAAY,YAAY;AACxB;AACA,wCAAwC;AACxC;AACA,mDAAmD,YAAY,IAAI,YAAY,KAAK,mBAAmB;AACvG;AACA;AACA;AACA;AACO;AACP;AACA;AACA,2CAA2C;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,eAAe;AAC3B,YAAY,iBAAiB;AAC7B;AACA;AACA,qCAAqC,oBAAoB,IAAI,oBAAoB,KAAK,+BAA+B;AACrH;AACA;AACA;AACA;AACO,oCAAoC;AAC3C;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,2CAA2C;AACvD,YAAY,YAAY;AACxB;AACA,wCAAwC;AACxC;AACA,mDAAmD,YAAY,IAAI,YAAY,KAAK,OAAO;AAC3F;AACA;AACA;AACA;AACO;AACP;AACA;AACA,2CAA2C;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,iDAAiD;AAC7D,YAAY,QAAQ;AACpB;AACA,gBAAgB;AAChB,gBAAgB;AAChB;AACA;AACA,8CAA8C,YAAY;AAC1D;AACA;AACA;AACA;AACO,uCAAuC;AAC9C,uCAAuC;AACvC,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA,kCAAkC,wCAAK;AACvC,oCAAoC,wCAAK;AACzC,4CAA4C,wCAAK;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA,kCAAkC,wCAAK;AACvC,oCAAoC,wCAAK;AACzC,4CAA4C,wCAAK;AACjD,oDAAoD,wCAAK;AACzD,sDAAsD,wCAAK;AAC3D,8DAA8D,wCAAK;AACnE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA,kCAAkC,wCAAK;AACvC,oCAAoC,wCAAK;AACzC,4CAA4C,wCAAK;AACjD,sCAAsC,wCAAK;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA,kCAAkC,wCAAK;AACvC,oCAAoC,wCAAK;AACzC,4CAA4C,wCAAK;AACjD,oDAAoD,wCAAK;AACzD,sDAAsD,wCAAK;AAC3D,8DAA8D,wCAAK;AACnE,sCAAsC,wCAAK;AAC3C;AACA,wDAAwD,wCAAK;AAC7D;AACA,4BAA4B,0DAAa;AACzC,0BAA0B,wDAAW;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA,kCAAkC,wCAAK;AACvC,oCAAoC,wCAAK;AACzC,4CAA4C,wCAAK;AACjD,sCAAsC,wCAAK;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACA;AACP,WAAW,0CAAK;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA,kCAAkC,wCAAK;AACvC,oCAAoC,wCAAK;AACzC,4CAA4C,wCAAK;AACjD,sCAAsC,wCAAK;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oDAAoD,wCAAK;AACzD,sDAAsD,wCAAK;AAC3D,8DAA8D,wCAAK;AACnE;AACA;AACA;AACA;AACA,wDAAwD,wCAAK;AAC7D;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACp1CA,gBAAgB,SAAI,IAAI,SAAI;AAC5B;AACA,iDAAiD,OAAO;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAC6B;AACK;AACQ;AACV;AACO;AACL;AACJ;AAC4B;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,OAAO;AACnB;AACA,iCAAiC,2BAA2B;AAC5D;AACA;AACA;AACO,WAAW,iDAAO;AACzB;AACA;AACA;AACA;AACA,YAAY,UAAU;AACtB;AACA,oCAAoC;AACpC,oCAAoC,MAAM;AAC1C;AACA;AACA;AACO,cAAc,oDAAU;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,OAAO;AACnB;AACA,iCAAiC,kBAAkB;AACnD;AACA;AACA;AACO,+BAA+B,wCAAK;AACpC;AACP;AACA,uBAAuB,wCAAK;AAC5B;AACA;AACA;AACA;AACA;AACA,4CAA4C,gBAAgB;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,UAAU;AACtB;AACA,eAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,oCAAoC,wCAAK,oBAAoB;AACpE;AACA;AACA,IAAI;AACG;AACP;AACA;AACA;AACA,0CAA0C,kBAAkB,2CAAM,oBAAoB,2CAAM,IAAI;AAChG;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,WAAW;AACvB;AACA,6CAA6C,YAAY,KAAK,YAAY;AAC1E,6CAA6C,YAAY,KAAK,kBAAkB;AAChF;AACA;AACA;AACO,eAAe,qDAAW;AACjC;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,MAAM;AAClB;AACA,qCAAqC,YAAY;AACjD,qCAAqC,YAAY;AACjD;AACA;AACA;AACO,UAAU,gDAAM;AAChB;AACP;AACA,aAAa,0CAAK;AAClB;AACA;AACA,kCAAkC;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,WAAW;AACvB,YAAY,SAAS;AACrB;AACA,6CAA6C,YAAY,iBAAiB,YAAY;AACtF,6CAA6C,YAAY;AACzD;AACA;AACA;AACO;AACP,qCAAqC,WAAW;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,WAAW;AACvB,YAAY,SAAS;AACrB;AACA,gEAAgE,YAAY,iBAAiB,YAAY;AACzG,gEAAgE,YAAY;AAC5E;AACA;AACA;AACO;AACP;AACA;AACA,mBAAmB,2CAAM;AACzB;AACA,kCAAkC;AAClC;AACA,eAAe,2CAAM;AACrB;AACA;AACO;AACP;AACA;AACA;AACA,eAAe,6CAAQ,OAAO,2CAAM,GAAG,2CAAM;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,cAAc;AAC1B,YAAY,SAAS;AACrB;AACA;AACA,8BAA8B,8BAA8B,IAAI,8BAA8B;AAC9F;AACA;AACA;AACA,8BAA8B,8BAA8B,IAAI,oBAAoB;AACpF;AACA;AACA;AACA,8BAA8B,8BAA8B,IAAI,kCAAkC;AAClG;AACA;AACA;AACA,8BAA8B,oBAAoB,IAAI,8BAA8B;AACpF;AACA;AACA;AACA;AACA;AACO,kBAAkB,wDAAc;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,SAAS;AACrB,YAAY,SAAS;AACrB;AACA,wCAAwC,oBAAoB;AAC5D,wCAAwC,oBAAoB;AAC5D;AACA;AACA;AACO,aAAa,mDAAS;AAC7B;AACA;AACA;AACA;AACA,YAAY,eAAe;AAC3B;AACA,0CAA0C,gBAAgB,GAAG,EAAE;AAC/D,4CAA4C,YAAY,KAAK,oBAAoB;AACjF;AACA;AACA;AACO,mBAAmB,yDAAe;AACzC;AACA;AACA;AACA;AACA,YAAY,MAAM;AAClB;AACA,gCAAgC,EAAE;AAClC,mCAAmC,YAAY,KAAK,oBAAoB;AACxE;AACA;AACA;AACA;AACO,UAAU,gDAAM;AAChB;AACP;AACA,qBAAqB,uBAAuB;AAC5C;AACA;AACA,+BAA+B,4DAAkB,YAAY,4DAAkB,CAAC,wCAAK;AACrF;AACO;AACP,4BAA4B,6DAAmB,MAAM,6DAAmB,CAAC,wCAAK;AAC9E;AACO;AACP;AACA,qBAAqB,uBAAuB;AAC5C;AACA;AACA,+BAA+B,iEAAuB,YAAY,iEAAuB,CAAC,wCAAK;AAC/F;AACA;AACA;AACA;AACA;AACA,YAAY,YAAY;AACxB;AACA,+CAA+C,MAAM;AACrD;AACA;AACA;AACO,gBAAgB,sDAAY;AAC5B;AACP,WAAW,8DAAoB;AAC/B;AACO;AACP,WAAW,qDAAW;AACtB;AACO;AACP,WAAW,qDAAW;AACtB;AACA;AACA;AACA;AACA;AACO;AACP;AACA,0BAA0B,uBAAuB,aAAa,+CAAI;AAClE;AACA;AACA;AACA;AACA;AACO;AACP;AACA,0BAA0B,uBAAuB,aAAa,+CAAI;AAClE;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,wBAAwB;AACpC,YAAY,SAAS;AACrB;AACA;AACA,8BAA8B,KAAK,WAAW,EAAE,qBAAqB,KAAK,UAAU,EAAE;AACtF,qDAAqD,qBAAqB;AAC1E;AACA;AACA,MAAM;AACN;AACA;AACA;AACA,MAAM;AACN,IAAI;AACJ;AACA;AACA;AACO,4BAA4B,kEAAwB;AACpD;AACP,WAAW,+DAAqB;AAChC;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,qBAAqB;AACjC,YAAY,SAAS;AACrB;AACA,kEAAkE,IAAI,EAAE,EAAE;AAC1E,kDAAkD,mBAAmB;AACrE;AACA;AACA,IAAI;AACJ;AACA;AACA;AACO,yBAAyB,+DAAqB;AAC9C;AACP,WAAW,4DAAkB;AAC7B;AACO;AACP,WAAW,yDAAe;AAC1B;AACA;AACA;AACA;AACA;AACA,YAAY,YAAY;AACxB;AACA,sCAAsC,YAAY;AAClD;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA,YAAY,cAAc;AAC1B;AACA,yEAAyE,YAAY;AACrF;AACA;AACA;AACA;AACO,kCAAkC,oBAAoB,4CAAO,IAAI,4CAAU;AAC3E;AACP,WAAW,4DAAkB;AAC7B;AACA;AACA;AACA;AACA;AACA,YAAY,QAAQ;AACpB;AACA,yDAAyD,YAAY;AACrE,yDAAyD,aAAa;AACtE;AACA;AACA;AACO,YAAY,kDAAQ;AAC3B;AACA;AACA;AACA;AACA,YAAY,OAAO;AACnB;AACA,wDAAwD,aAAa;AACrE,wDAAwD,cAAc;AACtE;AACA;AACA;AACO,WAAW,iDAAO;AACzB;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,OAAO;AACnB,YAAY,SAAS;AACrB;AACA,iDAAiD,oBAAoB;AACrE,gDAAgD,oBAAoB;AACpE;AACA;AACA;AACO,WAAW,iDAAO;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,QAAQ;AACpB,YAAY,QAAQ;AACpB;AACA,+BAA+B;AAC/B,sCAAsC,YAAY,IAAI,YAAY,KAAK,kBAAkB;AACzF,+BAA+B;AAC/B,sCAAsC,YAAY,IAAI,YAAY,KAAK,kBAAkB;AACzF;AACA;AACA;AACO;AACP,iBAAiB,kDAAQ;AACzB,+BAA+B;AAC/B;AACA,8BAA8B;AAC9B;AACA;AACA,8BAA8B;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,eAAe;AAC3B,YAAY,QAAQ;AACpB;AACA,+BAA+B;AAC/B,6CAA6C,YAAY,IAAI,YAAY,KAAK,KAAK;AACnF,+BAA+B;AAC/B,6CAA6C,YAAY,IAAI,YAAY,KAAK,KAAK;AACnF;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA,mBAAmB,yDAAe;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,aAAa;AACzB;AACA,uCAAuC,MAAM,IAAI,YAAY,KAAK,MAAM;AACxE,uCAAuC,MAAM,IAAI,YAAY,KAAK,MAAM;AACxE,uCAAuC,YAAY,IAAI,YAAY,KAAK,YAAY;AACpF;AACA;AACA;AACO;AACP;AACA;AACA,8BAA8B;AAC9B;AACA;AACA,8BAA8B;AAC9B;AACA,eAAe,uDAAa;AAC5B;AACA;AACA,WAAW,iDAAO;AAClB,oBAAoB,0DAAgB;AACpC,cAAc,oDAAU;AACxB,eAAe,qDAAW;AAC1B,mBAAmB,yDAAe;AAClC,cAAc,oDAAU;AACxB,iBAAiB,uDAAa;AAC9B,iBAAiB,uDAAa;AAC9B,oBAAoB,0DAAgB;AACpC,uBAAuB,6DAAmB;AAC1C,wBAAwB,8DAAoB;AAC5C,4BAA4B,kEAAwB;AACpD,6BAA6B,mEAAyB;AACtD,0BAA0B,gEAAsB;AAChD,0BAA0B,gEAAsB;AAChD,uBAAuB,6DAAmB;AAC1C,gBAAgB,sDAAY;AAC5B,gBAAgB,sDAAY;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B;AAC9B;AACA,4BAA4B;AAC5B;AACA,mDAAmD;AACnD;AACA;AACA,oBAAoB;AACpB;AACA,wCAAwC,kBAAkB;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,SAAS;AACrB;AACA,gEAAgE,mCAAmC;AACnG;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACO,aAAa,mDAAS;AAC7B;AACA;AACA;AACA;AACA;AACA,YAAY,YAAY;AACxB,YAAY,SAAS;AACrB;AACA,0DAA0D,GAAG;AAC7D,yCAAyC,mCAAmC;AAC5E;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACO,gBAAgB,sDAAY;AACnC;AACA;AACA;AACA;AACA,YAAY,YAAY;AACxB;AACA,mEAAmE,mCAAmC;AACtG;AACA;AACA,MAAM;AACN;AACA;AACA;AACA,MAAM;AACN,IAAI;AACJ;AACA;AACA;AACA;AACO,gBAAgB,sDAAY;AACnC;AACA;AACA;AACA;AACA;AACA,YAAY,eAAe;AAC3B,YAAY,SAAS;AACrB;AACA,4DAA4D,GAAG,4BAA4B,GAAG;AAC9F,4CAA4C,mCAAmC;AAC/E;AACA;AACA,MAAM;AACN;AACA;AACA;AACA,MAAM;AACN,IAAI;AACJ;AACA;AACA;AACA;AACO,mBAAmB,yDAAe;AAClC;AACP;AACA,qBAAqB,uBAAuB;AAC5C;AACA;AACA,+BAA+B,mDAAS,YAAY,mDAAS,CAAC,wCAAK;AACnE;AACO;AACP,4BAA4B,oDAAU,MAAM,oDAAU,CAAC,wCAAK;AAC5D;AACO;AACP;AACA,qBAAqB,uBAAuB;AAC5C;AACA;AACA,+BAA+B,wDAAc,YAAY,wDAAc,CAAC,wCAAK;AAC7E;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,UAAU;AACtB,YAAY,SAAS;AACrB;AACA,oCAAoC,8DAA8D;AAClG;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACO,cAAc,oDAAU;AAC/B;AACA;AACA;AACA;AACA,YAAY,WAAW;AACvB,YAAY,SAAS;AACrB;AACA;AACA,gBAAgB,uEAAuE;AACvF;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACO,eAAe,qDAAW;AACjC;AACA;AACA;AACA;AACO;AACA;AACP,4BAA4B,oDAAU,MAAM,oDAAU,CAAC,wCAAK;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,QAAQ;AACpB,YAAY,SAAS;AACrB,YAAY,KAAK;AACjB;AACA;AACA,sCAAsC,UAAU,IAAI,UAAU;AAC9D,sCAAsC,UAAU,IAAI,UAAU;AAC9D;AACA;AACA;AACA;AACO,YAAY,kDAAQ;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,eAAe;AAC3B,YAAY,YAAY;AACxB;AACA;AACA,qCAAqC,oBAAoB,IAAI,oBAAoB,KAAK,+BAA+B;AACrH;AACA;AACA;AACA;AACO,gBAAgB,sDAAY;AACnC;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,OAAO;AACnB;AACA,iBAAiB,qBAAqB,GAAG,+BAA+B,MAAM;AAC9E;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACO,yBAAyB,8CAAK;AACrC;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,iCAAiC;AACxC;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACO,0CAA0C;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,oCAAoC;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACO,6CAA6C;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,0DAAa;AAC7B,cAAc,wDAAW;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,oBAAoB;AAChC,YAAY,YAAY;AACxB;AACA,wCAAwC;AACxC;AACA,2CAA2C,YAAY,IAAI,YAAY,KAAK,mBAAmB;AAC/F;AACA;AACA;AACA;AACO;AACP;AACA;AACA,2CAA2C;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,eAAe;AAC3B,YAAY,iBAAiB;AAC7B;AACA;AACA,qCAAqC,oBAAoB,IAAI,oBAAoB,KAAK,+BAA+B;AACrH;AACA;AACA;AACA;AACO,oCAAoC;AAC3C;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,2BAA2B;AACvC,YAAY,YAAY;AACxB;AACA,wCAAwC;AACxC;AACA,2CAA2C,YAAY,IAAI,YAAY,KAAK,OAAO;AACnF;AACA;AACA;AACA;AACO;AACP;AACA;AACA,2CAA2C;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,iCAAiC;AAC7C,YAAY,QAAQ;AACpB;AACA,gBAAgB;AAChB,gBAAgB;AAChB;AACA;AACA,8CAA8C,YAAY;AAC1D;AACA;AACA;AACA;AACO,uCAAuC;AAC9C,uCAAuC;AACvC,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA,kCAAkC,wCAAK;AACvC,oCAAoC,wCAAK;AACzC,4CAA4C,wCAAK;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA,kCAAkC,wCAAK;AACvC,oCAAoC,wCAAK;AACzC,4CAA4C,wCAAK;AACjD,oDAAoD,wCAAK;AACzD,sDAAsD,wCAAK;AAC3D,8DAA8D,wCAAK;AACnE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA,kCAAkC,wCAAK;AACvC,oCAAoC,wCAAK;AACzC,4CAA4C,wCAAK;AACjD,sCAAsC,wCAAK;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA,kCAAkC,wCAAK;AACvC,oCAAoC,wCAAK;AACzC,4CAA4C,wCAAK;AACjD,oDAAoD,wCAAK;AACzD,sDAAsD,wCAAK;AAC3D,8DAA8D,wCAAK;AACnE,sCAAsC,wCAAK;AAC3C;AACA,wDAAwD,wCAAK;AAC7D;AACA,4BAA4B,0DAAa;AACzC,0BAA0B,wDAAW;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA,kCAAkC,wCAAK;AACvC,oCAAoC,wCAAK;AACzC,4CAA4C,wCAAK;AACjD,sCAAsC,wCAAK;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACO,qBAAqB,2DAAiB;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA,kCAAkC,wCAAK;AACvC,oCAAoC,wCAAK;AACzC,4CAA4C,wCAAK;AACjD,sCAAsC,wCAAK;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oDAAoD,wCAAK;AACzD,sDAAsD,wCAAK;AAC3D,8DAA8D,wCAAK;AACnE;AACA;AACA;AACA;AACA,wDAAwD,wCAAK;AAC7D;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AClnCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,YAAY;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACoD;AACpB;AACH;AACD;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,yBAAyB;AAChC,YAAY,qCAAM;AAClB,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,yBAAyB;AAChC,YAAY,qCAAM;AAClB,CAAC;AACD;AACA;AACA;AACA;AACO,8BAA8B;AACrC,0BAA0B;AAC1B,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,UAAU;AACtB;AACA;AACA;AACA;AACA;AACA;AACO,cAAc,2CAAS;AAC9B;AACA;AACA;AACA;AACA,YAAY,SAAS;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA,qCAAqC,YAAY,IAAI,YAAY,KAAK,YAAY;AAClF;AACA;AACA;AACO,qCAAqC;AAC5C;AACA;AACA;AACA,gBAAgB,0CAAK;AACrB;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA,YAAY,QAAQ;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA,qBAAqB,uBAAuB;AAC5C;AACA;AACA;AACA,2CAA2C,wCAAwC,uCAAuC;AAC1H,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,YAAY,cAAc;AAC1B;AACA,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP,0BAA0B;AAC1B,kCAAkC;AAClC,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,0BAA0B,UAAU,QAAQ,+CAAQ,EAAE;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,yBAAyB,UAAU,0BAA0B,aAAa;AACjF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,YAAY;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,gBAAgB,6CAAW;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACO,uCAAuC;AAC9C,uCAAuC,uBAAuB;AAC9D,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACA;AACP;AACA,sCAAsC;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP,8BAA8B;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP,8BAA8B;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,2BAA2B,mDAAY;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP,8BAA8B;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP,8BAA8B;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP,8BAA8B;AAC9B;;;;;;;;;;;;;;;;;;;;;;;;;;;ACpXA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACkC;AACQ;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACO,yCAAyC,UAAU,0BAA0B;AACpF,8BAA8B,OAAO,+CAAI;AACzC,kCAAkC,OAAO,+CAAI;AAC7C,mCAAmC,OAAO,+CAAI;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACO,yBAAyB,8CAAK;AACrC;AACA;AACA;AACA;AACA;AACA;AACO,0BAA0B;AACjC;AACA;AACA;AACO,2BAA2B;;;;;;;;;;;;;;;;;;;AChGF;AACzB;AACP;AACA;AACA,kCAAkC;AAClC;AACA;AACO;AACP;AACA;AACA,kCAAkC;AAClC;AACA;AACO;AACP;AACA;AACA,sCAAsC,uBAAuB,kCAAkC,0CAA0C,YAAY,2CAAM,MAAM,2CAAM,IAAI,IAAI;AAC/K;AACA;;;;;;;;;;;;;;;;AClBO;AACP,0BAA0B;AAC1B;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACFA,qBAAqB,SAAI,IAAI,SAAI;AACjC,6EAA6E,OAAO;AACpF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP,yBAAyB;AACzB,gCAAgC,sBAAsB,+BAA+B;AACrF,gCAAgC,sBAAsB,+BAA+B;AACrF,4BAA4B,gBAAgB;AAC5C,2BAA2B,eAAe;AAC1C,mCAAmC,sBAAsB,kCAAkC;AAC3F,4BAA4B,sBAAsB;AAClD,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,YAAY,0BAA0B;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP,yBAAyB;AACzB,kCAAkC,sBAAsB;AACxD,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,YAAY,YAAY;AACxB,YAAY,YAAY;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA,yBAAyB;AACzB;AACA,6BAA6B;AAC7B,KAAK;AACL;AACA;AACA;AACA;AACA;AACO,iCAAiC;AACxC,2BAA2B,sBAAsB,8BAA8B;AAC/E,wBAAwB,gBAAgB;AACxC,2BAA2B,sBAAsB,8BAA8B;AAC/E,uBAAuB;AACvB,CAAC;AACD;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,sBAAsB;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACO;AACP,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACO;AACA;AACP;AACA;AACA,yBAAyB,uBAAuB;AAChD;AACA;AACA;AACA;AACA;AACA,8BAA8B;AAC9B;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA,qBAAqB,uBAAuB;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,SAAS;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP,0BAA0B;AAC1B;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA,yBAAyB,uBAAuB;AAChD;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,sBAAsB;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACO,2BAA2B;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP,0BAA0B;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,0CAA0C;AACjD,uCAAuC,6BAA6B;AACpE;AACA,CAAC;AACD;AACO;AACP,oEAAoE,+BAA+B;AACnG;AACA;AACA;AACA;AACA;AACA,iCAAiC;AACjC;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACxVA,qBAAqB,SAAI,IAAI,SAAI;AACjC,6EAA6E,OAAO;AACpF;AACA;AACA;AACA;AACA;AACA;AACA;AACkC;AAClC;AACA;AACA;AACA;AACO,6BAA6B;AACpC;AACO,6BAA6B;AACpC;AACO,aAAa;AACpB;AACO,0BAA0B,UAAU,wBAAwB;AACnE;AACA;AACA;AACA;AACO,6BAA6B;AACpC;AACO,8BAA8B;AACrC;AACO,0BAA0B,UAAU,uBAAuB;AAClE;AACO,2BAA2B,UAAU,yBAAyB;AACrE;AACA;AACA;AACA;AACO,+BAA+B;AACtC;AACO,iCAAiC;AACxC;AACO,2BAA2B;AAClC;AACO,2BAA2B;AAClC;AACA;AACA;AACA;AACO;AACP;AACO;AACP;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACO,gDAAgD;AACvD;AACO;AACP;AACA;AACA;AACA,6BAA6B,uBAAuB;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA,6BAA6B,uBAAuB;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP,yBAAyB,+CAAI;AAC7B;AACA,KAAK;AACL;AACA;AACO;AACP,yBAAyB,+CAAI,iCAAiC,mDAAmD;AACjH;AACA;AACO;AACP,yBAAyB,+CAAI;AAC7B,8CAA8C,4BAA4B;AAC1E,KAAK;AACL;AACA;AACO;AACP,yBAAyB,+CAAI;AAC7B,8CAA8C,wBAAwB;AACtE,KAAK;AACL;AACA;AACO;AACP,yBAAyB,+CAAI;AAC7B,8CAA8C,0BAA0B;AACxE,KAAK;AACL;AACA;AACO;AACP,yBAAyB,+CAAI;AAC7B,8CAA8C,4BAA4B;AAC1E,KAAK;AACL;;;;;;;;;;;;;;;;;;;;;;;;;;ACvHA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,8BAA8B;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP,uCAAuC;AACvC;AACA;AACA;AACA;AACA;AACO;AACP;AACA,wCAAwC;AACxC;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACO;AACP,uCAAuC;AACvC;AACA;AACA;AACA;AACA;AACA,YAAY,eAAe;AAC3B;AACA;AACA;AACA;AACA;AACA;AACO;AACP,uCAAuC;AACvC;AACA;AACA;AACA;AACA;AACA,YAAY,mBAAmB;AAC/B;AACA;AACA;AACA;AACA;AACA;AACO;AACP,uCAAuC;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,YAAY;AACxB;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,gBAAgB;AAC5B;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA,2BAA2B,WAAW;AACtC,oCAAoC,wBAAwB;AAC5D,oCAAoC;AACpC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AC7HqE;AACjB;AACkB;AAC/D;AACP,0BAA0B,uBAAuB;AACjD;AACO;AACP,0BAA0B,uBAAuB;AACjD;AACO;AACP,0BAA0B,uBAAuB;AACjD;AACO;AACP,2BAA2B,wBAAwB;AACnD;AACO;AACP,0BAA0B,uBAAuB;AACjD;AACO;AACP,6BAA6B,wBAAwB;AACrD;AACO;AACP,0BAA0B,wBAAwB;AAClD;AACO;AACP,0BAA0B,uBAAuB;AACjD;AACO;AACP,6BAA6B,uBAAuB;AACpD;AACO;AACP;AACA;AACA,8BAA8B,uBAAuB;AACrD;AACA;AACO;AACP,6BAA6B,uBAAuB;AACpD;AACO;AACP,6BAA6B,uBAAuB;AACpD;AACO;AACP;AACA;AACA,8BAA8B,uBAAuB;AACrD;AACA;AACO;AACP,6BAA6B,uBAAuB;AACpD;AACO;AACP,6BAA6B,uBAAuB;AACpD;AACO;AACP,kCAAkC,uBAAuB;AACzD;AACO;AACP,0BAA0B,uBAAuB;AACjD;AACO;AACP,0BAA0B,uBAAuB;AACjD;AACO;AACP,0BAA0B,uBAAuB;AACjD;AACO;AACP,kCAAkC,uBAAuB;AACzD;AACO;AACP,0BAA0B,uBAAuB;AACjD;AACO;AACP,0BAA0B,uBAAuB;AACjD;AACO;AACP,0BAA0B,uBAAuB;AACjD;AACO;AACP,6BAA6B,wBAAwB;AACrD;AACO;AACP,2BAA2B,uBAAuB;AAClD;AACA,+BAA+B;AAC/B,qCAAqC;AACrC,wCAAwC;AACxC,6BAA6B;AAC7B,6BAA6B;AAC7B,iCAAiC;AACjC,8BAA8B;AAC9B,gCAAgC;AAChC,yCAAyC;AACzC,2BAA2B;AAC3B,mCAAmC;AACnC,kCAAkC;AAClC;AACA;AACA;AACA,kCAAkC;AAClC,oCAAoC;AACpC,kCAAkC;AAClC;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,+CAAQ;AAC5B,qBAAqB,gDAAS;AAC9B;AACA;AACA;AACA,uBAAuB,kDAAW;AAClC,4BAA4B,+CAAQ;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,+CAAQ;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kDAAkD,6DAA6D;AAC/G;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,WAAW,2CAAsB;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACrMa;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP,uCAAuC;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP,uCAAuC;AACvC;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA,wCAAwC;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,8BAA8B;AACrC;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;AACO,iCAAiC;AACxC;AACA;AACA;AACA,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;AACO,iCAAiC;AACxC;AACA;AACA;AACA,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;AACO,0BAA0B;AACjC;AACA;AACA;AACA,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;AACO,8BAA8B;AACrC;AACA;AACA;AACA,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;AACO,+BAA+B;AACtC;AACA;AACA;AACA,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;AACA;AACO,6BAA6B;AACpC;AACA;AACA;AACA;AACA;AACA,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;AACO,0BAA0B;AACjC;AACA;AACA;AACA,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA,eAAe,kEAAU;AACzB;AACA;AACA;AACA;AACA;AACA,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;;;;;;;;;;;;ACzQa;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,kBAAkB;AAClB,WAAW;AACX,YAAY;AACZ;AACA;AACA,0BAA0B,0BAA0B;AACpD;AACA;AACA;AACA,iCAAiC,qCAAqC,iCAAiC,WAAW,IAAI;AACtH;AACA;AACA,gCAAgC,uBAAuB,kCAAkC;AACzF;AACA,+BAA+B,aAAa;AAC5C,KAAK,IAAI;AACT;;;;;;;;;;;;AClBa;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,cAAc,GAAG,gBAAgB,GAAG,gBAAgB,GAAG,iBAAiB,GAAG,UAAU,GAAG,mBAAmB,GAAG,mBAAmB,GAAG,kBAAkB,GAAG,qBAAqB,GAAG,iBAAiB,GAAG,oBAAoB,GAAG,gBAAgB,GAAG,WAAW,GAAG,iBAAiB,GAAG,aAAa,GAAG,cAAc,GAAG,kBAAkB;AACpU,iBAAiB,mBAAO,CAAC,wDAAY;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC;AACrC,8BAA8B;AAC9B,CAAC;AACD,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,cAAc;AACd;AACA;AACA;AACA;AACA,YAAY,QAAQ;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,uBAAuB;AAC5C;AACA;AACA,8DAA8D,mCAAmC,uCAAuC,IAAI;AAC5I;AACA,aAAa;AACb;AACA,oCAAoC;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,gBAAgB;AAC5B,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS,4CAA4C;AACrD,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,SAAS,4CAA4C;AACrD,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B;AAC/B,qDAAqD,+BAA+B;AACpF;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA,gBAAgB;AAChB,8BAA8B;AAC9B;AACA;AACA,0BAA0B;AAC1B;AACA;AACA;AACA;AACA;AACA,iCAAiC;AACjC,8BAA8B,iDAAiD,0CAA0C;AACzH,CAAC;AACD,oBAAoB;AACpB;AACA;AACA;AACA;AACA,8BAA8B;AAC9B;AACA;AACA,CAAC;AACD,iBAAiB;AACjB;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd,uCAAuC;AACvC;;;;;;;;;;;;AC9Na;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,oCAAoC;AACnD;AACA;AACA,CAAC;AACD;AACA;AACA,CAAC;AACD;AACA,0CAA0C,4BAA4B;AACtE,CAAC;AACD;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA6C,EAAE,aAAa,EAAC;AAC7D,kBAAkB;AAClB,qBAAqB;AACrB,mBAAmB;AACnB,oBAAoB;AACpB,mBAAmB;AACnB,oBAAoB;AACpB,yBAAyB;AACzB,oBAAoB;AACpB,iBAAiB;AACjB,cAAc,mBAAO,CAAC,kDAAS;AAC/B,iBAAiB,mBAAO,CAAC,wDAAY;AACrC,qBAAqB,mBAAO,CAAC,wDAAY;AACzC;AACA,+BAA+B,uBAAuB;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,uBAAuB;AACrD;AACA;AACA;AACA,0BAA0B;AAC1B;AACA;AACA;AACA,0BAA0B,uBAAuB;AACjD;AACA;AACA;AACA,0BAA0B,uBAAuB;AACjD;AACA;AACA;AACA;AACA,8CAA8C,sEAAsE;AACpH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC;AAChC;;;;;;;;;;;;ACzFa;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,WAAW;AACX,YAAY;AACZ,cAAc;AACd,cAAW;AACX,6BAA6B;AAC7B,UAAU;AACV,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,mBAAO,CAAC,wDAAY;AACrC;AACA,0BAA0B,uBAAuB,iCAAiC,sBAAsB;AACxG;AACA;AACA,0BAA0B,wBAAwB,iCAAiC,cAAc;AACjG;AACA;AACA,6BAA6B,uBAAuB;AACpD;AACA,uBAAuB;AACvB,KAAK;AACL;AACA;AACA,gCAAgC,uBAAuB;AACvD;AACA,+BAA+B,aAAa;AAC5C,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,iCAAiC;AACjC;AACA;AACA;AACA;AACA,gCAAgC,iCAAiC,WAAW;AAC5E;AACA;AACA;AACA;AACA,6BAA6B;AAC7B;;;;;;;;;;;;ACxDa;AACb;AACA;AACA;AACA;AACA,eAAe,oCAAoC;AACnD;AACA;AACA,CAAC;AACD;AACA;AACA,CAAC;AACD;AACA,0CAA0C,4BAA4B;AACtE,CAAC;AACD;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA6C,EAAE,aAAa,EAAC;AAC7D,aAAa,GAAG,sCAAsC,GAAG,8CAA8C,GAAG,WAAW,GAAG,eAAe,GAAG,gBAAgB,GAAG,cAAc,GAAG,YAAY,GAAG,mBAAmB,GAAG,kBAAkB,GAAG,qBAAqB,GAAG,kBAAkB,GAAG,mBAAmB,GAAG,gBAAgB,GAAG,iBAAiB,GAAG,iBAAiB,GAAG,eAAe,GAAG,YAAY,GAAG,eAAe,GAAG,WAAW,GAAG,UAAU,GAAG,gBAAgB,GAAG,gBAAgB,GAAG,mBAAmB,GAAG,eAAe,GAAG,cAAc,GAAG,WAAW,GAAG,eAAe,GAAG,aAAa,GAAG,mBAAmB,GAAG,gBAAgB,GAAG,YAAY,GAAG,YAAY,GAAG,aAAa,GAAG,aAAa,GAAG,cAAc,GAAG,eAAe,GAAG,cAAc;AAC3tB,cAAc;AACd,YAAY;AACZ,aAAa;AACb,YAAY;AACZ,eAAe;AACf,aAAa;AACb,oBAAoB;AACpB,sBAAsB;AACtB,gBAAgB;AAChB,gBAAgB;AAChB,eAAe;AACf,gBAAgB;AAChB,kBAAkB;AAClB,mBAAmB;AACnB,mBAAmB;AACnB,oBAAoB;AACpB,WAAW,mBAAO,CAAC,4CAAM;AACzB,mBAAmB,mBAAO,CAAC,4DAAc;AACzC,iBAAiB,mBAAO,CAAC,wDAAY;AACrC,gBAAgB,mBAAO,CAAC,sDAAW;AACnC,qBAAqB,mBAAO,CAAC,wDAAY;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B;AAC9B,eAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA,YAAY,qDAAqD,oBAAoB;AACrF;AACA;AACA;AACA;AACA;AACA;AACA,gDAAgD,yCAAyC,iBAAiB,0CAA0C,oBAAoB,kEAAkE;AAC1O;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,6BAA6B;AACzC,YAAY,aAAa;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,8BAA8B;AAC1C,YAAY,aAAa;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,yBAAyB;AACrC,YAAY,aAAa;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B;AAC3B;AACA;AACA;AACA;AACA,YAAY,2BAA2B;AACvC,YAAY,aAAa;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B;AAC3B;AACA;AACA;AACA;AACA;AACA,YAAY,iCAAiC;AAC7C,YAAY,aAAa;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,kCAAkC;AAC9C,YAAY,aAAa;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,iCAAiC;AAC7C,YAAY,aAAa;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB;AACnB,8BAA8B;AAC9B;AACA,mCAAmC;AACnC;AACA,kCAAkC;AAClC;AACA,oCAAoC;AACpC;AACA;AACA;AACA,8BAA8B;AAC9B;AACA;AACA,yCAAyC;AACzC;AACA;AACA;AACA,8BAA8B;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B;AAC9B;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B;AACA;AACA,eAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA,+BAA+B;AAC/B;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA,6BAA6B,sBAAsB;AACnD;AACA;AACA,eAAe;AACf;AACA;AACA;AACA;AACA,oCAAoC;AACpC;AACA;AACA,mBAAmB;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iJAAiJ,0BAA0B;AAC3K;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA,uIAAuI,0BAA0B;AACjK;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA,mBAAmB;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA,YAAY,8BAA8B;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+CAA+C,WAAW,gBAAgB,WAAW;AACrF;AACA,eAAe;AACf;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,eAAe;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B;AAC/B;AACA;AACA,sCAAsC;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACntBa;AACb;AACA,6EAA6E,OAAO;AACpF;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA6C,EAAE,aAAa,EAAC;AAC7D,YAAY,GAAG,6BAA6B,GAAG,UAAU,GAAG,YAAY,GAAG,iBAAiB,GAAG,sBAAsB,GAAG,iBAAiB,GAAG,kBAAkB,GAAG,iBAAiB,GAAG,oBAAoB,GAAG,aAAa,GAAG,eAAe,GAAG,mBAAmB,GAAG,iBAAiB,GAAG,oBAAoB,GAAG,yBAAyB;AACxU,gBAAgB;AAChB,gBAAgB;AAChB,YAAY;AACZ,YAAY;AACZ,aAAa;AACb,iBAAiB;AACjB,iBAAiB;AACjB,cAAc;AACd,cAAc;AACd,gBAAgB;AAChB,YAAY;AACZ,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB,gCAAgC,sBAAsB,+BAA+B;AACrF,gCAAgC,sBAAsB,+BAA+B;AACrF,4BAA4B,gBAAgB;AAC5C,2BAA2B,eAAe;AAC1C,mCAAmC,sBAAsB,kCAAkC;AAC3F,4BAA4B,sBAAsB;AAClD,KAAK;AACL;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA,YAAY,0BAA0B;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB,kCAAkC,sBAAsB;AACxD,KAAK;AACL;AACA,oBAAoB;AACpB;AACA;AACA;AACA;AACA,YAAY,YAAY;AACxB,YAAY,YAAY;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA,6BAA6B;AAC7B,KAAK;AACL;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA,iCAAiC;AACjC,2BAA2B,sBAAsB,8BAA8B;AAC/E,wBAAwB,gBAAgB;AACxC,2BAA2B,sBAAsB,8BAA8B;AAC/E,uBAAuB;AACvB,CAAC;AACD,mBAAmB;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,sBAAsB;AACrD;AACA;AACA,eAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,yBAAyB,uBAAuB;AAChD;AACA;AACA;AACA;AACA;AACA,8BAA8B;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,uBAAuB;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,SAAS;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,uBAAuB;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,sBAAsB;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA,2BAA2B;AAC3B,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C;AAC1C,uCAAuC,6BAA6B;AACpE;AACA,CAAC;AACD,6BAA6B;AAC7B;AACA;AACA,oEAAoE,+BAA+B;AACnG;AACA;AACA;AACA;AACA;AACA,iCAAiC;AACjC;AACA;AACA,YAAY;;;;;;;;;;;;AChXC;AACb;AACA,6EAA6E,OAAO;AACpF;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA6C,EAAE,aAAa,EAAC;AAC7D,qBAAqB,GAAG,mBAAmB,GAAG,iBAAiB,GAAG,qBAAqB,GAAG,qBAAqB,GAAG,uBAAuB,GAAG,kBAAkB,GAAG,oBAAoB,GAAG,iCAAiC,GAAG,WAAW,GAAG,mBAAmB,GAAG,0BAA0B,GAAG,YAAY,GAAG,YAAY,GAAG,kBAAkB,GAAG,iBAAiB,GAAG,aAAa,GAAG,YAAY,GAAG,eAAe,GAAG,cAAc,GAAG,YAAY,GAAG,YAAY,GAAG,cAAc,GAAG,cAAc;AACne,iBAAiB,mBAAO,CAAC,wDAAY;AACrC;AACA;AACA;AACA;AACA,6BAA6B;AAC7B,cAAc;AACd;AACA,6BAA6B;AAC7B,cAAc;AACd;AACA,YAAY,KAAK;AACjB;AACA,0BAA0B,UAAU,wBAAwB;AAC5D,YAAY;AACZ;AACA;AACA;AACA;AACA,6BAA6B;AAC7B,cAAc;AACd;AACA,8BAA8B;AAC9B,eAAe;AACf;AACA,0BAA0B,UAAU,uBAAuB;AAC3D,YAAY;AACZ;AACA,2BAA2B,UAAU,yBAAyB;AAC9D,aAAa;AACb;AACA;AACA;AACA;AACA,+BAA+B;AAC/B,iBAAiB;AACjB;AACA,iCAAiC;AACjC,kBAAkB;AAClB;AACA,2BAA2B;AAC3B,YAAY;AACZ;AACA,2BAA2B;AAC3B,YAAY;AACZ;AACA;AACA;AACA;AACA,0BAA0B;AAC1B;AACA,mBAAmB;AACnB;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA,gDAAgD;AAChD,iCAAiC;AACjC;AACA;AACA;AACA;AACA;AACA,6BAA6B,uBAAuB;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA,6BAA6B,uBAAuB;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,uBAAuB;AACvB;AACA;AACA,8EAA8E,gEAAgE;AAC9I;AACA,qBAAqB;AACrB;AACA;AACA;AACA,8CAA8C,4BAA4B;AAC1E,KAAK;AACL;AACA,qBAAqB;AACrB;AACA;AACA;AACA,8CAA8C,wBAAwB;AACtE,KAAK;AACL;AACA,iBAAiB;AACjB;AACA;AACA;AACA,8CAA8C,0BAA0B;AACxE,KAAK;AACL;AACA,mBAAmB;AACnB;AACA;AACA;AACA,8CAA8C,4BAA4B;AAC1E,KAAK;AACL;AACA,qBAAqB;;;;;;;;;;;;AC9IR;AACb;AACA;AACA,iDAAiD,OAAO;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA6C,EAAE,aAAa,EAAC;AAC7D,cAAc;AACd,oBAAoB;AACpB,cAAc;AACd,4BAA4B,mBAAO,CAAC,6FAAuB;AAC3D,+BAA+B,mBAAO,CAAC,mGAA0B;AACjE,2BAA2B,mBAAO,CAAC,2FAAsB;AACzD,6CAA6C,4CAA4C,kDAAkD;AAC3I;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2EAA2E;AAC3E;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,sDAAsD;AACtD,0DAA0D;AAC1D;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,wBAAwB,8BAA8B;AAC9F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oDAAoD;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0DAA0D,qEAAqE;AAC/H;AACA,iC;;;;;;;;;;;AChIa;AACb;AACA;AACA,iDAAiD,OAAO;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA6C,EAAE,aAAa,EAAC;AAC7D,uBAAuB,GAAG,mBAAmB;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,mBAAmB;AACvC;AACA,wBAAwB,oBAAoB;AAC5C;AACA;AACA,8CAA8C;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU,8BAA8B,6DAA6D,kCAAkC;AACvI,UAAU;AACV;AACA,mBAAmB;AACnB,kDAAkD;AAClD,mBAAmB,2nBAA2nB;AAC9oB,uBAAuB,SAAS,gBAAgB,OAAO,QAAQ,QAAQ,SAAS,UAAU,YAAY,SAAS,SAAS,YAAY,aAAa,UAAU,SAAS,OAAO,QAAQ,QAAQ,SAAS,SAAS,SAAS,UAAU,SAAS,OAAO,QAAQ,QAAQ,QAAQ,SAAS,WAAW,UAAU,UAAU,UAAU,QAAQ,UAAU,UAAU,UAAU,WAAW,SAAS,WAAW,SAAS,mpBAAmpB;AAC3hC;AACA,uBAAuB;AACvB,2BAA8B;AAC9B,6BAAgC;AAChC,6BAAgC,olWAAolW,8DAA8D,itHAAitH,8DAA8D,ksBAAksB;AACnof,4C;;;;;;;;;;;ACjDa;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,yBAAyB;AACzB,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+C;;;;;;;;;;;ACjCa;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,uBAAuB,GAAG,yBAAyB,GAAG,oBAAoB,GAAG,qBAAqB;AAClG,qBAAqB;AACrB;AACA;AACA;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB,uBAAuB;AACvB,2C;;;;;;;;;;;ACjBa;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,gBAAgB,GAAG,8BAA8B,GAAG,6BAA6B,GAAG,oBAAoB;AACxG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,gBAAgB;AAC9C;AACA;AACA,mCAAmC,aAAa;AAChD;AACA;AACA,mDAAmD,cAAc;AACjE;AACA;AACA;AACA,QAAQ,mBAAO,CAAC,sDAAa;AAC7B,QAAQ,mBAAO,CAAC,wDAAc;AAC9B,UAAU,mBAAO,CAAC,sEAAqB;AACvC,QAAQ,mBAAO,CAAC,wDAAc;AAC9B,QAAQ,mBAAO,CAAC,wDAAc;AAC9B,iBAAiB,mBAAO,CAAC,4DAAgB;AACzC,QAAQ,mBAAO,CAAC,gDAAO;AACvB,cAAc,mBAAO,CAAC,mEAAS;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,eAAe;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,QAAQ;AAC5B;AACA,8BAA8B;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,8CAA8C;AACjF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iFAAiF,8BAA8B;AAC/G;AACA;AACA;AACA,4EAA4E,kBAAkB,6BAA6B,mBAAmB;AAC9I;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wDAAwD;AACxD,6BAA6B;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,yBAAyB;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wFAAwF,uCAAuC;AAC/H;AACA;AACA,KAAK;AACL;AACA,8BAA8B;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qEAAqE,yDAAyD,8BAA8B,gBAAgB,gBAAgB,YAAY;AACxM;AACA,gBAAgB;AAChB,uBAAuB;AACvB,kBAAe;AACf,iC;;;;;;;;;;;ACrKa;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,eAAe;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA,iC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACtBA,iBAAiB,SAAI,IAAI,SAAI;AAC7B;AACA;AACA,eAAe,gBAAgB,sCAAsC,kBAAkB;AACvF,8BAA8B;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB;AACxB;AACA;AACA,CAAC;AACD,gBAAgB,SAAI,IAAI,SAAI;AAC5B;AACA,iDAAiD,OAAO;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,SAAI,IAAI,SAAI;AACjC,6EAA6E,OAAO;AACpF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACuD;AACvD;AACA;AACA;AACA;AACO,eAAe,kDAAI;AAC1B;AACA;AACA;AACA;AACO;AACP,uBAAuB,kDAAkD;AACzE;AACA;AACA;AACA;AACA;AACO,cAAc,mDAAK;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B;AAC/B;AACA;AACA,gBAAgB,wDAAM;AACtB;AACA;AACA;AACA,SAAS,iFAAiF,oCAAoC;AAC9H;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,gCAAgC;AACnE;AACA;AACA,CAAC;AACe;AAChB;AACA;AACA;AACA;AACA;AACA;AACO,8BAA8B;AACrC;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACO;AACP,aAAa;AACb;AACA;AACA;AACA;AACO;AACP;AACA;AACA,oBAAoB,SAAS;AAC7B;AACA;AACA,eAAe;AACf;AACA;AACA;AACA;AACA,oBAAoB,OAAO;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,kDAAkD;AAC9E;AACA;AACA;AACA,oBAAoB,mBAAmB;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,qCAAqC;AACnD;AACA;AACA;AACA;AACA;AACA,2BAA2B,UAAU,4DAA4D;AACjG;AACA;AACA,oBAAoB,SAAS;AAC7B;AACA;AACA;AACA,mDAAmD,0BAA0B;AAC7E;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA,0BAA0B;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA,sDAAsD,6BAA6B;AACnF,sGAAsG;AACtG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,SAAS;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,UAAU,4DAA4D;AACjG;AACA;AACA,uDAAuD,4CAA4C;AACnG;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,SAAS;AACrC;AACA;AACA;AACA,oBAAoB,wDAAM;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,wDAAM;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,yBAAyB;AACzB;AACA;AACA;AACA;AACA,4BAA4B,SAAS;AACrC;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,8CAA8C,mBAAmB;AACjE;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA,gCAAgC,kBAAkB;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,kBAAkB;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+DAA+D,8CAA8C,IAAI;AACjH;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,iBAAiB;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,8CAA8C;AAC/D;AACA;AACA,oCAAoC,8CAA8C;AAClF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA,8BAA8B,iBAAiB;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2DAA2D,yCAAyC;AACpG;AACA;AACA,oEAAoE,6CAA6C;AACjH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,SAAS;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+CAA+C,+BAA+B;AAC9E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA,0CAA0C,oBAAoB;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6DAA6D,oBAAoB,oBAAoB,oDAAoD;AACzJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACmB;AACpB;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,kEAAkE,sBAAsB,oBAAoB,oDAAoD;AAChK;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACwB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACmB;AACpB;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,gEAAgE,cAAc;AAC9E;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACsB;AACvB;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,+DAA+D,+BAA+B,oBAAoB,oDAAoD;AACtK;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACqB;AACtB;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,+DAA+D,+BAA+B,oBAAoB,oDAAoD;AACtK;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACqB;AACtB;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,+BAA+B,oBAAoB,oDAAoD;AAC9H;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACqB;AACtB;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,gEAAgE,gCAAgC,oBAAoB,oDAAoD;AACxK;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACsB;AACvB;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,uFAAuF,oDAAoD;AAC3I;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACuB;AACxB;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,sEAAsE,kEAAkE,oBAAoB,oDAAoD;AAChN;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AAC4B;AAC7B;AACA;AACA;AACA;AACO;AAgBY;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACsB;AACvB;AACA;AACA;AACA;AACO;AACP,2BAA2B;AAC3B,4BAA4B;AAC5B,uDAAuD,kDAAkD;AACzG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACoB;AACrB;AACA;AACA;AACA;AACO;AACP,2BAA2B;AAC3B,4BAA4B,2BAA2B;AACvD;AACA,4BAA4B;AAC5B,qDAAqD,8CAA8C;AACnG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACyB;AAC1B;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,uCAAuC,6BAA6B;AAC3E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACwB;AACzB;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sDAAsD,+BAA+B,oBAAoB,wCAAwC,iBAAiB,mCAAmC;AACrM;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACoB;AACrB;AACA;AACA;AACA;AACO;AACP,2BAA2B;AAC3B,8CAA8C,gDAAgD;AAC9F;AACA,YAAY,wDAAM;AAClB;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,SAAS;AACjC;AACA;AACA,gBAAgB,wDAAM;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK,uDAAuD,4BAA4B;AACxF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACwB;AACzB;AACA;AACA;AACA;AACO;AACP,2BAA2B;AAC3B;AACA,0CAA0C,oBAAoB;AAC9D;AACA;AACA;AACA,4BAA4B,SAAS;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,YAAY,wDAAM;AAClB;AACA;AACA;AACA;AACA;AACA,wBAAwB,SAAS;AACjC;AACA;AACA;AACA;AACA,gBAAgB,wDAAM;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC;AACvC;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,+BAA+B;AAC/B,4BAA4B,SAAS;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACsB;AACvB;AACA;AACA;AACA;AACO;AACP,2BAA2B;AAC3B;AACA,0CAA0C,oBAAoB;AAC9D;AACA;AACA;AACA,4BAA4B,SAAS;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,YAAY,wDAAM;AAClB;AACA;AACA;AACA;AACA;AACA,wBAAwB,SAAS;AACjC;AACA;AACA;AACA;AACA,gBAAgB,wDAAM;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC;AACvC;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,+BAA+B;AAC/B,4BAA4B,SAAS;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACyB;AAC1B;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACoB;AACrB;AACA;AACA;AACA;AACO;AACP,2BAA2B;AAC3B;AACA;AACA;AACA;AACA;AACA,4BAA4B,WAAW;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,gBAAgB,wDAAM;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,kDAAkD,qCAAqC,oBAAoB,IAAI;AAC/G;AACA,4BAA4B,mBAAmB;AAC/C;AACA;AACA,oBAAoB,wDAAM;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,oDAAoD,sBAAsB;AAC1E;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AAC2B;AACrB;AACP,2BAA2B,+CAA+C,mBAAmB;AAC7F;AACA,qDAAqD,sCAAsC,oBAAoB,IAAI;AACnH;AACA;AACA;AACA;AACA,4BAA4B,SAAS;AACrC;AACA;AACA,oBAAoB,wDAAM;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,6DAA6D,yBAAyB;AACtF,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACoB;AACd;AACP,2BAA2B,+CAA+C,mBAAmB;AAC7F;AACA,8CAA8C,mFAAmF,uBAAuB,IAAI;AAC5J;AACA,YAAY,wDAAM;AAClB;AACA;AACA;AACA,0DAA0D;AAC1D;AACA,wBAAwB,SAAS;AACjC;AACA;AACA;AACA,gBAAgB,wDAAM;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK,kDAAkD,uCAAuC,2BAA2B,IAAI;AAC7H;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACuB;AACxB;AACA;AACA;AACA;AACO;AACP,2BAA2B;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AAC4B;AAC7B;AACA;AACA;AACA;AACO;AACP,2BAA2B;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,sCAAsC;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACoB;AACrB;AACA;AACA;AACA;AACA;AACA;AACO;AACP,2BAA2B;AAC3B;AACA;AACA;AACA,YAAY,wDAAM;AAClB;AACA;AACA;AACA,YAAY,wDAAM;AAClB;AACA;AACA,eAAe,uDAAK;AACpB,KAAK,iBAAiB,2CAA2C;AACjE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,iCAAiC,oBAAoB,oDAAoD;AAChI;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACuB;AACxB;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,8DAA8D,eAAe,oBAAoB,uBAAuB;AACxH;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACoB;AACrB;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,4DAA4D,cAAc;AAC1E;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACkB;AACnB;AACA;AACA;AACA;AACO;AACA;AACP,2BAA2B;AAC3B,mDAAmD,qCAAqC;AACxF;AACA,YAAY,wDAAM;AAClB;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AAC0B;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA,2BAA2B;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AASwB;AASJ;AACpB;AACA;AACA;AACA;AACO,gFAAgF;AACvF;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACO,wEAAwE;AAC/E,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+DAA+D,6CAA6C,oBAAoB,oDAAoD;AACpL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACqB;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACqB;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACO;AACP,yBAAyB;AACzB;;;;;;;;;;;AC5mDA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,EAAE;AACzB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,oBAAoB,iBAAiB;AACrC;AACA;AACA;AACA;AACA;AACA,+BAA+B;AAC/B;AACA,gCAAgC,oBAAoB;AACpD;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC;AACxC;AACA;AACA,uBAAuB;AACvB;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,QAAQ,IAA8B;AACtC,QAAQ,eAAkB;AAC1B,QAAQ,gBAAmB;AAC3B;AACA;AACA;AACA;;AAEA,YAAY,IAA6C;AACzD,YAAY,mCAAO;AACnB;AACA;AACA;AACA;AACA,aAAa;AAAA,kGAAC;AACd;AACA;AACA;AACA,CAAC,IAAI;;;;;;;;;;;ACtOL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,mCAAmC;AACnC,8BAA8B;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA,KAAK,4CAA4C;AACjD;AACA;AACA;AACA;AACA,sCAAsC;AACtC;AACA,aAAa;AACb,kEAAkE;AAClE,iBAAiB;AACjB;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,QAAQ;AACR;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,yDAAyD;AACzD;AACA;AACA,8GAA8G;AAC9G,oHAAoH;AACpH,0EAA0E;AAC1E;AACA,iBAAiB;AACjB;AACA;;AAEA,kDAAkD;AAClD;AACA;AACA,iBAAiB,yCAAyC;AAC1D,kFAAkF;AAClF,sEAAsE;AACtE;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,SAAS,MAAM;AACf;AACA;AACA;AACA;;AAEA;AACA;AACA,WAAW,QAAQ;AACnB;AACA;AACA;AACA,6CAA6C;AAC7C,4CAA4C;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,0B;;;;;;UC9GA;UACA;;UAEA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;;UAEA;UACA;;UAEA;UACA;UACA;;;;;WCtBA;WACA;WACA;WACA;WACA,yCAAyC,wCAAwC;WACjF;WACA;WACA,E;;;;;WCPA,wF;;;;;WCAA;WACA;WACA;WACA,uDAAuD,iBAAiB;WACxE;WACA,gDAAgD,aAAa;WAC7D,E;;;;;UENA;UACA;UACA;UACA","sources":["webpack://abap-adt-api/webpack/universalModuleDefinition","webpack://abap-adt-api/./build/AdtClient.js","webpack://abap-adt-api/./build/AdtException.js","webpack://abap-adt-api/./build/AdtHTTP.js","webpack://abap-adt-api/./build/api/abapgit.js","webpack://abap-adt-api/./build/api/activate.js","webpack://abap-adt-api/./build/api/atc.js","webpack://abap-adt-api/./build/api/cds.js","webpack://abap-adt-api/./build/api/debugger.js","webpack://abap-adt-api/./build/api/delete.js","webpack://abap-adt-api/./build/api/discovery.js","webpack://abap-adt-api/./build/api/feeds.js","webpack://abap-adt-api/./build/api/index.js","webpack://abap-adt-api/./build/api/nodeContents.js","webpack://abap-adt-api/./build/api/objectcontents.js","webpack://abap-adt-api/./build/api/objectcreator.js","webpack://abap-adt-api/./build/api/objectstructure.js","webpack://abap-adt-api/./build/api/refactor.js","webpack://abap-adt-api/./build/api/revisions.js","webpack://abap-adt-api/./build/api/search.js","webpack://abap-adt-api/./build/api/syntax.js","webpack://abap-adt-api/./build/api/tablecontents.js","webpack://abap-adt-api/./build/api/traces.js","webpack://abap-adt-api/./build/api/tracetypes.js","webpack://abap-adt-api/./build/api/transports.js","webpack://abap-adt-api/./build/api/unittest.js","webpack://abap-adt-api/./build/api/urlparser.js","webpack://abap-adt-api/./build/browser/node_https.js","webpack://abap-adt-api/./build/build/axios.js","webpack://abap-adt-api/./build/index.js","webpack://abap-adt-api/./build/requestLogger.js","webpack://abap-adt-api/./build/utilities.js","webpack://abap-adt-api/./node_modules/fast-xml-parser/src/fxp.js","webpack://abap-adt-api/./node_modules/fast-xml-parser/src/ignoreAttributes.js","webpack://abap-adt-api/./node_modules/fast-xml-parser/src/util.js","webpack://abap-adt-api/./node_modules/fast-xml-parser/src/validator.js","webpack://abap-adt-api/./node_modules/fast-xml-parser/src/xmlbuilder/json2xml.js","webpack://abap-adt-api/./node_modules/fast-xml-parser/src/xmlbuilder/orderedJs2Xml.js","webpack://abap-adt-api/./node_modules/fast-xml-parser/src/xmlparser/DocTypeReader.js","webpack://abap-adt-api/./node_modules/fast-xml-parser/src/xmlparser/OptionsBuilder.js","webpack://abap-adt-api/./node_modules/fast-xml-parser/src/xmlparser/OrderedObjParser.js","webpack://abap-adt-api/./node_modules/fast-xml-parser/src/xmlparser/XMLParser.js","webpack://abap-adt-api/./node_modules/fast-xml-parser/src/xmlparser/node2json.js","webpack://abap-adt-api/./node_modules/fast-xml-parser/src/xmlparser/xmlNode.js","webpack://abap-adt-api/./node_modules/fp-ts/es6/Applicative.js","webpack://abap-adt-api/./node_modules/fp-ts/es6/Apply.js","webpack://abap-adt-api/./node_modules/fp-ts/es6/Array.js","webpack://abap-adt-api/./node_modules/fp-ts/es6/Chain.js","webpack://abap-adt-api/./node_modules/fp-ts/es6/ChainRec.js","webpack://abap-adt-api/./node_modules/fp-ts/es6/Either.js","webpack://abap-adt-api/./node_modules/fp-ts/es6/Eq.js","webpack://abap-adt-api/./node_modules/fp-ts/es6/FromEither.js","webpack://abap-adt-api/./node_modules/fp-ts/es6/Functor.js","webpack://abap-adt-api/./node_modules/fp-ts/es6/Magma.js","webpack://abap-adt-api/./node_modules/fp-ts/es6/NonEmptyArray.js","webpack://abap-adt-api/./node_modules/fp-ts/es6/Option.js","webpack://abap-adt-api/./node_modules/fp-ts/es6/Ord.js","webpack://abap-adt-api/./node_modules/fp-ts/es6/Predicate.js","webpack://abap-adt-api/./node_modules/fp-ts/es6/ReadonlyArray.js","webpack://abap-adt-api/./node_modules/fp-ts/es6/ReadonlyNonEmptyArray.js","webpack://abap-adt-api/./node_modules/fp-ts/es6/ReadonlyRecord.js","webpack://abap-adt-api/./node_modules/fp-ts/es6/Record.js","webpack://abap-adt-api/./node_modules/fp-ts/es6/Semigroup.js","webpack://abap-adt-api/./node_modules/fp-ts/es6/Separated.js","webpack://abap-adt-api/./node_modules/fp-ts/es6/Witherable.js","webpack://abap-adt-api/./node_modules/fp-ts/es6/Zero.js","webpack://abap-adt-api/./node_modules/fp-ts/es6/function.js","webpack://abap-adt-api/./node_modules/fp-ts/es6/internal.js","webpack://abap-adt-api/./node_modules/fp-ts/es6/number.js","webpack://abap-adt-api/./node_modules/fp-ts/es6/pipeable.js","webpack://abap-adt-api/./node_modules/fp-ts/es6/string.js","webpack://abap-adt-api/./node_modules/fp-ts/lib/Chain.js","webpack://abap-adt-api/./node_modules/fp-ts/lib/Eq.js","webpack://abap-adt-api/./node_modules/fp-ts/lib/FromEither.js","webpack://abap-adt-api/./node_modules/fp-ts/lib/Functor.js","webpack://abap-adt-api/./node_modules/fp-ts/lib/These.js","webpack://abap-adt-api/./node_modules/fp-ts/lib/function.js","webpack://abap-adt-api/./node_modules/fp-ts/lib/internal.js","webpack://abap-adt-api/./node_modules/html-entities/dist/commonjs/index.js","webpack://abap-adt-api/./node_modules/html-entities/dist/commonjs/named-references.js","webpack://abap-adt-api/./node_modules/html-entities/dist/commonjs/numeric-unicode-map.js","webpack://abap-adt-api/./node_modules/html-entities/dist/commonjs/surrogate-pairs.js","webpack://abap-adt-api/./node_modules/io-ts-reporters/target/src/index.js","webpack://abap-adt-api/./node_modules/io-ts-reporters/target/src/utils.js","webpack://abap-adt-api/./node_modules/io-ts/es6/index.js","webpack://abap-adt-api/./node_modules/sprintf-js/src/sprintf.js","webpack://abap-adt-api/./node_modules/strnum/strnum.js","webpack://abap-adt-api/webpack/bootstrap","webpack://abap-adt-api/webpack/runtime/define property getters","webpack://abap-adt-api/webpack/runtime/hasOwnProperty shorthand","webpack://abap-adt-api/webpack/runtime/make namespace object","webpack://abap-adt-api/webpack/before-startup","webpack://abap-adt-api/webpack/startup","webpack://abap-adt-api/webpack/after-startup"],"sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"abap_adt_api\"] = factory();\n\telse\n\t\troot[\"abap_adt_api\"] = factory();\n})(this, () => {\nreturn ","\"use strict\";\r\nvar __importDefault = (this && this.__importDefault) || function (mod) {\r\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\r\n};\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.ADTClient = exports.createSSLConfig = void 0;\r\nconst AdtException_1 = require(\"./AdtException\");\r\nconst AdtHTTP_1 = require(\"./AdtHTTP\");\r\nconst api_1 = require(\"./api\");\r\nconst utilities_1 = require(\"./utilities\");\r\nconst https_1 = __importDefault(require(\"https\"));\r\nfunction createSSLConfig(allowUnauthorized, ca) {\r\n    const httpsAgent = new https_1.default.Agent({\r\n        keepAlive: true,\r\n        ca,\r\n        rejectUnauthorized: !allowUnauthorized // disable CA checks?\r\n    });\r\n    return { httpsAgent };\r\n}\r\nexports.createSSLConfig = createSSLConfig;\r\nclass ADTClient {\r\n    get httpClient() {\r\n        return this.h;\r\n    }\r\n    static mainInclude(object, withDefault = true) {\r\n        // packages don't really have any include\r\n        if ((0, api_1.isPackageType)(object.metaData[\"adtcore:type\"]))\r\n            return object.objectUrl;\r\n        if ((0, api_1.isClassStructure)(object)) {\r\n            const mainInclude = object.includes.find(x => x[\"class:includeType\"] === \"main\");\r\n            const mainLink = mainInclude &&\r\n                (mainInclude.links.find(x => x.type === \"text/plain\") ||\r\n                    mainInclude.links.find(x => !x.type)); // CDS have no type for the plain text link...\r\n            if (mainLink)\r\n                return (0, utilities_1.followUrl)(object.objectUrl, mainLink.href);\r\n        }\r\n        else {\r\n            const source = object.metaData[\"abapsource:sourceUri\"];\r\n            if (source)\r\n                return (0, utilities_1.followUrl)(object.objectUrl, source);\r\n            const mainLink = object.links.find(x => x.type === \"text/plain\");\r\n            if (mainLink)\r\n                return (0, utilities_1.followUrl)(object.objectUrl, mainLink.href);\r\n        }\r\n        return withDefault\r\n            ? (0, utilities_1.followUrl)(object.objectUrl, \"/source/main\")\r\n            : object.objectUrl;\r\n    }\r\n    static classIncludes(clas) {\r\n        const includes = new Map();\r\n        for (const i of clas.includes) {\r\n            const mainLink = i.links.find(x => x.type === \"text/plain\");\r\n            includes.set(i[\"class:includeType\"], (0, utilities_1.followUrl)(clas.objectUrl, mainLink.href));\r\n        }\r\n        return includes;\r\n    }\r\n    get id() {\r\n        return this.h.id;\r\n    }\r\n    /**\r\n     * Create an ADT client\r\n     *\r\n     * @argument baseUrlOrClient  Base url, i.e. http://vhcalnplci.local:8000\r\n     * @argument username SAP logon user\r\n     * @argument password Password\r\n     * @argument client   Login client (optional)\r\n     * @argument language Language key (optional)\r\n     */\r\n    constructor(baseUrlOrClient, username, password, client = \"\", language = \"\", options = {}) {\r\n        this.wrapFetcher = fetcher => {\r\n            let fetchBearer;\r\n            if (this.fetcher)\r\n                return this.fetcher;\r\n            this.fetcher = () => {\r\n                fetchBearer = fetchBearer || fetcher();\r\n                return fetchBearer;\r\n            };\r\n            return this.fetcher;\r\n        };\r\n        this.hasTransportConfig = async () => {\r\n            const collection = await this.findCollectionByUrl(\"/sap/bc/adt/cts/transportrequests/searchconfiguration/configurations\");\r\n            return !!collection;\r\n        };\r\n        this.isProposalMessage = api_1.isProposalMessage;\r\n        if (((0, utilities_1.isString)(baseUrlOrClient) && username && !password))\r\n            throw (0, AdtException_1.adtException)(\"Invalid ADTClient configuration: url, login and password are required\");\r\n        if (username == null)\r\n            username = \"\";\r\n        if (password == null)\r\n            password = \"\";\r\n        if (typeof password !== \"string\")\r\n            password = this.wrapFetcher(password);\r\n        this.options = {\r\n            baseUrlOrClient: baseUrlOrClient,\r\n            username,\r\n            password,\r\n            client,\r\n            language,\r\n            options\r\n        };\r\n        this.h = this.createHttp();\r\n    }\r\n    createHttp() {\r\n        const o = this.options;\r\n        return new AdtHTTP_1.AdtHTTP(o.baseUrlOrClient, o.username, o.password, o.client, o.language, o.options);\r\n    }\r\n    get pIsClone() {\r\n        return this.h.isClone;\r\n    }\r\n    set pIsClone(isClone) {\r\n        this.h.isClone = isClone;\r\n    }\r\n    get statelessClone() {\r\n        if (this.pIsClone)\r\n            return this;\r\n        if (!this.pClone) {\r\n            const pw = this.fetcher || this.password;\r\n            if (!pw)\r\n                throw (0, AdtException_1.adtException)(\"Not logged in\");\r\n            this.pClone = new ADTClient(this.baseUrl, this.username, pw, this.client, this.language, this.options.options);\r\n            this.pClone.pIsClone = true;\r\n        }\r\n        return this.pClone;\r\n    }\r\n    get stateful() {\r\n        return this.h.stateful;\r\n    }\r\n    set stateful(stateful) {\r\n        if (this.pIsClone)\r\n            throw (0, AdtException_1.adtException)(\"Stateful sessions not allowed in stateless clones\");\r\n        this.h.stateful = stateful;\r\n    }\r\n    get loggedin() {\r\n        return this.h.loggedin;\r\n    }\r\n    get isStateful() {\r\n        return this.h.isStateful;\r\n    }\r\n    get csrfToken() {\r\n        return this.h.csrfToken;\r\n    }\r\n    get baseUrl() {\r\n        return this.h.baseURL;\r\n    }\r\n    get client() {\r\n        return this.h.client;\r\n    }\r\n    get language() {\r\n        return this.h.language;\r\n    }\r\n    get username() {\r\n        return this.h.username;\r\n    }\r\n    get password() {\r\n        return this.h.password;\r\n    }\r\n    /**\r\n     * Logs on an ADT server. parameters provided on creation\r\n     */\r\n    login() {\r\n        // if loggedoff create a new client\r\n        if (!this.h.username)\r\n            this.h = this.createHttp();\r\n        return this.h.login();\r\n    }\r\n    /**\r\n     * Logs out current user, clearing cookies\r\n     * NOTE: you won't be able to login again with this client\r\n     *\r\n     * @memberof ADTClient\r\n     */\r\n    logout() {\r\n        return this.h.logout();\r\n    }\r\n    dropSession() {\r\n        return this.h.dropSession();\r\n    }\r\n    get sessionID() {\r\n        const cookies = this.h.ascookies() || \"\";\r\n        const sc = cookies.split(\";\").find(c => !!c.match(/SAP_SESSIONID/));\r\n        return sc ? sc.split(\"=\") : \"\";\r\n    }\r\n    nodeContents(\r\n    // tslint:disable: variable-name\r\n    parent_type, parent_name, user_name, parent_tech_name, rebuild_tree, parentnodes) {\r\n        return (0, api_1.nodeContents)(this.h, parent_type, parent_name, user_name, parent_tech_name, rebuild_tree, parentnodes);\r\n    }\r\n    async reentranceTicket() {\r\n        const response = await this.h.request(\"/sap/bc/adt/security/reentranceticket\");\r\n        return \"\" + response.body || \"\";\r\n    }\r\n    transportInfo(objSourceUrl, devClass, operation = \"I\") {\r\n        return (0, api_1.transportInfo)(this.h, objSourceUrl, devClass, operation);\r\n    }\r\n    createTransport(objSourceUrl, REQUEST_TEXT, DEVCLASS, transportLayer) {\r\n        return (0, api_1.createTransport)(this.h, objSourceUrl, REQUEST_TEXT, DEVCLASS, \"I\", transportLayer);\r\n    }\r\n    objectStructure(objectUrl, version) {\r\n        return (0, api_1.objectStructure)(this.h, objectUrl, version);\r\n    }\r\n    activate(objectNameOrObjects, objectUrlOrPreauditReq = true, mainInclude, preauditRequested = true) {\r\n        if ((0, utilities_1.isString)(objectNameOrObjects))\r\n            return (0, api_1.activate)(this.h, objectNameOrObjects, objectUrlOrPreauditReq, // validated downstream\r\n            mainInclude, preauditRequested);\r\n        else\r\n            return (0, api_1.activate)(this.h, objectNameOrObjects, objectUrlOrPreauditReq // validated downstream\r\n            );\r\n    }\r\n    inactiveObjects() {\r\n        return (0, api_1.inactiveObjects)(this.h);\r\n    }\r\n    mainPrograms(includeUrl) {\r\n        return (0, api_1.mainPrograms)(this.h, includeUrl);\r\n    }\r\n    lock(objectUrl, accessMode = \"MODIFY\") {\r\n        return (0, api_1.lock)(this.h, objectUrl, accessMode);\r\n    }\r\n    unLock(objectUrl, lockHandle) {\r\n        return (0, api_1.unLock)(this.h, objectUrl, lockHandle);\r\n    }\r\n    /**\r\n     * Retrieves a resource content (i.e. a program's source code)\r\n     *\r\n     * @param objectSourceUrl Resource URL\r\n     * @param gitUser Username, only used for abapGit objects\r\n     * @param gitPassword password, only used for abapGit objects\r\n     */\r\n    getObjectSource(objectSourceUrl, options) {\r\n        return (0, api_1.getObjectSource)(this.h, objectSourceUrl, options);\r\n    }\r\n    setObjectSource(objectSourceUrl, source, lockHandle, transport) {\r\n        return (0, api_1.setObjectSource)(this.h, objectSourceUrl, source, lockHandle, transport);\r\n    }\r\n    /**\r\n     * Search object by name pattern\r\n     *\r\n     * @param {string} query     case sensitive in older systems, no wildcard added\r\n     * @param {string} [objType] if passed, only the first part is used i.e. PROG rather than PROG/P\r\n     * @param {number} [max=100] max number of results\r\n     * @returns\r\n     * @memberof ADTClient\r\n     */\r\n    searchObject(query, objType, max = 100) {\r\n        return (0, api_1.searchObject)(this.h, query, objType, max);\r\n    }\r\n    findObjectPath(objectUrl) {\r\n        return (0, api_1.findObjectPath)(this.h, objectUrl);\r\n    }\r\n    validateNewObject(options) {\r\n        return (0, api_1.validateNewObject)(this.h, options);\r\n    }\r\n    createObject(optionsOrType, name, parentName, description, parentPath, responsible = \"\", transport = \"\") {\r\n        if ((0, api_1.isCreatableTypeId)(optionsOrType)) {\r\n            if (!name || !parentName || !parentPath || !description)\r\n                throw (0, AdtException_1.adtException)(\"\");\r\n            return (0, api_1.createObject)(this.h, {\r\n                description,\r\n                name,\r\n                objtype: optionsOrType,\r\n                parentName,\r\n                parentPath,\r\n                responsible,\r\n                transport\r\n            });\r\n        }\r\n        else\r\n            return (0, api_1.createObject)(this.h, optionsOrType);\r\n    }\r\n    async featureDetails(title) {\r\n        if (!this.discovery)\r\n            this.discovery = await this.adtDiscovery();\r\n        return this.discovery.find(d => d.title === title);\r\n    }\r\n    async collectionFeatureDetails(url) {\r\n        if (!this.discovery)\r\n            this.discovery = await this.adtDiscovery();\r\n        return this.discovery.find(f => f.collection.find(c => c.templateLinks.find(l => l.template === url)));\r\n    }\r\n    async findCollectionByUrl(url) {\r\n        if (!this.discovery)\r\n            this.discovery = await this.adtDiscovery();\r\n        for (const discoveryResult of this.discovery) {\r\n            const collection = discoveryResult.collection.find(c => c.href === url);\r\n            if (collection)\r\n                return { discoveryResult, collection };\r\n        }\r\n    }\r\n    createTestInclude(clas, lockHandle, transport = \"\") {\r\n        return (0, api_1.createTestInclude)(this.h, clas, lockHandle, transport);\r\n    }\r\n    objectRegistrationInfo(objectUrl) {\r\n        return (0, api_1.objectRegistrationInfo)(this.h, objectUrl);\r\n    }\r\n    deleteObject(objectUrl, lockHandle, transport) {\r\n        return (0, api_1.deleteObject)(this.h, objectUrl, lockHandle, transport);\r\n    }\r\n    loadTypes() {\r\n        return (0, api_1.loadTypes)(this.h);\r\n    }\r\n    adtDiscovery() {\r\n        return (0, api_1.adtDiscovery)(this.h);\r\n    }\r\n    adtCoreDiscovery() {\r\n        return (0, api_1.adtCoreDiscovery)(this.h);\r\n    }\r\n    adtCompatibiliyGraph() {\r\n        return (0, api_1.adtCompatibilityGraph)(this.h);\r\n    }\r\n    syntaxCheckTypes() {\r\n        return (0, api_1.syntaxCheckTypes)(this.h);\r\n    }\r\n    syntaxCheck(url, mainUrl, content, mainProgram = \"\", version = \"active\") {\r\n        if (url.match(/^\\/sap\\/bc\\/adt\\/((ddic\\/ddlx?)|(acm\\/dcl))\\/sources\\//))\r\n            return (0, api_1.syntaxCheckCDS)(this.h, url, mainUrl, content);\r\n        else {\r\n            if (!mainUrl || !content)\r\n                throw (0, AdtException_1.adtException)(\"mainUrl and content are required for syntax check\");\r\n            return (0, api_1.syntaxCheck)(this.h, url, mainUrl, content, mainProgram, version);\r\n        }\r\n    }\r\n    codeCompletion(sourceUrl, source, line, column) {\r\n        return (0, api_1.codeCompletion)(this.h, sourceUrl, source, line, column);\r\n    }\r\n    codeCompletionFull(sourceUrl, source, line, column, patternKey) {\r\n        return (0, api_1.codeCompletionFull)(this.h, sourceUrl, source, line, column, patternKey);\r\n    }\r\n    async runClass(className) {\r\n        const response = await this.h.request(\"/sap/bc/adt/oo/classrun/\" + className.toUpperCase(), {\r\n            method: \"POST\"\r\n        });\r\n        return \"\" + response.body;\r\n    }\r\n    /**\r\n     * Read code completion elements\r\n     * Will fail on older systems where this returns HTML fragments rather than XML\r\n     *\r\n     * @param {string} sourceUrl\r\n     * @param {string} source\r\n     * @param {number} line\r\n     * @param {number} column\r\n     * @returns\r\n     * @memberof ADTClient\r\n     */\r\n    codeCompletionElement(sourceUrl, source, line, column) {\r\n        return (0, api_1.codeCompletionElement)(this.h, sourceUrl, source, line, column);\r\n    }\r\n    findDefinition(url, source, line, startCol, endCol, implementation = false, mainProgram = \"\") {\r\n        return (0, api_1.findDefinition)(this.h, url, source, line, startCol, endCol, implementation, mainProgram);\r\n    }\r\n    usageReferences(url, line, column) {\r\n        return (0, api_1.usageReferences)(this.h, url, line, column);\r\n    }\r\n    usageReferenceSnippets(references) {\r\n        return (0, api_1.usageReferenceSnippets)(this.h, references);\r\n    }\r\n    fixProposals(url, source, line, column) {\r\n        return (0, api_1.fixProposals)(this.h, url, source, line, column);\r\n    }\r\n    fixEdits(proposal, source) {\r\n        return (0, api_1.fixEdits)(this.h, proposal, source);\r\n    }\r\n    unitTestRun(url, flags = api_1.DefaultUnitTestRunFlags) {\r\n        return (0, api_1.runUnitTest)(this.h, url, flags);\r\n    }\r\n    unitTestEvaluation(clas, flags = api_1.DefaultUnitTestRunFlags) {\r\n        return (0, api_1.unitTestEvaluation)(this.h, clas, flags);\r\n    }\r\n    unitTestOccurrenceMarkers(url, source) {\r\n        return (0, api_1.unitTestOccurrenceMarkers)(this.h, url, source);\r\n    }\r\n    classComponents(url) {\r\n        return (0, api_1.classComponents)(this.h, url);\r\n    }\r\n    fragmentMappings(url, type, name) {\r\n        return (0, api_1.fragmentMappings)(this.h, url, type, name);\r\n    }\r\n    objectTypes() {\r\n        return (0, api_1.objectTypes)(this.h);\r\n    }\r\n    prettyPrinterSetting() {\r\n        return (0, api_1.prettyPrinterSetting)(this.h);\r\n    }\r\n    setPrettyPrinterSetting(indent, style) {\r\n        return (0, api_1.setPrettyPrinterSetting)(this.h, indent, style);\r\n    }\r\n    prettyPrinter(source) {\r\n        return (0, api_1.prettyPrinter)(this.h, source);\r\n    }\r\n    typeHierarchy(url, body, line, offset, superTypes = false) {\r\n        return (0, api_1.typeHierarchy)(this.h, url, body, line, offset, superTypes);\r\n    }\r\n    transportConfigurations() {\r\n        return (0, api_1.transportConfigurations)(this.h);\r\n    }\r\n    getTransportConfiguration(url) {\r\n        return (0, api_1.getTransportConfiguration)(this.h, url);\r\n    }\r\n    setTransportsConfig(uri, etag, config) {\r\n        return (0, api_1.setTransportsConfig)(this.h, uri, etag, config);\r\n    }\r\n    createTransportsConfig() {\r\n        return (0, api_1.createTransportsConfig)(this.h);\r\n    }\r\n    userTransports(user, targets = true) {\r\n        return (0, api_1.userTransports)(this.h, user, targets);\r\n    }\r\n    transportsByConfig(configUri, targets = true) {\r\n        return (0, api_1.transportsByConfig)(this.h, configUri, targets);\r\n    }\r\n    transportDelete(transportNumber) {\r\n        return (0, api_1.transportDelete)(this.h, transportNumber);\r\n    }\r\n    transportRelease(transportNumber, ignoreLocks = false, IgnoreATC = false) {\r\n        return (0, api_1.transportRelease)(this.h, transportNumber, ignoreLocks, IgnoreATC);\r\n    }\r\n    transportSetOwner(transportNumber, targetuser) {\r\n        return (0, api_1.transportSetOwner)(this.h, transportNumber, targetuser);\r\n    }\r\n    transportAddUser(transportNumber, user) {\r\n        return (0, api_1.transportAddUser)(this.h, transportNumber, user);\r\n    }\r\n    systemUsers() {\r\n        return (0, api_1.systemUsers)(this.h);\r\n    }\r\n    transportReference(pgmid, obj_wbtype, obj_name, tr_number = \"\") {\r\n        return (0, api_1.transportReference)(this.h, pgmid, obj_wbtype, obj_name, tr_number);\r\n    }\r\n    revisions(objectUrl, clsInclude) {\r\n        return (0, api_1.revisions)(this.h, objectUrl, clsInclude);\r\n    }\r\n    abapDocumentation(objectUri, body, line, column, language = \"EN\") {\r\n        return (0, api_1.abapDocumentation)(this.h, objectUri, body, line, column, language);\r\n    }\r\n    packageSearchHelp(type, name = \"*\") {\r\n        return (0, api_1.packageSearchHelp)(this.h, type, name);\r\n    }\r\n    gitRepos() {\r\n        return (0, api_1.gitRepos)(this.h);\r\n    }\r\n    gitExternalRepoInfo(repourl, user = \"\", password = \"\") {\r\n        return (0, api_1.externalRepoInfo)(this.h, repourl, user, password);\r\n    }\r\n    gitCreateRepo(packageName, repourl, branch = \"refs/heads/master\", transport = \"\", user = \"\", password = \"\") {\r\n        return (0, api_1.createRepo)(this.h, packageName, repourl, branch, transport, user, password);\r\n    }\r\n    gitPullRepo(repoId, branch = \"refs/heads/master\", transport = \"\", user = \"\", password = \"\") {\r\n        return (0, api_1.pullRepo)(this.h, repoId, branch, transport, user, password);\r\n    }\r\n    gitUnlinkRepo(repoId) {\r\n        return (0, api_1.unlinkRepo)(this.h, repoId);\r\n    }\r\n    stageRepo(repo, user = \"\", password = \"\") {\r\n        return (0, api_1.stageRepo)(this.h, repo, user, password);\r\n    }\r\n    pushRepo(repo, staging, user = \"\", password = \"\") {\r\n        return (0, api_1.pushRepo)(this.h, repo, staging, user, password);\r\n    }\r\n    checkRepo(repo, user = \"\", password = \"\") {\r\n        return (0, api_1.checkRepo)(this.h, repo, user, password);\r\n    }\r\n    /**\r\n     * @deprecated since 1.2.1, duplicate of gitExternalRepoInfo\r\n     */\r\n    remoteRepoInfo(repo, user = \"\", password = \"\") {\r\n        return (0, api_1.remoteRepoInfo)(this.h, repo, user, password);\r\n    }\r\n    switchRepoBranch(repo, branch, create = false, user = \"\", password = \"\") {\r\n        return (0, api_1.switchRepoBranch)(this.h, repo, branch, create, user, password);\r\n    }\r\n    annotationDefinitions() {\r\n        return (0, api_1.annotationDefinitions)(this.h);\r\n    }\r\n    ddicElement(path, getTargetForAssociation = false, getExtensionViews = true, getSecondaryObjects = true) {\r\n        return (0, api_1.ddicElement)(this.h, path, getTargetForAssociation, getExtensionViews, getSecondaryObjects);\r\n    }\r\n    ddicRepositoryAccess(path) {\r\n        return (0, api_1.ddicRepositoryAccess)(this.h, path);\r\n    }\r\n    publishServiceBinding(name, version) {\r\n        return (0, api_1.publishServiceBinding)(this.h, name, version);\r\n    }\r\n    unPublishServiceBinding(name, version) {\r\n        return (0, api_1.unpublishServiceBinding)(this.h, name, version);\r\n    }\r\n    /** Reads table data - usually returns one line more than requested */\r\n    tableContents(ddicEntityName, rowNumber = 100, decode = true, sqlQuery = \"\") {\r\n        return (0, api_1.tableContents)(this.h, ddicEntityName, rowNumber, decode, sqlQuery);\r\n    }\r\n    /** Runs a given SQL query on the target */\r\n    runQuery(sqlQuery, rowNumber = 100, decode = true) {\r\n        return (0, api_1.runQuery)(this.h, sqlQuery, rowNumber, decode);\r\n    }\r\n    bindingDetails(binding, index = 0) {\r\n        return (0, api_1.bindingDetails)(this.h, binding, index);\r\n    }\r\n    feeds() {\r\n        return (0, api_1.feeds)(this.h);\r\n    }\r\n    dumps(query) {\r\n        return (0, api_1.dumps)(this.h, query);\r\n    }\r\n    debuggerListeners(debuggingMode, terminalId, ideId, user, checkConflict = true) {\r\n        return (0, api_1.debuggerListeners)(this.h, debuggingMode, terminalId, ideId, user, checkConflict);\r\n    }\r\n    debuggerListen(debuggingMode, terminalId, ideId, user, checkConflict = true, isNotifiedOnConflict = true) {\r\n        return (0, api_1.debuggerListen)(this.h, debuggingMode, terminalId, ideId, user, checkConflict, isNotifiedOnConflict);\r\n    }\r\n    debuggerDeleteListener(debuggingMode, terminalId, ideId, user) {\r\n        return (0, api_1.debuggerDeleteListener)(this.h, debuggingMode, terminalId, ideId, user);\r\n    }\r\n    debuggerSetBreakpoints(debuggingMode, terminalId, ideId, clientId, breakpoints, user, scope = \"external\", systemDebugging = false, deactivated = false, syncScupeUrl = \"\") {\r\n        return (0, api_1.debuggerSetBreakpoints)(this.h, debuggingMode, terminalId, ideId, clientId, breakpoints, user, scope, systemDebugging, deactivated, syncScupeUrl);\r\n    }\r\n    debuggerDeleteBreakpoints(breakpoint, debuggingMode, terminalId, ideId, requestUser, scope = \"external\") {\r\n        return (0, api_1.debuggerDeleteBreakpoints)(this.h, breakpoint, debuggingMode, terminalId, ideId, requestUser, scope);\r\n    }\r\n    debuggerAttach(debuggingMode, debuggeeId, user, dynproDebugging = false) {\r\n        return (0, api_1.debuggerAttach)(this.h, debuggingMode, debuggeeId, user, dynproDebugging);\r\n    }\r\n    debuggerSaveSettings(settings) {\r\n        return (0, api_1.debuggerSaveSettings)(this.h, settings);\r\n    }\r\n    async debuggerStackTrace(semanticURIs = true) {\r\n        const stack = await this.collectionFeatureDetails(\"/sap/bc/adt/debugger/stack\");\r\n        if (stack)\r\n            return (0, api_1.debuggerStack)(this.h, semanticURIs);\r\n        else\r\n            return (0, api_1.simpleDebuggerStack)(this.h, semanticURIs);\r\n    }\r\n    debuggerVariables(parents) {\r\n        return (0, api_1.debuggerVariables)(this.h, parents);\r\n    }\r\n    debuggerChildVariables(parent = [\"@DATAAGING\", \"@ROOT\"]) {\r\n        return (0, api_1.debuggerChildVariables)(this.h, parent);\r\n    }\r\n    debuggerStep(steptype, url) {\r\n        return (0, api_1.debuggerStep)(this.h, steptype, url);\r\n    }\r\n    /**\r\n     * Go to stack entry\r\n     *\r\n     * @param urlOrPosition The stack entry stackUri in newer systems, the stack id in older ones that return a DebugStackSimple\r\n     */\r\n    debuggerGoToStack(urlOrPosition) {\r\n        if ((0, utilities_1.isString)(urlOrPosition))\r\n            return (0, api_1.debuggerGoToStack)(this.h, urlOrPosition);\r\n        else\r\n            return (0, api_1.debuggerGoToStackOld)(this.h, urlOrPosition);\r\n    }\r\n    debuggerSetVariableValue(variableName, value) {\r\n        return (0, api_1.debuggerSetVariableValue)(this.h, variableName, value);\r\n    }\r\n    renameEvaluate(uri, line, startColumn, endColumn) {\r\n        return (0, api_1.renameEvaluate)(this.h, uri, line, startColumn, endColumn);\r\n    }\r\n    renamePreview(renameRefactoring, transport = \"\") {\r\n        return (0, api_1.renamePreview)(this.h, renameRefactoring, transport);\r\n    }\r\n    renameExecute(refactoring) {\r\n        return (0, api_1.renameExecute)(this.h, refactoring);\r\n    }\r\n    atcCustomizing() {\r\n        return (0, api_1.atcCustomizing)(this.h);\r\n    }\r\n    atcCheckVariant(variant) {\r\n        return (0, api_1.atcCheckVariant)(this.h, variant);\r\n    }\r\n    createAtcRun(variant, mainUrl, maxResults = 100) {\r\n        return (0, api_1.createAtcRun)(this.h, variant, mainUrl, maxResults);\r\n    }\r\n    atcWorklists(runResultId, timestamp, usedObjectSet, includeExempted = false) {\r\n        return (0, api_1.atcWorklists)(this.h, runResultId, timestamp, usedObjectSet, includeExempted);\r\n    }\r\n    atcUsers() {\r\n        return (0, api_1.atcUsers)(this.h);\r\n    }\r\n    atcExemptProposal(markerId) {\r\n        return (0, api_1.atcExemptProposal)(this.h, markerId);\r\n    }\r\n    atcRequestExemption(proposal) {\r\n        return (0, api_1.atcRequestExemption)(this.h, proposal);\r\n    }\r\n    atcContactUri(findingUri) {\r\n        return (0, api_1.atcContactUri)(this.h, findingUri);\r\n    }\r\n    atcChangeContact(itemUri, userId) {\r\n        return (0, api_1.atcChangeContact)(this.h, itemUri, userId);\r\n    }\r\n    tracesList(user) {\r\n        return (0, api_1.tracesList)(this.h, user || this.username);\r\n    }\r\n    tracesListRequests(user) {\r\n        return (0, api_1.tracesListRequests)(this.h, user || this.username);\r\n    }\r\n    tracesHitList(id, withSystemEvents = false) {\r\n        return (0, api_1.tracesHitList)(this.h, id, withSystemEvents);\r\n    }\r\n    tracesDbAccess(id, withSystemEvents = false) {\r\n        return (0, api_1.tracesDbAccess)(this.h, id, withSystemEvents);\r\n    }\r\n    tracesStatements(id, options = {}) {\r\n        return (0, api_1.tracesStatements)(this.h, id, options);\r\n    }\r\n    tracesSetParameters(parameters) {\r\n        return (0, api_1.tracesSetParameters)(this.h, parameters);\r\n    }\r\n    tracesCreateConfiguration(config) {\r\n        return (0, api_1.tracesCreateConfiguration)(this.h, config);\r\n    }\r\n    tracesDeleteConfiguration(id) {\r\n        return (0, api_1.tracesDeleteConfiguration)(this.h, id);\r\n    }\r\n    tracesDelete(id) {\r\n        return (0, api_1.tracesDelete)(this.h, id);\r\n    }\r\n    extractMethodEvaluate(uri, range) {\r\n        return (0, api_1.extractMethodEvaluate)(this.h, uri, range);\r\n    }\r\n    extractMethodPreview(proposal) {\r\n        return (0, api_1.extractMethodPreview)(this.h, proposal);\r\n    }\r\n    extractMethodExecute(refactoring) {\r\n        return (0, api_1.extractMethodExecute)(this.h, refactoring);\r\n    }\r\n}\r\nexports.ADTClient = ADTClient;\r\n","\"use strict\";\r\nvar __importDefault = (this && this.__importDefault) || function (mod) {\r\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\r\n};\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.isErrorMessageType = exports.validateParseResult = exports.ValidateStateful = exports.ValidateObjectUrl = exports.adtException = exports.fromException = exports.fromError = exports.fromResponse = exports.isLoginError = exports.isAdtException = exports.isHttpError = exports.isCsrfError = exports.isAdtError = exports.AdtErrorException = exports.SAPRC = void 0;\r\nconst utilities_1 = require(\"./utilities\");\r\nconst axios_1 = __importDefault(require(\"axios\"));\r\nconst These_1 = require(\"fp-ts/lib/These\");\r\nconst io_ts_reporters_1 = __importDefault(require(\"io-ts-reporters\"));\r\nconst ADTEXTYPEID = Symbol.for(\"ADT EXCEPTION\");\r\nconst CSRFEXTYPEID = Symbol.for(\"BAD CSRF\");\r\nconst HTTPEXTYPEID = Symbol.for(\"HTTP EXCEPTION\");\r\nvar SAPRC;\r\n(function (SAPRC) {\r\n    SAPRC[\"Success\"] = \"S\";\r\n    SAPRC[\"Info\"] = \"I\";\r\n    SAPRC[\"Warning\"] = \"W\";\r\n    SAPRC[\"Error\"] = \"E\";\r\n    SAPRC[\"CriticalError\"] = \"A\";\r\n    SAPRC[\"Exception\"] = \"X\";\r\n})(SAPRC = exports.SAPRC || (exports.SAPRC = {}));\r\nconst isResponse = (r) => (0, utilities_1.isObject)(r) && !!(r === null || r === void 0 ? void 0 : r.status) && (0, utilities_1.isString)(r === null || r === void 0 ? void 0 : r.statusText);\r\nclass AdtErrorException extends Error {\r\n    get typeID() {\r\n        return ADTEXTYPEID;\r\n    }\r\n    static create(errOrResponse, properties, type, message, parent, namespace, localizedMessage, response) {\r\n        if (!(0, utilities_1.isNumber)(errOrResponse)) {\r\n            return this.create(errOrResponse.status, properties, \"\", errOrResponse.statusText || \"Unknown error in adt client\", undefined, undefined, undefined, errOrResponse);\r\n        }\r\n        else {\r\n            return new AdtErrorException(errOrResponse, properties, type, message, parent, namespace, localizedMessage, response);\r\n        }\r\n    }\r\n    constructor(err, properties, type, message, parent, namespace, localizedMessage, response) {\r\n        super();\r\n        this.err = err;\r\n        this.properties = properties;\r\n        this.type = type;\r\n        this.message = message;\r\n        this.parent = parent;\r\n        this.namespace = namespace;\r\n        this.localizedMessage = localizedMessage;\r\n        this.response = response;\r\n    }\r\n}\r\nexports.AdtErrorException = AdtErrorException;\r\n// tslint:disable-next-line:max-classes-per-file\r\nclass AdtCsrfException extends Error {\r\n    get typeID() {\r\n        return CSRFEXTYPEID;\r\n    }\r\n    constructor(message, parent) {\r\n        super();\r\n        this.message = message;\r\n        this.parent = parent;\r\n    }\r\n}\r\n// tslint:disable-next-line:max-classes-per-file\r\nclass AdtHttpException extends Error {\r\n    get typeID() {\r\n        return HTTPEXTYPEID;\r\n    }\r\n    get code() {\r\n        const p = this.parent;\r\n        return (p.response && p.response.status) || 0;\r\n    }\r\n    get message() {\r\n        return this.parent.message;\r\n    }\r\n    get name() {\r\n        return this.parent.name;\r\n    }\r\n    constructor(parent) {\r\n        super();\r\n        this.parent = parent;\r\n    }\r\n}\r\nfunction isAdtError(e) {\r\n    return (e === null || e === void 0 ? void 0 : e.typeID) === ADTEXTYPEID;\r\n}\r\nexports.isAdtError = isAdtError;\r\nfunction isCsrfError(e) {\r\n    return (e === null || e === void 0 ? void 0 : e.typeID) === CSRFEXTYPEID;\r\n}\r\nexports.isCsrfError = isCsrfError;\r\nfunction isHttpError(e) {\r\n    return (e === null || e === void 0 ? void 0 : e.typeID) === HTTPEXTYPEID;\r\n}\r\nexports.isHttpError = isHttpError;\r\nfunction isAdtException(e) {\r\n    return isAdtError(e) || isCsrfError(e) || isHttpError(e);\r\n}\r\nexports.isAdtException = isAdtException;\r\nconst isLoginError = (adtErr) => (isHttpError(adtErr) && adtErr.code === 401) || isCsrfError(adtErr);\r\nexports.isLoginError = isLoginError;\r\nconst simpleError = (response) => adtException(`Error ${response.status}:${response.statusText}`, response.status);\r\nconst isCsrfException = (r) => (r.status === 403 && r.headers[\"x-csrf-token\"] === \"Required\") ||\r\n    (r.status === 400 && r.statusText === \"Session timed out\"); // hack to get login refresh to work on expired sessions\r\nconst fromResponse = (data, response) => {\r\n    if (!data)\r\n        return simpleError(response);\r\n    if (data.match(/CSRF/))\r\n        return new AdtCsrfException(data);\r\n    const raw = (0, utilities_1.fullParse)(data);\r\n    const root = raw[\"exc:exception\"];\r\n    if (!root && response.status === 401)\r\n        return simpleError(response);\r\n    const getf = (base, idx) => (base ? base[idx] : \"\");\r\n    const properties = {};\r\n    (0, utilities_1.xmlArray)(root, \"properties\", \"entry\").forEach((p) => {\r\n        properties[p[\"@_key\"]] = `${p[\"#text\"]}`\r\n            .replace(/^\\s+/, \"\")\r\n            .replace(/\\s+$/, \"\");\r\n    });\r\n    return new AdtErrorException(response.status, properties, root.type[\"@_id\"], root.message[\"#text\"], undefined, getf(root.namespace, \"@_id\"), getf(root.localizedMessage, \"#text\"));\r\n};\r\nexports.fromResponse = fromResponse;\r\nconst axiosErrorBody = (e) => { var _a; return ((_a = e.response) === null || _a === void 0 ? void 0 : _a.data) ? `${e.response.data}` : \"\"; };\r\nconst fromError = (error) => {\r\n    try {\r\n        if (isAdtError(error))\r\n            return error;\r\n        if (axios_1.default.isAxiosError(error) && error.response) {\r\n            if (error.status === 401)\r\n                return new AdtHttpException(error);\r\n            return (0, exports.fromResponse)(axiosErrorBody(error), error.response);\r\n        }\r\n        if ((0, utilities_1.isObject)(error) && \"message\" in error && (0, utilities_1.isString)(error === null || error === void 0 ? void 0 : error.message))\r\n            return new AdtErrorException(500, {}, \"\", error.message);\r\n    }\r\n    catch (error) { }\r\n    return AdtErrorException.create(500, {}, \"Unknown error\", `${error}`); // hopefully will never happen\r\n};\r\nexports.fromError = fromError;\r\nfunction fromExceptionOrResponse_int(errOrResp, config) {\r\n    try {\r\n        if (isResponse(errOrResp))\r\n            return (0, exports.fromResponse)(errOrResp.body, errOrResp);\r\n        else\r\n            return (0, exports.fromError)(errOrResp);\r\n    }\r\n    catch (e) {\r\n        return isResponse(errOrResp)\r\n            ? AdtErrorException.create(errOrResp, {})\r\n            : (0, exports.fromError)(e);\r\n    }\r\n}\r\nfunction fromException(errOrResp, config) {\r\n    if (isAdtException(errOrResp))\r\n        return errOrResp;\r\n    if (!isResponse(errOrResp) &&\r\n        (!(0, utilities_1.isNativeError)(errOrResp) ||\r\n            ((0, utilities_1.isNativeError)(errOrResp) && !axios_1.default.isAxiosError(errOrResp))))\r\n        return AdtErrorException.create(500, {}, \"Unknown error\", `${errOrResp}`); // hopefully will never happen\r\n    return fromExceptionOrResponse_int(errOrResp, config);\r\n}\r\nexports.fromException = fromException;\r\nfunction adtException(message, number = 0) {\r\n    return new AdtErrorException(number, {}, \"\", message);\r\n}\r\nexports.adtException = adtException;\r\nfunction ValidateObjectUrl(url) {\r\n    if (url.match(/^\\/sap\\/bc\\/adt\\/[a-z]+\\/[a-zA-Z%\\$]?[\\w%]+/))\r\n        return; // valid\r\n    throw new AdtErrorException(0, {}, \"BADOBJECTURL\", \"Invalid Object URL:\" + url);\r\n}\r\nexports.ValidateObjectUrl = ValidateObjectUrl;\r\nfunction ValidateStateful(h) {\r\n    if (h.isStateful)\r\n        return;\r\n    throw new AdtErrorException(0, {}, \"STATELESS\", \"This operation can only be performed in stateful mode\");\r\n}\r\nexports.ValidateStateful = ValidateStateful;\r\nconst validateParseResult = (parseResult) => {\r\n    if ((0, These_1.isLeft)(parseResult)) {\r\n        const messages = io_ts_reporters_1.default.report(parseResult);\r\n        throw adtException(messages.slice(0, 3).join(\"\\n\"));\r\n    }\r\n    return parseResult.right;\r\n};\r\nexports.validateParseResult = validateParseResult;\r\nconst isErrorMessageType = (x) => !!`${x}`.match(/^[EAX]$/i);\r\nexports.isErrorMessageType = isErrorMessageType;\r\n","\"use strict\";\r\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    var desc = Object.getOwnPropertyDescriptor(m, k);\r\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\r\n      desc = { enumerable: true, get: function() { return m[k]; } };\r\n    }\r\n    Object.defineProperty(o, k2, desc);\r\n}) : (function(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    o[k2] = m[k];\r\n}));\r\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\r\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\r\n}) : function(o, v) {\r\n    o[\"default\"] = v;\r\n});\r\nvar __importStar = (this && this.__importStar) || function (mod) {\r\n    if (mod && mod.__esModule) return mod;\r\n    var result = {};\r\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\r\n    __setModuleDefault(result, mod);\r\n    return result;\r\n};\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.AdtHTTP = exports.AxiosHttpClient = exports.session_types = void 0;\r\nconst axios_1 = __importStar(require(\"axios\"));\r\nconst AdtException_1 = require(\"./AdtException\");\r\nconst _1 = require(\".\");\r\nconst requestLogger_1 = require(\"./requestLogger\");\r\nconst utilities_1 = require(\"./utilities\");\r\nconst FETCH_CSRF_TOKEN = \"fetch\";\r\nconst CSRF_TOKEN_HEADER = \"x-csrf-token\";\r\nconst SESSION_HEADER = \"X-sap-adt-sessiontype\";\r\nconst runningInNode = typeof process !== \"undefined\" &&\r\n    process.versions != null &&\r\n    process.versions.node != null;\r\nlet lastClientId = 0;\r\nvar session_types;\r\n(function (session_types) {\r\n    session_types[\"stateful\"] = \"stateful\";\r\n    session_types[\"stateless\"] = \"stateless\";\r\n    session_types[\"keep\"] = \"\";\r\n})(session_types = exports.session_types || (exports.session_types = {}));\r\nconst toAxiosConfig = (options) => {\r\n    const config = {\r\n        method: options.method || \"GET\",\r\n        url: options.url,\r\n        headers: options.headers || {},\r\n        params: options.qs,\r\n        httpsAgent: options.httpsAgent,\r\n        timeout: options.timeout,\r\n        auth: options.auth,\r\n        data: options.body,\r\n        adtRequestNumber: options.adtRequestNumber,\r\n        adtStartTime: options.adtStartTime\r\n    };\r\n    return config;\r\n};\r\nlet adtRequestNumber = 0;\r\nconst convertheaders = (raw) => {\r\n    if (raw instanceof axios_1.AxiosHeaders)\r\n        return raw;\r\n    const headers = new axios_1.AxiosHeaders();\r\n    for (const k in Object.keys(raw))\r\n        headers.set(k, raw[k]);\r\n    return headers;\r\n};\r\nclass AxiosHttpClient {\r\n    constructor(baseURL, config) {\r\n        this.baseURL = baseURL;\r\n        const conf = toAxiosConfig({ ...config });\r\n        this.axios = axios_1.default.create({ ...conf, baseURL });\r\n    }\r\n    async request(options) {\r\n        try {\r\n            const config = toAxiosConfig(options);\r\n            const { data, headers, ...rest } = await this.axios.request(config);\r\n            const body = data ? ((0, utilities_1.isString)(data) ? data : `${data}`) : \"\";\r\n            return { body, headers: convertheaders(headers), ...rest };\r\n        }\r\n        catch (error) {\r\n            throw (0, _1.fromError)(error);\r\n        }\r\n    }\r\n}\r\nexports.AxiosHttpClient = AxiosHttpClient;\r\nclass AdtHTTP {\r\n    get isStateful() {\r\n        return (this.stateful === session_types.stateful ||\r\n            (this.stateful === session_types.keep &&\r\n                this.currentSession === session_types.stateful));\r\n    }\r\n    get stateful() {\r\n        return this._stateful;\r\n    }\r\n    set stateful(value) {\r\n        this._stateful = value;\r\n        if (value !== session_types.keep)\r\n            this.currentSession = value;\r\n    }\r\n    get csrfToken() {\r\n        return this.commonHeaders[CSRF_TOKEN_HEADER] || FETCH_CSRF_TOKEN;\r\n    }\r\n    set csrfToken(token) {\r\n        this.commonHeaders[CSRF_TOKEN_HEADER] = token;\r\n    }\r\n    get loggedin() {\r\n        return this.csrfToken !== FETCH_CSRF_TOKEN;\r\n    }\r\n    constructor(baseURLOrClient, username, password, client, language, config) {\r\n        this.username = username;\r\n        this.client = client;\r\n        this.language = language;\r\n        this.isClone = false;\r\n        this.currentSession = session_types.stateless;\r\n        this._stateful = session_types.stateless;\r\n        this.needKeepalive = false;\r\n        this.cookie = new Map();\r\n        this.keep_session = async () => {\r\n            if (this.needKeepalive && this.loggedin)\r\n                await this._request(\"/sap/bc/adt/compatibility/graph\", {}).catch(() => { });\r\n            this.needKeepalive = true;\r\n        };\r\n        if ((0, utilities_1.isString)(baseURLOrClient) && username && !password)\r\n            throw (0, _1.adtException)(\"Invalid ADTClient configuration: url, login and password are required\");\r\n        this.baseURL = (0, utilities_1.isString)(baseURLOrClient) ? baseURLOrClient : \"\";\r\n        this.id = lastClientId++;\r\n        if ((0, utilities_1.isString)(password))\r\n            this.password = password;\r\n        else\r\n            this.getToken = password;\r\n        this.commonHeaders = {\r\n            ...config === null || config === void 0 ? void 0 : config.headers,\r\n            Accept: \"*/*\",\r\n            \"Cache-Control\": \"no-cache\",\r\n            [CSRF_TOKEN_HEADER]: FETCH_CSRF_TOKEN\r\n        };\r\n        this.httpclient = (0, utilities_1.isString)(baseURLOrClient)\r\n            ? new AxiosHttpClient(baseURLOrClient, config)\r\n            : baseURLOrClient;\r\n        this.debugCallback = config === null || config === void 0 ? void 0 : config.debugCallback;\r\n        if (config === null || config === void 0 ? void 0 : config.keepAlive)\r\n            this.keepAlive = setInterval(() => this.keep_session(), 120000);\r\n    }\r\n    async login() {\r\n        if (this.loginPromise)\r\n            return this.loginPromise;\r\n        this.cookie.clear();\r\n        // oauth\r\n        if (this.getToken && !this.bearer) {\r\n            await this.getToken().then(bearer => (this.bearer = bearer));\r\n        }\r\n        else\r\n            this.auth = {\r\n                username: this.username || \"\",\r\n                password: this.password || \"\"\r\n            };\r\n        const qs = {};\r\n        if (this.client)\r\n            qs[\"sap-client\"] = this.client;\r\n        if (this.language)\r\n            qs[\"sap-language\"] = this.language;\r\n        this.csrfToken = FETCH_CSRF_TOKEN;\r\n        try {\r\n            this.loginPromise = this._request(\"/sap/bc/adt/compatibility/graph\", {\r\n                qs\r\n            });\r\n            await this.loginPromise;\r\n        }\r\n        finally {\r\n            this.loginPromise = undefined;\r\n        }\r\n    }\r\n    ascookies() {\r\n        return [...this.cookie.values()].join(\"; \");\r\n    }\r\n    async logout() {\r\n        this.stateful = session_types.stateless;\r\n        await this._request(\"/sap/public/bc/icf/logoff\", {});\r\n        // prevent autologin\r\n        this.auth = undefined;\r\n        this.bearer = undefined;\r\n        // new cookie jar\r\n        this.cookie.clear();\r\n        // clear token\r\n        this.csrfToken = FETCH_CSRF_TOKEN;\r\n    }\r\n    async dropSession() {\r\n        this.stateful = session_types.stateless;\r\n        await this._request(\"/sap/bc/adt/compatibility/graph\", {});\r\n    }\r\n    async request(url, config) {\r\n        let autologin = false;\r\n        try {\r\n            if (!this.loggedin) {\r\n                autologin = true;\r\n                await this.login();\r\n            }\r\n            return await this._request(url, config || {});\r\n        }\r\n        catch (e) {\r\n            const adtErr = (0, AdtException_1.fromException)(e, config);\r\n            // if the logon ticket expired try to logon again, unless in stateful mode\r\n            // or already tried a login\r\n            if ((0, _1.isLoginError)(adtErr) && !autologin && !this.isStateful) {\r\n                try {\r\n                    this.csrfToken = FETCH_CSRF_TOKEN;\r\n                    await this.login();\r\n                    return await this._request(url, config || {});\r\n                }\r\n                catch (e2) {\r\n                    throw (0, AdtException_1.fromException)(e2, config);\r\n                }\r\n            }\r\n            else\r\n                throw adtErr;\r\n        }\r\n    }\r\n    updateCookies(response) {\r\n        if (runningInNode) {\r\n            const cookies = response.headers[\"set-cookie\"] || [];\r\n            cookies.forEach(cookie => {\r\n                const cleaned = cookie\r\n                    .replace(/path=\\/,/g, \"\")\r\n                    .replace(/path=\\//g, \"\")\r\n                    .split(\";\")[0];\r\n                const [key] = cookie.split(\"=\", 1);\r\n                this.cookie.set(key, cleaned);\r\n            });\r\n        }\r\n    }\r\n    logResponse(exceptionOrResponse, options) {\r\n        if (!this.debugCallback)\r\n            return;\r\n        if ((0, _1.isAdtException)(exceptionOrResponse))\r\n            (0, requestLogger_1.logError)(this.id, exceptionOrResponse, this.debugCallback, options);\r\n        else\r\n            (0, requestLogger_1.logResponse)(this.id, exceptionOrResponse, options, this.debugCallback);\r\n    }\r\n    /**\r\n     * HTTP request without automated login / retry\r\n     *\r\n     * @param url URL suffix\r\n     * @param options request options\r\n     */\r\n    async _request(url, options) {\r\n        this.needKeepalive = false;\r\n        const headers = { ...this.commonHeaders, ...options.headers };\r\n        headers[SESSION_HEADER] = this.stateful;\r\n        if (!headers[\"Cookie\"] && runningInNode)\r\n            headers[\"Cookie\"] = this.ascookies();\r\n        adtRequestNumber++;\r\n        const adtStartTime = new Date();\r\n        const config = {\r\n            ...options,\r\n            auth: this.auth,\r\n            headers,\r\n            adtStartTime,\r\n            adtRequestNumber,\r\n            url\r\n        };\r\n        try {\r\n            if (this.getToken && !this.bearer)\r\n                this.bearer = await this.getToken();\r\n            if (this.bearer)\r\n                headers.Authorization = `bearer ${this.bearer}`;\r\n            const response = await this.httpclient.request(config);\r\n            this.updateCookies(response);\r\n            if (response.status >= 400)\r\n                throw (0, AdtException_1.fromException)(response, config);\r\n            if (this.csrfToken === FETCH_CSRF_TOKEN &&\r\n                (0, utilities_1.isString)(response.headers[CSRF_TOKEN_HEADER]))\r\n                this.csrfToken = response.headers[CSRF_TOKEN_HEADER];\r\n            this.logResponse(response, config);\r\n            return response;\r\n        }\r\n        catch (error) {\r\n            const exc = (0, AdtException_1.fromException)(error, config);\r\n            this.logResponse(exc, config);\r\n            throw exc;\r\n        }\r\n    }\r\n}\r\nexports.AdtHTTP = AdtHTTP;\r\n","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.switchRepoBranch = exports.remoteRepoInfo = exports.stageRepo = exports.pushRepo = exports.checkRepo = exports.unlinkRepo = exports.pullRepo = exports.createRepo = exports.externalRepoInfo = exports.gitRepos = void 0;\r\nconst utilities_1 = require(\"../utilities\");\r\nconst AdtException_1 = require(\"../AdtException\");\r\nconst parseDate = (d) => {\r\n    const match = d.match(/(\\d\\d\\d\\d)(\\d\\d)(\\d\\d)(\\d\\d)(\\d\\d)(\\d\\d)/);\r\n    if (!match)\r\n        return new Date(); // wrong but valid\r\n    const [Y, M, D, h, m, s] = match.slice(1);\r\n    return new Date(Date.UTC((0, utilities_1.toInt)(Y), (0, utilities_1.toInt)(M) - 1, (0, utilities_1.toInt)(D), (0, utilities_1.toInt)(h), (0, utilities_1.toInt)(m), (0, utilities_1.toInt)(s)));\r\n};\r\nasync function gitRepos(h) {\r\n    const headers = { Accept: \"application/abapgit.adt.repos.v2+xml\" };\r\n    const response = await h.request(`/sap/bc/adt/abapgit/repos`, { headers });\r\n    const raw = (0, utilities_1.parse)(response.body, {\r\n        ignoreAttributes: false,\r\n        parseAttributeValue: false,\r\n        parseTagValue: false,\r\n        removeNSPrefix: true\r\n    });\r\n    return (0, utilities_1.xmlArray)(raw, \"repositories\", \"repository\").map((x) => {\r\n        const { key, package: sapPackage, url, status, status_text, } = x;\r\n        // tslint:disable: variable-name\r\n        const branch_name = x.branch_name || x.branchName || \"\";\r\n        const created_by = x.created_by || x.createdBy || \"\";\r\n        const created_at = x.created_at || x.createdAt || \"\";\r\n        const created_email = x.created_email || x.createdEmail || \"\";\r\n        const deserialized_by = x.deserialized_by || x.deserializedBy || \"\";\r\n        const deserialized_email = x.deserialized_email || x.deserializedEmail || \"\";\r\n        const deserialized_at = x.deserialized_at || x.deserializedAt || \"\";\r\n        const links = (0, utilities_1.xmlArray)(x, \"link\").map(utilities_1.xmlNodeAttr);\r\n        const repo = {\r\n            key,\r\n            sapPackage,\r\n            url,\r\n            branch_name,\r\n            created_by,\r\n            created_at: parseDate(created_at),\r\n            created_email,\r\n            deserialized_by,\r\n            deserialized_email,\r\n            deserialized_at: deserialized_at && parseDate(deserialized_at),\r\n            status,\r\n            status_text,\r\n            links,\r\n        };\r\n        return repo;\r\n    });\r\n}\r\nexports.gitRepos = gitRepos;\r\nasync function externalRepoInfo(h, repourl, user = \"\", password = \"\") {\r\n    const headers = {\r\n        \"Content-Type\": \"application/abapgit.adt.repo.info.ext.request.v2+xml\",\r\n        Accept: \"application/abapgit.adt.repo.info.ext.response.v2+xml\",\r\n    };\r\n    const body = `<?xml version=\"1.0\" ?>\n  <abapgitexternalrepo:externalRepoInfoRequest xmlns:abapgitexternalrepo=\"http://www.sap.com/adt/abapgit/externalRepo\">\n    <abapgitexternalrepo:url>${repourl}</abapgitexternalrepo:url>\n    <abapgitexternalrepo:user>${user}</abapgitexternalrepo:user>\n    <abapgitexternalrepo:password>${password}</abapgitexternalrepo:password>\n  </abapgitexternalrepo:externalRepoInfoRequest>`;\r\n    const response = await h.request(`/sap/bc/adt/abapgit/externalrepoinfo`, {\r\n        method: \"POST\",\r\n        body,\r\n        headers,\r\n    });\r\n    const raw = (0, utilities_1.fullParse)(response.body, { removeNSPrefix: true });\r\n    // tslint:disable-next-line: variable-name\r\n    const access_mode = (0, utilities_1.xmlNode)(raw, \"externalRepoInfo\", \"accessMode\");\r\n    const branches = (0, utilities_1.xmlArray)(raw, \"externalRepoInfo\", \"branch\").map((branch) => ({\r\n        name: branch.name,\r\n        type: branch.type,\r\n        sha1: branch.sha1,\r\n        display_name: branch.displayName,\r\n        is_head: (0, utilities_1.boolFromAbap)(branch && branch.is_head),\r\n    }));\r\n    return { access_mode, branches };\r\n}\r\nexports.externalRepoInfo = externalRepoInfo;\r\nconst parseObjects = (body) => {\r\n    const raw = (0, utilities_1.fullParse)(body);\r\n    return (0, utilities_1.xmlArray)(raw, \"objects\", \"object\").map((r) => {\r\n        const { type, name, package: pkg, status, msgType, msgText, } = r;\r\n        const obj = {\r\n            obj_type: type,\r\n            obj_name: name,\r\n            package: pkg,\r\n            obj_status: status,\r\n            msg_type: msgType,\r\n            msg_text: msgText,\r\n        };\r\n    });\r\n};\r\nasync function createRepo(h, packageName, repourl, branch = \"refs/heads/master\", transport = \"\", user = \"\", password = \"\") {\r\n    const headers = {\r\n        \"Content-Type\": \"application/abapgit.adt.repo.v3+xml\",\r\n    };\r\n    const body = `<?xml version=\"1.0\" ?>\n  <abapgitrepo:repository xmlns:abapgitrepo=\"http://www.sap.com/adt/abapgit/repositories\">\n    <abapgitrepo:package>${packageName}</abapgitrepo:package>\n    <abapgitrepo:url>${repourl}</abapgitrepo:url>\n    <abapgitrepo:branchName>${branch}</abapgitrepo:branchName>\n    <abapgitrepo:transportRequest>${transport}</abapgitrepo:transportRequest>\n    <abapgitrepo:remoteUser>${user}</abapgitrepo:remoteUser>\n    <abapgitrepo:remotePassword>${password}</abapgitrepo:remotePassword>\n  </abapgitrepo:repository>`;\r\n    const response = await h.request(`/sap/bc/adt/abapgit/repos`, {\r\n        method: \"POST\",\r\n        body,\r\n        headers, // encodeEntity?\r\n    });\r\n    return parseObjects(response.body);\r\n}\r\nexports.createRepo = createRepo;\r\nasync function pullRepo(h, repoId, branch = \"refs/heads/master\", transport = \"\", user = \"\", password = \"\") {\r\n    const headers = {\r\n        \"Content-Type\": \"application/abapgit.adt.repo.v3+xml\",\r\n    };\r\n    branch = `<abapgitrepo:branchName>${branch}</abapgitrepo:branchName>`;\r\n    transport = transport\r\n        ? `<abapgitrepo:transportRequest>${transport}</abapgitrepo:transportRequest>`\r\n        : \"\";\r\n    user = user ? `<abapgitrepo:remoteUser>${user}</abapgitrepo:remoteUser>` : \"\";\r\n    password = password ? `<abapgitrepo:remotePassword>${password}</abapgitrepo:remotePassword>` : \"\";\r\n    const body = `<?xml version=\"1.0\" ?><abapgitrepo:repository xmlns:abapgitrepo=\"http://www.sap.com/adt/abapgit/repositories\">\n    ${branch}${transport}${user}${password}</abapgitrepo:repository>`;\r\n    const response = await h.request(`/sap/bc/adt/abapgit/repos/${repoId}/pull`, {\r\n        method: \"POST\",\r\n        body,\r\n        headers,\r\n    });\r\n    return parseObjects(response.body);\r\n}\r\nexports.pullRepo = pullRepo;\r\nasync function unlinkRepo(h, repoId) {\r\n    const headers = {\r\n        \"Content-Type\": \"application/abapgit.adt.repo.v3+xml\",\r\n    };\r\n    await h.request(`/sap/bc/adt/abapgit/repos/${repoId}`, {\r\n        method: \"DELETE\",\r\n        headers,\r\n    });\r\n}\r\nexports.unlinkRepo = unlinkRepo;\r\nconst deserializeStaging = (body) => {\r\n    const raw = (0, utilities_1.xmlNode)((0, utilities_1.fullParse)(body), \"abapgitstaging:abapgitstaging\");\r\n    const parsefile = (x) => ({\r\n        ...(0, utilities_1.stripNs)((0, utilities_1.xmlNodeAttr)(x)),\r\n        links: (0, utilities_1.xmlArray)(x, \"atom:link\")\r\n            .map(utilities_1.xmlNodeAttr)\r\n            .map(utilities_1.stripNs)\r\n            .map((l) => ({ ...l, href: l.href })),\r\n    });\r\n    const parseObject = (x) => {\r\n        const attrs = (0, utilities_1.stripNs)((0, utilities_1.xmlNodeAttr)(x));\r\n        const abapGitFiles = (0, utilities_1.xmlArray)(x, \"abapgitstaging:abapgitfile\").map(parsefile);\r\n        return { ...attrs, abapGitFiles };\r\n    };\r\n    const unstaged = (0, utilities_1.xmlArray)(raw, \"abapgitstaging:unstaged_objects\", \"abapgitstaging:abapgitobject\").map(parseObject);\r\n    const staged = (0, utilities_1.xmlArray)(raw, \"abapgitstaging:staged_objects\", \"abapgitstaging:abapgitobject\").map(parseObject);\r\n    const ignored = (0, utilities_1.xmlArray)(raw, \"abapgitstaging:ignored_objects\", \"abapgitstaging:abapgitobject\").map(parseObject);\r\n    const commentNode = (0, utilities_1.xmlNode)(raw, \"abapgitstaging:abapgit_comment\");\r\n    const extractUser = (p) => (0, utilities_1.stripNs)((0, utilities_1.xmlNodeAttr)((0, utilities_1.xmlNode)(commentNode, p)));\r\n    const comment = commentNode[\"@_abapgitstaging:comment\"] || \"\";\r\n    const author = extractUser(\"abapgitstaging:author\");\r\n    const committer = extractUser(\"abapgitstaging:author\");\r\n    const result = {\r\n        staged,\r\n        unstaged,\r\n        ignored,\r\n        comment,\r\n        author,\r\n        committer,\r\n    };\r\n    return result;\r\n};\r\nconst serializeStaging = (s) => {\r\n    const formatFile = (f) => {\r\n        const { links, ...rest } = f;\r\n        return `  <abapgitstaging:abapgitfile ${(0, utilities_1.toXmlAttributes)(rest, \"abapgitstaging\")}>${links\r\n            .map((l) => ({ ...l, href: (0, utilities_1.encodeEntity)(l.href) }))\r\n            .map((l) => `<atom:link ${(0, utilities_1.toXmlAttributes)(l, \"\")}/>`)\r\n            .join(\"\")}\n  </abapgitstaging:abapgitfile>`;\r\n    };\r\n    const formatObject = (obj) => {\r\n        const { abapGitFiles, wbkey, ...rest } = obj;\r\n        return `<abapgitstaging:abapgitobject ${(0, utilities_1.toXmlAttributes)(rest, \"adtcore\")} abapgitstaging:wbkey=\"${obj.wbkey}\">\n    ${obj.abapGitFiles.map(formatFile).join(\"\")}\n </abapgitstaging:abapgitobject>`;\r\n    };\r\n    const formatObjects = (objects, root) => {\r\n        if (!objects.length)\r\n            return `<${root}/>`;\r\n        return `<${root}>${objects.map(formatObject).join(\"\")}</${root}>`;\r\n    };\r\n    const unstaged = formatObjects(s.unstaged, \"abapgitstaging:unstaged_objects\");\r\n    const staged = formatObjects(s.staged, \"abapgitstaging:staged_objects\");\r\n    const ignored = formatObjects(s.ignored, \"abapgitstaging:ignored_objects\");\r\n    const comment = `<abapgitstaging:abapgit_comment abapgitstaging:comment=\"${s.comment}\">\n  <abapgitstaging:author abapgitstaging:name=\"${s.author.name}\" abapgitstaging:email=\"${s.author.email}\"/>\n  <abapgitstaging:committer abapgitstaging:name=\"${s.committer.name}\" abapgitstaging:email=\"${s.committer.email}\"/>\n</abapgitstaging:abapgit_comment>\n`;\r\n    return `<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n  <abapgitstaging:abapgitstaging xmlns:abapgitstaging=\"http://www.sap.com/adt/abapgit/staging\"\n         xmlns:adtcore=\"http://www.sap.com/adt/core\"\n         xmlns:atom=\"http://www.w3.org/2005/Atom\">\n  ${unstaged}\n  ${staged}\n  ${ignored}\n  ${comment}\n  </abapgitstaging:abapgitstaging>`;\r\n};\r\nasync function checkRepo(h, repo, user = \"\", password = \"\") {\r\n    const clink = repo.links.find((l) => l.type === \"check_link\");\r\n    if (!(clink === null || clink === void 0 ? void 0 : clink.href))\r\n        throw (0, AdtException_1.adtException)(\"Check link not found\");\r\n    const headers = {\r\n        Accept: \"text/plain\",\r\n    };\r\n    if (user)\r\n        headers.Username = user;\r\n    if (password)\r\n        headers.Password = (0, utilities_1.btoa)(password);\r\n    await h.request(clink.href, { method: \"POST\", headers });\r\n}\r\nexports.checkRepo = checkRepo;\r\nasync function pushRepo(h, repo, staging, user = \"\", password = \"\") {\r\n    const link = repo.links.find((l) => l.type === \"push_link\");\r\n    if (!(link === null || link === void 0 ? void 0 : link.href))\r\n        throw (0, AdtException_1.adtException)(\"Push link not found\");\r\n    const headers = {\r\n        Accept: \"application/abapgit.adt.repo.stage.v1+xml\",\r\n    };\r\n    headers[\"Content-Type\"] = headers.Accept;\r\n    if (user)\r\n        headers.Username = user;\r\n    if (password)\r\n        headers.Password = (0, utilities_1.btoa)(password);\r\n    const body = serializeStaging(staging);\r\n    await h.request(link.href, { method: \"POST\", headers, body });\r\n}\r\nexports.pushRepo = pushRepo;\r\nasync function stageRepo(h, repo, user = \"\", password = \"\") {\r\n    const link = repo.links.find((l) => l.type === \"stage_link\");\r\n    if (!(link === null || link === void 0 ? void 0 : link.href))\r\n        throw (0, AdtException_1.adtException)(\"Stage link not found\");\r\n    const headers = {\r\n        \"Content-Type\": \"application/abapgit.adt.repo.stage.v1+xml\",\r\n    };\r\n    if (user)\r\n        headers.Username = user;\r\n    if (password)\r\n        headers.Password = (0, utilities_1.btoa)(password);\r\n    const resp = await h.request(link.href, { headers });\r\n    return deserializeStaging(resp.body);\r\n}\r\nexports.stageRepo = stageRepo;\r\n/**\r\n * @deprecated since 1.2.1, duplicate of externalRepoInfo\r\n */\r\nasync function remoteRepoInfo(h, repo, user = \"\", password = \"\") {\r\n    var _a;\r\n    const headers = {\r\n        \"Content-Type\": \"application/abapgit.adt.repo.info.ext.request.v1+xml\",\r\n        Accept: \"application/abapgit.adt.repo.info.ext.response.v1+xml\",\r\n    };\r\n    const body = `<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<repository_ext>\n<url>${repo.url}</url>\n<user>${user}</user>\n<password>${password}</password>\n</repository_ext>`;\r\n    const resp = await h.request(\"/sap/bc/adt/abapgit/externalrepoinfo\", {\r\n        headers,\r\n        body,\r\n        method: \"POST\",\r\n    });\r\n    const raw = (_a = (0, utilities_1.parse)(resp.body)) === null || _a === void 0 ? void 0 : _a.repository_external;\r\n    const { access_mode, branches } = raw;\r\n    return {\r\n        access_mode,\r\n        branches: (0, utilities_1.xmlArray)(branches, \"branch\"),\r\n    };\r\n}\r\nexports.remoteRepoInfo = remoteRepoInfo;\r\nasync function switchRepoBranch(h, repo, branch, create = false, user = \"\", password = \"\") {\r\n    const headers = {};\r\n    if (user)\r\n        headers.Username = user;\r\n    if (password)\r\n        headers.Password = (0, utilities_1.btoa)(password);\r\n    await h.request(`/sap/bc/adt/abapgit/repos/${repo.key}/branches/${encodeURIComponent(branch)}?create=${create}`, {\r\n        headers,\r\n        method: \"POST\",\r\n    });\r\n}\r\nexports.switchRepoBranch = switchRepoBranch;\r\n","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.inactiveObjects = exports.inactiveObjectsInResults = exports.mainPrograms = exports.activate = void 0;\r\nconst AdtException_1 = require(\"../AdtException\");\r\nconst utilities_1 = require(\"../utilities\");\r\nfunction toElement(source) {\r\n    if (!source || !source[\"ioc:ref\"])\r\n        return undefined;\r\n    return {\r\n        deleted: source[\"@_ioc:deleted\"],\r\n        user: source[\"@_ioc:user\"],\r\n        ...(0, utilities_1.xmlNodeAttr)(source[\"ioc:ref\"])\r\n    };\r\n}\r\nfunction parseInactive(raw) {\r\n    return (0, utilities_1.xmlArray)(raw, \"ioc:inactiveObjects\", \"ioc:entry\").map((obj) => {\r\n        return {\r\n            object: toElement((0, utilities_1.xmlNode)(obj, \"ioc:object\")),\r\n            transport: toElement((0, utilities_1.xmlNode)(obj, \"ioc:transport\"))\r\n        };\r\n    });\r\n}\r\nasync function activate(h, objectNameOrObjects, objectUrlOrPreauditReq = true, mainInclude, preauditRequested = true) {\r\n    let objects = [];\r\n    let incl = \"\";\r\n    if ((0, utilities_1.isString)(objectNameOrObjects)) {\r\n        if (!(0, utilities_1.isString)(objectUrlOrPreauditReq))\r\n            throw (0, AdtException_1.adtException)(\"Invalid parameters, objectUrl should be  a string\");\r\n        (0, AdtException_1.ValidateObjectUrl)(objectUrlOrPreauditReq || \"\");\r\n        if (mainInclude)\r\n            incl = `?context=${encodeURIComponent(mainInclude)}`;\r\n        objects.push(`<adtcore:objectReference adtcore:uri=\"${objectUrlOrPreauditReq}${incl}\" adtcore:name=\"${objectNameOrObjects}\"/>`);\r\n    }\r\n    else {\r\n        let inactives;\r\n        if ((0, utilities_1.isString)(objectUrlOrPreauditReq))\r\n            throw (0, AdtException_1.adtException)(\"Invalid parameters, preauditRequested should be a boolean\");\r\n        preauditRequested = objectUrlOrPreauditReq;\r\n        if ((0, utilities_1.isArray)(objectNameOrObjects)) {\r\n            inactives = objectNameOrObjects;\r\n        }\r\n        else\r\n            inactives = [objectNameOrObjects];\r\n        inactives.forEach(i => (0, AdtException_1.ValidateObjectUrl)(i[\"adtcore:uri\"]));\r\n        objects = inactives.map(i => `<adtcore:objectReference adtcore:uri=\"${i[\"adtcore:uri\"]}\" adtcore:type=\"${i[\"adtcore:type\"]}\" adtcore:parentUri=\"${i[\"adtcore:parentUri\"]}\" adtcore:name=\"${i[\"adtcore:name\"]}\"/>`);\r\n    }\r\n    const qs = { method: \"activate\", preauditRequested };\r\n    const body = `<?xml version=\"1.0\" encoding=\"UTF-8\"?>` +\r\n        `<adtcore:objectReferences xmlns:adtcore=\"http://www.sap.com/adt/core\">` +\r\n        objects.join(`\\n`) +\r\n        `</adtcore:objectReferences>`;\r\n    const response = await h.request(\"/sap/bc/adt/activation\", {\r\n        body,\r\n        method: \"POST\",\r\n        qs\r\n    });\r\n    let messages = [];\r\n    let success = true;\r\n    let inactive = [];\r\n    if (response.body) {\r\n        const raw = (0, utilities_1.fullParse)(response.body);\r\n        inactive = parseInactive(raw);\r\n        messages = (0, utilities_1.xmlArray)(raw, \"chkl:messages\", \"msg\").map((m) => {\r\n            const message = (0, utilities_1.xmlNodeAttr)(m);\r\n            message.shortText = (m.shortText && m.shortText.txt) || \"Syntax error\";\r\n            return message;\r\n        });\r\n        if (inactive.length > 0)\r\n            success = false;\r\n        else\r\n            messages.some(m => {\r\n                if (m.type.match(/[EAX]/))\r\n                    success = false;\r\n                return !success;\r\n            });\r\n    }\r\n    return { messages, success, inactive };\r\n}\r\nexports.activate = activate;\r\nasync function mainPrograms(h, IncludeUrl) {\r\n    (0, AdtException_1.ValidateObjectUrl)(IncludeUrl);\r\n    const response = await h.request(`${IncludeUrl}/mainprograms`);\r\n    const parsed = (0, utilities_1.fullParse)(response.body);\r\n    const includes = (0, utilities_1.xmlArray)(parsed[\"adtcore:objectReferences\"], \"adtcore:objectReference\").map(utilities_1.xmlNodeAttr);\r\n    return includes;\r\n}\r\nexports.mainPrograms = mainPrograms;\r\nfunction inactiveObjectsInResults(results) {\r\n    const obj = results.inactive.filter(x => x.object).map(x => x.object);\r\n    return obj.map(o => {\r\n        const { user, deleted, ...rest } = o;\r\n        return rest;\r\n    });\r\n}\r\nexports.inactiveObjectsInResults = inactiveObjectsInResults;\r\nasync function inactiveObjects(h) {\r\n    const headers = {\r\n        Accept: \"application/vnd.sap.adt.inactivectsobjects.v1+xml, application/xml;q=0.8\"\r\n    };\r\n    const response = await h.request(\"/sap/bc/adt/activation/inactiveobjects\", {\r\n        headers\r\n    });\r\n    return parseInactive((0, utilities_1.fullParse)(response.body));\r\n}\r\nexports.inactiveObjects = inactiveObjects;\r\n","\"use strict\";\r\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    var desc = Object.getOwnPropertyDescriptor(m, k);\r\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\r\n      desc = { enumerable: true, get: function() { return m[k]; } };\r\n    }\r\n    Object.defineProperty(o, k2, desc);\r\n}) : (function(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    o[k2] = m[k];\r\n}));\r\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\r\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\r\n}) : function(o, v) {\r\n    o[\"default\"] = v;\r\n});\r\nvar __importStar = (this && this.__importStar) || function (mod) {\r\n    if (mod && mod.__esModule) return mod;\r\n    var result = {};\r\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\r\n    __setModuleDefault(result, mod);\r\n    return result;\r\n};\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.atcChangeContact = exports.atcContactUri = exports.atcRequestExemption = exports.atcExemptProposal = exports.atcUsers = exports.atcWorklists = exports.createAtcRun = exports.atcCheckVariant = exports.atcCustomizing = exports.isProposalMessage = void 0;\r\nconst utilities_1 = require(\"../utilities\");\r\nconst t = __importStar(require(\"io-ts\"));\r\nconst __1 = require(\"..\");\r\nconst urlparser_1 = require(\"./urlparser\");\r\nconst exemptionKind = t.union([\r\n    t.literal(\"A\"),\r\n    t.literal(\"I\"),\r\n    t.literal(\"\"),\r\n    t.string\r\n]); // SATC_AC_RSLT_XMPT_KIND Atc based/Inline/none\r\nconst proposalFinding = (0, utilities_1.mixed)({\r\n    uri: t.string,\r\n    type: t.string,\r\n    name: t.string,\r\n    location: t.string,\r\n    processor: t.string,\r\n    lastChangedBy: t.string,\r\n    priority: t.number,\r\n    checkId: t.string,\r\n    checkTitle: t.string,\r\n    messageId: t.string,\r\n    messageTitle: t.string,\r\n    exemptionApproval: t.string,\r\n    exemptionKind,\r\n    checksum: t.number,\r\n    quickfixInfo: t.string\r\n}, {\r\n    quickfixes: t.partial({\r\n        automatic: t.boolean,\r\n        manual: t.boolean,\r\n        pseudo: t.boolean\r\n    })\r\n});\r\nconst restriction = t.type({\r\n    enabled: t.boolean,\r\n    singlefinding: t.boolean,\r\n    rangeOfFindings: t.type({\r\n        enabled: t.boolean,\r\n        restrictByObject: t.type({\r\n            object: t.boolean,\r\n            package: t.boolean,\r\n            subobject: t.boolean,\r\n            target: t.union([\r\n                t.literal(\"subobject\"),\r\n                t.literal(\"object\"),\r\n                t.literal(\"package\"),\r\n                t.literal(\"\")\r\n            ])\r\n        }),\r\n        restrictByCheck: t.type({\r\n            check: t.boolean,\r\n            message: t.boolean,\r\n            target: t.union([t.literal(\"message\"), t.literal(\"check\"), t.literal(\"\")])\r\n        })\r\n    })\r\n});\r\nconst atcProposal = (0, utilities_1.mixed)({\r\n    finding: t.union([proposalFinding, t.string]),\r\n    package: t.string,\r\n    subObject: t.string,\r\n    subObjectType: t.string,\r\n    subObjectTypeDescr: t.string,\r\n    objectTypeDescr: t.string,\r\n    approver: t.string,\r\n    reason: t.union([t.literal(\"FPOS\"), t.literal(\"OTHR\"), t.literal(\"\")]),\r\n    justification: t.string,\r\n    notify: t.union([\r\n        t.literal(\"never\"),\r\n        t.literal(\"on_rejection\"),\r\n        t.literal(\"always\")\r\n    ]),\r\n    restriction: restriction\r\n}, {\r\n    apprIsArea: t.string,\r\n    checkClass: t.string,\r\n    validUntil: t.string\r\n});\r\nconst atcProposalMessage = t.type({\r\n    type: t.string,\r\n    message: t.string\r\n});\r\nconst atcRunResultInfo = t.type({\r\n    type: t.string,\r\n    description: t.string\r\n});\r\nconst atcRunResult = t.type({\r\n    id: t.string,\r\n    timestamp: t.number,\r\n    infos: t.array(atcRunResultInfo)\r\n});\r\nconst atcExcemption = t.type({\r\n    id: t.string,\r\n    justificationMandatory: t.boolean,\r\n    title: t.string\r\n});\r\nconst atcProperty = t.type({\r\n    name: t.string,\r\n    value: t.union([t.boolean, t.string])\r\n});\r\nconst atcCustomizingi = t.type({\r\n    properties: t.array(atcProperty),\r\n    excemptions: t.array(atcExcemption)\r\n});\r\nconst objectSet = t.type({\r\n    name: t.string,\r\n    title: t.string,\r\n    kind: t.string\r\n});\r\nconst link = t.type({\r\n    href: t.string,\r\n    rel: t.string,\r\n    type: t.string\r\n});\r\nconst finding = t.type({\r\n    uri: t.string,\r\n    location: urlparser_1.uriParts,\r\n    priority: t.number,\r\n    checkId: t.string,\r\n    checkTitle: t.string,\r\n    messageId: t.string,\r\n    messageTitle: t.string,\r\n    exemptionApproval: t.string,\r\n    exemptionKind,\r\n    quickfixInfo: (0, utilities_1.orUndefined)(t.string),\r\n    link: link\r\n});\r\nconst object = t.type({\r\n    uri: t.string,\r\n    type: t.string,\r\n    name: t.string,\r\n    packageName: t.string,\r\n    author: t.string,\r\n    objectTypeId: (0, utilities_1.orUndefined)(t.string),\r\n    findings: t.array(finding)\r\n});\r\nconst atcWorklist = t.type({\r\n    id: t.string,\r\n    timestamp: t.number,\r\n    usedObjectSet: t.string,\r\n    objectSetIsComplete: t.boolean,\r\n    objectSets: t.array(objectSet),\r\n    objects: t.array(object)\r\n});\r\nconst atcUser = t.type({\r\n    id: t.string,\r\n    title: t.string\r\n});\r\nexports.isProposalMessage = atcProposalMessage.is;\r\nasync function atcCustomizing(h) {\r\n    const headers = {\r\n        Accept: \"application/xml, application/vnd.sap.atc.customizing-v1+xml\"\r\n    };\r\n    const response = await h.request(\"/sap/bc/adt/atc/customizing\", { headers });\r\n    const raw = (0, utilities_1.fullParse)(response.body, {\r\n        removeNSPrefix: true,\r\n        parseTagValue: false\r\n    });\r\n    const properties = (0, utilities_1.xmlArray)(raw, \"customizing\", \"properties\", \"property\").map(utilities_1.xmlNodeAttr);\r\n    const excemptions = (0, utilities_1.xmlArray)(raw, \"customizing\", \"exemption\", \"reasons\", \"reason\").map(utilities_1.xmlNodeAttr);\r\n    const retval = { properties, excemptions };\r\n    return (0, __1.validateParseResult)(atcCustomizingi.decode(retval));\r\n}\r\nexports.atcCustomizing = atcCustomizing;\r\nasync function atcCheckVariant(h, variant) {\r\n    const headers = { Accept: \"text/plain\" };\r\n    const response = await h.request(`/sap/bc/adt/atc/worklists?checkVariant=${variant}`, { method: \"POST\", headers });\r\n    return response.body;\r\n}\r\nexports.atcCheckVariant = atcCheckVariant;\r\nasync function createAtcRun(h, variant, mainUrl, maxResults = 100) {\r\n    const body = `<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<atc:run maximumVerdicts=\"${maxResults}\" xmlns:atc=\"http://www.sap.com/adt/atc\">\n\t<objectSets xmlns:adtcore=\"http://www.sap.com/adt/core\">\n\t\t<objectSet kind=\"inclusive\">\n\t\t\t<adtcore:objectReferences>\n\t\t\t\t<adtcore:objectReference adtcore:uri=\"${mainUrl}\"/>\n\t\t\t</adtcore:objectReferences>\n\t\t</objectSet>\n\t</objectSets>\n</atc:run>`;\r\n    const headers = {\r\n        Accept: \"application/xml\",\r\n        \"Content-Type\": \"application/xml\"\r\n    };\r\n    const response = await h.request(`/sap/bc/adt/atc/runs?worklistId=${variant}`, { method: \"POST\", headers, body });\r\n    const raw = (0, utilities_1.fullParse)(response.body, {\r\n        removeNSPrefix: true,\r\n        parseTagValue: false\r\n    });\r\n    const id = (0, utilities_1.xmlNode)(raw, \"worklistRun\", \"worklistId\");\r\n    const ts = (0, utilities_1.xmlNode)(raw, \"worklistRun\", \"worklistTimestamp\");\r\n    const infos = (0, utilities_1.xmlArray)(raw, \"worklistRun\", \"infos\", \"info\");\r\n    const retval = { id, timestamp: new Date(ts).getTime() / 1000, infos };\r\n    return (0, __1.validateParseResult)(atcRunResult.decode(retval));\r\n}\r\nexports.createAtcRun = createAtcRun;\r\nasync function atcWorklists(h, runResultId, timestamp, usedObjectSet, includeExemptedFindings = false) {\r\n    const headers = { Accept: \"application/atc.worklist.v1+xml\" };\r\n    const qs = { timestamp, usedObjectSet, includeExemptedFindings };\r\n    const response = await h.request(`/sap/bc/adt/atc/worklists/${runResultId}`, {\r\n        headers,\r\n        qs\r\n    });\r\n    const raw = (0, utilities_1.fullParse)(response.body, {\r\n        removeNSPrefix: true,\r\n        parseTagValue: false,\r\n        numberParseOptions: utilities_1.numberParseOptions\r\n    });\r\n    const root = (0, utilities_1.xmlNode)(raw, \"worklist\");\r\n    const attrs = (0, utilities_1.xmlNodeAttr)(root);\r\n    const objectSets = (0, utilities_1.xmlArray)(root, \"objectSets\", \"objectSet\").map(utilities_1.xmlNodeAttr);\r\n    const objects = (0, utilities_1.xmlArray)(root, \"objects\", \"object\").map(o => {\r\n        const oa = (0, utilities_1.xmlNodeAttr)(o);\r\n        const findings = (0, utilities_1.xmlArray)(o, \"findings\", \"finding\").map(f => {\r\n            const fa = (0, utilities_1.xmlNodeAttr)(f);\r\n            const priority = (0, utilities_1.toInt)(fa.priority);\r\n            const link = (0, utilities_1.xmlNodeAttr)((0, utilities_1.xmlNode)(f, \"link\"));\r\n            const location = (0, urlparser_1.parseUri)(fa.location);\r\n            const messageTitle = fa.messageTitle;\r\n            const checkTitle = fa.checkTitle;\r\n            return {\r\n                ...fa,\r\n                priority,\r\n                messageTitle,\r\n                checkTitle,\r\n                location,\r\n                messageId: `${fa.messageId}`,\r\n                link\r\n            };\r\n        });\r\n        return { ...oa, findings };\r\n    });\r\n    const ts = new Date(attrs.timestamp).getTime() / 1000;\r\n    const result = { ...attrs, timestamp: ts, objectSets, objects };\r\n    return (0, __1.validateParseResult)(atcWorklist.decode(result));\r\n}\r\nexports.atcWorklists = atcWorklists;\r\nasync function atcUsers(h) {\r\n    const headers = { Accept: \"application/atom+xml;type=feed\" };\r\n    const response = await h.request(`/sap/bc/adt/system/users`, { headers });\r\n    const raw = (0, utilities_1.fullParse)(response.body, {\r\n        removeNSPrefix: true,\r\n        parseTagValue: false,\r\n        parseAttributeValue: false\r\n    });\r\n    const users = (0, utilities_1.xmlArray)(raw, \"feed\", \"entry\");\r\n    return (0, __1.validateParseResult)(t.array(atcUser).decode(users));\r\n}\r\nexports.atcUsers = atcUsers;\r\nasync function atcExemptProposal(h, markerId) {\r\n    const headers = {\r\n        Accept: \"application/atc.xmpt.v1+xml, application/atc.xmptapp.v1+xml\"\r\n    };\r\n    const qs = { markerId };\r\n    const response = await h.request(`/sap/bc/adt/atc/exemptions/apply`, {\r\n        headers,\r\n        qs\r\n    });\r\n    const raw = (0, utilities_1.fullParse)(response.body, {\r\n        removeNSPrefix: true,\r\n        parseTagValue: false,\r\n        parseAttributeValue: false\r\n    });\r\n    const root = (0, utilities_1.xmlNode)(raw, \"exemptionApply\", \"exemptionProposal\");\r\n    const { message, type } = (0, utilities_1.xmlNode)(raw, \"exemptionApply\", \"status\") || {};\r\n    if ((0, __1.isErrorMessageType)(type))\r\n        throw (0, __1.adtException)(message);\r\n    if (message && type)\r\n        return (0, __1.validateParseResult)(atcProposalMessage.decode({ message, type }));\r\n    const finding = (0, utilities_1.isString)(root.finding)\r\n        ? root.finding\r\n        : (0, utilities_1.xmlNodeAttr)((0, utilities_1.xmlNode)(root, \"finding\"));\r\n    if (!(0, utilities_1.isString)(finding)) {\r\n        finding.priority = (0, utilities_1.toInt)(finding.priority);\r\n        finding.checksum = (0, utilities_1.toInt)(finding.checksum);\r\n        const qf = (0, utilities_1.xmlNodeAttr)((0, utilities_1.xmlNode)(root, \"finding\", \"quickfixes\"));\r\n        finding.quickfixes = {\r\n            automatic: qf.automatic === \"true\",\r\n            manual: qf.manual === \"true\",\r\n            pseudo: qf.pseudo === \"true\"\r\n        };\r\n    }\r\n    const { package: pa, subObject, subObjectType, subObjectTypeDescr, objectTypeDescr, approver, reason, justification, notify, apprIsArea, checkClass, validUntil } = root;\r\n    const { thisFinding, rangeOfFindings } = (0, utilities_1.xmlNode)(root, \"restriction\");\r\n    const { restrictByObject, restrictByCheck } = rangeOfFindings;\r\n    const result = {\r\n        finding,\r\n        package: pa,\r\n        subObject,\r\n        subObjectType,\r\n        subObjectTypeDescr,\r\n        objectTypeDescr,\r\n        approver,\r\n        reason,\r\n        justification,\r\n        notify,\r\n        apprIsArea,\r\n        checkClass,\r\n        validUntil,\r\n        restriction: {\r\n            enabled: thisFinding[\"@_enabled\"] === \"true\",\r\n            singlefinding: thisFinding[\"#text\"] === \"true\",\r\n            rangeOfFindings: {\r\n                enabled: rangeOfFindings[\"@_enabled\"] === \"true\",\r\n                restrictByObject: {\r\n                    object: restrictByObject[\"@_object\"] === \"true\",\r\n                    package: restrictByObject[\"@_package\"] === \"true\",\r\n                    subobject: restrictByObject[\"@_subobject\"] === \"true\",\r\n                    target: restrictByObject[\"#text\"] || \"\"\r\n                },\r\n                restrictByCheck: {\r\n                    check: restrictByCheck[\"@_check\"] === \"true\",\r\n                    message: restrictByCheck[\"@_message\"] === \"true\",\r\n                    target: restrictByCheck[\"#text\"] || \"\"\r\n                }\r\n            }\r\n        }\r\n    };\r\n    return (0, __1.validateParseResult)(atcProposal.decode(result));\r\n}\r\nexports.atcExemptProposal = atcExemptProposal;\r\nasync function atcRequestExemption(h, proposal) {\r\n    const headers = {\r\n        \"Content-Type\": \"application/atc.xmptprop.v1+xml\",\r\n        Accept: \"application/atc.xmpt.v1+xml, application/atc.xmptprop.v1+xml\"\r\n    };\r\n    const { finding, restriction: { rangeOfFindings: { restrictByCheck, restrictByObject } }, restriction } = proposal;\r\n    const qs = { markerId: (0, utilities_1.isString)(finding) ? finding : finding.quickfixInfo };\r\n    const findingXml = (0, utilities_1.isString)(finding)\r\n        ? `<atcexmpt:finding>${finding}</atcexmpt:finding>`\r\n        : `<atcfinding:finding adtcore:name=\"${finding.name}\" adtcore:type=\"${finding.type}\" adtcore:uri=\"${finding.uri}\" \n    atcfinding:checkId=\"${finding.checkId}\" atcfinding:checksum=\"${finding.checksum}\" atcfinding:checkTitle=\"${(0, utilities_1.encodeEntity)(finding.checkTitle)}\" \n    atcfinding:exemptionApproval=\"${finding.exemptionApproval}\" atcfinding:exemptionKind=\"${finding.exemptionKind}\" \n    atcfinding:lastChangedBy=\"${finding.lastChangedBy}\" \n    atcfinding:location=\"${finding.location}\" atcfinding:messageId=\"${finding.messageId}\" atcfinding:messageTitle=\"${(0, utilities_1.encodeEntity)(finding.messageTitle)}\" \n    atcfinding:priority=\"${finding.priority}\" atcfinding:processor=\"${finding.processor}\" atcfinding:quickfixInfo=\"${finding.quickfixInfo}\">\n      <atcfinding:quickfixes atcfinding:automatic=\"false\" atcfinding:manual=\"false\" atcfinding:pseudo=\"false\" />\n    </atcfinding:finding>`;\r\n    const body = `<?xml version=\"1.0\" encoding=\"ASCII\"?>\n    <atcexmpt:exemptionProposal xmlns:adtcore=\"http://www.sap.com/adt/core\" xmlns:atcexmpt=\"http://www.sap.com/adt/atc/exemption\" xmlns:atcfinding=\"http://www.sap.com/adt/atc/finding\">\n      ${findingXml}\n      <atcexmpt:package>${proposal.package}</atcexmpt:package>\n      <atcexmpt:subObject>${proposal.subObject}</atcexmpt:subObject>\n      <atcexmpt:subObjectType>${proposal.subObjectType}</atcexmpt:subObjectType>\n      <atcexmpt:subObjectTypeDescr>${proposal.subObjectTypeDescr}</atcexmpt:subObjectTypeDescr>\n      <atcexmpt:objectTypeDescr>${proposal.objectTypeDescr}</atcexmpt:objectTypeDescr>\n      <atcexmpt:restriction>\n        <atcexmpt:thisFinding enabled=\"${restriction.enabled}\">${restriction.singlefinding}</atcexmpt:thisFinding>\n        <atcexmpt:rangeOfFindings enabled=\"${restriction.rangeOfFindings.enabled}\">\n          <atcexmpt:restrictByObject object=\"${restrictByObject.object}\" package=\"${restrictByObject.package}\" subobject=\"${restrictByObject.subobject}\">\n          ${restrictByObject.target}</atcexmpt:restrictByObject>\n          <atcexmpt:restrictByCheck check=\"${restrictByCheck.check}\" message=\"${restrictByCheck.message}\">\n          ${restrictByCheck.target}</atcexmpt:restrictByCheck>\n        </atcexmpt:rangeOfFindings>\n      </atcexmpt:restriction>\n      <atcexmpt:approver>${proposal.approver}</atcexmpt:approver>\n      <atcexmpt:reason>${proposal.reason}</atcexmpt:reason>\n      <atcexmpt:justification>${(0, utilities_1.encodeEntity)(proposal.justification)}</atcexmpt:justification>\n      <atcexmpt:notify>${proposal.notify}</atcexmpt:notify>\n      <atcexmpt:apprIsArea>${proposal.apprIsArea || \"\"}</atcexmpt:apprIsArea>\n      <atcexmpt:checkClass>${proposal.checkClass || \"\"}</atcexmpt:checkClass>\n      <atcexmpt:validUntil>${proposal.validUntil || \"\"}</atcexmpt:validUntil>\n      </atcexmpt:exemptionProposal>`;\r\n    const response = await h.request(`/sap/bc/adt/atc/exemptions/apply`, {\r\n        headers,\r\n        body,\r\n        qs,\r\n        method: \"POST\"\r\n    });\r\n    const raw = (0, utilities_1.fullParse)(response.body, {\r\n        removeNSPrefix: true,\r\n        parseTagValue: false,\r\n        parseAttributeValue: false\r\n    });\r\n    const result = (0, __1.validateParseResult)(atcProposalMessage.decode(raw === null || raw === void 0 ? void 0 : raw.status));\r\n    if ((0, __1.isErrorMessageType)(result.type))\r\n        throw (0, __1.adtException)(result.message);\r\n    return (0, __1.validateParseResult)(atcProposalMessage.decode(result));\r\n}\r\nexports.atcRequestExemption = atcRequestExemption;\r\nasync function atcContactUri(h, findingUri) {\r\n    const headers = {\r\n        \"Content-Type\": \"application/vnd.sap.adt.atc.findingreferences.v1+xml\",\r\n        Accept: \"application/vnd.sap.adt.atc.items.v1+xml\"\r\n    };\r\n    const qs = { step: \"proposal\" };\r\n    const body = `<?xml version=\"1.0\" encoding=\"ASCII\"?>\n    <atcfinding:findingReferences xmlns:adtcore=\"http://www.sap.com/adt/core\" xmlns:atcfinding=\"http://www.sap.com/adt/atc/finding\">\n      <atcfinding:findingReference adtcore:uri=\"${findingUri}\"/>\n    </atcfinding:findingReferences>`;\r\n    const response = await h.request(`/sap/bc/adt/atc/items`, {\r\n        headers,\r\n        body,\r\n        method: \"POST\",\r\n        qs\r\n    });\r\n    const raw = (0, utilities_1.fullParse)(response.body, {\r\n        removeNSPrefix: true,\r\n        parseTagValue: false,\r\n        parseAttributeValue: false\r\n    });\r\n    const { uri } = (0, utilities_1.xmlNodeAttr)((0, utilities_1.xmlNode)(raw, \"items\", \"item\"));\r\n    return (0, __1.validateParseResult)(t.string.decode(uri));\r\n}\r\nexports.atcContactUri = atcContactUri;\r\nasync function atcChangeContact(h, itemUri, userId) {\r\n    const headers = { \"Content-Type\": \"application/vnd.sap.adt.atc.items.v1+xml\" };\r\n    const body = `<?xml version=\"1.0\" encoding=\"ASCII\"?>\n    <atcfinding:items xmlns:adtcore=\"http://www.sap.com/adt/core\" xmlns:atcfinding=\"http://www.sap.com/adt/atc/finding\">\n      <atcfinding:item adtcore:uri=\"${itemUri}\" atcfinding:processor=\"${userId}\" atcfinding:status=\"2\"/>\n    </atcfinding:items>`;\r\n    await h.request(`/sap/bc/adt/atc/items`, { headers, body, method: \"PUT\" });\r\n}\r\nexports.atcChangeContact = atcChangeContact;\r\n","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.unpublishServiceBinding = exports.publishServiceBinding = exports.ddicRepositoryAccess = exports.ddicElement = exports.annotationDefinitions = exports.syntaxCheckCDS = void 0;\r\nconst utilities_1 = require(\"../utilities\");\r\nconst syntax_1 = require(\"./syntax\");\r\nasync function syntaxCheckCDS(h, url, mainUrl, content) {\r\n    const artifacts = mainUrl && content\r\n        ? `<chkrun:artifacts>\n  <chkrun:artifact chkrun:contentType=\"text/plain; charset=utf-8\" chkrun:uri=\"${mainUrl}\">\n      <chkrun:content>${(0, utilities_1.btoa)(content)}</chkrun:content>\n  </chkrun:artifact>\n</chkrun:artifacts>`\r\n        : \"\";\r\n    const response = await h.request(\"/sap/bc/adt/checkruns?reporters=abapCheckRun\", {\r\n        method: \"POST\",\r\n        headers: {\r\n            \"Content-Type\": \"application/vnd.sap.adt.checkobjects+xml\",\r\n            Accept: \"application/vnd.sap.adt.checkmessages+xml\"\r\n        },\r\n        body: `<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<chkrun:checkObjectList xmlns:adtcore=\"http://www.sap.com/adt/core\" xmlns:chkrun=\"http://www.sap.com/adt/checkrun\">\n  <chkrun:checkObject adtcore:uri=\"${url}\" chkrun:version=\"active\">${artifacts}</chkrun:checkObject>\n</chkrun:checkObjectList>`\r\n    });\r\n    const raw = (0, utilities_1.fullParse)(response.body);\r\n    return (0, syntax_1.parseCheckResults)(raw);\r\n}\r\nexports.syntaxCheckCDS = syntaxCheckCDS;\r\nasync function annotationDefinitions(h) {\r\n    const headers = {\r\n        Accept: \"application/vnd.sap.adt.cds.annotation.definitions.v1+xml, application/vnd.sap.adt.cds.annotation.definitions.v2+xml\"\r\n    };\r\n    const response = await h.request(\"/sap/bc/adt/ddic/cds/annotation/definitions\", { headers });\r\n    const raw = (0, utilities_1.fullParse)(response.body);\r\n    return (0, utilities_1.xmlNode)(raw, \"cds:annotation\", \"cds:definitions\");\r\n}\r\nexports.annotationDefinitions = annotationDefinitions;\r\nfunction parseDDICProps(raw) {\r\n    const converted = (0, utilities_1.xmlArray)(raw, \"abapsource:entry\").reduce((prev, cur) => {\r\n        const key = cur[\"@_abapsource:key\"];\r\n        const value = cur[\"#text\"];\r\n        prev[key] = value;\r\n        return prev;\r\n    }, {});\r\n    const { ddicIsKey, ddicDataElement, ddicDataType, ddicLength, ddicDecimals, ddicHeading, ddicLabelShort, ddicLabelMedium, ddicLabelLong, ddicHeadingLength, ddicLabelShortLength, ddicLabelMediumLength, ddicLabelLongLength, parentName, ...rawanno } = converted;\r\n    const elementProps = (ddicDataType || ddicDataType === \"\") && {\r\n        ddicIsKey: !!ddicIsKey,\r\n        ddicDataElement,\r\n        ddicDataType,\r\n        ddicLength,\r\n        ddicDecimals,\r\n        ddicHeading,\r\n        ddicLabelShort,\r\n        ddicLabelMedium,\r\n        ddicLabelLong,\r\n        ddicHeadingLength,\r\n        ddicLabelShortLength,\r\n        ddicLabelMediumLength,\r\n        ddicLabelLongLength,\r\n        parentName\r\n    };\r\n    const annotations = [];\r\n    // tslint:disable-next-line: forin\r\n    for (const key in rawanno) {\r\n        const match = key.match(/annotation(Key|Value).([0-9]+)/);\r\n        if (match && match.groups) {\r\n            const mtype = match.groups[1];\r\n            const idx = (0, utilities_1.toInt)(match.groups[2]);\r\n            const anno = annotations[idx] || { key: \"\", value: \"\" };\r\n            if (mtype === \"Key\")\r\n                anno.key = rawanno[key];\r\n            else\r\n                anno.value = rawanno[key];\r\n            annotations[idx] = anno;\r\n        }\r\n    }\r\n    return {\r\n        elementProps,\r\n        annotations\r\n    };\r\n}\r\nfunction parseDdicElement(raw) {\r\n    const type = raw[\"@_adtcore:type\"];\r\n    const name = raw[\"@_adtcore:name\"];\r\n    const properties = parseDDICProps(raw[\"abapsource:properties\"]);\r\n    const children = (0, utilities_1.xmlArray)(raw, \"abapsource:elementInfo\").map(parseDdicElement);\r\n    return { type, name, properties, children };\r\n}\r\nasync function ddicElement(h, path, getTargetForAssociation = false, getExtensionViews = true, getSecondaryObjects = true) {\r\n    const headers = { Accept: \"application/vnd.sap.adt.elementinfo+xml\" };\r\n    const qs = (0, utilities_1.formatQS)({\r\n        getTargetForAssociation,\r\n        getExtensionViews,\r\n        getSecondaryObjects,\r\n        path\r\n    });\r\n    const uri = `/sap/bc/adt/ddic/ddl/elementinfo?${qs}`;\r\n    const response = await h.request(uri, { headers });\r\n    const raw = (0, utilities_1.fullParse)(response.body);\r\n    return parseDdicElement(raw[\"abapsource:elementInfo\"]);\r\n}\r\nexports.ddicElement = ddicElement;\r\nasync function ddicRepositoryAccess(h, path) {\r\n    const headers = { Accept: \"application/*\" };\r\n    const qs = (0, utilities_1.isArray)(path)\r\n        ? (0, utilities_1.formatQS)({ requestScope: \"all\", path })\r\n        : `datasource=${encodeURIComponent(path)}`;\r\n    const url = `/sap/bc/adt/ddic/ddl/ddicrepositoryaccess?${qs}`;\r\n    const response = await h.request(url, { headers });\r\n    const raw = (0, utilities_1.fullParse)(response.body);\r\n    const records = raw[\"adtcore:objectReferences\"]\r\n        ? (0, utilities_1.xmlArray)(raw, \"adtcore:objectReferences\", \"adtcore:objectReference\")\r\n        : (0, utilities_1.xmlArray)(raw, \"ddl:ddlObjectReferences\", \"ddl:ddlObjectReference\");\r\n    return records.map(r => {\r\n        const attr = (0, utilities_1.xmlNodeAttr)(r);\r\n        return {\r\n            uri: attr[\"adtcore:uri\"] || \"\",\r\n            type: attr[\"adtcore:type\"] || \"\",\r\n            name: attr[\"adtcore:name\"] || \"\",\r\n            path: attr[\"ddl:path\"] || \"\"\r\n        };\r\n    });\r\n}\r\nexports.ddicRepositoryAccess = ddicRepositoryAccess;\r\nasync function publishUnpublishServiceBinding(h, base, name, version) {\r\n    const headers = { Accept: \"application/*\" };\r\n    const qs = `servicename=${encodeURIComponent(name)}&serviceversion=${version}`;\r\n    const url = `/sap/bc/adt/businessservices/odatav2/${base}?${qs}`;\r\n    const body = `<adtcore:objectReferences xmlns:adtcore=\"http://www.sap.com/adt/core\">\n  <adtcore:objectReference adtcore:name=\"${name}\"/>\n  </adtcore:objectReferences>`;\r\n    const response = await h.request(url, { headers, method: \"POST\", body });\r\n    const raw = (0, utilities_1.fullParse)(response.body);\r\n    const data = (0, utilities_1.xmlNode)(raw, \"asx:abap/asx:values/DATA\");\r\n    const severity = (0, utilities_1.xmlNode)(data, \"SEVERITY\");\r\n    const shortText = (0, utilities_1.xmlNode)(data, \"SHORT_TEXT\");\r\n    const longText = (0, utilities_1.xmlNode)(data, \"LONG_TEXT\");\r\n    return { severity, shortText, longText };\r\n}\r\nasync function publishServiceBinding(h, name, version) {\r\n    return publishUnpublishServiceBinding(h, \"publishjobs\", name, version);\r\n}\r\nexports.publishServiceBinding = publishServiceBinding;\r\nasync function unpublishServiceBinding(h, name, version) {\r\n    return publishUnpublishServiceBinding(h, \"unpublishjobs\", name, version);\r\n}\r\nexports.unpublishServiceBinding = unpublishServiceBinding;\r\n","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.debuggerSetVariableValue = exports.debuggerGoToStackOld = exports.debuggerGoToStack = exports.debuggerStep = exports.debuggerVariables = exports.debuggerChildVariables = exports.simpleDebuggerStack = exports.debuggerStack = exports.debuggerSaveSettings = exports.debuggerAttach = exports.debuggerDeleteBreakpoints = exports.debuggerSetBreakpoints = exports.isDebuggerBreakpoint = exports.debuggerDeleteListener = exports.debuggerListen = exports.debuggerListeners = exports.isDebuggee = exports.isDebugListenerError = exports.debugMetaIsComplex = void 0;\r\nconst __1 = require(\"..\");\r\nconst utilities_1 = require(\"../utilities\");\r\nconst urlparser_1 = require(\"./urlparser\");\r\nconst debugMetaIsComplex = (m) => ![\"simple\", \"string\", \"boxedcomp\", \"anonymcomp\", \"unknown\"].find(e => e === m);\r\nexports.debugMetaIsComplex = debugMetaIsComplex;\r\nconst parseStep = (body) => {\r\n    var _a;\r\n    const raw = (0, utilities_1.fullParse)(body, { removeNSPrefix: true });\r\n    checkException(raw);\r\n    const attrs = (0, utilities_1.xmlNodeAttr)(raw.step);\r\n    const settings = (0, utilities_1.xmlNodeAttr)((_a = raw === null || raw === void 0 ? void 0 : raw.step) === null || _a === void 0 ? void 0 : _a.settings);\r\n    const actions = (0, utilities_1.xmlArray)(raw, \"step\", \"actions\", \"action\").map(utilities_1.xmlNodeAttr);\r\n    return { ...attrs, actions, settings };\r\n};\r\nconst convertVariable = (v) => ({\r\n    ...v, TABLE_LINES: (0, utilities_1.toInt)(v.TABLE_LINES),\r\n    LENGTH: (0, utilities_1.toInt)(v.LENGTH),\r\n    INHERITANCE_LEVEL: (0, utilities_1.toInt)(v.INHERITANCE_LEVEL),\r\n    VALUE: v.VALUE,\r\n    ID: v.ID,\r\n    NAME: v.NAME\r\n});\r\nconst parseVariables = (body) => {\r\n    const raw = (0, utilities_1.fullParse)(body, { removeNSPrefix: true, parseTagValue: false, numberParseOptions: utilities_1.numberParseOptions });\r\n    const variables = (0, utilities_1.xmlArray)(raw, \"abap\", \"values\", \"DATA\", \"STPDA_ADT_VARIABLE\")\r\n        .map(convertVariable);\r\n    return variables;\r\n};\r\nconst parseChildVariables = (body) => {\r\n    const raw = (0, utilities_1.fullParse)(body, { removeNSPrefix: true, parseTagValue: false, numberParseOptions: utilities_1.numberParseOptions });\r\n    const hierarchies = (0, utilities_1.xmlArray)(raw, \"abap\", \"values\", \"DATA\", \"HIERARCHIES\", \"STPDA_ADT_VARIABLE_HIERARCHY\");\r\n    const variables = (0, utilities_1.xmlArray)(raw, \"abap\", \"values\", \"DATA\", \"VARIABLES\", \"STPDA_ADT_VARIABLE\")\r\n        .map(convertVariable);\r\n    return { hierarchies, variables };\r\n};\r\nconst parseStack = (body) => {\r\n    const raw = (0, utilities_1.fullParse)(body, { removeNSPrefix: true });\r\n    const stack = (0, utilities_1.xmlArray)(raw, \"stack\", \"stackEntry\")\r\n        .map(utilities_1.xmlNodeAttr)\r\n        .map(x => ({ ...x, uri: (0, urlparser_1.parseUri)(x.uri) }));\r\n    const attrs = (0, utilities_1.xmlNodeAttr)(raw.stack);\r\n    return { ...attrs, stack };\r\n};\r\nconst parseDebugSettings = (body) => {\r\n    const raw = (0, utilities_1.fullParse)(body, { removeNSPrefix: true });\r\n    return (0, utilities_1.xmlNodeAttr)(raw.settings);\r\n};\r\nconst parseAttach = (body) => {\r\n    const raw = (0, utilities_1.fullParse)(body, { removeNSPrefix: true });\r\n    const attrs = (0, utilities_1.xmlNodeAttr)(raw.attach);\r\n    const reachedBreakpoints = (0, utilities_1.xmlArray)(raw, \"attach\", \"reachedBreakpoints\", \"breakpoint\").map(utilities_1.xmlNodeAttr);\r\n    const actions = (0, utilities_1.xmlArray)(raw, \"attach\", \"actions\", \"action\").map(utilities_1.xmlNodeAttr);\r\n    return { ...attrs, actions, reachedBreakpoints };\r\n};\r\nconst parseBreakpoints = (body) => {\r\n    const raw = (0, utilities_1.fullParse)(body, { removeNSPrefix: true });\r\n    return (0, utilities_1.xmlArray)(raw, \"breakpoints\", \"breakpoint\")\r\n        .map(utilities_1.xmlNodeAttr)\r\n        .map(x => {\r\n        if (x.uri)\r\n            return { ...x, uri: (0, urlparser_1.parseUri)(x.uri) };\r\n        return x;\r\n    });\r\n};\r\nconst parseDebugError = (raw) => {\r\n    if (raw.exception) {\r\n        const { namespace: { \"@_id\": namespace }, type: { \"@_id\": type }, localizedMessage, message } = raw.exception;\r\n        const parseMessage = (m) => ({ text: m[\"#text\"], lang: m[\"@_lang\"] });\r\n        const entries = {};\r\n        for (const ex of (0, utilities_1.xmlArray)(raw.exception, \"properties\", \"entry\"))\r\n            entries[ex[\"@_key\"]] = ex[\"#text\"];\r\n        return {\r\n            ...entries,\r\n            namespace,\r\n            type,\r\n            message: parseMessage(message),\r\n            localizedMessage: parseMessage(localizedMessage)\r\n        };\r\n    }\r\n};\r\nconst checkException = (raw) => {\r\n    const e = parseDebugError(raw);\r\n    if (e) {\r\n        const err = new Error(e.message.text);\r\n        err.extra = e;\r\n        throw err;\r\n    }\r\n};\r\nconst isDebugListenerError = (e) => !!e && \"conflictText\" in e && \"com.sap.adt.communicationFramework.subType\" in e;\r\nexports.isDebugListenerError = isDebugListenerError;\r\nconst isDebuggee = (d) => !!d && ![\"CLIENT\", \"DEBUGGEE_ID\", \"TERMINAL_ID\", \"IDE_ID\", \"DEBUGGEE_USER\"].find(f => !(f in d));\r\nexports.isDebuggee = isDebuggee;\r\nconst parseDebugListeners = (body) => {\r\n    if (!body)\r\n        return;\r\n    const raw = (0, utilities_1.fullParse)(body, { removeNSPrefix: true });\r\n    const err = parseDebugError(raw);\r\n    if (err)\r\n        return err;\r\n    const debug = (0, utilities_1.xmlNode)(raw, \"abap\", \"values\", \"DATA\", \"STPDA_DEBUGGEE\");\r\n    return { ...debug, URI: (0, urlparser_1.parseUri)(debug.URI) };\r\n};\r\nasync function debuggerListeners(h, debuggingMode, terminalId, ideId, requestUser, checkConflict = true) {\r\n    const qs = {\r\n        debuggingMode,\r\n        requestUser,\r\n        terminalId,\r\n        ideId,\r\n        checkConflict\r\n    };\r\n    const response = await h.request(\"/sap/bc/adt/debugger/listeners\", { qs });\r\n    if (!response.body)\r\n        return;\r\n    const raw = (0, utilities_1.fullParse)(response.body, { removeNSPrefix: true });\r\n    return parseDebugError(raw);\r\n}\r\nexports.debuggerListeners = debuggerListeners;\r\nasync function debuggerListen(h, debuggingMode, terminalId, ideId, requestUser, checkConflict = true, isNotifiedOnConflict = true) {\r\n    const qs = {\r\n        debuggingMode,\r\n        requestUser,\r\n        terminalId,\r\n        ideId,\r\n        checkConflict,\r\n        isNotifiedOnConflict\r\n    };\r\n    const response = await h.request(\"/sap/bc/adt/debugger/listeners\", {\r\n        method: \"POST\",\r\n        timeout: 360000000,\r\n        qs\r\n    });\r\n    return parseDebugListeners(response.body);\r\n}\r\nexports.debuggerListen = debuggerListen;\r\nasync function debuggerDeleteListener(h, debuggingMode, terminalId, ideId, requestUser) {\r\n    const qs = {\r\n        debuggingMode,\r\n        requestUser,\r\n        terminalId,\r\n        ideId,\r\n        checkConflict: false,\r\n        notifyConflict: true\r\n    };\r\n    await h.request(\"/sap/bc/adt/debugger/listeners\", { method: \"DELETE\", qs });\r\n}\r\nexports.debuggerDeleteListener = debuggerDeleteListener;\r\nconst formatBreakpoint = (clientId) => (b) => {\r\n    if ((0, utilities_1.isString)(b))\r\n        return `<breakpoint xmlns:adtcore=\"http://www.sap.com/adt/core\" kind=\"line\" clientId=\"${clientId}\" skipCount=\"0\" adtcore:uri=\"${b}\"/>`;\r\n    const uri = `adtcore:uri=\"${b.uri.uri}#start=${b.uri.range.start.line}\"`;\r\n    const condition = b.condition ? `condition=\"${b.condition}\"` : ``;\r\n    return `<breakpoint xmlns:adtcore=\"http://www.sap.com/adt/core\" kind=\"${b.kind}\" clientId=\"${b.clientId}\" skipCount=\"0\" ${uri} ${condition}/>`;\r\n};\r\nconst isDebuggerBreakpoint = (x) => \"uri\" in x;\r\nexports.isDebuggerBreakpoint = isDebuggerBreakpoint;\r\nasync function debuggerSetBreakpoints(h, debuggingMode, terminalId, ideId, clientId, breakpoints, requestUser, scope = \"external\", systemDebugging = false, deactivated = false, syncScopeUri = \"\") {\r\n    const syncScope = syncScopeUri ?\r\n        `<syncScope mode=\"partial\"><adtcore:objectReference xmlns:adtcore=\"http://www.sap.com/adt/core\" adtcore:uri=\"${syncScopeUri}\"/></syncScope>`\r\n        : `<syncScope mode=\"full\"></syncScope>`;\r\n    const body = `<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n    <dbg:breakpoints scope=\"${scope}\" debuggingMode=\"${debuggingMode}\" requestUser=\"${requestUser}\" \n        terminalId=\"${terminalId}\" ideId=\"${ideId}\" systemDebugging=\"${systemDebugging}\" deactivated=\"${deactivated}\"\n        xmlns:dbg=\"http://www.sap.com/adt/debugger\">\n        ${syncScope}\n        ${breakpoints.map(formatBreakpoint(clientId)).join(\"\")}\n    </dbg:breakpoints>`;\r\n    const headers = {\r\n        \"Content-Type\": \"application/xml\",\r\n        Accept: \"application/xml\"\r\n    };\r\n    const response = await h.request(\"/sap/bc/adt/debugger/breakpoints\", {\r\n        method: \"POST\",\r\n        headers,\r\n        body\r\n    });\r\n    return parseBreakpoints(response.body);\r\n}\r\nexports.debuggerSetBreakpoints = debuggerSetBreakpoints;\r\nasync function debuggerDeleteBreakpoints(h, breakpoint, debuggingMode, terminalId, ideId, requestUser, scope = \"external\") {\r\n    const headers = { Accept: \"application/xml\" };\r\n    const qs = { scope, debuggingMode, requestUser, terminalId, ideId };\r\n    await h.request(`/sap/bc/adt/debugger/breakpoints/${encodeURIComponent(breakpoint.id)}`, {\r\n        method: \"DELETE\",\r\n        headers,\r\n        qs\r\n    });\r\n}\r\nexports.debuggerDeleteBreakpoints = debuggerDeleteBreakpoints;\r\nasync function debuggerAttach(h, debuggingMode, debuggeeId, requestUser = \"\", dynproDebugging = true) {\r\n    const headers = {\r\n        Accept: \"application/xml\"\r\n    };\r\n    const qs = {\r\n        method: \"attach\",\r\n        debuggeeId,\r\n        dynproDebugging,\r\n        debuggingMode,\r\n        requestUser\r\n    };\r\n    const response = await h.request(\"/sap/bc/adt/debugger\", {\r\n        method: \"POST\",\r\n        headers,\r\n        qs\r\n    });\r\n    return parseAttach(response.body);\r\n}\r\nexports.debuggerAttach = debuggerAttach;\r\nasync function debuggerSaveSettings(h, settings) {\r\n    const headers = {\r\n        \"Content-Type\": \"application/xml\",\r\n        Accept: \"application/xml\"\r\n    };\r\n    const { systemDebugging = false, createExceptionObject = false, backgroundRFC = false, sharedObjectDebugging = false, showDataAging = true, updateDebugging = false } = settings;\r\n    const body = `<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n    <dbg:settings xmlns:dbg=\"http://www.sap.com/adt/debugger\" \n    systemDebugging=\"${systemDebugging}\" createExceptionObject=\"${createExceptionObject}\" \n    backgroundRFC=\"${backgroundRFC}\" sharedObjectDebugging=\"${sharedObjectDebugging}\" \n    showDataAging=\"${showDataAging}\" updateDebugging=\"${updateDebugging}\">\n    </dbg:settings>`;\r\n    const qs = { method: \"setDebuggerSettings\" };\r\n    const response = await h.request(\"/sap/bc/adt/debugger\", {\r\n        method: \"POST\",\r\n        headers,\r\n        body,\r\n        qs\r\n    });\r\n    return parseDebugSettings(response.body);\r\n}\r\nexports.debuggerSaveSettings = debuggerSaveSettings;\r\nasync function debuggerStack(h, semanticURIs = true) {\r\n    const headers = { Accept: \"application/xml\" };\r\n    const qs = { method: \"getStack\", emode: \"_\", semanticURIs };\r\n    const response = await h.request(\"/sap/bc/adt/debugger/stack\", {\r\n        headers,\r\n        qs\r\n    });\r\n    return parseStack(response.body);\r\n}\r\nexports.debuggerStack = debuggerStack;\r\nasync function simpleDebuggerStack(h, semanticURIs = true) {\r\n    const headers = { Accept: \"application/xml\" };\r\n    const qs = { method: \"getStack\", emode: \"_\", semanticURIs };\r\n    const response = await h.request(\"/sap/bc/adt/debugger\", { headers, method: \"POST\", qs });\r\n    return parseStack(response.body);\r\n}\r\nexports.simpleDebuggerStack = simpleDebuggerStack;\r\nasync function debuggerChildVariables(h, parents = [\"@ROOT\", \"@DATAAGING\"]) {\r\n    const headers = {\r\n        Accept: \"application/vnd.sap.as+xml;charset=UTF-8;dataname=com.sap.adt.debugger.ChildVariables\",\r\n        \"Content-Type\": \"application/vnd.sap.as+xml; charset=UTF-8; dataname=com.sap.adt.debugger.ChildVariables\"\r\n    };\r\n    const hierarchies = parents.map(p => `<STPDA_ADT_VARIABLE_HIERARCHY><PARENT_ID>${(0, utilities_1.encodeEntity)(p)}</PARENT_ID></STPDA_ADT_VARIABLE_HIERARCHY>`);\r\n    const body = `<?xml version=\"1.0\" encoding=\"UTF-8\" ?><asx:abap version=\"1.0\" xmlns:asx=\"http://www.sap.com/abapxml\"><asx:values><DATA>\n    <HIERARCHIES>${hierarchies.join(\"\")}</HIERARCHIES>\n    </DATA></asx:values></asx:abap>`;\r\n    const qs = { method: \"getChildVariables\" };\r\n    const response = await h.request(\"/sap/bc/adt/debugger\", { method: \"POST\", headers, qs, body });\r\n    return parseChildVariables(response.body);\r\n}\r\nexports.debuggerChildVariables = debuggerChildVariables;\r\nasync function debuggerVariables(h, parents) {\r\n    const headers = {\r\n        Accept: \"application/vnd.sap.as+xml;charset=UTF-8;dataname=com.sap.adt.debugger.Variables\",\r\n        \"Content-Type\": \"application/vnd.sap.as+xml; charset=UTF-8; dataname=com.sap.adt.debugger.Variables\"\r\n    };\r\n    const mainBody = parents.map(p => `<STPDA_ADT_VARIABLE><ID>${(0, utilities_1.encodeEntity)(p)}</ID></STPDA_ADT_VARIABLE>`).join(\"\");\r\n    const body = `<?xml version=\"1.0\" encoding=\"UTF-8\" ?><asx:abap xmlns:asx=\"http://www.sap.com/abapxml\" version=\"1.0\"><asx:values>\n    <DATA>${mainBody}</DATA></asx:values></asx:abap>`;\r\n    const qs = { method: \"getVariables\" };\r\n    const response = await h.request(\"/sap/bc/adt/debugger\", { method: \"POST\", headers, qs, body });\r\n    return parseVariables(response.body);\r\n}\r\nexports.debuggerVariables = debuggerVariables;\r\nasync function debuggerStep(h, method, uri) {\r\n    const headers = { Accept: \"application/xml\" };\r\n    const response = await h.request(\"/sap/bc/adt/debugger\", { method: \"POST\", headers, qs: { method, uri } });\r\n    return parseStep(response.body);\r\n}\r\nexports.debuggerStep = debuggerStep;\r\nasync function debuggerGoToStack(h, stackUri) {\r\n    if (!stackUri.match(/^\\/sap\\/bc\\/adt\\/debugger\\/stack\\/type\\/[\\w]+\\/position\\/\\d+$/))\r\n        throw (0, __1.adtException)(`Invalid stack URL: ${stackUri}`);\r\n    await h.request(stackUri, { method: \"PUT\" });\r\n}\r\nexports.debuggerGoToStack = debuggerGoToStack;\r\nasync function debuggerGoToStackOld(h, position) {\r\n    const qs = { method: \"setStackPosition\", position };\r\n    await h.request(`/sap/bc/adt/debugger`, { method: \"POST\", qs });\r\n}\r\nexports.debuggerGoToStackOld = debuggerGoToStackOld;\r\nasync function debuggerSetVariableValue(h, variableName, value) {\r\n    const qs = { variableName };\r\n    const resp = await h.request(`/sap/bc/adt/debugger?method=setVariableValue`, { method: \"POST\", qs, body: value });\r\n    return resp.body;\r\n}\r\nexports.debuggerSetVariableValue = debuggerSetVariableValue;\r\n","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.deleteObject = exports.objectRegistrationInfo = void 0;\r\nconst AdtException_1 = require(\"../AdtException\");\r\nconst utilities_1 = require(\"../utilities\");\r\nasync function objectRegistrationInfo(h, objectUrl) {\r\n    (0, AdtException_1.ValidateObjectUrl)(objectUrl);\r\n    const response = await h.request(\"/sap/bc/adt/sscr/registration/objects\", {\r\n        qs: { uri: objectUrl }\r\n    });\r\n    const raw = (0, utilities_1.fullParse)(response.body)[\"reg:objectRegistrationResponse\"];\r\n    return {\r\n        developer: (0, utilities_1.xmlNodeAttr)(raw[\"reg:developer\"]),\r\n        object: (0, utilities_1.xmlNodeAttr)(raw[\"reg:object\"]),\r\n        ...(0, utilities_1.xmlNodeAttr)(raw)\r\n    };\r\n}\r\nexports.objectRegistrationInfo = objectRegistrationInfo;\r\nasync function deleteObject(h, objectUrl, lockHandle, transport) {\r\n    (0, AdtException_1.ValidateObjectUrl)(objectUrl);\r\n    (0, AdtException_1.ValidateStateful)(h);\r\n    const qs = { lockHandle };\r\n    if (transport)\r\n        qs.corrNr = transport;\r\n    const method = \"DELETE\";\r\n    // no return value, will throw on failure\r\n    await h.request(objectUrl, { method, qs });\r\n}\r\nexports.deleteObject = deleteObject;\r\n","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.objectTypes = exports.adtCompatibilityGraph = exports.adtCoreDiscovery = exports.adtDiscovery = void 0;\r\nconst utilities_1 = require(\"../utilities\");\r\nasync function adtDiscovery(h) {\r\n    const response = await h.request(\"/sap/bc/adt/discovery\");\r\n    const ret = (0, utilities_1.fullParse)(response.body);\r\n    const objects = (0, utilities_1.xmlArray)(ret, \"app:service\", \"app:workspace\").map((o) => {\r\n        return {\r\n            collection: (0, utilities_1.xmlArray)(o, \"app:collection\").map((c) => {\r\n                return {\r\n                    href: c[\"@_href\"],\r\n                    templateLinks: (0, utilities_1.xmlArray)(c, \"adtcomp:templateLinks\", \"adtcomp:templateLink\").map(utilities_1.xmlNodeAttr),\r\n                    title: c[\"atom:title\"]\r\n                };\r\n            }),\r\n            title: o[\"atom:title\"]\r\n        };\r\n    });\r\n    return objects;\r\n}\r\nexports.adtDiscovery = adtDiscovery;\r\nasync function adtCoreDiscovery(h) {\r\n    const response = await h.request(\"/sap/bc/adt/core/discovery\");\r\n    const ret = (0, utilities_1.fullParse)(response.body);\r\n    const workspaces = (0, utilities_1.xmlArray)(ret, \"app:service\", \"app:workspace\").filter((w) => w[\"app:collection\"]);\r\n    return workspaces.map((w) => {\r\n        const collection = w[\"app:collection\"];\r\n        return {\r\n            collection: {\r\n                category: collection[\"atom:category\"][\"@_term\"],\r\n                href: collection[\"@_href\"],\r\n                title: collection[\"atom:title\"]\r\n            },\r\n            title: w[\"atom:title\"]\r\n        };\r\n    });\r\n}\r\nexports.adtCoreDiscovery = adtCoreDiscovery;\r\nasync function adtCompatibilityGraph(h) {\r\n    const response = await h.request(\"/sap/bc/adt/compatibility/graph\");\r\n    const ret = (0, utilities_1.fullParse)(response.body);\r\n    const edges = (0, utilities_1.xmlArray)(ret, \"compatibility:graph\", \"edges\", \"edge\").map((e) => {\r\n        return {\r\n            sourceNode: (0, utilities_1.xmlNodeAttr)(e.sourceNode),\r\n            targetNode: (0, utilities_1.xmlNodeAttr)(e.targetNode)\r\n        };\r\n    });\r\n    const nodes = (0, utilities_1.xmlArray)(ret, \"compatibility:graph\", \"nodes\", \"node\").map(utilities_1.xmlNodeAttr);\r\n    return { edges, nodes };\r\n}\r\nexports.adtCompatibilityGraph = adtCompatibilityGraph;\r\nasync function objectTypes(h) {\r\n    const qs = { maxItemCount: 999, name: \"*\", data: \"usedByProvider\" };\r\n    const response = await h.request(\"/sap/bc/adt/repository/informationsystem/objecttypes\", { qs });\r\n    const ret = (0, utilities_1.parse)(response.body);\r\n    const types = (0, utilities_1.xmlArray)(ret, \"nameditem:namedItemList\", \"nameditem:namedItem\")\r\n        .map((n) => {\r\n        const data = n[\"nameditem:data\"] || \"\";\r\n        const fields = data.split(\";\").reduce((acc, cur) => {\r\n            const parts = cur.split(\":\", 2);\r\n            acc[parts[0]] = parts[1] || \"\";\r\n            return acc;\r\n        }, {});\r\n        let o;\r\n        if (fields.type && fields.usedBy)\r\n            o = {\r\n                name: n[\"nameditem:name\"],\r\n                description: n[\"nameditem:description\"],\r\n                type: fields.type,\r\n                usedBy: fields.usedBy.split(\",\")\r\n            };\r\n        return o;\r\n    })\r\n        .filter(x => x);\r\n    return types;\r\n}\r\nexports.objectTypes = objectTypes;\r\n","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.dumps = exports.feeds = void 0;\r\nconst utilities_1 = require(\"../utilities\");\r\nconst parseFeeds = (body) => {\r\n    const raw = (0, utilities_1.fullParse)(body, { removeNSPrefix: true });\r\n    const parseDt = (dt) => {\r\n        const { \"@_id\": id, label = \"\" } = dt;\r\n        const operators = (0, utilities_1.xmlArray)(dt, \"operators\", \"operator\");\r\n        return { id, label, operators: operators.map((o) => o[\"@_id\"]) };\r\n    };\r\n    const parseAttribute = (at) => {\r\n        var _a;\r\n        const dataType = (_a = at.dataType) === null || _a === void 0 ? void 0 : _a[\"@_id\"];\r\n        return { ...parseDt(at), dataType };\r\n    };\r\n    const parseOperators = (op) => ({ ...(0, utilities_1.xmlNodeAttr)(op), label: op.label });\r\n    const feeds = (0, utilities_1.xmlArray)(raw, \"feed\", \"entry\").map((f) => {\r\n        var _a, _b;\r\n        const author = (0, utilities_1.xmlNode)(f, \"author\", \"name\");\r\n        const { href, type: accept } = (0, utilities_1.xmlNodeAttr)(f[\"link\"]);\r\n        const { published, summary, title, updated } = f;\r\n        const ed = f.extendedData;\r\n        const refresh = (0, utilities_1.xmlNodeAttr)((_a = ed === null || ed === void 0 ? void 0 : ed.refresh) === null || _a === void 0 ? void 0 : _a.interval);\r\n        const paging = (_b = ed === null || ed === void 0 ? void 0 : ed.paging) === null || _b === void 0 ? void 0 : _b['@_size'];\r\n        const { queryIsObligatory, queryDepth } = ed;\r\n        const operators = (0, utilities_1.xmlArray)(ed, \"operators\", \"operator\").map(parseOperators);\r\n        const dataTypes = (0, utilities_1.xmlArray)(ed, \"dataTypes\", \"dataType\").map(parseDt);\r\n        const attributes = (0, utilities_1.xmlArray)(ed, \"attributes\", \"attribute\").map(parseAttribute);\r\n        const queryVariants = (0, utilities_1.xmlArray)(ed, \"queryVariants\", \"queryVariant\").map(utilities_1.xmlNodeAttr);\r\n        return {\r\n            author, href, published: (0, utilities_1.parseJsonDate)(published), summary, title, updated: (0, utilities_1.parseJsonDate)(updated), accept, refresh, paging,\r\n            operators, dataTypes, attributes,\r\n            queryIsObligatory, queryDepth, queryVariants\r\n        };\r\n    });\r\n    return feeds;\r\n};\r\nconst parseDumps = (body) => {\r\n    var _a;\r\n    const raw = (_a = (0, utilities_1.fullParse)(body, { removeNSPrefix: true })) === null || _a === void 0 ? void 0 : _a.feed;\r\n    const { href } = (0, utilities_1.xmlNodeAttr)(raw === null || raw === void 0 ? void 0 : raw.link);\r\n    const { title, updated } = raw;\r\n    const dumps = (0, utilities_1.xmlArray)(raw, \"entry\").map((e) => {\r\n        const { category, id, author: { name: author }, summary: { \"#text\": text, \"@_type\": type } } = e;\r\n        const links = (0, utilities_1.xmlArray)(e, \"link\").map(utilities_1.xmlNodeAttr);\r\n        return { categories: category.map(utilities_1.xmlNodeAttr), links, id, author, text: text, type };\r\n    });\r\n    return { href, title, updated: (0, utilities_1.parseJsonDate)(updated), dumps };\r\n};\r\nasync function feeds(h) {\r\n    const headers = { Accept: \"application/atom+xml;type=feed\" };\r\n    const response = await h.request(\"/sap/bc/adt/feeds\", { method: \"GET\", headers });\r\n    return parseFeeds(response.body);\r\n}\r\nexports.feeds = feeds;\r\nasync function dumps(h, query = \"\") {\r\n    const headers = { Accept: \"application/atom+xml;type=feed\" };\r\n    const qs = {};\r\n    if (query)\r\n        qs[\"$query\"] = query;\r\n    const response = await h.request(\"/sap/bc/adt/runtime/dumps\", { method: \"GET\", qs, headers });\r\n    return parseDumps(response.body);\r\n}\r\nexports.dumps = dumps;\r\n","\"use strict\";\r\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    var desc = Object.getOwnPropertyDescriptor(m, k);\r\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\r\n      desc = { enumerable: true, get: function() { return m[k]; } };\r\n    }\r\n    Object.defineProperty(o, k2, desc);\r\n}) : (function(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    o[k2] = m[k];\r\n}));\r\nvar __exportStar = (this && this.__exportStar) || function(m, exports) {\r\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);\r\n};\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\n__exportStar(require(\"./atc\"), exports);\r\n__exportStar(require(\"./cds\"), exports);\r\n__exportStar(require(\"./delete\"), exports);\r\n__exportStar(require(\"./discovery\"), exports);\r\n__exportStar(require(\"./nodeContents\"), exports);\r\n__exportStar(require(\"./transports\"), exports);\r\n__exportStar(require(\"./objectcreator\"), exports);\r\n__exportStar(require(\"./objectstructure\"), exports);\r\n__exportStar(require(\"./activate\"), exports);\r\n__exportStar(require(\"./objectcontents\"), exports);\r\n__exportStar(require(\"./revisions\"), exports);\r\n__exportStar(require(\"./refactor\"), exports);\r\n__exportStar(require(\"./search\"), exports);\r\n__exportStar(require(\"./syntax\"), exports);\r\n__exportStar(require(\"./unittest\"), exports);\r\n__exportStar(require(\"./urlparser\"), exports);\r\n__exportStar(require(\"./abapgit\"), exports);\r\n__exportStar(require(\"./tablecontents\"), exports);\r\n__exportStar(require(\"./feeds\"), exports);\r\n__exportStar(require(\"./debugger\"), exports);\r\n__exportStar(require(\"./traces\"), exports);\r\n","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.nodeContents = exports.isNodeParent = void 0;\r\nconst utilities_1 = require(\"../utilities\");\r\nfunction isNodeParent(t) {\r\n    return t === \"DEVC/K\" || t === \"PROG/P\" || t === \"FUGR/F\" || t === \"PROG/PI\";\r\n}\r\nexports.isNodeParent = isNodeParent;\r\nconst decodeComponents = (keys) => (x) => {\r\n    if ((0, utilities_1.isObject)(x)) {\r\n        const o = keys.reduce((acc, key) => {\r\n            const v = x[key] || \"\";\r\n            return (0, utilities_1.isString)(v) ? { ...acc, [key]: v } : acc;\r\n        }, {});\r\n        return { ...x, ...o };\r\n    }\r\n    return x;\r\n};\r\nconst parsePackageResponse = (data) => {\r\n    let nodes = [];\r\n    let categories = [];\r\n    let objectTypes = [];\r\n    if (data) {\r\n        const xml = (0, utilities_1.parse)(data);\r\n        const root = xml[\"asx:abap\"][\"asx:values\"].DATA;\r\n        nodes = (0, utilities_1.xmlArray)(root, \"TREE_CONTENT\", \"SEU_ADT_REPOSITORY_OBJ_NODE\");\r\n        for (const node of nodes) {\r\n            if (!(0, utilities_1.isString)(node.OBJECT_NAME)) {\r\n                node.OBJECT_NAME = (node.OBJECT_NAME || \"\").toString();\r\n                node.TECH_NAME = (node.TECH_NAME || \"\").toString();\r\n            }\r\n            node.DESCRIPTION = node.DESCRIPTION || \"\";\r\n        }\r\n        categories = (0, utilities_1.xmlArray)(root, \"CATEGORIES\", \"SEU_ADT_OBJECT_CATEGORY_INFO\");\r\n        objectTypes = (0, utilities_1.xmlArray)(root, \"OBJECT_TYPES\", \"SEU_ADT_OBJECT_TYPE_INFO\")\r\n            .map(decodeComponents([\"OBJECT_TYPE_LABEL\"]))\r\n            .map(ot => {\r\n            const o = ot;\r\n            return o.OBJECT_TYPE_LABEL === \"<no type text>\" &&\r\n                o.OBJECT_TYPE === \"FUGR/I\"\r\n                ? { ...o, OBJECT_TYPE_LABEL: \"Includes\" }\r\n                : o;\r\n        });\r\n    }\r\n    return {\r\n        categories,\r\n        nodes,\r\n        objectTypes\r\n    };\r\n};\r\n// tslint:disable: variable-name\r\nasync function nodeContents(h, parent_type, parent_name, user_name, parent_tech_name, rebuild_tree, parentnodes) {\r\n    const qs = {\r\n        parent_type,\r\n        withShortDescriptions: true\r\n    };\r\n    const options = { method: \"POST\", qs };\r\n    if (parent_name)\r\n        qs.parent_name = parent_name;\r\n    if (parent_tech_name)\r\n        qs.parent_tech_name = parent_tech_name;\r\n    if (user_name)\r\n        qs.user_name = user_name;\r\n    if (rebuild_tree)\r\n        qs.rebuild_tree = \"X\";\r\n    if (parentnodes === null || parentnodes === void 0 ? void 0 : parentnodes.length)\r\n        options.body = `<?xml version=\"1.0\" encoding=\"UTF-8\" ?><asx:abap version=\"1.0\" xmlns:asx=\"http://www.sap.com/abapxml\">\n<asx:values><DATA>\n${parentnodes\r\n            .map(n => `<TV_NODEKEY>${n.toString().padStart(6, \"0\")}</TV_NODEKEY>`)\r\n            .join(\"\")}\n<TV_NODEKEY>000000</TV_NODEKEY>\n</DATA></asx:values></asx:abap>\n`;\r\n    const response = await h.request(\"/sap/bc/adt/repository/nodestructure\", options);\r\n    return parsePackageResponse(response.body);\r\n}\r\nexports.nodeContents = nodeContents;\r\n","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.unLock = exports.lock = exports.setObjectSource = exports.getObjectSource = void 0;\r\nconst AdtException_1 = require(\"../AdtException\");\r\nconst utilities_1 = require(\"../utilities\");\r\nasync function getObjectSource(h, objectSourceUrl, options) {\r\n    (0, AdtException_1.ValidateObjectUrl)(objectSourceUrl);\r\n    const config = {};\r\n    const { gitPassword, gitUser, version } = options || {};\r\n    if (gitUser || gitPassword) {\r\n        config.headers = {};\r\n        if (gitUser)\r\n            config.headers.Username = gitUser;\r\n        if (gitPassword)\r\n            config.headers.Password = (0, utilities_1.btoa)(gitPassword);\r\n    }\r\n    if (version)\r\n        config.qs = { version };\r\n    const response = await h.request(objectSourceUrl, config);\r\n    return response.body;\r\n}\r\nexports.getObjectSource = getObjectSource;\r\nasync function setObjectSource(h, objectSourceUrl, source, lockHandle, transport) {\r\n    (0, AdtException_1.ValidateObjectUrl)(objectSourceUrl);\r\n    (0, AdtException_1.ValidateStateful)(h);\r\n    const qs = { lockHandle };\r\n    const ctype = source.match(/^<\\?xml\\s/i)\r\n        ? \"application/*\"\r\n        : \"text/plain; charset=utf-8\";\r\n    if (transport)\r\n        qs.corrNr = transport;\r\n    await h.request(objectSourceUrl, {\r\n        body: source,\r\n        headers: { \"content-type\": ctype },\r\n        method: \"PUT\",\r\n        qs\r\n    });\r\n}\r\nexports.setObjectSource = setObjectSource;\r\nasync function lock(h, objectUrl, accessMode = \"MODIFY\") {\r\n    (0, AdtException_1.ValidateObjectUrl)(objectUrl);\r\n    (0, AdtException_1.ValidateStateful)(h);\r\n    const qs = { _action: \"LOCK\", accessMode };\r\n    const response = await h.request(objectUrl, {\r\n        headers: {\r\n            Accept: \"application/*,application/vnd.sap.as+xml;charset=UTF-8;dataname=com.sap.adt.lock.result\"\r\n        },\r\n        method: \"POST\",\r\n        qs\r\n    });\r\n    const raw = (0, utilities_1.parse)(response.body);\r\n    const locks = (0, utilities_1.xmlArray)(raw, \"asx:abap\", \"asx:values\", \"DATA\");\r\n    return locks[0];\r\n}\r\nexports.lock = lock;\r\nasync function unLock(h, objectUrl, lockHandle) {\r\n    (0, AdtException_1.ValidateObjectUrl)(objectUrl);\r\n    const qs = {\r\n        _action: \"UNLOCK\",\r\n        lockHandle: encodeURIComponent(lockHandle)\r\n    };\r\n    const response = await h.request(objectUrl, {\r\n        method: \"POST\",\r\n        qs\r\n    });\r\n    return response.body;\r\n}\r\nexports.unLock = unLock;\r\n","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.parentTypeId = exports.isCreatableTypeId = exports.isNonGroupType = exports.CreatableTypes = exports.isPackageType = exports.isGroupType = exports.createTestInclude = exports.createObject = exports.validateNewObject = exports.objectPath = exports.loadTypes = exports.isBindingOptions = exports.isPackageOptions = exports.hasPackageOptions = exports.BindinTypes = void 0;\r\nconst sprintf_js_1 = require(\"sprintf-js\");\r\nconst AdtException_1 = require(\"../AdtException\");\r\nconst utilities_1 = require(\"../utilities\");\r\nexports.BindinTypes = [\r\n    { description: \"Odata V2 - Web API\", bindingtype: \"ODATA\", category: \"0\" },\r\n    { description: \"Odata V2 - UI\", bindingtype: \"ODATA\", category: \"1\" }\r\n];\r\nconst hasPackageOptions = (o) => !!(o === null || o === void 0 ? void 0 : o.swcomp);\r\nexports.hasPackageOptions = hasPackageOptions;\r\nconst isPackageOptions = (o) => (o === null || o === void 0 ? void 0 : o.objtype) === \"DEVC/K\" && (0, exports.hasPackageOptions)(o);\r\nexports.isPackageOptions = isPackageOptions;\r\nconst isBindingOptions = (o) => (o === null || o === void 0 ? void 0 : o.objtype) === \"SRVB/SVB\" &&\r\n    !!(o === null || o === void 0 ? void 0 : o.service) &&\r\n    !!(o === null || o === void 0 ? void 0 : o.bindingtype);\r\nexports.isBindingOptions = isBindingOptions;\r\nconst xmlEntry = (value, key) => value ? `<${key}>${(0, utilities_1.encodeEntity)(value)}</${key}>}` : `<${key}/>`;\r\nconst xmlAttribute = (value, key) => value ? `${key}=\"${(0, utilities_1.encodeEntity)(value)}\"` : ``;\r\nfunction createBodyPackage(options) {\r\n    const responsible = `adtcore:responsible=\"${options.responsible}\"`;\r\n    const compname = xmlAttribute(options.swcomp, `pak:name`);\r\n    const description = xmlAttribute(options.description, \"adtcore:description\");\r\n    const superp = xmlAttribute(options.parentName, \"adtcore:name\");\r\n    const pkgname = xmlAttribute(options.name, \"adtcore:name\");\r\n    const pkgtype = xmlAttribute(options.packagetype, \"pak:packageType\");\r\n    return `<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<pak:package xmlns:pak=\"http://www.sap.com/adt/packages\"\nxmlns:adtcore=\"http://www.sap.com/adt/core\" ${description}\n${pkgname} adtcore:type=\"DEVC/K\" adtcore:version=\"active\" ${responsible}>\n<adtcore:packageRef  adtcore:name=\"YMU_RAP\"/>\n<pak:attributes ${pkgtype}/>\n<pak:superPackage ${superp}/>\n<pak:applicationComponent/>\n<pak:transport>\n <pak:softwareComponent ${compname}/>\n <pak:transportLayer pak:name=\"${(0, utilities_1.encodeEntity)(options.transportLayer)}\"/>\n</pak:transport>\n<pak:translation/>\n<pak:useAccesses/>\n<pak:packageInterfaces/>\n<pak:subPackages/>\n</pak:package>`;\r\n}\r\nfunction createBodyFunc(options, type) {\r\n    const responsible = `adtcore:responsible=\"${options.responsible}\"`;\r\n    return `<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n  <${type.rootName} ${type.nameSpace} \n  xmlns:adtcore=\"http://www.sap.com/adt/core\"\n  adtcore:description=\"${(0, utilities_1.encodeEntity)(options.description)}\"\n  adtcore:name=\"${options.name}\" adtcore:type=\"${options.objtype}\">\n  <adtcore:containerRef adtcore:name=\"${options.parentName}\" \n    adtcore:type=\"FUGR/F\"\n    adtcore:uri=\"${options.parentPath}\" />\n</${type.rootName}>`;\r\n}\r\nfunction createBodySimple(options, type, body = \"\") {\r\n    const responsible = `adtcore:responsible=\"${options.responsible}\"`;\r\n    body = body || `<adtcore:packageRef adtcore:name=\"${options.parentName}\"/>`;\r\n    return `<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n        <${type.rootName} ${type.nameSpace}\n          xmlns:adtcore=\"http://www.sap.com/adt/core\"\n          adtcore:description=\"${(0, utilities_1.encodeEntity)(options.description)}\"\n          adtcore:name=\"${options.name}\" adtcore:type=\"${options.objtype}\"\n          ${responsible} ${type.extra || \"\"}>\n          ${body}\n        </${type.rootName}>`;\r\n}\r\nfunction createBodyBinding(options, type) {\r\n    const body = `<adtcore:packageRef adtcore:name=\"${options.parentName}\"/>\n      <srvb:services srvb:name=\"${options.name}\">\n          <srvb:content srvb:version=\"0001\">\n              <srvb:serviceDefinition adtcore:name=\"${options.service}\"/>\n          </srvb:content>\n      </srvb:services>\n      <srvb:binding srvb:category=\"0\" srvb:type=\"${options.bindingtype}\" srvb:version=\"V2\">\n          <srvb:implementation adtcore:name=\"\"/>\n      </srvb:binding>`;\r\n    return createBodySimple(options, type, body);\r\n}\r\nfunction createBody(options, type) {\r\n    switch (type.typeId) {\r\n        case \"DEVC/K\":\r\n            if ((0, exports.isPackageOptions)(options))\r\n                return createBodyPackage(options);\r\n            throw (0, AdtException_1.adtException)(\"Can't create a Package with incomplete data\");\r\n        case \"FUGR/FF\":\r\n        case \"FUGR/I\":\r\n            return createBodyFunc(options, type);\r\n        case \"SRVB/SVB\":\r\n            if ((0, exports.isBindingOptions)(options))\r\n                return createBodyBinding(options, type);\r\n            throw (0, AdtException_1.adtException)(\"Can't create service binding with incomplete data\");\r\n        default:\r\n            return createBodySimple(options, type);\r\n    }\r\n}\r\nasync function loadTypes(h) {\r\n    const response = await h.request(\"/sap/bc/adt/repository/typestructure\", {\r\n        method: \"POST\"\r\n    });\r\n    const raw = (0, utilities_1.fullParse)(response.body);\r\n    return (0, utilities_1.xmlArray)(raw, \"asx:abap\", \"asx:values\", \"DATA\", \"SEU_ADT_OBJECT_TYPE_DESCRIPTOR\").map((x) => {\r\n        return { ...x, CAPABILITIES: (0, utilities_1.xmlArray)(x, \"CAPABILITIES\", \"SEU_ACTION\") };\r\n    });\r\n}\r\nexports.loadTypes = loadTypes;\r\nfunction objectPath(typeIdOrObjectOptions, name, parentName) {\r\n    if (!(0, utilities_1.isString)(typeIdOrObjectOptions))\r\n        return objectPath(typeIdOrObjectOptions.objtype, typeIdOrObjectOptions.name, typeIdOrObjectOptions.parentName);\r\n    const encodedname = encodeURIComponent(name || \"\");\r\n    const ot = exports.CreatableTypes.get(typeIdOrObjectOptions);\r\n    if (!ot)\r\n        return \"\";\r\n    return (\"/sap/bc/adt/\" +\r\n        (0, sprintf_js_1.sprintf)(ot.creationPath, encodeURIComponent(parentName || \"\")) +\r\n        \"/\" +\r\n        encodedname);\r\n}\r\nexports.objectPath = objectPath;\r\nasync function validateNewObject(h, options) {\r\n    const ot = exports.CreatableTypes.get(options.objtype);\r\n    if (!ot)\r\n        throw (0, AdtException_1.adtException)(\"Unsupported object type\");\r\n    if (!ot.validationPath)\r\n        throw (0, AdtException_1.adtException)(`Validation not supported for object ${ot} ${options.objname}`);\r\n    const response = await h.request(\"/sap/bc/adt/\" + ot.validationPath, {\r\n        method: \"POST\",\r\n        qs: options\r\n    });\r\n    const raw = (0, utilities_1.fullParse)(response.body);\r\n    const results = (0, utilities_1.xmlArray)(raw, \"asx:abap\", \"asx:values\", \"DATA\");\r\n    const record = (results && results[0]) || {};\r\n    const { SEVERITY, SHORT_TEXT, CHECK_RESULT } = record;\r\n    if (SEVERITY === \"ERROR\")\r\n        throw (0, AdtException_1.adtException)(record.SHORT_TEXT);\r\n    return {\r\n        SEVERITY,\r\n        SHORT_TEXT,\r\n        success: !!CHECK_RESULT || !!SEVERITY\r\n    };\r\n}\r\nexports.validateNewObject = validateNewObject;\r\nasync function createObject(h, options) {\r\n    const ot = exports.CreatableTypes.get(options.objtype);\r\n    if (!ot)\r\n        throw (0, AdtException_1.adtException)(\"Unsupported object type\");\r\n    const url = \"/sap/bc/adt/\" +\r\n        (0, sprintf_js_1.sprintf)(ot.creationPath, encodeURIComponent(options.parentName.toLowerCase()));\r\n    options.responsible = (options.responsible || h.username).toUpperCase();\r\n    const body = createBody(options, ot);\r\n    const qs = {};\r\n    if (options.transport)\r\n        qs.corrNr = options.transport;\r\n    // will raise exceptions on failure\r\n    await h.request(url, {\r\n        body,\r\n        headers: { \"Content-Type\": \"application/*\" },\r\n        method: \"POST\",\r\n        qs\r\n    });\r\n}\r\nexports.createObject = createObject;\r\nasync function createTestInclude(h, clas, lockHandle, corrNr) {\r\n    const body = `<?xml version=\"1.0\" encoding=\"UTF-8\"?><class:abapClassInclude\n  xmlns:class=\"http://www.sap.com/adt/oo/classes\" xmlns:adtcore=\"http://www.sap.com/adt/core\"\n  adtcore:name=\"dummy\" class:includeType=\"testclasses\"/>`;\r\n    await h.request(`/sap/bc/adt/oo/classes/${encodeURIComponent(clas)}/includes`, {\r\n        body,\r\n        headers: { \"Content-Type\": \"application/*\" },\r\n        method: \"POST\",\r\n        qs: { lockHandle, corrNr }\r\n    });\r\n}\r\nexports.createTestInclude = createTestInclude;\r\nfunction isGroupType(type) {\r\n    return type === \"FUGR/FF\" || type === \"FUGR/I\";\r\n}\r\nexports.isGroupType = isGroupType;\r\nfunction isPackageType(type) {\r\n    return type === \"DEVC/K\";\r\n}\r\nexports.isPackageType = isPackageType;\r\nexports.CreatableTypes = new Map();\r\nfunction isNonGroupType(type) {\r\n    return exports.CreatableTypes.has(type) && !isGroupType(type);\r\n}\r\nexports.isNonGroupType = isNonGroupType;\r\nfunction isCreatableTypeId(type) {\r\n    return isGroupType(type) || isNonGroupType(type);\r\n}\r\nexports.isCreatableTypeId = isCreatableTypeId;\r\nfunction parentTypeId(type) {\r\n    return isGroupType(type) ? \"FUGR/F\" : \"DEVC/K\";\r\n}\r\nexports.parentTypeId = parentTypeId;\r\nconst ctypes = [\r\n    {\r\n        creationPath: \"programs/programs\",\r\n        label: \"Program\",\r\n        nameSpace: 'xmlns:program=\"http://www.sap.com/adt/programs/programs\"',\r\n        rootName: \"program:abapProgram\",\r\n        typeId: \"PROG/P\",\r\n        validationPath: \"programs/validation\",\r\n        maxLen: 30\r\n    },\r\n    {\r\n        creationPath: \"oo/classes\",\r\n        label: \"Class\",\r\n        nameSpace: 'xmlns:class=\"http://www.sap.com/adt/oo/classes\"',\r\n        rootName: \"class:abapClass\",\r\n        typeId: \"CLAS/OC\",\r\n        validationPath: \"oo/validation/objectname\",\r\n        maxLen: 30\r\n    },\r\n    {\r\n        creationPath: \"oo/interfaces\",\r\n        label: \"Interface\",\r\n        nameSpace: 'xmlns:intf=\"http://www.sap.com/adt/oo/interfaces\"',\r\n        rootName: \"intf:abapInterface\",\r\n        typeId: \"INTF/OI\",\r\n        validationPath: \"oo/validation/objectname\",\r\n        maxLen: 30\r\n    },\r\n    {\r\n        creationPath: \"programs/includes\",\r\n        label: \"Include\",\r\n        nameSpace: 'xmlns:include=\"http://www.sap.com/adt/programs/includes\"',\r\n        rootName: \"include:abapInclude\",\r\n        typeId: \"PROG/I\",\r\n        validationPath: \"includes/validation\",\r\n        maxLen: 30\r\n    },\r\n    {\r\n        creationPath: \"functions/groups\",\r\n        label: \"Function Group\",\r\n        nameSpace: 'xmlns:group=\"http://www.sap.com/adt/functions/groups\"',\r\n        rootName: \"group:abapFunctionGroup\",\r\n        typeId: \"FUGR/F\",\r\n        validationPath: \"functions/validation\",\r\n        maxLen: 26\r\n    },\r\n    {\r\n        creationPath: \"functions/groups/%s/fmodules\",\r\n        label: \"Function module\",\r\n        nameSpace: 'xmlns:fmodule=\"http://www.sap.com/adt/functions/fmodules\"',\r\n        rootName: \"fmodule:abapFunctionModule\",\r\n        typeId: \"FUGR/FF\",\r\n        validationPath: \"functions/validation\",\r\n        maxLen: 30\r\n    },\r\n    {\r\n        creationPath: \"functions/groups/%s/includes\",\r\n        label: \"Function group include\",\r\n        nameSpace: 'xmlns:finclude=\"http://www.sap.com/adt/functions/fincludes\"',\r\n        rootName: \"finclude:abapFunctionGroupInclude\",\r\n        typeId: \"FUGR/I\",\r\n        validationPath: \"functions/validation\",\r\n        maxLen: 3\r\n    },\r\n    {\r\n        creationPath: \"ddic/ddl/sources\",\r\n        label: \"CDS Data Definitions\",\r\n        nameSpace: 'xmlns:ddl=\"http://www.sap.com/adt/ddic/ddlsources\"',\r\n        rootName: \"ddl:ddlSource\",\r\n        typeId: \"DDLS/DF\",\r\n        validationPath: \"ddic/ddl/validation\",\r\n        maxLen: 30\r\n    },\r\n    {\r\n        creationPath: \"acm/dcl/sources\",\r\n        label: \"CDS Access Control\",\r\n        nameSpace: 'xmlns:dcl=\"http://www.sap.com/adt/acm/dclsources\"',\r\n        rootName: \"dcl:dclSource\",\r\n        typeId: \"DCLS/DL\",\r\n        validationPath: \"acm/dcl/validation\",\r\n        maxLen: 30\r\n    },\r\n    {\r\n        creationPath: \"ddic/ddlx/sources\",\r\n        label: \"CDS metadata extensions\",\r\n        nameSpace: 'xmlns:ddlx=\"http://www.sap.com/adt/ddic/ddlxsources\"',\r\n        rootName: \"ddlx:ddlxSource\",\r\n        typeId: \"DDLX/EX\",\r\n        validationPath: \"ddic/ddlx/sources/validation\",\r\n        maxLen: 30\r\n    },\r\n    {\r\n        creationPath: \"ddic/ddla/sources\",\r\n        label: \"CDS Annotation definitions\",\r\n        nameSpace: 'xmlns:ddla=\"http://www.sap.com/adt/ddic/ddlasources\"',\r\n        rootName: \"ddla:ddlaSource\",\r\n        typeId: \"DDLA/ADF\",\r\n        validationPath: \"ddic/ddla/sources/validation\",\r\n        maxLen: 30\r\n    },\r\n    {\r\n        creationPath: \"packages\",\r\n        label: \"Package\",\r\n        nameSpace: 'xmlns:pak=\"http://www.sap.com/adt/packages\"',\r\n        rootName: \"pak:package\",\r\n        typeId: \"DEVC/K\",\r\n        validationPath: \"packages/validation\",\r\n        maxLen: 30\r\n    },\r\n    {\r\n        creationPath: \"ddic/tables\",\r\n        label: \"Table\",\r\n        nameSpace: 'xmlns:blue=\"http://www.sap.com/wbobj/blue\"',\r\n        rootName: \"blue:blueSource\",\r\n        typeId: \"TABL/DT\",\r\n        validationPath: \"ddic/tables/validation\",\r\n        maxLen: 16\r\n    },\r\n    {\r\n        creationPath: \"ddic/srvd/sources\",\r\n        label: \"Service definition\",\r\n        nameSpace: 'xmlns:srvd=\"http://www.sap.com/adt/ddic/srvdsources\"',\r\n        rootName: \"srvd:srvdSource\",\r\n        typeId: \"SRVD/SRV\",\r\n        validationPath: \"ddic/srvd/sources/validation\",\r\n        extra: `srvd:srvdSourceType=\"S\"`,\r\n        maxLen: 30\r\n    },\r\n    {\r\n        creationPath: \"aps/iam/auth\",\r\n        rootName: \"auth:auth\",\r\n        nameSpace: 'xmlns:auth=\"http://www.sap.com/iam/auth\"',\r\n        label: \"Authorization field\",\r\n        typeId: \"AUTH\",\r\n        validationPath: \"aps/iam/auth/validation\",\r\n        maxLen: 10\r\n    },\r\n    {\r\n        creationPath: \"aps/iam/suso\",\r\n        validationPath: \"aps/iam/suso/validation\",\r\n        rootName: \"susob:suso\",\r\n        nameSpace: `xmlns:susob=\"http://www.sap.com/iam/suso\"`,\r\n        label: \"Authorization object\",\r\n        typeId: \"SUSO/B\",\r\n        maxLen: 10\r\n    },\r\n    {\r\n        creationPath: \"ddic/dataelements\",\r\n        validationPath: \"ddic/dataelements/validation\",\r\n        rootName: \"blue:wbobj\",\r\n        nameSpace: 'xmlns:blue=\"http://www.sap.com/wbobj/dictionary/dtel\"',\r\n        label: \"Data Element\",\r\n        typeId: \"DTEL/DE\",\r\n        maxLen: 30\r\n    },\r\n    {\r\n        creationPath: \"businessservices/bindings\",\r\n        validationPath: \"businessservices/bindings/validation\",\r\n        rootName: \"srvb:serviceBinding\",\r\n        nameSpace: 'xmlns:srvb=\"http://www.sap.com/adt/ddic/ServiceBindings\"',\r\n        label: \"Service binding\",\r\n        typeId: \"SRVB/SVB\",\r\n        maxLen: 26\r\n    },\r\n    {\r\n        creationPath: \"messageclass\",\r\n        validationPath: \"messageclass/validation\",\r\n        rootName: \"mc:messageClass\",\r\n        nameSpace: `xmlns:mc=\"http://www.sap.com/adt/MessageClass\"`,\r\n        label: \"Message class\",\r\n        typeId: \"MSAG/N\",\r\n        maxLen: 20\r\n    }\r\n];\r\nctypes.forEach(v => exports.CreatableTypes.set(v.typeId, v));\r\n","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.objectStructure = exports.isClassStructure = exports.isClassMetaData = void 0;\r\nconst AdtException_1 = require(\"../AdtException\");\r\nconst utilities_1 = require(\"../utilities\");\r\nfunction isClassMetaData(meta) {\r\n    return meta[\"class:visibility\"] !== undefined;\r\n}\r\nexports.isClassMetaData = isClassMetaData;\r\nfunction isClassStructure(struc) {\r\n    return isClassMetaData(struc.metaData);\r\n}\r\nexports.isClassStructure = isClassStructure;\r\nconst convertIncludes = (i) => {\r\n    const imeta = (0, utilities_1.xmlNodeAttr)(i);\r\n    const links = i[\"atom:link\"].map(utilities_1.xmlNodeAttr);\r\n    return { ...imeta, links };\r\n};\r\nasync function objectStructure(h, objectUrl, version) {\r\n    (0, AdtException_1.ValidateObjectUrl)(objectUrl);\r\n    const qs = version ? { version } : {};\r\n    const response = await h.request(objectUrl, { qs });\r\n    const res = (0, utilities_1.fullParse)(response.body);\r\n    // return type depends on object type, but always have a single root\r\n    const root = (0, utilities_1.xmlRoot)(res);\r\n    const attr = (0, utilities_1.xmlNodeAttr)(root);\r\n    attr[\"adtcore:changedAt\"] = Date.parse(attr[\"adtcore:changedAt\"]) || 0;\r\n    attr[\"adtcore:createdAt\"] = Date.parse(attr[\"adtcore:createdAt\"]) || 0;\r\n    const links = (0, utilities_1.xmlArray)(root, \"atom:link\").map(utilities_1.xmlNodeAttr);\r\n    const metaData = attr;\r\n    if (isClassMetaData(metaData)) {\r\n        const includes = (0, utilities_1.xmlArray)(root, \"class:include\").map(convertIncludes);\r\n        return { objectUrl, metaData, includes, links };\r\n    }\r\n    return { objectUrl, metaData, links };\r\n}\r\nexports.objectStructure = objectStructure;\r\n","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.extractMethodExecute = exports.extractMethodPreview = exports.extractMethodEvaluate = exports.renameExecute = exports.renamePreview = exports.renameEvaluate = exports.fixEdits = exports.fixProposals = void 0;\r\nconst html_entities_1 = require(\"html-entities\");\r\nconst _1 = require(\".\");\r\nconst AdtException_1 = require(\"../AdtException\");\r\nconst utilities_1 = require(\"../utilities\");\r\nconst urlparser_1 = require(\"./urlparser\");\r\nasync function fixProposals(h, uri, body, line, column) {\r\n    const qs = { uri: `${uri}#start=${line},${column}` };\r\n    const headers = { \"Content-Type\": \"application/*\", Accept: \"application/*\" };\r\n    const response = await h.request(\"/sap/bc/adt/quickfixes/evaluation\", {\r\n        method: \"POST\",\r\n        qs,\r\n        headers,\r\n        body\r\n    });\r\n    const raw = (0, utilities_1.fullParse)(response.body, { processEntities: false });\r\n    const rawResults = (0, utilities_1.xmlArray)(raw, \"qf:evaluationResults\", \"evaluationResult\");\r\n    return rawResults.map(x => {\r\n        const attrs = (0, utilities_1.xmlNodeAttr)((0, utilities_1.xmlNode)(x, \"adtcore:objectReference\"));\r\n        const userContent = (0, html_entities_1.decode)((0, utilities_1.xmlNode)(x, \"userContent\") || \"\");\r\n        return {\r\n            ...attrs,\r\n            \"adtcore:name\": attrs[\"adtcore:name\"],\r\n            \"adtcore:description\": attrs[\"adtcore:description\"],\r\n            uri,\r\n            line,\r\n            column,\r\n            userContent\r\n        };\r\n    });\r\n}\r\nexports.fixProposals = fixProposals;\r\nasync function fixEdits(h, proposal, source) {\r\n    if (!proposal[\"adtcore:uri\"].match(/\\/sap\\/bc\\/adt\\/quickfixes/))\r\n        throw (0, AdtException_1.adtException)(\"Invalid fix proposal\");\r\n    const body = `<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n  <quickfixes:proposalRequest xmlns:quickfixes=\"http://www.sap.com/adt/quickfixes\"\n     xmlns:adtcore=\"http://www.sap.com/adt/core\">\n    <input>\n      <content>${(0, utilities_1.encodeEntity)(source)}</content>\n      <adtcore:objectReference adtcore:uri=\"${proposal.uri}#start=${proposal.line},${proposal.column}\"/>\n    </input>\n    <userContent>${(0, utilities_1.encodeEntity)(proposal.userContent)}</userContent>\n  </quickfixes:proposalRequest>`;\r\n    const headers = { \"Content-Type\": \"application/*\", Accept: \"application/*\" };\r\n    const response = await h.request(proposal[\"adtcore:uri\"], {\r\n        method: \"POST\",\r\n        headers,\r\n        body\r\n    });\r\n    const raw = (0, utilities_1.fullParse)(response.body);\r\n    const parseDelta = (d) => {\r\n        const attr = (0, utilities_1.xmlNodeAttr)((0, utilities_1.xmlNode)(d, \"adtcore:objectReference\"));\r\n        const content = d.content;\r\n        const { uri, range } = (0, urlparser_1.parseUri)(attr[\"adtcore:uri\"]);\r\n        return {\r\n            uri,\r\n            range,\r\n            name: attr[\"adtcore:name\"],\r\n            type: attr[\"adtcore:type\"],\r\n            content\r\n        };\r\n    };\r\n    const deltas = (0, utilities_1.xmlArray)(raw, \"qf:proposalResult\", \"deltas\", \"unit\").map(parseDelta);\r\n    return deltas;\r\n}\r\nexports.fixEdits = fixEdits;\r\nconst parseGeneric = (generic) => {\r\n    const affectedObjects = (0, utilities_1.xmlArray)(generic, \"affectedObjects\", \"affectedObject\").map(o => {\r\n        const { uri, type, name, parentUri } = (0, utilities_1.xmlNodeAttr)(o);\r\n        const textReplaceDeltas = (0, utilities_1.xmlArray)(o, \"textReplaceDeltas\", \"textReplaceDelta\").map(z => {\r\n            return {\r\n                rangeFragment: (0, urlparser_1.parseUri)((0, utilities_1.xmlNode)(z, \"rangeFragment\")).range,\r\n                contentOld: (0, utilities_1.xmlNode)(z, \"contentOld\"),\r\n                contentNew: (0, utilities_1.xmlNode)(z, \"contentNew\")\r\n            };\r\n        });\r\n        return {\r\n            uri,\r\n            type,\r\n            name,\r\n            parentUri,\r\n            userContent: o.userContent,\r\n            textReplaceDeltas\r\n        };\r\n    });\r\n    const { ignoreSyntaxErrorsAllowed, ignoreSyntaxErrors, transport, userContent = \"\", adtObjectUri = \"\", title } = generic;\r\n    return {\r\n        title,\r\n        ignoreSyntaxErrorsAllowed,\r\n        ignoreSyntaxErrors,\r\n        transport,\r\n        adtObjectUri: (0, urlparser_1.parseUri)(adtObjectUri),\r\n        userContent: (0, html_entities_1.decode)(userContent),\r\n        affectedObjects\r\n    };\r\n};\r\nfunction parseRenameRefactoring(body) {\r\n    const raw = (0, utilities_1.fullParse)(body, { removeNSPrefix: true });\r\n    const root = (0, utilities_1.xmlNode)(raw, \"renameRefactoring\");\r\n    const { ignoreSyntaxErrorsAllowed, ignoreSyntaxErrors, transport, adtObjectUri, affectedObjects, userContent } = parseGeneric((0, utilities_1.xmlNode)(root || raw, \"genericRefactoring\")); // depending on the caller the generic refactoring might be wrapped or not\r\n    return {\r\n        oldName: (0, utilities_1.xmlNode)(root, \"oldName\") || \"\",\r\n        newName: (0, utilities_1.xmlNode)(root, \"newName\") || \"\",\r\n        adtObjectUri,\r\n        ignoreSyntaxErrorsAllowed: !!ignoreSyntaxErrorsAllowed,\r\n        ignoreSyntaxErrors: !!ignoreSyntaxErrors,\r\n        transport,\r\n        affectedObjects,\r\n        userContent: userContent\r\n    };\r\n}\r\nasync function renameEvaluate(h, uri, line, startColumn, endColumn) {\r\n    const qs = {\r\n        step: `evaluate`,\r\n        rel: `http://www.sap.com/adt/relations/refactoring/rename`,\r\n        uri: `${uri}#start=${line},${startColumn};end=${line},${endColumn}`\r\n    };\r\n    const headers = { \"Content-Type\": \"application/*\", Accept: \"application/*\" };\r\n    const response = await h.request(\"/sap/bc/adt/refactorings\", {\r\n        method: \"POST\",\r\n        qs: qs,\r\n        headers: headers\r\n    });\r\n    return parseRenameRefactoring(response.body);\r\n}\r\nexports.renameEvaluate = renameEvaluate;\r\nconst serializeAffectedObject = (o) => {\r\n    const pu = o.parentUri ? `adtcore:parentUri=\"${o.parentUri}\"` : \"\";\r\n    return `<generic:affectedObject adtcore:name=\"${o.name}\" ${pu} adtcore:type=\"${o.type}\" adtcore:uri=\"${o.uri}\">\n        <generic:textReplaceDeltas>\n          ${o.textReplaceDeltas\r\n        .map(y => {\r\n        return `<generic:textReplaceDelta>\n            <generic:rangeFragment>${(0, _1.rangeToString)(y.rangeFragment)}</generic:rangeFragment>\n            <generic:contentOld>${(0, utilities_1.encodeEntity)(y.contentOld)}</generic:contentOld>\n            <generic:contentNew>${(0, utilities_1.encodeEntity)(y.contentNew)}</generic:contentNew>\n          </generic:textReplaceDelta>`;\r\n    })\r\n        .join(\"\")}\n          </generic:textReplaceDeltas>\n        <generic:userContent>${o.userContent}</generic:userContent>\n      </generic:affectedObject>`;\r\n};\r\nconst serializeGenericRefactoring = (g) => {\r\n    return `<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<generic:genericRefactoring xmlns:adtcore=\"http://www.sap.com/adt/core\" xmlns:generic=\"http://www.sap.com/adt/refactoring/genericrefactoring\">\n  <generic:title>${g.title}</generic:title>\n  <generic:adtObjectUri>${(0, urlparser_1.uriPartsToString)(g.adtObjectUri)}</generic:adtObjectUri>\n  <generic:affectedObjects>\n  ${g.affectedObjects.map(serializeAffectedObject).join(\"\\n\")}\n  </generic:affectedObjects>\n  <generic:transport>${g.transport}</generic:transport>\n  <generic:ignoreSyntaxErrorsAllowed>${g.ignoreSyntaxErrorsAllowed}</generic:ignoreSyntaxErrorsAllowed>\n  <generic:ignoreSyntaxErrors>${g.ignoreSyntaxErrors}</generic:ignoreSyntaxErrors>\n  <generic:userContent/>\n</generic:genericRefactoring>`;\r\n};\r\nconst srializeRefactoring = (renameRefactoring, wrapped, transport = \"\") => {\r\n    const start = wrapped\r\n        ? `<rename:renameRefactoring xmlns:adtcore=\"http://www.sap.com/adt/core\" xmlns:generic=\"http://www.sap.com/adt/refactoring/genericrefactoring\" \n  xmlns:rename=\"http://www.sap.com/adt/refactoring/renamerefactoring\">\n  <rename:oldName>${renameRefactoring.oldName}</rename:oldName>\n  <rename:newName>${renameRefactoring.newName}</rename:newName>`\r\n        : \"\";\r\n    const end = wrapped ? `<rename:userContent/></rename:renameRefactoring>` : \"\";\r\n    const genns = wrapped\r\n        ? \"\"\r\n        : ` xmlns:generic=\"http://www.sap.com/adt/refactoring/genericrefactoring\" xmlns:adtcore=\"http://www.sap.com/adt/core\"`;\r\n    const addAffectedObjects = (affectedObject) => affectedObject.map(serializeAffectedObject);\r\n    const bodyXml = `<?xml version=\"1.0\" encoding=\"ASCII\"?>\n  ${start}\n    <generic:genericRefactoring ${genns}>\n      <generic:title>Rename Field</generic:title>\n      <generic:adtObjectUri>${renameRefactoring.adtObjectUri.uri}${(0, _1.rangeToString)(renameRefactoring.adtObjectUri.range)}</generic:adtObjectUri>\n      <generic:affectedObjects>\n        ${addAffectedObjects(renameRefactoring.affectedObjects).join(\"\")}\n      </generic:affectedObjects>\n      <generic:transport>${renameRefactoring.transport || transport}</generic:transport>\n      <generic:ignoreSyntaxErrorsAllowed>${renameRefactoring.ignoreSyntaxErrorsAllowed}</generic:ignoreSyntaxErrorsAllowed>\n      <generic:ignoreSyntaxErrors>${renameRefactoring.ignoreSyntaxErrors}</generic:ignoreSyntaxErrors>\n      <generic:userContent/>\n    </generic:genericRefactoring>\n    ${end}`;\r\n    return bodyXml;\r\n};\r\nconst extractMethodBody = (proposal) => {\r\n    const parameters = proposal.parameters\r\n        .map(p => `<extractmethod:parameter>\n      <extractmethod:id>${(0, utilities_1.encodeEntity)(p.id)}</extractmethod:id>\n      <extractmethod:name>${p.name}</extractmethod:name>\n      <extractmethod:direction>${p.direction}</extractmethod:direction>\n      <extractmethod:byValue>${p.byValue}</extractmethod:byValue>\n      <extractmethod:typeType>${p.typeType}</extractmethod:typeType>\n      <extractmethod:type>${p.type}</extractmethod:type>\n      <extractmethod:userContent>${(0, utilities_1.encodeEntity)(p.userContent)}</extractmethod:userContent>\n    </extractmethod:parameter>`)\r\n        .join(\"\\n\");\r\n    const exceptions = proposal.exceptions\r\n        .map(e => `<extractmethod:exception>\n      <extractmethod:name>${e.name}</extractmethod:name>\n      <extractmethod:resumable>${e.resumable}</extractmethod:resumable>\n      <extractmethod:userContent>${e.userContent}</extractmethod:userContent>\n    </extractmethod:exception>`)\r\n        .join(\"\\n\");\r\n    const exc = exceptions.length\r\n        ? `<extractmethod:exceptions>${exceptions}</extractmethod:exceptions>  `\r\n        : `<extractmethod:exceptions/>`;\r\n    const gr = proposal.genericRefactoring;\r\n    const affected = gr.affectedObjects\r\n        .map(o => {\r\n        const deltas = o.textReplaceDeltas.length === 0\r\n            ? undefined\r\n            : o.textReplaceDeltas\r\n                .map(d => `<generic:textReplaceDelta> <generic:rangeFragment>${d.rangeFragment}</generic:rangeFragment> <generic:contentOld>${(0, utilities_1.encodeEntity)(d.contentOld)}</generic:contentOld> <generic:contentNew>${(0, utilities_1.encodeEntity)(d.contentNew)}</generic:contentNew> </generic:textReplaceDelta>`)\r\n                .join(\"\\n\");\r\n        const delta = deltas\r\n            ? `<generic:textReplaceDeltas>${deltas}</generic:textReplaceDeltas>`\r\n            : ``;\r\n        return `<generic:affectedObject adtcore:name=\"${o.name}\" adtcore:parentUri=\"${o.parentUri}\" adtcore:type=\"${o.type}\" adtcore:uri=\"${o.uri}\">\n        <generic:userContent>${o.userContent}</generic:userContent>\n        ${delta}\n      </generic:affectedObject>`;\r\n    })\r\n        .join(\"\\n\");\r\n    return `<?xml version=\"1.0\" encoding=\"ASCII\"?>\n<extractmethod:extractMethodRefactoring xmlns:adtcore=\"http://www.sap.com/adt/core\" xmlns:extractmethod=\"http://www.sap.com/adt/refactoring/extractmethodrefactoring\" xmlns:generic=\"http://www.sap.com/adt/refactoring/genericrefactoring\">\n  <extractmethod:name>${proposal.name}</extractmethod:name>\n  <extractmethod:isStatic>${proposal.isStatic}</extractmethod:isStatic>\n  <extractmethod:visibility>${proposal.visibility}</extractmethod:visibility>\n  <extractmethod:classBasedExceptions>${proposal.classBasedExceptions}</extractmethod:classBasedExceptions>\n  <extractmethod:parameters>\n  ${parameters}\n  </extractmethod:parameters>\n  ${exc}\n  <extractmethod:content>${(0, utilities_1.encodeEntity)(proposal.content)}</extractmethod:content>\n  <generic:genericRefactoring>\n    <generic:title>${gr.title}</generic:title>\n    <generic:adtObjectUri>${(0, urlparser_1.uriPartsToString)(gr.adtObjectUri)}</generic:adtObjectUri>\n    <generic:affectedObjects>\n    ${affected}\n    </generic:affectedObjects>\n    <generic:transport>${gr.transport}</generic:transport>\n    <generic:ignoreSyntaxErrorsAllowed>${gr.ignoreSyntaxErrorsAllowed}</generic:ignoreSyntaxErrorsAllowed>\n    <generic:ignoreSyntaxErrors>${gr.ignoreSyntaxErrors}</generic:ignoreSyntaxErrors>\n    <generic:userContent>${gr.userContent}</generic:userContent>\n  </generic:genericRefactoring>\n  <extractmethod:className>ZAPIADT_TESTCASE_CLASS1${proposal}</extractmethod:className>\n  <extractmethod:isEventAllowed>${proposal.isEventAllowed}</extractmethod:isEventAllowed>\n  <extractmethod:isEvent>${proposal.isEvent}</extractmethod:isEvent>\n  <extractmethod:userContent>${(0, utilities_1.encodeEntity)(proposal.userContent)}</extractmethod:userContent>\n  <extractmethod:isForTesting>${proposal.isForTesting}</extractmethod:isForTesting>\n</extractmethod:extractMethodRefactoring>`;\r\n};\r\nconst parseExtractMethodEval = (body) => {\r\n    const root = (0, utilities_1.fullParse)(body, {\r\n        removeNSPrefix: true\r\n    }).extractMethodRefactoring;\r\n    const parameters = (0, utilities_1.xmlArray)(root, \"parameters\", \"parameter\");\r\n    const exceptions = (0, utilities_1.xmlArray)(root, \"exceptions\", \"exception\");\r\n    const { name, isStatic, visibility, classBasedExceptions, content, className, isEventAllowed, isEvent, userContent } = root;\r\n    const genericRefactoring = parseGeneric(root.genericRefactoring);\r\n    const resp = {\r\n        name,\r\n        isStatic,\r\n        visibility,\r\n        classBasedExceptions,\r\n        genericRefactoring,\r\n        content,\r\n        className,\r\n        isForTesting: false,\r\n        isEventAllowed,\r\n        isEvent,\r\n        userContent: (0, html_entities_1.decode)(userContent),\r\n        parameters,\r\n        exceptions\r\n    };\r\n    return resp;\r\n};\r\nasync function renamePreview(h, renameRefactoring, transport) {\r\n    const qs = {\r\n        step: `preview`,\r\n        rel: `http://www.sap.com/adt/relations/refactoring/rename`\r\n    };\r\n    const bodyXml = srializeRefactoring(renameRefactoring, true, transport);\r\n    const headers = { \"Content-Type\": \"application/*\", Accept: \"application/*\" };\r\n    const response = await h.request(\"/sap/bc/adt/refactorings\", {\r\n        method: \"POST\",\r\n        qs: qs,\r\n        body: bodyXml,\r\n        headers: headers\r\n    });\r\n    const parsed = parseRenameRefactoring(response.body);\r\n    return { ...parsed, transport: parsed.transport || transport };\r\n}\r\nexports.renamePreview = renamePreview;\r\nasync function renameExecute(h, rename) {\r\n    const qs = {\r\n        step: `execute`\r\n    };\r\n    const headers = { \"Content-Type\": \"application/*\", Accept: \"application/*\" };\r\n    const body = srializeRefactoring(rename, false);\r\n    const response = await h.request(\"/sap/bc/adt/refactorings\", {\r\n        method: \"POST\",\r\n        qs: qs,\r\n        body,\r\n        headers: headers\r\n    });\r\n    const result = parseRenameRefactoring(response.body);\r\n    return { ...result, transport: result.transport || rename.transport };\r\n}\r\nexports.renameExecute = renameExecute;\r\nasync function extractMethodEvaluate(h, uri, range) {\r\n    const qs = {\r\n        step: `evaluate`,\r\n        rel: `http://www.sap.com/adt/relations/refactoring/extractmethod`,\r\n        uri: `${uri}#start=${range.start.line},${range.start.column};end=${range.end.line},${range.end.column}`\r\n    };\r\n    const headers = { \"Content-Type\": \"application/*\", Accept: \"application/*\" };\r\n    const opts = { method: \"POST\", qs, headers };\r\n    const response = await h.request(\"/sap/bc/adt/refactorings\", opts);\r\n    return parseExtractMethodEval(response.body);\r\n}\r\nexports.extractMethodEvaluate = extractMethodEvaluate;\r\nasync function extractMethodPreview(h, proposal) {\r\n    const body = extractMethodBody(proposal);\r\n    const qs = {\r\n        step: `preview`,\r\n        rel: `http://www.sap.com/adt/relations/refactoring/extractmethod`\r\n    };\r\n    const headers = { \"Content-Type\": \"application/*\", Accept: \"application/*\" };\r\n    const opts = { method: \"POST\", qs, headers, body };\r\n    const response = await h.request(\"/sap/bc/adt/refactorings\", opts);\r\n    const raw = (0, utilities_1.fullParse)(response.body, {\r\n        removeNSPrefix: true\r\n    }).genericRefactoring;\r\n    return parseGeneric(raw);\r\n}\r\nexports.extractMethodPreview = extractMethodPreview;\r\nasync function extractMethodExecute(h, refactoring) {\r\n    const body = serializeGenericRefactoring(refactoring);\r\n    const qs = { step: `execute` };\r\n    const headers = { \"Content-Type\": \"application/*\", Accept: \"application/*\" };\r\n    const opts = { method: \"POST\", qs, headers, body };\r\n    const response = await h.request(\"/sap/bc/adt/refactorings\", opts);\r\n    const raw = (0, utilities_1.fullParse)(response.body, {\r\n        removeNSPrefix: true\r\n    }).genericRefactoring;\r\n    return parseGeneric(raw);\r\n}\r\nexports.extractMethodExecute = extractMethodExecute;\r\n","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.revisions = exports.getRevisionLink = void 0;\r\nconst AdtException_1 = require(\"../AdtException\");\r\nconst utilities_1 = require(\"../utilities\");\r\nconst objectstructure_1 = require(\"./objectstructure\");\r\nfunction extractRevisionLink(links) {\r\n    return links.find(l => l.rel === \"http://www.sap.com/adt/relations/versions\");\r\n}\r\nfunction getRevisionLink(struct, includeName) {\r\n    let link;\r\n    if ((0, objectstructure_1.isClassStructure)(struct)) {\r\n        const iname = includeName || \"main\";\r\n        const include = struct.includes.find(i => i[\"class:includeType\"] === iname);\r\n        if (include)\r\n            link = extractRevisionLink(include.links);\r\n    }\r\n    else {\r\n        link = extractRevisionLink(struct.links);\r\n    }\r\n    if (link)\r\n        return (0, utilities_1.followUrl)(struct.objectUrl, link.href);\r\n    return \"\";\r\n}\r\nexports.getRevisionLink = getRevisionLink;\r\nconst extractVersion = (entry) => {\r\n    const ADTTYPE = \"application/vnd.sap.adt.transportrequests.v1+xml\";\r\n    const base = (0, utilities_1.xmlNode)(entry, \"atom:link\");\r\n    if (Array.isArray(base)) {\r\n        const vlink = base.find(l => l[\"@_type\"] === ADTTYPE) || base[0];\r\n        return (0, utilities_1.xmlNode)(vlink, \"@_adtcore:name\") || \"\";\r\n    }\r\n    else\r\n        return (0, utilities_1.xmlNode)(base, \"@_adtcore:name\") || \"\";\r\n};\r\nasync function revisions(h, objectUrl, includeName) {\r\n    const str = (0, utilities_1.isString)(objectUrl)\r\n        ? await (0, objectstructure_1.objectStructure)(h, objectUrl)\r\n        : objectUrl;\r\n    const name = str.metaData[\"adtcore:name\"];\r\n    const revisionUrl = getRevisionLink(str, includeName);\r\n    if (!revisionUrl)\r\n        throw (0, AdtException_1.adtException)(`Revision URL not found for object ${name}`);\r\n    const headers = { Accept: \"application/atom+xml;type=feed\" };\r\n    const response = await h.request(revisionUrl, {\r\n        method: \"GET\",\r\n        headers\r\n    });\r\n    const raw = (0, utilities_1.fullParse)(response.body);\r\n    const versions = (0, utilities_1.xmlArray)(raw, \"atom:feed\", \"atom:entry\").map((entry) => {\r\n        const uri = (0, utilities_1.xmlNode)(entry, \"atom:content\", \"@_src\") || \"\";\r\n        const version = extractVersion(entry);\r\n        const versionTitle = (0, utilities_1.xmlNode)(entry, \"atom:title\") || \"\";\r\n        const date = (0, utilities_1.xmlNode)(entry, \"atom:updated\") || \"\";\r\n        const author = (0, utilities_1.xmlNode)(entry, \"atom:author\", \"atom:name\");\r\n        const r = { uri, version, versionTitle, date, author };\r\n        return r;\r\n    });\r\n    return versions;\r\n}\r\nexports.revisions = revisions;\r\n","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.packageSearchHelp = exports.abapDocumentation = exports.findObjectPath = exports.searchObject = void 0;\r\nconst AdtException_1 = require(\"../AdtException\");\r\nconst utilities_1 = require(\"../utilities\");\r\nasync function searchObject(h, query, objType, maxResults = 100) {\r\n    const qs = { operation: \"quickSearch\", query, maxResults };\r\n    if (objType)\r\n        qs.objectType = objType.replace(/\\/.*$/, \"\");\r\n    const response = await h.request(`/sap/bc/adt/repository/informationsystem/search`, { qs, headers: { Accept: \"application/*\" } });\r\n    const raw = (0, utilities_1.fullParse)(response.body);\r\n    return (0, utilities_1.xmlArray)(raw, \"adtcore:objectReferences\", \"adtcore:objectReference\").map((sr) => {\r\n        const result = (0, utilities_1.xmlNodeAttr)(sr);\r\n        // older systems return things like \"ZREPORT (PROGRAM)\"...\r\n        const r = result[\"adtcore:name\"].match(/([^\\s]*)\\s*\\((.*)\\)/);\r\n        if (r) {\r\n            result[\"adtcore:name\"] = r[1];\r\n            if (!result[\"adtcore:description\"])\r\n                result[\"adtcore:description\"] = r[2];\r\n        }\r\n        return result;\r\n    });\r\n}\r\nexports.searchObject = searchObject;\r\nasync function findObjectPath(h, objectUrl) {\r\n    (0, AdtException_1.ValidateObjectUrl)(objectUrl);\r\n    const qs = { uri: objectUrl };\r\n    const response = await h.request(`/sap/bc/adt/repository/nodepath`, {\r\n        method: \"POST\",\r\n        qs\r\n    });\r\n    const raw = (0, utilities_1.fullParse)(response.body);\r\n    return (0, utilities_1.xmlArray)(raw, \"projectexplorer:nodepath\", \"projectexplorer:objectLinkReferences\", \"objectLinkReference\").map(utilities_1.xmlNodeAttr);\r\n}\r\nexports.findObjectPath = findObjectPath;\r\nasync function abapDocumentation(h, objectUri, body, line, column, language = \"EN\") {\r\n    (0, AdtException_1.ValidateObjectUrl)(objectUri);\r\n    const headers = {\r\n        \"Content-Type\": \"text/plain\",\r\n        Accept: \"application/vnd.sap.adt.docu.v1+html,text/html\"\r\n    };\r\n    const uri = `${objectUri}#start=${line},${column}`;\r\n    const qs = { uri, language, format: \"eclipse\" };\r\n    const response = await h.request(`/sap/bc/adt/docu/abap/langu`, {\r\n        method: \"POST\",\r\n        qs,\r\n        headers,\r\n        body\r\n    });\r\n    return response.body;\r\n}\r\nexports.abapDocumentation = abapDocumentation;\r\nasync function packageSearchHelp(h, type, name = \"*\") {\r\n    const headers = { Accept: \"application/*\" };\r\n    const qs = { name };\r\n    const uri = `/sap/bc/adt/packages/valuehelps/${type}`;\r\n    const response = await h.request(uri, { qs, headers });\r\n    const raw = (0, utilities_1.fullParse)(response.body);\r\n    return (0, utilities_1.xmlArray)(raw, \"nameditem:namedItemList\", \"nameditem:namedItem\").map((item) => {\r\n        return {\r\n            name: item[\"nameditem:name\"],\r\n            description: item[\"nameditem:description\"],\r\n            data: item[\"nameditem:data\"]\r\n        };\r\n    });\r\n}\r\nexports.packageSearchHelp = packageSearchHelp;\r\n","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.typeHierarchy = exports.prettyPrinter = exports.setPrettyPrinterSetting = exports.prettyPrinterSetting = exports.fragmentMappings = exports.classComponents = exports.usageReferenceSnippets = exports.usageReferences = exports.findDefinition = exports.codeCompletionElement = exports.codeCompletionFull = exports.codeCompletion = exports.syntaxCheck = exports.parseCheckResults = exports.syntaxCheckTypes = void 0;\r\nconst AdtException_1 = require(\"../AdtException\");\r\nconst utilities_1 = require(\"../utilities\");\r\nasync function syntaxCheckTypes(h) {\r\n    const response = await h.request(\"/sap/bc/adt/checkruns/reporters\");\r\n    const raw = (0, utilities_1.fullParse)(response.body);\r\n    const reporters = (0, utilities_1.xmlArray)(raw, \"chkrun:checkReporters\", \"chkrun:reporter\").reduce((acc, cur) => {\r\n        acc.set(cur[\"@_chkrun:name\"], (0, utilities_1.xmlArray)(cur, \"chkrun:supportedType\"));\r\n        return acc;\r\n    }, new Map());\r\n    return reporters;\r\n}\r\nexports.syntaxCheckTypes = syntaxCheckTypes;\r\nfunction parseCheckResults(raw) {\r\n    const messages = [];\r\n    (0, utilities_1.xmlArray)(raw, \"chkrun:checkRunReports\", \"chkrun:checkReport\", \"chkrun:checkMessageList\", \"chkrun:checkMessage\").forEach((m) => {\r\n        const rawUri = m[\"@_chkrun:uri\"] || \"\";\r\n        let message = {\r\n            uri: rawUri,\r\n            line: 0,\r\n            offset: 0,\r\n            severity: m[\"@_chkrun:type\"],\r\n            text: m[\"@_chkrun:shortText\"]\r\n        };\r\n        const matches = rawUri.match(/([^#]+)#start=([\\d]+),([\\d]+)/);\r\n        if (matches) {\r\n            const [uri, line, offset] = matches.slice(1);\r\n            message = { ...message, uri, line: (0, utilities_1.toInt)(line), offset: (0, utilities_1.toInt)(offset) };\r\n        }\r\n        messages.push(message);\r\n    });\r\n    return messages;\r\n}\r\nexports.parseCheckResults = parseCheckResults;\r\nasync function syntaxCheck(h, inclUrl, sourceUrl, content, mainProgram = \"\", version = \"active\") {\r\n    const source = mainProgram\r\n        ? `${sourceUrl}?context=${encodeURIComponent(mainProgram)}`\r\n        : sourceUrl;\r\n    const body = `<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n  <chkrun:checkObjectList xmlns:chkrun=\"http://www.sap.com/adt/checkrun\" xmlns:adtcore=\"http://www.sap.com/adt/core\">\n  <chkrun:checkObject adtcore:uri=\"${source}\" chkrun:version=\"${version}\">\n    <chkrun:artifacts>\n      <chkrun:artifact chkrun:contentType=\"text/plain; charset=utf-8\" chkrun:uri=\"${inclUrl}\">\n        <chkrun:content>${(0, utilities_1.btoa)(content)}</chkrun:content>\n      </chkrun:artifact>\n    </chkrun:artifacts>\n  </chkrun:checkObject>\n</chkrun:checkObjectList>`;\r\n    const headers = {\r\n        // Accept: \"application/vnd.sap.adt.checkmessages+xml\",\r\n        // \"Content-Type\": \"application/vnd.sap.adt.checkobjects+xml\"\r\n        \"Content-Type\": \"application/*\"\r\n    };\r\n    const response = await h.request(\"/sap/bc/adt/checkruns?reporters=abapCheckRun\", { method: \"POST\", headers, body });\r\n    const raw = (0, utilities_1.fullParse)(response.body);\r\n    return parseCheckResults(raw);\r\n}\r\nexports.syntaxCheck = syntaxCheck;\r\nasync function codeCompletion(h, url, body, line, offset) {\r\n    const uri = `${url}#start=${line},${offset}`;\r\n    const qs = { uri, signalCompleteness: true };\r\n    const headers = { \"Content-Type\": \"application/*\" };\r\n    const response = await h.request(\"/sap/bc/adt/abapsource/codecompletion/proposal\", { method: \"POST\", qs, headers, body });\r\n    const raw = (0, utilities_1.parse)(response.body);\r\n    const proposals = (0, utilities_1.xmlArray)(raw, \"asx:abap\", \"asx:values\", \"DATA\", \"SCC_COMPLETION\")\r\n        .filter((p) => p.IDENTIFIER && p.IDENTIFIER !== \"@end\")\r\n        .map((p) => ({\r\n        ...p,\r\n        IDENTIFIER: p.IDENTIFIER\r\n    }));\r\n    return proposals;\r\n}\r\nexports.codeCompletion = codeCompletion;\r\nasync function codeCompletionFull(h, url, body, line, offset, patternKey) {\r\n    const uri = `${url}#start=${line},${offset}`;\r\n    const qs = { uri, patternKey };\r\n    const headers = { \"Content-Type\": \"application/*\" };\r\n    const response = await h.request(\"/sap/bc/adt/abapsource/codecompletion/insertion\", { method: \"POST\", qs, headers, body });\r\n    return response.body;\r\n}\r\nexports.codeCompletionFull = codeCompletionFull;\r\nfunction extractDocLink(raw) {\r\n    const link = (0, utilities_1.xmlNode)(raw, \"abapsource:elementInfo\", \"atom:link\", \"@_href\") || \"\";\r\n    return link.replace(/\\w+:\\/\\/[^\\/]*/, \"\");\r\n}\r\nasync function codeCompletionElement(h, url, body, line, offset) {\r\n    const qs = { uri: `${url}#start=${line},${offset}` };\r\n    const headers = { \"Content-Type\": \"text/plain\", Accept: \"application/*\" };\r\n    const response = await h.request(\"/sap/bc/adt/abapsource/codecompletion/elementinfo\", { method: \"POST\", qs, headers, body });\r\n    const raw = (0, utilities_1.fullParse)(response.body);\r\n    if (!(0, utilities_1.xmlNode)(raw, \"abapsource:elementInfo\"))\r\n        return response.body;\r\n    const elinfo = (0, utilities_1.xmlNodeAttr)((0, utilities_1.xmlNode)(raw, \"abapsource:elementInfo\"));\r\n    const doc = (0, utilities_1.xmlNode)(raw, \"abapsource:elementInfo\", \"abapsource:documentation\", \"#text\") || \"\";\r\n    const href = extractDocLink(raw);\r\n    const components = (0, utilities_1.xmlArray)(raw, \"abapsource:elementInfo\", \"abapsource:elementInfo\").map((c) => {\r\n        return {\r\n            ...(0, utilities_1.xmlNodeAttr)(c),\r\n            entries: (0, utilities_1.xmlArray)(c, \"abapsource:properties\", \"abapsource:entry\").map((e) => {\r\n                return {\r\n                    value: e[\"#text\"],\r\n                    key: e[\"@_abapsource:key\"]\r\n                };\r\n            })\r\n        };\r\n    });\r\n    return {\r\n        name: elinfo[\"adtcore:name\"],\r\n        type: elinfo[\"adtcore:type\"],\r\n        doc,\r\n        href,\r\n        components\r\n    };\r\n}\r\nexports.codeCompletionElement = codeCompletionElement;\r\nasync function findDefinition(h, url, body, line, firstof, lastof, implementation, mainProgram) {\r\n    const ctx = mainProgram ? `?context=${encodeURIComponent(mainProgram)}` : \"\";\r\n    const qs = {\r\n        uri: `${url}${ctx}#start=${line},${firstof};end=${line},${lastof}`,\r\n        filter: implementation ? \"implementation\" : \"definition\"\r\n    };\r\n    const headers = { \"Content-Type\": \"text/plain\", Accept: \"application/*\" };\r\n    const response = await h.request(\"/sap/bc/adt/navigation/target\", {\r\n        method: \"POST\",\r\n        qs,\r\n        headers,\r\n        body\r\n    });\r\n    const raw = (0, utilities_1.fullParse)(response.body);\r\n    const rawLink = (0, utilities_1.xmlNode)(raw, \"adtcore:objectReference\", \"@_adtcore:uri\") || \"\";\r\n    const match = rawLink.match(/([^#]+)#start=(\\d+),(\\d+)/);\r\n    return {\r\n        url: (match && match[1]) || rawLink,\r\n        line: (0, utilities_1.toInt)(match && match[2]),\r\n        column: (0, utilities_1.toInt)(match && match[3])\r\n    };\r\n}\r\nexports.findDefinition = findDefinition;\r\nasync function usageReferences(h, url, line, column) {\r\n    const headers = { \"Content-Type\": \"application/*\", Accept: \"application/*\" };\r\n    const uri = line && column ? `${url}#start=${line},${column}` : url;\r\n    const qs = { uri };\r\n    const body = `<?xml version=\"1.0\" encoding=\"ASCII\"?>\n  <usagereferences:usageReferenceRequest xmlns:usagereferences=\"http://www.sap.com/adt/ris/usageReferences\">\n    <usagereferences:affectedObjects/>\n  </usagereferences:usageReferenceRequest>`;\r\n    const response = await h.request(\"/sap/bc/adt/repository/informationsystem/usageReferences\", {\r\n        method: \"POST\",\r\n        qs,\r\n        headers,\r\n        body\r\n    });\r\n    const raw = (0, utilities_1.fullParse)(response.body);\r\n    const rawreferences = (0, utilities_1.xmlArray)(raw, \"usageReferences:usageReferenceResult\", \"usageReferences:referencedObjects\", \"usageReferences:referencedObject\");\r\n    const references = rawreferences.map((r) => {\r\n        const reference = {\r\n            ...(0, utilities_1.xmlNodeAttr)(r),\r\n            ...(0, utilities_1.xmlNodeAttr)((0, utilities_1.xmlNode)(r, \"usageReferences:adtObject\") || {}),\r\n            packageRef: (0, utilities_1.xmlNodeAttr)((0, utilities_1.xmlNode)(r, \"usageReferences:adtObject\", \"adtcore:packageRef\") || {}),\r\n            objectIdentifier: r.objectIdentifier || \"\"\r\n        };\r\n        // older systems hide the type in the URI\r\n        if (!reference[\"adtcore:type\"]) {\r\n            const uriParts = splitReferenceUri(reference.uri, \"\");\r\n            reference[\"adtcore:type\"] = uriParts.type;\r\n        }\r\n        return reference;\r\n    });\r\n    return references;\r\n}\r\nexports.usageReferences = usageReferences;\r\nfunction splitReferenceUri(url, matches) {\r\n    const [uri, context, hash] = (0, utilities_1.parts)(url, /([^#\\?]*)(?:\\?context=([^#]*))?(?:#(.*))/);\r\n    const uparts = { uri, context };\r\n    if (hash) {\r\n        hash.split(\";\").forEach(p => {\r\n            const [name, value] = p.split(\"=\");\r\n            if (name === \"start\" || name === \"end\") {\r\n                const [line, column] = value.split(\",\");\r\n                if (line)\r\n                    uparts[name] = { line: (0, utilities_1.toInt)(line), column: (0, utilities_1.toInt)(column) };\r\n            }\r\n            else if (name === \"type\" || name === \"name\")\r\n                uparts[name] = decodeURIComponent(value);\r\n        });\r\n    }\r\n    const [start, end] = (0, utilities_1.parts)(matches, /(\\d+)-(\\d+)/);\r\n    if (!uparts.start)\r\n        uparts.start = { line: 0, column: (0, utilities_1.toInt)(start) };\r\n    if (!uparts.start.column)\r\n        uparts.start.column = (0, utilities_1.toInt)(start);\r\n    if (!uparts.end)\r\n        uparts.end = {\r\n            line: uparts.start.line,\r\n            column: (0, utilities_1.toInt)(end) || uparts.start.column\r\n        };\r\n    return uparts;\r\n}\r\nasync function usageReferenceSnippets(h, references) {\r\n    const headers = { \"Content-Type\": \"application/*\", Accept: \"application/*\" };\r\n    const refNodes = references\r\n        .filter(r => r.objectIdentifier)\r\n        .reduce((last, current) => `${last}<usagereferences:objectIdentifier optional=\"false\">${current.objectIdentifier}</usagereferences:objectIdentifier>`, \"\");\r\n    const body = `<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n  <usagereferences:usageSnippetRequest xmlns:usagereferences=\"http://www.sap.com/adt/ris/usageReferences\">\n  <usagereferences:objectIdentifiers>\n  ${refNodes}\n  </usagereferences:objectIdentifiers>\n  <usagereferences:affectedObjects/>\n</usagereferences:usageSnippetRequest>`;\r\n    const response = await h.request(\"/sap/bc/adt/repository/informationsystem/usageSnippets\", {\r\n        method: \"POST\",\r\n        headers,\r\n        body\r\n    });\r\n    const raw = (0, utilities_1.fullParse)(response.body);\r\n    const snippetReferences = (0, utilities_1.xmlArray)(raw, \"usageReferences:usageSnippetResult\", \"usageReferences:codeSnippetObjects\", \"usageReferences:codeSnippetObject\").map((o) => {\r\n        const snippets = (0, utilities_1.xmlArray)(o, \"usageReferences:codeSnippets\", \"usageReferences:codeSnippet\").map((s) => {\r\n            const parms = (0, utilities_1.xmlNodeAttr)(s);\r\n            const uri = splitReferenceUri(parms.uri, parms.matches);\r\n            return {\r\n                uri,\r\n                matches: parms.matches,\r\n                content: s.content,\r\n                description: s.description\r\n            };\r\n        });\r\n        return { objectIdentifier: o.objectIdentifier, snippets };\r\n    });\r\n    return snippetReferences;\r\n}\r\nexports.usageReferenceSnippets = usageReferenceSnippets;\r\nconst parseElement = (e) => {\r\n    const attrs = (0, utilities_1.xmlNodeAttr)(e);\r\n    const links = (0, utilities_1.xmlArray)(e, \"atom:link\").map(utilities_1.xmlNodeAttr);\r\n    const components = (0, utilities_1.xmlArray)(e, \"abapsource:objectStructureElement\").map(parseElement);\r\n    return { ...attrs, links, components };\r\n};\r\nasync function classComponents(h, url) {\r\n    (0, AdtException_1.ValidateObjectUrl)(url);\r\n    const uri = `${url}/objectstructure`;\r\n    const qs = { version: \"active\", withShortDescriptions: true };\r\n    const headers = { \"Content-Type\": \"application/*\" };\r\n    const response = await h.request(uri, { qs, headers });\r\n    const raw = (0, utilities_1.fullParse)(response.body);\r\n    const header = parseElement((0, utilities_1.xmlNode)(raw, \"abapsource:objectStructureElement\"));\r\n    return header;\r\n}\r\nexports.classComponents = classComponents;\r\nasync function fragmentMappings(h, url, type, name) {\r\n    (0, AdtException_1.ValidateObjectUrl)(url);\r\n    const qs = { uri: `${url}#type=${type};name=${name}` };\r\n    const headers = { \"Content-Type\": \"application/*\" };\r\n    const response = await h.request(\"/sap/bc/adt/urifragmentmappings\", {\r\n        qs,\r\n        headers\r\n    });\r\n    const [sourceUrl, line, column] = (0, utilities_1.parts)(response.body, /([^#]*)#start=([\\d]+),([\\d]+)/);\r\n    if (!column)\r\n        throw (0, AdtException_1.adtException)(\"Fragment not found\");\r\n    const location = {\r\n        uri: sourceUrl,\r\n        line: (0, utilities_1.toInt)(line),\r\n        column: (0, utilities_1.toInt)(column)\r\n    };\r\n    return location;\r\n}\r\nexports.fragmentMappings = fragmentMappings;\r\nasync function prettyPrinterSetting(h) {\r\n    const response = await h.request(\"/sap/bc/adt/abapsource/prettyprinter/settings\");\r\n    const raw = (0, utilities_1.fullParse)(response.body);\r\n    const settings = (0, utilities_1.xmlNodeAttr)(raw[\"abapformatter:PrettyPrinterSettings\"]);\r\n    return settings;\r\n}\r\nexports.prettyPrinterSetting = prettyPrinterSetting;\r\nasync function setPrettyPrinterSetting(h, indent, style) {\r\n    const headers = { \"Content-Type\": \"application/*\" };\r\n    const body = `<?xml version=\"1.0\" encoding=\"UTF-8\"?><prettyprintersettings:PrettyPrinterSettings\nxmlns:prettyprintersettings=\"http://www.sap.com/adt/prettyprintersettings\"\nprettyprintersettings:indentation=\"${indent}\" prettyprintersettings:style=\"${style}\"/>`;\r\n    const response = await h.request(\"/sap/bc/adt/abapsource/prettyprinter/settings\", { method: \"PUT\", headers, body });\r\n    return response.body || \"\";\r\n}\r\nexports.setPrettyPrinterSetting = setPrettyPrinterSetting;\r\nasync function prettyPrinter(h, body) {\r\n    const headers = { \"Content-Type\": \"text/plain\", Accept: \"text/plain\" };\r\n    const response = await h.request(\"/sap/bc/adt/abapsource/prettyprinter\", {\r\n        method: \"POST\",\r\n        headers,\r\n        body\r\n    });\r\n    return (response.body || body).toString();\r\n}\r\nexports.prettyPrinter = prettyPrinter;\r\nasync function typeHierarchy(h, url, body, line, offset, superTypes = false) {\r\n    const qs = {\r\n        uri: `${url}#start=${line},${offset}`,\r\n        type: superTypes ? \"superTypes\" : \"subTypes\"\r\n    };\r\n    const headers = { \"Content-Type\": \"text/plain\", Accept: \"application/*\" };\r\n    const response = await h.request(\"/sap/bc/adt/abapsource/typehierarchy\", {\r\n        method: \"POST\",\r\n        qs,\r\n        headers,\r\n        body\r\n    });\r\n    const raw = (0, utilities_1.fullParse)(response.body);\r\n    const hierarchy = (0, utilities_1.xmlArray)(raw, \"hierarchy:info\", \"entries\", \"entry\").map(he => {\r\n        const rawh = (0, utilities_1.xmlNodeAttr)(he);\r\n        const [uri, srcline, character] = (0, utilities_1.parts)(rawh[\"adtcore:uri\"], /([^#]+)(?:#start=(\\d+)(?:,(\\d+))?)?/);\r\n        const node = {\r\n            hasDefOrImpl: rawh.hasDefOrImpl,\r\n            uri,\r\n            line: (0, utilities_1.toInt)(srcline),\r\n            character: (0, utilities_1.toInt)(character),\r\n            type: rawh[\"adtcore:type\"] || \"\",\r\n            name: rawh[\"adtcore:name\"] || \"\",\r\n            parentUri: rawh[\"adtcore:parentUri\"] || \"\",\r\n            description: rawh[\"adtcore:description\"] || \"\"\r\n        };\r\n        return node;\r\n    });\r\n    return hierarchy;\r\n}\r\nexports.typeHierarchy = typeHierarchy;\r\n","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.bindingDetails = exports.runQuery = exports.tableContents = exports.servicePreviewUrl = exports.parseBindingDetails = exports.parseQueryResponse = exports.decodeQueryResult = exports.extractBindingLinks = exports.parseServiceBinding = exports.TypeKinds = void 0;\r\nconst AdtException_1 = require(\"../AdtException\");\r\nconst utilities_1 = require(\"../utilities\");\r\nvar TypeKinds;\r\n(function (TypeKinds) {\r\n    TypeKinds[\"ANY\"] = \"~\";\r\n    TypeKinds[\"CHAR\"] = \"C\";\r\n    TypeKinds[\"CLASS\"] = \"*\";\r\n    TypeKinds[\"CLIKE\"] = \"&\";\r\n    TypeKinds[\"CSEQUENCE\"] = \"?\";\r\n    TypeKinds[\"DATA\"] = \"#\";\r\n    TypeKinds[\"DATE\"] = \"D\";\r\n    TypeKinds[\"DECFLOAT\"] = \"/\";\r\n    TypeKinds[\"DECFLOAT16\"] = \"a\";\r\n    TypeKinds[\"DECFLOAT34\"] = \"e\";\r\n    TypeKinds[\"DREF\"] = \"l\";\r\n    TypeKinds[\"FLOAT\"] = \"F\";\r\n    TypeKinds[\"HEX\"] = \"X\";\r\n    TypeKinds[\"INT\"] = \"I\";\r\n    TypeKinds[\"INT1\"] = \"b\";\r\n    TypeKinds[\"INT8\"] = \"8\";\r\n    TypeKinds[\"INT2\"] = \"s\";\r\n    TypeKinds[\"INTF\"] = \"+\";\r\n    TypeKinds[\"IREF\"] = \"m\";\r\n    TypeKinds[\"NUM\"] = \"N\";\r\n    TypeKinds[\"NUMERIC\"] = \"%\";\r\n    TypeKinds[\"OREF\"] = \"r\";\r\n    TypeKinds[\"PACKED\"] = \"P\";\r\n    TypeKinds[\"SIMPLE\"] = \"$\";\r\n    TypeKinds[\"STRING\"] = \"g\";\r\n    TypeKinds[\"STRUCT1\"] = \"u\";\r\n    TypeKinds[\"STRUCT2\"] = \"v\";\r\n    TypeKinds[\"TABLE\"] = \"h\";\r\n    TypeKinds[\"TIME\"] = \"T\";\r\n    TypeKinds[\"W\"] = \"w\";\r\n    TypeKinds[\"XSEQUENCE\"] = \"!\";\r\n    TypeKinds[\"XSTRING\"] = \"y\";\r\n    TypeKinds[\"BREF\"] = \"j\";\r\n})(TypeKinds = exports.TypeKinds || (exports.TypeKinds = {}));\r\nconst parseServiceBinding = (xml) => {\r\n    const s = (0, utilities_1.fullParse)(xml, { removeNSPrefix: true, parseAttributeValue: false });\r\n    const attrs = (0, utilities_1.xmlNodeAttr)(s.serviceBinding);\r\n    for (const key of [\"releaseSupported\", \"published\", \"repair\", \"bindingCreated\"])\r\n        attrs[key] = !`${attrs[key]}`.match(/false/i);\r\n    const packageRef = (0, utilities_1.xmlNodeAttr)(s.serviceBinding.packageRef);\r\n    const links = s.serviceBinding.link.map(utilities_1.xmlNodeAttr);\r\n    const parseService = (name) => (service) => {\r\n        const { \"@_version\": version, \"@_releaseState\": releaseState } = service;\r\n        const serviceDefinition = (0, utilities_1.xmlNodeAttr)(service.serviceDefinition);\r\n        return { name, version, releaseState, serviceDefinition };\r\n    };\r\n    const { \"@_name\": serviceName } = (0, utilities_1.xmlNode)(s, \"serviceBinding\", \"services\");\r\n    const services = (0, utilities_1.xmlArray)(s, \"serviceBinding\", \"services\", \"content\").map(parseService(serviceName));\r\n    const parseBinding = (b) => ({ ...(0, utilities_1.xmlNodeAttr)(b), implementation: { ...(0, utilities_1.xmlNodeAttr)(b.implementation) } });\r\n    const binding = parseBinding(s.serviceBinding.binding);\r\n    return { ...attrs, packageRef, links, services, binding };\r\n};\r\nexports.parseServiceBinding = parseServiceBinding;\r\nconst extractBindingLinks = (binding) => {\r\n    var _a;\r\n    const url = (_a = binding.links.find(l => l.rel === \"http://www.sap.com/categories/odatav2\")) === null || _a === void 0 ? void 0 : _a.href;\r\n    if (!url)\r\n        return [];\r\n    return binding.services.map(service => {\r\n        const { name: servicename, version: serviceversion, serviceDefinition: { name: srvdname } } = service;\r\n        const query = { servicename, serviceversion, srvdname };\r\n        return { service, query, url };\r\n    });\r\n};\r\nexports.extractBindingLinks = extractBindingLinks;\r\nconst decodeSapDate = (raw) => new Date(`${raw.substr(0, 4)}-${raw.substr(4, 2)}-${raw.substr(6, 2)}`);\r\nconst parseValue = (type, raw) => {\r\n    switch (type) {\r\n        case TypeKinds.DATE:\r\n            return decodeSapDate(raw);\r\n        case TypeKinds.DECFLOAT:\r\n        case TypeKinds.DECFLOAT16:\r\n        case TypeKinds.DECFLOAT34:\r\n        case TypeKinds.FLOAT:\r\n        case TypeKinds.NUM:\r\n        case TypeKinds.NUMERIC:\r\n        case TypeKinds.PACKED:\r\n            return parseFloat(raw);\r\n        case TypeKinds.INT:\r\n        case TypeKinds.INT1:\r\n        case TypeKinds.INT8:\r\n        case TypeKinds.INT2:\r\n            return parseInt(raw, 10);\r\n        case TypeKinds.TIME:\r\n            return raw; // converting to date doesn't sound like a great idea\r\n        default:\r\n            return raw;\r\n    }\r\n};\r\nconst decodeQueryResult = (original) => {\r\n    const { columns } = original;\r\n    const types = new Map();\r\n    for (const c of columns)\r\n        types.set(c.name, c.type);\r\n    const values = original.values.map(l => {\r\n        const decoded = (k) => parseValue(types.get(k), l[k]);\r\n        return Object.keys(l).reduce((o, k) => { o[k] = decoded(k); return o; }, {});\r\n    });\r\n    return { columns, values };\r\n};\r\nexports.decodeQueryResult = decodeQueryResult;\r\nconst parseColumn = (raw) => {\r\n    const { \"@_name\": name = \"\", \"@_type\": type = \"\", \"@_description\": description, \"@_keyAttribute\": keyAttribute = false, \"@_colType\": colType, \"@_isKeyFigure\": isKeyFigure = false, \"@_length\": length = 0, } = raw.metadata;\r\n    const values = (0, utilities_1.xmlArray)(raw, \"dataSet\", \"data\");\r\n    const meta = { name, type, description, keyAttribute, colType, isKeyFigure, length };\r\n    return { values, meta };\r\n};\r\nfunction parseQueryResponse(body) {\r\n    const raw = (0, utilities_1.fullParse)(body, { removeNSPrefix: true, parseTagValue: false });\r\n    const fields = (0, utilities_1.xmlArray)(raw, \"tableData\", \"columns\").map(parseColumn);\r\n    const columns = fields.map(c => c.meta);\r\n    const longest = fields.map(f => f.values).reduce((m, l) => l.length > m.length ? l : m, []);\r\n    const row = (_, i) => fields.reduce((r, f) => {\r\n        return { ...r, [f.meta.name]: f.values[i] };\r\n    }, {});\r\n    const values = longest.map(row);\r\n    return { columns, values };\r\n}\r\nexports.parseQueryResponse = parseQueryResponse;\r\nconst parseBindingDetails = (xml) => {\r\n    var _a;\r\n    const s = (0, utilities_1.fullParse)(xml, { removeNSPrefix: true, parseAttributeValue: false });\r\n    const link = (0, utilities_1.xmlNodeAttr)((_a = s === null || s === void 0 ? void 0 : s.serviceList) === null || _a === void 0 ? void 0 : _a.link);\r\n    const parseCollection = (c) => {\r\n        const name = c[\"@_name\"];\r\n        const navigation = (0, utilities_1.xmlArray)(c, \"navigation\").map(utilities_1.xmlNodeAttr);\r\n        return { name, navigation };\r\n    };\r\n    const parseService = (s) => {\r\n        const base = (0, utilities_1.xmlNodeAttr)(s);\r\n        const serviceInformation = (0, utilities_1.xmlNodeAttr)(s.serviceInformation);\r\n        serviceInformation.collection = (0, utilities_1.xmlArray)(s, \"serviceInformation\", \"collection\").map(parseCollection);\r\n        return ({ ...base, serviceInformation });\r\n    };\r\n    const services = (0, utilities_1.xmlArray)(s, \"serviceList\", \"services\").map(parseService);\r\n    return { link, services };\r\n};\r\nexports.parseBindingDetails = parseBindingDetails;\r\nconst servicePreviewUrl = (service, collectionName) => {\r\n    const { serviceId, serviceInformation: { collection, url, name, version } } = service;\r\n    const annotation = `${name.substr(0, 28)}_VAN`;\r\n    const baseUrl = url.replace(/(https?:\\/\\/[^\\/]+).*/, \"$1\");\r\n    const cn = collection.find(c => c.name === collectionName);\r\n    if (!cn)\r\n        return;\r\n    const encrypt = (s) => s.split(\"\").map(c => String.fromCharCode(c.charCodeAt(0) + 20)).join(\"\");\r\n    const names = cn.navigation.map(n => n.name).join(\"@@\");\r\n    const targets = cn.navigation.map(n => n.target).join(\"@@\");\r\n    const rawparm = [serviceId, cn.name, names, targets, annotation, version].join(\"##\");\r\n    return `${baseUrl}/sap/bc/adt/businessservices/odatav2/feap?feapParams=${encodeURIComponent(encrypt(rawparm))}`;\r\n};\r\nexports.servicePreviewUrl = servicePreviewUrl;\r\nasync function tableContents(h, ddicEntityName, rowNumber = 100, decode = true, sqlQuery = \"\") {\r\n    const qs = { rowNumber, ddicEntityName };\r\n    const response = await h.request(`/sap/bc/adt/datapreview/ddic`, { qs, headers: { Accept: \"application/*\" }, method: \"POST\", body: sqlQuery });\r\n    const queryResult = parseQueryResponse(response.body);\r\n    if (decode)\r\n        return (0, exports.decodeQueryResult)(queryResult);\r\n    return queryResult;\r\n}\r\nexports.tableContents = tableContents;\r\nasync function runQuery(h, sqlQuery, rowNumber = 100, decode = true) {\r\n    const qs = { rowNumber };\r\n    const response = await h.request(`/sap/bc/adt/datapreview/freestyle`, { qs, headers: { Accept: \"application/*\" }, method: \"POST\", body: sqlQuery });\r\n    const queryResult = parseQueryResponse(response.body);\r\n    if (decode)\r\n        return (0, exports.decodeQueryResult)(queryResult);\r\n    return queryResult;\r\n}\r\nexports.runQuery = runQuery;\r\nasync function bindingDetails(h, binding, index = 0) {\r\n    const queries = (0, exports.extractBindingLinks)(binding);\r\n    const { query: qs, url } = queries[index];\r\n    if (!qs || !url)\r\n        throw (0, AdtException_1.adtException)(\"Binding not found\");\r\n    const response = await h.request(url, { qs, headers: { Accept: \"application/*\" }, method: \"GET\" });\r\n    return (0, exports.parseBindingDetails)(response.body);\r\n}\r\nexports.bindingDetails = bindingDetails;\r\n","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.tracesDelete = exports.tracesDeleteConfiguration = exports.tracesCreateConfiguration = exports.tracesSetParameters = exports.tracesStatements = exports.tracesDbAccess = exports.tracesHitList = exports.tracesListRequests = exports.tracesList = exports.traceProcessObjects = void 0;\r\nconst tracetypes_1 = require(\"./tracetypes\");\r\nconst __1 = require(\"..\");\r\nvar tracetypes_2 = require(\"./tracetypes\");\r\nObject.defineProperty(exports, \"traceProcessObjects\", { enumerable: true, get: function () { return tracetypes_2.traceProcessObjects; } });\r\nconst tracesList = async (h, user) => {\r\n    const qs = { user: user.toUpperCase() };\r\n    const response = await h.request(`/sap/bc/adt/runtime/traces/abaptraces`, {\r\n        qs\r\n    });\r\n    return (0, tracetypes_1.parseTraceResults)(response.body);\r\n};\r\nexports.tracesList = tracesList;\r\nconst tracesListRequests = async (h, user) => {\r\n    const qs = { user: user.toUpperCase() };\r\n    const response = await h.request(`/sap/bc/adt/runtime/traces/abaptraces/requests`, { qs });\r\n    return (0, tracetypes_1.parseTraceRequestList)(response.body);\r\n};\r\nexports.tracesListRequests = tracesListRequests;\r\nconst traceId = (id) => id.startsWith(\"/sap/bc/adt/runtime/traces/abaptraces/\")\r\n    ? id\r\n    : `/sap/bc/adt/runtime/traces/abaptraces/${id}`;\r\nconst tracesHitList = async (h, id, withSystemEvents = false) => {\r\n    const opts = { qs: { withSystemEvents } };\r\n    const response = await h.request(`${traceId(id)}/hitlist`, opts);\r\n    return (0, tracetypes_1.parseTraceHitList)(response.body);\r\n};\r\nexports.tracesHitList = tracesHitList;\r\nconst tracesDbAccess = async (h, id, withSystemEvents = false) => {\r\n    const opts = { qs: { withSystemEvents } };\r\n    const response = await h.request(`${traceId(id)}/dbAccesses`, opts);\r\n    return (0, tracetypes_1.parseTraceDbAccess)(response.body);\r\n};\r\nexports.tracesDbAccess = tracesDbAccess;\r\nconst tracesStatements = async (h, id, options = {}) => {\r\n    const headers = {\r\n        Accept: \"application/vnd.sap.adt.runtime.traces.abaptraces.aggcalltree+xml, application/xml\"\r\n    };\r\n    const opts = { qs: options, headers };\r\n    const response = await h.request(`${traceId(id)}/statements`, opts);\r\n    return (0, tracetypes_1.parseTraceStatements)(response.body);\r\n};\r\nexports.tracesStatements = tracesStatements;\r\nconst tracesSetParameters = async (h, parameters) => {\r\n    const headers = { \"Content-Type\": \"application/xml\" };\r\n    const body = `<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n  <trc:parameters xmlns:trc=\"http://www.sap.com/adt/runtime/traces/abaptraces\">\n      <trc:allMiscAbapStatements value=\"${parameters.allMiscAbapStatements}\"></trc:allMiscAbapStatements>\n      <trc:allProceduralUnits value=\"${parameters.allProceduralUnits}\"></trc:allProceduralUnits>\n      <trc:allInternalTableEvents value=\"${parameters.allInternalTableEvents}\"></trc:allInternalTableEvents>\n      <trc:allDynproEvents value=\"${parameters.allDynproEvents}\"></trc:allDynproEvents>\n      <trc:description value=\"${parameters.description}\"></trc:description>\n      <trc:aggregate value=\"${parameters.aggregate}\"></trc:aggregate>\n      <trc:explicitOnOff value=\"${parameters.explicitOnOff}\"></trc:explicitOnOff>\n      <trc:withRfcTracing value=\"${parameters.withRfcTracing}\"></trc:withRfcTracing>\n      <trc:allSystemKernelEvents value=\"${parameters.allSystemKernelEvents}\"></trc:allSystemKernelEvents>\n      <trc:sqlTrace value=\"${parameters.sqlTrace}\"></trc:sqlTrace>\n      <trc:allDbEvents value=\"${parameters.allDbEvents}\"></trc:allDbEvents>\n      <trc:maxSizeForTraceFile value=\"${parameters.maxSizeForTraceFile}\"></trc:maxSizeForTraceFile>\n      <trc:maxTimeForTracing value=\"${parameters.maxTimeForTracing}\"></trc:maxTimeForTracing>\n  </trc:parameters>`;\r\n    const opts = { headers, method: \"POST\", body };\r\n    const response = await h.request(`/sap/bc/adt/runtime/traces/abaptraces/parameters`, opts);\r\n    const uri = response.headers[\"location\"];\r\n    if (!uri)\r\n        throw (0, __1.adtException)(\"trace configuration not set\");\r\n    return uri;\r\n};\r\nexports.tracesSetParameters = tracesSetParameters;\r\nconst tracesCreateConfiguration = async (h, config) => {\r\n    if (!tracetypes_1.traceProcessObjects[config.processType].includes(config.objectType))\r\n        throw (0, __1.adtException)(`Invalid process type ${config.processType} or object type ${config.objectType}`);\r\n    const qs = {\r\n        ...config,\r\n        server: config.server || \"*\",\r\n        processType: tracetypes_1.traceProcessTypeUris[config.processType],\r\n        objectType: tracetypes_1.traceObjectTypeUris[config.objectType]\r\n    };\r\n    const opts = { method: \"POST\", qs };\r\n    const response = await h.request(`/sap/bc/adt/runtime/traces/abaptraces/requests`, opts);\r\n    return (0, tracetypes_1.parseTraceRequestList)(response.body);\r\n};\r\nexports.tracesCreateConfiguration = tracesCreateConfiguration;\r\nconst tracesDeleteConfiguration = async (h, id) => {\r\n    const prefix = `/sap/bc/adt/runtime/traces/abaptraces/requests`;\r\n    const url = id.startsWith(prefix) ? id : `${prefix}/${id}`;\r\n    await h.request(url, { method: \"DELETE\" });\r\n};\r\nexports.tracesDeleteConfiguration = tracesDeleteConfiguration;\r\nconst tracesDelete = async (h, id) => {\r\n    const prefix = `/sap/bc/adt/runtime/traces/abaptraces/`;\r\n    const url = id.startsWith(prefix) ? id : `${prefix}/${id}`;\r\n    await h.request(url, { method: \"DELETE\" });\r\n};\r\nexports.tracesDelete = tracesDelete;\r\n","\"use strict\";\r\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    var desc = Object.getOwnPropertyDescriptor(m, k);\r\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\r\n      desc = { enumerable: true, get: function() { return m[k]; } };\r\n    }\r\n    Object.defineProperty(o, k2, desc);\r\n}) : (function(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    o[k2] = m[k];\r\n}));\r\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\r\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\r\n}) : function(o, v) {\r\n    o[\"default\"] = v;\r\n});\r\nvar __importStar = (this && this.__importStar) || function (mod) {\r\n    if (mod && mod.__esModule) return mod;\r\n    var result = {};\r\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\r\n    __setModuleDefault(result, mod);\r\n    return result;\r\n};\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.parseTraceRequestList = exports.parseTraceStatements = exports.parseTraceDbAccess = exports.parseTraceHitList = exports.parseTraceResults = exports.traceProcessObjects = exports.traceObjectTypeUris = exports.traceProcessTypeUris = void 0;\r\nconst t = __importStar(require(\"io-ts\"));\r\nconst utilities_1 = require(\"../utilities\");\r\nconst AdtException_1 = require(\"../AdtException\");\r\nconst contributorClass = t.type({ name: t.string });\r\nconst link = t.type({\r\n    \"@_href\": t.string,\r\n    \"@_rel\": t.string,\r\n    \"@_type\": t.string,\r\n    \"@_title\": t.string\r\n});\r\n// A\tActive\r\n// R\tRead Only\r\n// E\tError\r\n// S\tSizeLim\r\n// T\tTimeLim\r\n// C\tClose Error\r\nconst state = t.type({ \"@_value\": t.string, \"@_text\": t.string });\r\nconst extendedData = t.type({\r\n    host: t.string,\r\n    size: t.number,\r\n    runtime: t.number,\r\n    runtimeABAP: t.number,\r\n    runtimeSystem: t.number,\r\n    runtimeDatabase: t.number,\r\n    expiration: t.string,\r\n    system: t.string,\r\n    client: t.number,\r\n    isAggregated: t.boolean,\r\n    aggregationKind: (0, utilities_1.orUndefined)(t.string),\r\n    objectName: t.string,\r\n    state: state\r\n});\r\nconst entryAuthor = t.type({ name: t.string, uri: t.string });\r\nconst entry = t.type({\r\n    author: entryAuthor,\r\n    content: t.type({\r\n        \"@_type\": t.string,\r\n        \"@_src\": t.string\r\n    }),\r\n    id: t.string,\r\n    link: (0, utilities_1.xmlArrayType)(link),\r\n    published: t.string,\r\n    title: t.string,\r\n    updated: t.string,\r\n    extendedData: extendedData,\r\n    \"@_lang\": t.string\r\n});\r\nconst feed = t.type({\r\n    author: contributorClass,\r\n    contributor: contributorClass,\r\n    title: t.string,\r\n    updated: t.string,\r\n    entry: (0, utilities_1.xmlArrayType)(entry)\r\n});\r\nconst traceResults = t.type({ feed: feed });\r\nconst time = t.type({\r\n    \"@_time\": t.number,\r\n    \"@_percentage\": t.number\r\n});\r\nconst baseLink = t.type({\r\n    \"@_rel\": t.string,\r\n    \"@_href\": t.string\r\n});\r\nconst calledProgram = t.type({ \"@_context\": t.string });\r\nconst callingProgram = (0, utilities_1.mixed)({\r\n    \"@_context\": t.string,\r\n    \"@_byteCodeOffset\": t.number\r\n}, {\r\n    \"@_uri\": t.string,\r\n    \"@_type\": t.string,\r\n    \"@_name\": t.string,\r\n    \"@_packageName\": t.string,\r\n    \"@_objectReferenceQuery\": t.string\r\n});\r\nconst hlentry = (0, utilities_1.mixed)({\r\n    calledProgram: calledProgram,\r\n    grossTime: time,\r\n    traceEventNetTime: time,\r\n    proceduralNetTime: time,\r\n    \"@_topDownIndex\": t.number,\r\n    \"@_index\": t.number,\r\n    \"@_hitCount\": t.number,\r\n    \"@_recursionDepth\": t.number,\r\n    \"@_description\": t.string\r\n}, {\r\n    callingProgram: callingProgram,\r\n    \"@_stackCount\": t.number,\r\n    \"@_proceduralEntryAnchor\": t.number,\r\n    \"@_dbAccessAnchor\": t.number\r\n});\r\nconst Hitlist = t.type({\r\n    link: baseLink,\r\n    entry: (0, utilities_1.xmlArrayType)(hlentry)\r\n});\r\nconst HitListResponse = t.type({ hitlist: Hitlist });\r\n///\r\nconst accessTime = t.type({\r\n    \"@_total\": t.number,\r\n    \"@_applicationServer\": t.number,\r\n    \"@_database\": t.number,\r\n    \"@_ratioOfTraceTotal\": t.number\r\n});\r\nconst dBAccess = (0, utilities_1.mixed)({\r\n    accessTime: accessTime,\r\n    \"@_index\": t.number,\r\n    \"@_tableName\": t.string,\r\n    \"@_statement\": t.string,\r\n    \"@_type\": t.union([\r\n        t.literal(\"EXEC SQL\"),\r\n        t.literal(\"OpenSQL\"),\r\n        t.literal(\"\")\r\n    ]),\r\n    \"@_totalCount\": t.number,\r\n    \"@_bufferedCount\": t.number\r\n}, {\r\n    callingProgram: callingProgram\r\n});\r\nconst dBAccesses = t.type({\r\n    link: baseLink,\r\n    dbAccess: (0, utilities_1.xmlArrayType)(dBAccess),\r\n    tables: t.union([\r\n        t.type({\r\n            table: (0, utilities_1.xmlArrayType)(t.type({\r\n                \"@_name\": t.string,\r\n                \"@_type\": t.string,\r\n                \"@_description\": t.string,\r\n                \"@_bufferMode\": t.string,\r\n                \"@_storageType\": t.string,\r\n                \"@_package\": t.string\r\n            }))\r\n        }),\r\n        t.literal(\"\")\r\n    ]),\r\n    \"@_totalDbTime\": t.number\r\n});\r\nconst traceDBAccesResponse = t.type({ dbAccesses: dBAccesses });\r\n///\r\nconst statement = (0, utilities_1.mixed)({\r\n    callingProgram: callingProgram,\r\n    grossTime: time,\r\n    traceEventNetTime: time,\r\n    proceduralNetTime: time,\r\n    \"@_index\": t.number,\r\n    \"@_id\": t.number,\r\n    \"@_description\": t.string,\r\n    \"@_hitCount\": t.number,\r\n    \"@_hasDetailSubnodes\": t.boolean,\r\n    \"@_hasProcedureLikeSubnodes\": t.boolean,\r\n    \"@_callerId\": t.number,\r\n    \"@_callLevel\": t.number,\r\n    \"@_subnodeCount\": t.number,\r\n    \"@_directSubnodeCount\": t.number,\r\n    \"@_directSubnodeCountProcedureLike\": t.number,\r\n    \"@_hitlistAnchor\": t.number\r\n}, {\r\n    \"@_isProcedureLike\": t.boolean,\r\n    \"@_isProceduralUnit\": t.boolean,\r\n    \"@_isAutoDrillDowned\": t.boolean,\r\n    \"@_calltreeAnchor\": t.number,\r\n    \"@_moduleHitlistAnchor\": t.number\r\n});\r\nconst traceStatementResponse = t.type({\r\n    statements: t.type({\r\n        link: baseLink,\r\n        statement: (0, utilities_1.xmlArrayType)(statement),\r\n        \"@_withDetails\": t.boolean,\r\n        \"@_withSysEvents\": t.boolean,\r\n        \"@_count\": t.union([t.number, t.string])\r\n    })\r\n});\r\n///\r\nconst author = t.type({\r\n    name: t.string,\r\n    uri: t.string,\r\n    \"@_role\": t.string\r\n});\r\nconst client = t.partial({\r\n    \"#text\": (0, utilities_1.orUndefined)(t.number),\r\n    \"@_role\": t.string\r\n});\r\nconst executions = t.type({\r\n    \"@_maximal\": t.number,\r\n    \"@_completed\": t.number\r\n});\r\nconst rawProcessTypes = t.union([\r\n    t.literal(\"/sap/bc/adt/runtime/traces/abaptraces/processtypes/any\"),\r\n    t.literal(\"/sap/bc/adt/runtime/traces/abaptraces/processtypes/http\"),\r\n    t.literal(\"/sap/bc/adt/runtime/traces/abaptraces/processtypes/dialog\"),\r\n    t.literal(\"/sap/bc/adt/runtime/traces/abaptraces/processtypes/batch\"),\r\n    t.literal(\"/sap/bc/adt/runtime/traces/abaptraces/processtypes/rfc\"),\r\n    t.literal(\"/sap/bc/adt/runtime/traces/abaptraces/processtypes/sharedobjectsarea\")\r\n]);\r\nconst rawObjectTypes = t.union([\r\n    t.literal(\"/sap/bc/adt/runtime/traces/abaptraces/objecttypes/any\"),\r\n    t.literal(\"/sap/bc/adt/runtime/traces/abaptraces/objecttypes/url\"),\r\n    t.literal(\"/sap/bc/adt/runtime/traces/abaptraces/objecttypes/transaction\"),\r\n    t.literal(\"/sap/bc/adt/runtime/traces/abaptraces/objecttypes/report\"),\r\n    t.literal(\"/sap/bc/adt/runtime/traces/abaptraces/objecttypes/functionmodule\"),\r\n    t.literal(\"/sap/bc/adt/runtime/traces/abaptraces/objecttypes/sharedobjectarea\")\r\n]);\r\nconst traceListextendedData = t.type({\r\n    host: t.string,\r\n    requestIndex: t.number,\r\n    client: (0, utilities_1.xmlArrayType)(client),\r\n    description: t.string,\r\n    isAggregated: t.boolean,\r\n    expires: t.string,\r\n    processType: t.type({ \"@_processTypeId\": rawProcessTypes }),\r\n    object: t.type({ \"@_objectTypeId\": rawObjectTypes }),\r\n    executions: executions\r\n});\r\nconst traceListEntry = (0, utilities_1.mixed)({\r\n    id: t.string,\r\n    author: (0, utilities_1.xmlArrayType)(author),\r\n    content: t.type({\r\n        \"@_type\": t.string,\r\n        \"@_src\": t.string\r\n    }),\r\n    published: t.string,\r\n    title: t.string,\r\n    updated: t.string,\r\n    extendedData: traceListextendedData,\r\n    \"@_lang\": t.string\r\n}, {\r\n    link: (0, utilities_1.xmlArrayType)(link)\r\n});\r\nconst tlFeed = t.type({\r\n    contributor: t.type({\r\n        name: t.string,\r\n        \"@_role\": t.string\r\n    }),\r\n    title: t.string,\r\n    updated: t.string,\r\n    entry: (0, utilities_1.xmlArrayType)(traceListEntry)\r\n});\r\nconst tracesListRequest = t.type({ feed: tlFeed });\r\nexports.traceProcessTypeUris = {\r\n    ANY: \"/sap/bc/adt/runtime/traces/abaptraces/processtypes/any\",\r\n    HTTP: \"/sap/bc/adt/runtime/traces/abaptraces/processtypes/http\",\r\n    DIALOG: \"/sap/bc/adt/runtime/traces/abaptraces/processtypes/dialog\",\r\n    BATCH: \"/sap/bc/adt/runtime/traces/abaptraces/processtypes/batch\",\r\n    RFC: \"/sap/bc/adt/runtime/traces/abaptraces/processtypes/rfc\",\r\n    SHARED_OBJECTS_AREA: \"/sap/bc/adt/runtime/traces/abaptraces/processtypes/sharedobjectsarea\"\r\n};\r\nexports.traceObjectTypeUris = {\r\n    ANY: \"/sap/bc/adt/runtime/traces/abaptraces/objecttypes/any\",\r\n    URL: \"/sap/bc/adt/runtime/traces/abaptraces/objecttypes/url\",\r\n    TRANSACTION: \"/sap/bc/adt/runtime/traces/abaptraces/objecttypes/transaction\",\r\n    REPORT: \"/sap/bc/adt/runtime/traces/abaptraces/objecttypes/report\",\r\n    FUNCTION_MODULE: \"/sap/bc/adt/runtime/traces/abaptraces/objecttypes/functionmodule\",\r\n    SHARED_OBJECTS_AREA: \"/sap/bc/adt/runtime/traces/abaptraces/objecttypes/sharedobjectarea\"\r\n};\r\nconst decodeObjectType = (x) => {\r\n    switch (x) {\r\n        case \"/sap/bc/adt/runtime/traces/abaptraces/objecttypes/any\":\r\n            return \"ANY\";\r\n        case \"/sap/bc/adt/runtime/traces/abaptraces/objecttypes/url\":\r\n            return \"URL\";\r\n        case \"/sap/bc/adt/runtime/traces/abaptraces/objecttypes/transaction\":\r\n            return \"TRANSACTION\";\r\n        case \"/sap/bc/adt/runtime/traces/abaptraces/objecttypes/report\":\r\n            return \"REPORT\";\r\n        case \"/sap/bc/adt/runtime/traces/abaptraces/objecttypes/functionmodule\":\r\n            return \"FUNCTION_MODULE\";\r\n        case \"/sap/bc/adt/runtime/traces/abaptraces/objecttypes/sharedobjectarea\":\r\n            return \"SHARED_OBJECTS_AREA\";\r\n        default:\r\n            return \"ANY\";\r\n    }\r\n};\r\nconst decodeProcessType = (x) => {\r\n    switch (x) {\r\n        case \"/sap/bc/adt/runtime/traces/abaptraces/processtypes/any\":\r\n            return \"ANY\";\r\n        case \"/sap/bc/adt/runtime/traces/abaptraces/processtypes/http\":\r\n            return \"HTTP\";\r\n        case \"/sap/bc/adt/runtime/traces/abaptraces/processtypes/dialog\":\r\n            return \"DIALOG\";\r\n        case \"/sap/bc/adt/runtime/traces/abaptraces/processtypes/batch\":\r\n            return \"BATCH\";\r\n        case \"/sap/bc/adt/runtime/traces/abaptraces/processtypes/rfc\":\r\n            return \"RFC\";\r\n        case \"/sap/bc/adt/runtime/traces/abaptraces/processtypes/sharedobjectsarea\":\r\n            return \"SHARED_OBJECTS_AREA\";\r\n        default:\r\n            return \"ANY\";\r\n    }\r\n};\r\nexports.traceProcessObjects = {\r\n    ANY: [\r\n        \"FUNCTION_MODULE\",\r\n        \"URL\",\r\n        \"TRANSACTION\",\r\n        \"REPORT\",\r\n        \"SHARED_OBJECTS_AREA\",\r\n        \"ANY\"\r\n    ],\r\n    HTTP: [\"URL\"],\r\n    DIALOG: [\"TRANSACTION\", \"REPORT\"],\r\n    BATCH: [\"REPORT\"],\r\n    RFC: [\"FUNCTION_MODULE\"],\r\n    SHARED_OBJECTS_AREA: [\"SHARED_OBJECTS_AREA\"]\r\n};\r\nconst parseRawTrace = (x) => (0, AdtException_1.validateParseResult)(traceResults.decode(x)).feed;\r\nconst parseTraceResults = (xml) => {\r\n    const raw = parseRawTrace((0, utilities_1.fullParse)(xml, { removeNSPrefix: true }));\r\n    const runs = (0, utilities_1.extractXmlArray)(raw.entry).map(l => {\r\n        const links = (0, utilities_1.extractXmlArray)(l.link).map(utilities_1.typedNodeAttr);\r\n        const { id, author: { name: author, uri: authorUri }, content: { \"@_type\": type, \"@_src\": src }, \"@_lang\": lang, title } = l;\r\n        const published = new Date(l.published);\r\n        const updated = new Date(l.updated);\r\n        const extendedData = {\r\n            ...l.extendedData,\r\n            expiration: new Date(l.extendedData.expiration),\r\n            state: (0, utilities_1.typedNodeAttr)(l.extendedData.state)\r\n        };\r\n        // @ts-ignore\r\n        delete extendedData[\"#text\"];\r\n        return {\r\n            id,\r\n            author,\r\n            title,\r\n            published,\r\n            updated,\r\n            authorUri,\r\n            type,\r\n            src,\r\n            lang,\r\n            extendedData,\r\n            links\r\n        };\r\n    });\r\n    const { author: { name: author }, contributor: { name: contributor }, title } = raw;\r\n    const updated = new Date((0, utilities_1.xmlNode)(raw, \"updated\"));\r\n    return { author, contributor, title, updated, runs };\r\n};\r\nexports.parseTraceResults = parseTraceResults;\r\nconst parseTraceHitList = (xml) => {\r\n    const raw = (0, AdtException_1.validateParseResult)(HitListResponse.decode((0, utilities_1.fullParse)(xml, { removeNSPrefix: true }))).hitlist;\r\n    const parentLink = raw.link[\"@_href\"];\r\n    const entries = (0, utilities_1.extractXmlArray)(raw.entry).map(e => {\r\n        var _a;\r\n        const callingProgram = e.callingProgram\r\n            ? (0, utilities_1.typedNodeAttr)(e.callingProgram)\r\n            : undefined;\r\n        const calledProgram = (_a = e.calledProgram) === null || _a === void 0 ? void 0 : _a[\"@_context\"];\r\n        const grossTime = (0, utilities_1.typedNodeAttr)(e.grossTime);\r\n        const traceEventNetTime = (0, utilities_1.typedNodeAttr)(e.traceEventNetTime);\r\n        const proceduralNetTime = (0, utilities_1.typedNodeAttr)(e.proceduralNetTime);\r\n        return {\r\n            ...(0, utilities_1.typedNodeAttr)(e),\r\n            callingProgram,\r\n            calledProgram,\r\n            grossTime,\r\n            traceEventNetTime,\r\n            proceduralNetTime\r\n        };\r\n    });\r\n    return { parentLink, entries };\r\n};\r\nexports.parseTraceHitList = parseTraceHitList;\r\nconst parseTraceDbAccess = (xml) => {\r\n    const toParse = (0, utilities_1.fullParse)(xml, { removeNSPrefix: true });\r\n    const parsed = traceDBAccesResponse.decode(toParse);\r\n    const raw = (0, AdtException_1.validateParseResult)(parsed).dbAccesses;\r\n    const parentLink = raw.link[\"@_href\"];\r\n    const dbaccesses = (0, utilities_1.extractXmlArray)(raw.dbAccess).map(a => {\r\n        const callingProgram = a.callingProgram && (0, utilities_1.typedNodeAttr)(a.callingProgram);\r\n        const accessTime = (0, utilities_1.typedNodeAttr)(a.accessTime);\r\n        return { ...(0, utilities_1.typedNodeAttr)(a), accessTime, callingProgram };\r\n    });\r\n    const tables = raw.tables === \"\"\r\n        ? []\r\n        : (0, utilities_1.extractXmlArray)(raw.tables.table).map(utilities_1.typedNodeAttr);\r\n    return { parentLink, dbaccesses, tables };\r\n};\r\nexports.parseTraceDbAccess = parseTraceDbAccess;\r\nconst parseCount = (count) => {\r\n    if ((0, utilities_1.isNumber)(count))\r\n        return count;\r\n    const [base, exp] = count.split(\"E\").map(utilities_1.toInt);\r\n    if (exp)\r\n        return base * 10 ** exp;\r\n    return base;\r\n};\r\nconst parseTraceStatements = (xml) => {\r\n    const raw = (0, AdtException_1.validateParseResult)(traceStatementResponse.decode((0, utilities_1.fullParse)(xml, { removeNSPrefix: true }))).statements;\r\n    const parentLink = raw.link[\"@_href\"];\r\n    const statements = (0, utilities_1.extractXmlArray)(raw.statement).map(s => {\r\n        const callingProgram = (0, utilities_1.typedNodeAttr)(s.callingProgram);\r\n        const grossTime = (0, utilities_1.typedNodeAttr)(s.grossTime);\r\n        const proceduralNetTime = (0, utilities_1.typedNodeAttr)(s.proceduralNetTime);\r\n        const traceEventNetTime = (0, utilities_1.typedNodeAttr)(s.traceEventNetTime);\r\n        return {\r\n            ...(0, utilities_1.typedNodeAttr)(s),\r\n            callingProgram,\r\n            grossTime,\r\n            traceEventNetTime,\r\n            proceduralNetTime\r\n        };\r\n    });\r\n    const count = parseCount(raw[\"@_count\"]);\r\n    return { ...(0, utilities_1.typedNodeAttr)(raw), count, parentLink, statements };\r\n};\r\nexports.parseTraceStatements = parseTraceStatements;\r\nconst parseTraceRequestList = (xml) => {\r\n    const raw = tracesListRequest.decode((0, utilities_1.fullParse)(xml, { removeNSPrefix: true }));\r\n    const parsed = (0, AdtException_1.validateParseResult)(raw).feed;\r\n    const { contributor: { name: contributorName, \"@_role\": contributorRole }, title } = parsed;\r\n    const requests = (0, utilities_1.extractXmlArray)(parsed.entry).map(e => {\r\n        const { id, \"@_lang\": lang, title } = e;\r\n        const published = new Date(e.published);\r\n        const updated = new Date(e.updated);\r\n        const links = (0, utilities_1.extractXmlArray)(e.link).map(utilities_1.typedNodeAttr);\r\n        const authors = (0, utilities_1.extractXmlArray)(e.author).map(({ name, uri, \"@_role\": role }) => ({ name, role, uri }));\r\n        const { \"@_src\": contentSrc, \"@_type\": contentType } = e.content;\r\n        const { description, executions, isAggregated, host, requestIndex } = e.extendedData;\r\n        const expires = new Date(e.extendedData.expires);\r\n        const processType = decodeProcessType(e.extendedData.processType[\"@_processTypeId\"]);\r\n        const objectType = decodeObjectType(e.extendedData.object[\"@_objectTypeId\"]);\r\n        const clients = (0, utilities_1.extractXmlArray)(e.extendedData.client).map(({ \"#text\": id = 0, \"@_role\": role = \"\" }) => ({ id, role }));\r\n        const extendedData = {\r\n            description,\r\n            executions: (0, utilities_1.typedNodeAttr)(executions),\r\n            isAggregated,\r\n            host,\r\n            expires,\r\n            processType,\r\n            objectType,\r\n            requestIndex,\r\n            clients\r\n        };\r\n        return {\r\n            id,\r\n            lang,\r\n            title,\r\n            published,\r\n            updated,\r\n            links,\r\n            authors,\r\n            contentSrc,\r\n            contentType,\r\n            extendedData\r\n        };\r\n    });\r\n    return { title, contributorName, contributorRole, requests };\r\n};\r\nexports.parseTraceRequestList = parseTraceRequestList;\r\n","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.getTransportConfiguration = exports.transportConfigurations = exports.transportReference = exports.systemUsers = exports.transportAddUser = exports.transportSetOwner = exports.transportRelease = exports.transportDelete = exports.setTransportsConfig = exports.createTransportsConfig = exports.transportsByConfig = exports.userTransports = exports.createTransport = exports.transportInfo = exports.TransportDateFilter = void 0;\r\nconst AdtException_1 = require(\"../AdtException\");\r\nconst utilities_1 = require(\"../utilities\");\r\nvar TransportDateFilter;\r\n(function (TransportDateFilter) {\r\n    TransportDateFilter[TransportDateFilter[\"SinceYesterday\"] = 0] = \"SinceYesterday\";\r\n    TransportDateFilter[TransportDateFilter[\"SincleTwoWeeks\"] = 1] = \"SincleTwoWeeks\";\r\n    TransportDateFilter[TransportDateFilter[\"SinceFourWeeks\"] = 2] = \"SinceFourWeeks\";\r\n    TransportDateFilter[TransportDateFilter[\"DateRange\"] = 3] = \"DateRange\";\r\n})(TransportDateFilter = exports.TransportDateFilter || (exports.TransportDateFilter = {}));\r\nfunction extractLocks(raw) {\r\n    const lock = raw && raw.CTS_OBJECT_LOCK;\r\n    if (!lock)\r\n        return;\r\n    try {\r\n        const holder = lock.LOCK_HOLDER;\r\n        const TASKS = (0, utilities_1.xmlArray)(holder, \"TASK_HEADERS\").map((x) => x.CTS_TASK_HEADER);\r\n        return {\r\n            HEADER: holder.REQ_HEADER,\r\n            OBJECT_KEY: (0, utilities_1.xmlNode)(lock, \"OBJECT_KEY\"),\r\n            TASKS\r\n        };\r\n    }\r\n    catch (_a) {\r\n        return;\r\n    }\r\n}\r\nfunction extractTransports(raw) {\r\n    return (0, utilities_1.xmlArray)(raw, \"CTS_REQUEST\").map((x) => x.REQ_HEADER);\r\n}\r\nasync function transportInfo(h, URI, DEVCLASS = \"\", OPERATION = \"I\") {\r\n    (0, AdtException_1.ValidateObjectUrl)(URI);\r\n    const body = (0, utilities_1.JSON2AbapXML)({\r\n        DEVCLASS,\r\n        OPERATION,\r\n        URI\r\n    });\r\n    const headers = {\r\n        Accept: \"application/vnd.sap.as+xml;charset=UTF-8;dataname=com.sap.adt.transport.service.checkData\",\r\n        \"Content-Type\": \"application/vnd.sap.as+xml; charset=UTF-8; dataname=com.sap.adt.transport.service.checkData\"\r\n    };\r\n    const response = await h.request(\"/sap/bc/adt/cts/transportchecks\", {\r\n        body,\r\n        method: \"POST\",\r\n        headers\r\n    });\r\n    // return parsePackageResponse(response.body)\r\n    // tslint:disable-next-line: prefer-const\r\n    let { REQUESTS, LOCKS, MESSAGES, ...header } = (0, utilities_1.parse)(response.body)[\"asx:abap\"][\"asx:values\"].DATA;\r\n    if (MESSAGES) {\r\n        MESSAGES = (0, utilities_1.xmlArray)(MESSAGES, \"CTS_MESSAGE\").map((m) => {\r\n            // tslint:disable-next-line: prefer-const\r\n            let { VARIABLES, ...rest } = m;\r\n            VARIABLES =\r\n                (VARIABLES && (0, utilities_1.xmlArray)(m, \"VARIABLES\", \"CTS_VARIABLE\")).map((v) => v.VARIABLE) || [];\r\n            return { VARIABLES, ...rest };\r\n        });\r\n        MESSAGES.filter((m) => m.SEVERITY.match(/[EAX]/)).some((e) => {\r\n            throw (0, AdtException_1.adtException)(e.TEXT);\r\n        });\r\n    }\r\n    const TRANSPORTS = extractTransports(REQUESTS);\r\n    return { ...header, LOCKS: extractLocks(LOCKS), TRANSPORTS };\r\n}\r\nexports.transportInfo = transportInfo;\r\nasync function createTransport(h, REF, REQUEST_TEXT, DEVCLASS, OPERATION = \"I\", transportLayer = \"\") {\r\n    var _a;\r\n    (0, AdtException_1.ValidateObjectUrl)(REF);\r\n    const body = (0, utilities_1.JSON2AbapXML)({ DEVCLASS, REQUEST_TEXT, REF, OPERATION });\r\n    const qs = transportLayer ? { transportLayer } : {};\r\n    const response = await h.request(\"/sap/bc/adt/cts/transports\", {\r\n        body,\r\n        qs,\r\n        headers: {\r\n            Accept: \"text/plain\",\r\n            \"Content-Type\": \"application/vnd.sap.as+xml; charset=UTF-8; dataname=com.sap.adt.CreateCorrectionRequest\"\r\n        },\r\n        method: \"POST\"\r\n    });\r\n    const transport = (_a = response.body) === null || _a === void 0 ? void 0 : _a.split(\"/\").pop();\r\n    return transport || \"\";\r\n}\r\nexports.createTransport = createTransport;\r\nconst parseTask = (t) => {\r\n    const task = {\r\n        ...(0, utilities_1.xmlNodeAttr)(t),\r\n        links: (0, utilities_1.xmlArray)(t, \"atom:link\").map(utilities_1.xmlNodeAttr),\r\n        objects: (0, utilities_1.xmlArray)(t, \"tm:abap_object\").map(utilities_1.xmlNodeAttr)\r\n    };\r\n    if (task[\"tm:desc\"])\r\n        task[\"tm:desc\"] = task[\"tm:desc\"];\r\n    return task;\r\n};\r\nconst parseRequest = (r) => {\r\n    const request = {\r\n        ...parseTask(r),\r\n        tasks: (0, utilities_1.xmlArray)(r, \"tm:task\").map(parseTask)\r\n    };\r\n    return request;\r\n};\r\nconst parseTargets = (s) => ({\r\n    ...(0, utilities_1.xmlNodeAttr)(s),\r\n    modifiable: (0, utilities_1.xmlArray)(s, \"tm:modifiable\", \"tm:request\").map(parseRequest),\r\n    released: (0, utilities_1.xmlArray)(s, \"tm:released\", \"tm:request\").map(parseRequest)\r\n});\r\nasync function userTransports(h, user, targets = true) {\r\n    const response = await h.request(\"/sap/bc/adt/cts/transportrequests\", {\r\n        qs: { user, targets }\r\n    });\r\n    const raw = (0, utilities_1.fullParse)(response.body);\r\n    const workbench = (0, utilities_1.xmlArray)(raw, \"tm:root\", \"tm:workbench\", \"tm:target\").map(parseTargets);\r\n    const customizing = (0, utilities_1.xmlArray)(raw, \"tm:root\", \"tm:customizing\", \"tm:target\").map(parseTargets);\r\n    const retval = { workbench, customizing };\r\n    return retval;\r\n}\r\nexports.userTransports = userTransports;\r\nasync function transportsByConfig(h, configUri, targets = true) {\r\n    const response = await h.request(\"/sap/bc/adt/cts/transportrequests\", {\r\n        qs: { configUri, targets }\r\n    });\r\n    const raw = (0, utilities_1.fullParse)(response.body);\r\n    const workbench = (0, utilities_1.xmlArray)(raw, \"tm:root\", \"tm:workbench\", \"tm:target\").map(parseTargets);\r\n    const customizing = (0, utilities_1.xmlArray)(raw, \"tm:root\", \"tm:customizing\", \"tm:target\").map(parseTargets);\r\n    const retval = { workbench, customizing };\r\n    return retval;\r\n}\r\nexports.transportsByConfig = transportsByConfig;\r\nconst serializeTransportConfig = (cfg) => {\r\n    const w = (k, v) => `<configuration:property key=\"${k}\">${v}</configuration:property>`;\r\n    const p = (v, k) => w(k, v[k]);\r\n    const td = (d) => `${(0, utilities_1.toSapDate)(new Date(d))}`;\r\n    const datelimit = cfg.DateFilter === TransportDateFilter.DateRange\r\n        ? `${w(\"FromDate\", td(cfg.FromDate))}${w(\"ToDate\", td(cfg.ToDate))}`\r\n        : \"\";\r\n    return \"\".concat(`<configuration:configuration xmlns:configuration=\"http://www.sap.com/adt/configuration\"> <configuration:properties>`, p(cfg, \"WorkbenchRequests\"), p(cfg, \"CustomizingRequests\"), p(cfg, \"TransportOfCopies\"), p(cfg, \"DateFilter\"), p(cfg, \"Modifiable\"), p(cfg, \"Released\"), p(cfg, \"User\"), datelimit, `</configuration:properties> </configuration:configuration>`);\r\n};\r\nasync function createTransportsConfig(h) {\r\n    const headers = { Accept: \"application/vnd.sap.adt.configuration.v1+xml\" };\r\n    const uri = \"/sap/bc/adt/cts/transportrequests/searchconfiguration/configurations\";\r\n    const response = await h.request(uri, { method: \"POST\", headers });\r\n    return parseTransportConfig(response.body);\r\n}\r\nexports.createTransportsConfig = createTransportsConfig;\r\nasync function setTransportsConfig(h, uri, etag, config) {\r\n    const body = serializeTransportConfig(config);\r\n    const headers = {\r\n        Accept: \"application/vnd.sap.adt.configuration.v1+xml\",\r\n        \"Content-Type\": \"application/vnd.sap.adt.configuration.v1+xml\",\r\n        \"If-Match\": etag\r\n    };\r\n    const response = await h.request(uri, { method: \"PUT\", headers, body });\r\n    return parseTransportConfig(response.body);\r\n}\r\nexports.setTransportsConfig = setTransportsConfig;\r\nfunction validateTransport(transportNumber) {\r\n    if (transportNumber.length !== 10 || !transportNumber.match(/^[a-z]\\w\\wk/i))\r\n        (0, AdtException_1.adtException)(\"Invalid transport number:\" + transportNumber);\r\n}\r\nasync function transportDelete(h, transportNumber) {\r\n    validateTransport(transportNumber);\r\n    await h.request(\"/sap/bc/adt/cts/transportrequests/\" + transportNumber, {\r\n        method: \"DELETE\",\r\n        headers: { Accept: \"application/*\" }\r\n    });\r\n}\r\nexports.transportDelete = transportDelete;\r\nasync function transportRelease(h, transportNumber, ignoreLocks = false, IgnoreATC = false) {\r\n    validateTransport(transportNumber);\r\n    const action = IgnoreATC\r\n        ? \"relObjigchkatc\"\r\n        : ignoreLocks\r\n            ? \"relwithignlock\"\r\n            : \"newreleasejobs\";\r\n    const response = await h.request(`/sap/bc/adt/cts/transportrequests/${transportNumber}/${action}`, {\r\n        method: \"POST\",\r\n        headers: { Accept: \"application/*\" }\r\n    });\r\n    const raw = (0, utilities_1.fullParse)(response.body);\r\n    const reports = (0, utilities_1.xmlArray)(raw, \"tm:root\", \"tm:releasereports\", \"chkrun:checkReport\").map((r) => {\r\n        return {\r\n            ...(0, utilities_1.xmlNodeAttr)(r),\r\n            messages: (0, utilities_1.xmlArray)(r, \"chkrun:checkMessageList\", \"chkrun:checkMessage\").map(utilities_1.xmlNodeAttr)\r\n        };\r\n    });\r\n    return reports;\r\n}\r\nexports.transportRelease = transportRelease;\r\nasync function transportSetOwner(h, transportNumber, targetuser) {\r\n    validateTransport(transportNumber);\r\n    const body = `<?xml version=\"1.0\" encoding=\"ASCII\"?><tm:root xmlns:tm=\"http://www.sap.com/cts/adt/tm\" tm:number=\"${transportNumber}\" tm:targetuser=\"${targetuser}\" tm:useraction=\"changeowner\"/>`;\r\n    const response = await h.request(\"/sap/bc/adt/cts/transportrequests/\" + transportNumber, {\r\n        method: \"PUT\",\r\n        headers: { Accept: \"application/*\" },\r\n        qs: { targetuser },\r\n        body\r\n    });\r\n    const raw = (0, utilities_1.fullParse)(response.body);\r\n    return (0, utilities_1.xmlNodeAttr)((0, utilities_1.xmlNode)(raw, \"tm:root\"));\r\n}\r\nexports.transportSetOwner = transportSetOwner;\r\nasync function transportAddUser(h, transportNumber, user) {\r\n    validateTransport(transportNumber);\r\n    const body = `<?xml version=\"1.0\" encoding=\"ASCII\"?>\n  <tm:root xmlns:tm=\"http://www.sap.com/cts/adt/tm\" tm:number=\"${transportNumber}\"\n  tm:targetuser=\"${user}\" tm:useraction=\"newtask\"/>`;\r\n    const response = await h.request(\"/sap/bc/adt/cts/transportrequests/\" + transportNumber + \"/tasks\", {\r\n        method: \"POST\",\r\n        body,\r\n        headers: { Accept: \"application/*\", \"Content-Type\": \"text/plain\" }\r\n    });\r\n    const raw = (0, utilities_1.fullParse)(response.body);\r\n    return (0, utilities_1.xmlNodeAttr)((0, utilities_1.xmlNode)(raw, \"tm:root\"));\r\n}\r\nexports.transportAddUser = transportAddUser;\r\nasync function systemUsers(h) {\r\n    const response = await h.request(\"/sap/bc/adt/system/users\", {\r\n        headers: { Accept: \"application/atom+xml;type=feed\" }\r\n    });\r\n    const raw = (0, utilities_1.parse)(response.body);\r\n    return (0, utilities_1.xmlArray)(raw, \"atom:feed\", \"atom:entry\").map((r) => ({ id: r[\"atom:id\"], title: r[\"atom:title\"] }));\r\n}\r\nexports.systemUsers = systemUsers;\r\n// tslint:disable: variable-name\r\nasync function transportReference(h, pgmid, obj_wbtype, obj_name, tr_number = \"\") {\r\n    const response = await h.request(\"/sap/bc/adt/cts/transportrequests/reference\", {\r\n        headers: { Accept: \"application/*\" },\r\n        qs: { obj_name, obj_wbtype, pgmid, tr_number }\r\n    });\r\n    const raw = (0, utilities_1.fullParse)(response.body);\r\n    const link = (0, utilities_1.xmlNodeAttr)((0, utilities_1.xmlNode)(raw, \"tm:root\", \"atom:link\"));\r\n    return link.href;\r\n}\r\nexports.transportReference = transportReference;\r\nconst parseTransportConfigItemList = (body) => {\r\n    const raw = (0, utilities_1.fullParse)(body, { parseAttributeValue: false });\r\n    return (0, utilities_1.xmlArray)(raw, \"configurations:configurations\", \"configuration:configuration\").map((conf) => {\r\n        const { \"atom:link\": { \"@_href\": link, \"@_etag\": etag }, ...rest } = conf;\r\n        const { createdAt, changedAt, ...attrs } = (0, utilities_1.xmlNodeAttr)(rest);\r\n        const item = {\r\n            ...attrs,\r\n            link,\r\n            etag,\r\n            createdAt: Date.parse(createdAt),\r\n            changedAt: Date.parse(changedAt)\r\n        };\r\n        return item;\r\n    });\r\n};\r\nasync function transportConfigurations(h) {\r\n    const headers = { Accept: \"application/vnd.sap.adt.configurations.v1+xml\" };\r\n    const url = \"/sap/bc/adt/cts/transportrequests/searchconfiguration/configurations\";\r\n    const response = await h.request(url, { headers });\r\n    return parseTransportConfigItemList(response.body);\r\n}\r\nexports.transportConfigurations = transportConfigurations;\r\nconst parseTransportConfig = (r) => {\r\n    const raw = (0, utilities_1.fullParse)(r, { parseAttributeValue: false });\r\n    const props = (0, utilities_1.xmlArray)(raw, \"configuration:configuration\", \"configuration:properties\", \"configuration:property\").map((p) => {\r\n        return { key: p[\"@_key\"], value: p[\"#text\"] };\r\n    });\r\n    const cfg = {};\r\n    for (const { key, value } of props)\r\n        cfg[key] = value;\r\n    const WorkbenchRequests = cfg.WorkbenchRequests;\r\n    const TransportOfCopies = cfg.TransportOfCopies;\r\n    const Released = cfg.Released;\r\n    const User = cfg.User;\r\n    const CustomizingRequests = cfg.CustomizingRequests;\r\n    const FromDate = cfg.FromDate && (0, utilities_1.parseSapDate)(`${cfg.FromDate}`);\r\n    const ToDate = cfg.ToDate && (0, utilities_1.parseSapDate)(`${cfg.ToDate}`);\r\n    const DateFilter = cfg.DateFilter;\r\n    const Modifiable = cfg.Modifiable;\r\n    return {\r\n        WorkbenchRequests,\r\n        TransportOfCopies,\r\n        Released,\r\n        User,\r\n        CustomizingRequests,\r\n        FromDate,\r\n        ToDate,\r\n        DateFilter,\r\n        Modifiable\r\n    };\r\n};\r\nasync function getTransportConfiguration(h, url) {\r\n    const headers = { Accept: \"application/vnd.sap.adt.configuration.v1+xml\" };\r\n    const response = await h.request(url, { headers });\r\n    return parseTransportConfig(response.body);\r\n}\r\nexports.getTransportConfiguration = getTransportConfiguration;\r\n","\"use strict\";\r\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    var desc = Object.getOwnPropertyDescriptor(m, k);\r\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\r\n      desc = { enumerable: true, get: function() { return m[k]; } };\r\n    }\r\n    Object.defineProperty(o, k2, desc);\r\n}) : (function(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    o[k2] = m[k];\r\n}));\r\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\r\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\r\n}) : function(o, v) {\r\n    o[\"default\"] = v;\r\n});\r\nvar __importStar = (this && this.__importStar) || function (mod) {\r\n    if (mod && mod.__esModule) return mod;\r\n    var result = {};\r\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\r\n    __setModuleDefault(result, mod);\r\n    return result;\r\n};\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.unitTestOccurrenceMarkers = exports.unitTestEvaluation = exports.runUnitTest = exports.DefaultUnitTestRunFlags = exports.UnitTestSeverity = exports.UnitTestAlertKind = void 0;\r\nconst t = __importStar(require(\"io-ts\"));\r\nconst __1 = require(\"..\");\r\nconst utilities_1 = require(\"../utilities\");\r\nconst urlparser_1 = require(\"./urlparser\");\r\nvar UnitTestAlertKind;\r\n(function (UnitTestAlertKind) {\r\n    UnitTestAlertKind[\"exception\"] = \"exception\";\r\n    UnitTestAlertKind[\"failedAssertion\"] = \"failedAssertion\";\r\n    UnitTestAlertKind[\"warning\"] = \"warning\";\r\n})(UnitTestAlertKind = exports.UnitTestAlertKind || (exports.UnitTestAlertKind = {}));\r\nvar UnitTestSeverity;\r\n(function (UnitTestSeverity) {\r\n    UnitTestSeverity[\"critical\"] = \"critical\";\r\n    UnitTestSeverity[\"fatal\"] = \"fatal\";\r\n    UnitTestSeverity[\"tolerable\"] = \"tolerable\";\r\n    UnitTestSeverity[\"tolerant\"] = \"tolerant\";\r\n})(UnitTestSeverity = exports.UnitTestSeverity || (exports.UnitTestSeverity = {}));\r\nconst markerCodec = t.type({\r\n    kind: t.string,\r\n    keepsResult: t.boolean,\r\n    location: urlparser_1.uriParts\r\n});\r\nconst parseDetail = (alert) => (0, utilities_1.xmlArray)(alert, \"details\", \"detail\").reduce((result, d) => {\r\n    const main = (d && d[\"@_text\"]) || \"\";\r\n    const children = (0, utilities_1.xmlArray)(d, \"details\", \"detail\")\r\n        .map((dd) => (dd && `\\n\\t${dd[\"@_text\"]}`) || \"\")\r\n        .join(\"\");\r\n    return main ? [...result, main + children] : result;\r\n}, []);\r\nconst parseStack = (alert) => (0, utilities_1.xmlArray)(alert, \"stack\", \"stackEntry\").map(x => {\r\n    const entry = (0, utilities_1.xmlNodeAttr)(x);\r\n    entry[\"adtcore:description\"] = entry[\"adtcore:description\"];\r\n    return entry;\r\n});\r\nconst parseAlert = (alert) => ({\r\n    ...(0, utilities_1.xmlNodeAttr)(alert),\r\n    details: parseDetail(alert),\r\n    stack: parseStack(alert),\r\n    title: (alert === null || alert === void 0 ? void 0 : alert.title) || \"\"\r\n});\r\nconst parseMethod = (method) => ({\r\n    ...(0, utilities_1.xmlNodeAttr)(method),\r\n    alerts: (0, utilities_1.xmlArray)(method, \"alerts\", \"alert\").map(parseAlert)\r\n});\r\nexports.DefaultUnitTestRunFlags = {\r\n    harmless: true,\r\n    dangerous: false,\r\n    critical: false,\r\n    short: true,\r\n    medium: false,\r\n    long: false\r\n};\r\nasync function runUnitTest(h, url, flags = exports.DefaultUnitTestRunFlags) {\r\n    const headers = { \"Content-Type\": \"application/*\", Accept: \"application/*\" };\r\n    const body = `<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n  <aunit:runConfiguration xmlns:aunit=\"http://www.sap.com/adt/aunit\">\n  <external>\n    <coverage active=\"false\"/>\n  </external>\n  <options>\n    <uriType value=\"semantic\"/>\n    <testDeterminationStrategy sameProgram=\"true\" assignedTests=\"false\"/>\n    <testRiskLevels harmless=\"${flags.harmless}\" dangerous=\"${flags.dangerous}\" critical=\"${flags.critical}\"/>\n    <testDurations short=\"${flags.short}\" medium=\"${flags.medium}\" long=\"${flags.long}\"/>\n    <withNavigationUri enabled=\"true\"/>    \n  </options>\n  <adtcore:objectSets xmlns:adtcore=\"http://www.sap.com/adt/core\">\n    <objectSet kind=\"inclusive\">\n      <adtcore:objectReferences>\n        <adtcore:objectReference adtcore:uri=\"${url}\"/>\n      </adtcore:objectReferences>\n    </objectSet>\n  </adtcore:objectSets>\n</aunit:runConfiguration>`;\r\n    const response = await h.request(\"/sap/bc/adt/abapunit/testruns\", {\r\n        method: \"POST\",\r\n        headers,\r\n        body\r\n    });\r\n    const raw = (0, utilities_1.fullParse)(response.body);\r\n    const classes = (0, utilities_1.xmlFlatArray)(raw, \"aunit:runResult\", \"program\", \"testClasses\", \"testClass\").map(c => {\r\n        return {\r\n            ...(0, utilities_1.xmlNodeAttr)(c),\r\n            alerts: (0, utilities_1.xmlArray)(c, \"alerts\", \"alert\").map(parseAlert),\r\n            testmethods: (0, utilities_1.xmlFlatArray)(c, \"testMethods\", \"testMethod\").map(parseMethod)\r\n        };\r\n    });\r\n    return classes;\r\n}\r\nexports.runUnitTest = runUnitTest;\r\nasync function unitTestEvaluation(h, clas, flags = exports.DefaultUnitTestRunFlags) {\r\n    const headers = { \"Content-Type\": \"application/*l\", Accept: \"application/*\" };\r\n    const references = clas.testmethods\r\n        .map(m => `<adtcore:objectReference adtcore:uri=\"${m[\"adtcore:uri\"]}\" />`)\r\n        .join(\"\\n\");\r\n    const body = `<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n  <aunit:runConfiguration xmlns:aunit=\"http://www.sap.com/adt/aunit\">\n      <options>\n          <uriType value=\"${clas.uriType}\"></uriType>\n          <testDeterminationStrategy sameProgram=\"true\" assignedTests=\"false\"></testDeterminationStrategy>\n          <testRiskLevels harmless=\"${flags.harmless}\" dangerous=\"${flags.dangerous}\" critical=\"${flags.critical}\"/>\n          <testDurations short=\"${flags.short}\" medium=\"${flags.medium}\" long=\"${flags.long}\"/>      \n          <withNavigationUri enabled=\"true\"></withNavigationUri>\n      </options>\n      <adtcore:objectSets xmlns:adtcore=\"http://www.sap.com/adt/core\">\n          <objectSet kind=\"inclusive\">\n              <adtcore:objectReferences>\n              ${references}\n              </adtcore:objectReferences>\n          </objectSet>\n      </adtcore:objectSets>\n  </aunit:runConfiguration>`;\r\n    const response = await h.request(\"/sap/bc/adt/abapunit/testruns/evaluation\", {\r\n        method: \"POST\",\r\n        headers,\r\n        body\r\n    });\r\n    const raw = (0, utilities_1.fullParse)(response.body);\r\n    return (0, utilities_1.xmlArray)(raw, \"aunit:runResult\", \"program\", \"testClasses\", \"testClass\", \"testMethods\", \"testMethod\").map(parseMethod);\r\n}\r\nexports.unitTestEvaluation = unitTestEvaluation;\r\nasync function unitTestOccurrenceMarkers(h, uri, source) {\r\n    const headers = { \"Content-Type\": \"text/plain\", Accept: \"application/*\" };\r\n    const response = await h.request(\"/sap/bc/adt/abapsource/occurencemarkers\", {\r\n        method: \"POST\",\r\n        headers,\r\n        body: source,\r\n        qs: { uri }\r\n    });\r\n    const raw = (0, utilities_1.fullParse)(response.body, { removeNSPrefix: true });\r\n    const markers = (0, utilities_1.xmlArray)(raw, \"occurrenceInfo\", \"occurrences\", \"occurrence\").map(o => {\r\n        const { kind, keepsResult } = (0, utilities_1.xmlNodeAttr)(o);\r\n        const { uri } = (0, utilities_1.xmlNodeAttr)(o === null || o === void 0 ? void 0 : o.objectReference);\r\n        return { kind, keepsResult, location: (0, urlparser_1.parseUri)(uri) };\r\n    });\r\n    return (0, __1.validateParseResult)(t.array(markerCodec).decode(markers));\r\n}\r\nexports.unitTestOccurrenceMarkers = unitTestOccurrenceMarkers;\r\n","\"use strict\";\r\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    var desc = Object.getOwnPropertyDescriptor(m, k);\r\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\r\n      desc = { enumerable: true, get: function() { return m[k]; } };\r\n    }\r\n    Object.defineProperty(o, k2, desc);\r\n}) : (function(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    o[k2] = m[k];\r\n}));\r\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\r\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\r\n}) : function(o, v) {\r\n    o[\"default\"] = v;\r\n});\r\nvar __importStar = (this && this.__importStar) || function (mod) {\r\n    if (mod && mod.__esModule) return mod;\r\n    var result = {};\r\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\r\n    __setModuleDefault(result, mod);\r\n    return result;\r\n};\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.parseUri = exports.uriPartsToString = exports.rangeToString = exports.uriParts = void 0;\r\nconst utilities_1 = require(\"../utilities\");\r\nconst t = __importStar(require(\"io-ts\"));\r\nconst location = t.type({\r\n    line: t.number,\r\n    column: t.number\r\n});\r\nconst range = t.type({\r\n    start: location,\r\n    end: location\r\n});\r\nexports.uriParts = t.type({\r\n    uri: t.string,\r\n    query: t.union([t.undefined, t.record(t.string, t.string)]),\r\n    range: range,\r\n    hashparms: t.union([t.undefined, t.record(t.string, t.string)]),\r\n});\r\nconst rangeToString = (range) => `#start=${range.start.line},${range.start.column};end=${range.end.line},${range.end.column}`;\r\nexports.rangeToString = rangeToString;\r\nconst serializeKv = (r) => {\r\n    const rec = r || {};\r\n    return Object.keys(rec).map(k => `${encodeURIComponent(k)}=${encodeURIComponent(rec[k])}`);\r\n};\r\nconst isNullRange = (r) => r.start.line === 0 && r.start.column === 0 && r.end.line === 0 && r.end.column === 0;\r\nconst uriPartsToString = (parts) => {\r\n    const range = isNullRange(parts.range) ? \"\" : (0, exports.rangeToString)(parts.range);\r\n    const parms = serializeKv(parts.hashparms).join(\";\");\r\n    const query = serializeKv(parts.query).join(\"&\");\r\n    const hash = `${range ? range : \"\"}${parms ? `${range ? \";\" : \"#\"}${parms}` : ``}`;\r\n    return `${parts.uri}${query ? `?${query}` : ``}${hash}`;\r\n};\r\nexports.uriPartsToString = uriPartsToString;\r\nfunction parseUri(sourceuri) {\r\n    const [uri, qs, hash] = (0, utilities_1.parts)(sourceuri, /([^\\?#]*)(?:\\?([^#]*))?(?:#(.*))?/);\r\n    //\r\n    const query = (qs || \"\").split(/&/).reduce((acc, cur) => {\r\n        const [key, val] = cur.split(\"=\");\r\n        if (key)\r\n            acc[decodeURIComponent(key)] = decodeURIComponent(val);\r\n        return acc;\r\n    }, {});\r\n    const { start, end, ...hashparms } = (hash || \"\")\r\n        .split(/;/)\r\n        .reduce((acc, cur) => {\r\n        const [key, val] = cur.split(\"=\");\r\n        if (key)\r\n            acc[decodeURIComponent(key)] = decodeURIComponent(val);\r\n        return acc;\r\n    }, {});\r\n    const parsePos = (x) => {\r\n        const [line, column] = x ? x.split(\",\").map(utilities_1.toInt) : [0, 0];\r\n        return { line: line || 0, column: column || 0 };\r\n    };\r\n    const st = parsePos(start);\r\n    const range = {\r\n        start: st,\r\n        end: end ? parsePos(end) : st\r\n    };\r\n    return { range, uri, query, hashparms };\r\n}\r\nexports.parseUri = parseUri;\r\n","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.Agent = void 0;\r\nclass Agent {\r\n    constructor(opts) {\r\n        //opts.ca\r\n        //opts.keepAlive\r\n        //opts.rejectUnauthorized\r\n    }\r\n}\r\nexports.Agent = Agent;\r\nconst https = { Agent: Agent };\r\nexports.default = https;\r\n","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconsole.log(axios);\r\nmodule.exports = axios;\r\n","\"use strict\";\r\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    var desc = Object.getOwnPropertyDescriptor(m, k);\r\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\r\n      desc = { enumerable: true, get: function() { return m[k]; } };\r\n    }\r\n    Object.defineProperty(o, k2, desc);\r\n}) : (function(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    o[k2] = m[k];\r\n}));\r\nvar __exportStar = (this && this.__exportStar) || function(m, exports) {\r\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);\r\n};\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.traceProcessObjects = exports.servicePreviewUrl = exports.parseServiceBinding = exports.parentTypeId = exports.objectPath = exports.isDebuggerBreakpoint = exports.isDebuggee = exports.isDebugListenerError = exports.isPackageType = exports.isPackageOptions = exports.isNonGroupType = exports.isNodeParent = exports.isGroupType = exports.isCreatableTypeId = exports.isClassStructure = exports.isClassMetaData = exports.isBindingOptions = exports.inactiveObjectsInResults = exports.hasPackageOptions = exports.debugMetaIsComplex = exports.uriPartsToString = exports.UnitTestSeverity = exports.UnitTestAlertKind = exports.TypeKinds = exports.TransportDateFilter = exports.CreatableTypes = exports.BindinTypes = exports.session_types = void 0;\r\nvar AdtHTTP_1 = require(\"./AdtHTTP\");\r\nObject.defineProperty(exports, \"session_types\", { enumerable: true, get: function () { return AdtHTTP_1.session_types; } });\r\n__exportStar(require(\"./AdtClient\"), exports);\r\n__exportStar(require(\"./AdtException\"), exports);\r\nvar api_1 = require(\"./api\");\r\nObject.defineProperty(exports, \"BindinTypes\", { enumerable: true, get: function () { return api_1.BindinTypes; } });\r\nObject.defineProperty(exports, \"CreatableTypes\", { enumerable: true, get: function () { return api_1.CreatableTypes; } });\r\nObject.defineProperty(exports, \"TransportDateFilter\", { enumerable: true, get: function () { return api_1.TransportDateFilter; } });\r\nObject.defineProperty(exports, \"TypeKinds\", { enumerable: true, get: function () { return api_1.TypeKinds; } });\r\nObject.defineProperty(exports, \"UnitTestAlertKind\", { enumerable: true, get: function () { return api_1.UnitTestAlertKind; } });\r\nObject.defineProperty(exports, \"UnitTestSeverity\", { enumerable: true, get: function () { return api_1.UnitTestSeverity; } });\r\nObject.defineProperty(exports, \"uriPartsToString\", { enumerable: true, get: function () { return api_1.uriPartsToString; } });\r\nObject.defineProperty(exports, \"debugMetaIsComplex\", { enumerable: true, get: function () { return api_1.debugMetaIsComplex; } });\r\nObject.defineProperty(exports, \"hasPackageOptions\", { enumerable: true, get: function () { return api_1.hasPackageOptions; } });\r\nObject.defineProperty(exports, \"inactiveObjectsInResults\", { enumerable: true, get: function () { return api_1.inactiveObjectsInResults; } });\r\nObject.defineProperty(exports, \"isBindingOptions\", { enumerable: true, get: function () { return api_1.isBindingOptions; } });\r\nObject.defineProperty(exports, \"isClassMetaData\", { enumerable: true, get: function () { return api_1.isClassMetaData; } });\r\nObject.defineProperty(exports, \"isClassStructure\", { enumerable: true, get: function () { return api_1.isClassStructure; } });\r\nObject.defineProperty(exports, \"isCreatableTypeId\", { enumerable: true, get: function () { return api_1.isCreatableTypeId; } });\r\nObject.defineProperty(exports, \"isGroupType\", { enumerable: true, get: function () { return api_1.isGroupType; } });\r\nObject.defineProperty(exports, \"isNodeParent\", { enumerable: true, get: function () { return api_1.isNodeParent; } });\r\nObject.defineProperty(exports, \"isNonGroupType\", { enumerable: true, get: function () { return api_1.isNonGroupType; } });\r\nObject.defineProperty(exports, \"isPackageOptions\", { enumerable: true, get: function () { return api_1.isPackageOptions; } });\r\nObject.defineProperty(exports, \"isPackageType\", { enumerable: true, get: function () { return api_1.isPackageType; } });\r\nObject.defineProperty(exports, \"isDebugListenerError\", { enumerable: true, get: function () { return api_1.isDebugListenerError; } });\r\nObject.defineProperty(exports, \"isDebuggee\", { enumerable: true, get: function () { return api_1.isDebuggee; } });\r\nObject.defineProperty(exports, \"isDebuggerBreakpoint\", { enumerable: true, get: function () { return api_1.isDebuggerBreakpoint; } });\r\nObject.defineProperty(exports, \"objectPath\", { enumerable: true, get: function () { return api_1.objectPath; } });\r\nObject.defineProperty(exports, \"parentTypeId\", { enumerable: true, get: function () { return api_1.parentTypeId; } });\r\nObject.defineProperty(exports, \"parseServiceBinding\", { enumerable: true, get: function () { return api_1.parseServiceBinding; } });\r\nObject.defineProperty(exports, \"servicePreviewUrl\", { enumerable: true, get: function () { return api_1.servicePreviewUrl; } });\r\nObject.defineProperty(exports, \"traceProcessObjects\", { enumerable: true, get: function () { return api_1.traceProcessObjects; } });\r\n","\"use strict\";\r\nvar __importDefault = (this && this.__importDefault) || function (mod) {\r\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\r\n};\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.logResponse = exports.logError = void 0;\r\nconst axios_1 = __importDefault(require(\"axios\"));\r\nconst _1 = require(\".\");\r\nconst utilities_1 = require(\"./utilities\");\r\nconst getLoggingData = (config) => {\r\n    if (!(0, utilities_1.isObject)(config))\r\n        return { id: -1, startTime: new Date(), duration: 0 };\r\n    const id = (0, utilities_1.isNumber)(config === null || config === void 0 ? void 0 : config.adtRequestNumber) ? config.adtRequestNumber : -1;\r\n    const startTime = (config === null || config === void 0 ? void 0 : config.adtStartTime) instanceof Date ? config.adtStartTime : new Date();\r\n    return {\r\n        id,\r\n        startTime,\r\n        duration: new Date().getTime() - startTime.getTime()\r\n    };\r\n};\r\nconst createLogData = (request, response, clientId, config, error) => {\r\n    var _a;\r\n    const { id, duration, startTime } = getLoggingData(config);\r\n    const stateful = ((_a = request.headers) === null || _a === void 0 ? void 0 : _a[\"X-sap-adt-sessiontype\"]) === _1.session_types.stateful;\r\n    return { id, request, response, startTime, duration, stateful, clientId };\r\n};\r\nconst convertRequest = (original) => {\r\n    if (!(0, utilities_1.isObject)(original))\r\n        return { headers: {}, method: \"\", uri: \"\", params: {} };\r\n    const { headers, data, method, uri, params } = original;\r\n    return {\r\n        method: method || \"GET\",\r\n        uri: (0, utilities_1.isString)(uri) ? uri : \"\",\r\n        params: (0, utilities_1.isObject)(params) ? { ...params } : {},\r\n        headers: (0, utilities_1.isObject)(headers) ? { ...headers } : {},\r\n        body: (0, utilities_1.isString)(data) || (0, utilities_1.isUndefined)(data) ? data : JSON.stringify(data)\r\n    };\r\n};\r\nconst convertAxiosResponse = (original) => {\r\n    if (!original)\r\n        return { headers: {}, statusCode: 0, statusMessage: \"\" };\r\n    const { headers, data, status, statusText } = original;\r\n    return {\r\n        headers: headers ? { ...headers } : {},\r\n        statusCode: status,\r\n        statusMessage: statusText,\r\n        body: (0, utilities_1.isString)(data) ? data : JSON.stringify(data)\r\n    };\r\n};\r\nconst convertResponse = (original) => {\r\n    if (!original)\r\n        return { headers: {}, statusCode: 0, statusMessage: \"\" };\r\n    if ((0, _1.isAdtException)(original)) {\r\n        const resp = {\r\n            headers: {},\r\n            statusCode: (0, _1.isAdtError)(original) ? original.err : 501,\r\n            statusMessage: original.message\r\n        };\r\n        return resp;\r\n    }\r\n    else {\r\n        const { headers, body, status, statusText } = original;\r\n        return {\r\n            headers: headers ? { ...headers } : {},\r\n            statusCode: status,\r\n            statusMessage: statusText,\r\n            body: (0, utilities_1.isString)(body) ? body : JSON.stringify(body)\r\n        };\r\n    }\r\n};\r\nconst logError = (clientId, error, callback, config) => {\r\n    try {\r\n        if (!callback)\r\n            return;\r\n        if (axios_1.default.isAxiosError(error)) {\r\n            const request = convertRequest(error.config);\r\n            const response = convertAxiosResponse(error.response);\r\n            callback(createLogData(request, response, clientId, error.config, error));\r\n        }\r\n        else {\r\n            const resp = (0, _1.isAdtException)(error)\r\n                ? convertResponse(error)\r\n                : convertResponse(undefined);\r\n            callback(createLogData(convertRequest(config), resp, clientId, config, error));\r\n        }\r\n    }\r\n    catch (error) { }\r\n};\r\nexports.logError = logError;\r\nconst logResponse = (clientId, original, config, callback) => {\r\n    try {\r\n        if (!callback)\r\n            return;\r\n        const request = convertRequest(config);\r\n        const response = convertResponse(original);\r\n        callback(createLogData(request, response, clientId, config));\r\n    }\r\n    catch (error) { }\r\n};\r\nexports.logResponse = logResponse;\r\n","\"use strict\";\r\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    var desc = Object.getOwnPropertyDescriptor(m, k);\r\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\r\n      desc = { enumerable: true, get: function() { return m[k]; } };\r\n    }\r\n    Object.defineProperty(o, k2, desc);\r\n}) : (function(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    o[k2] = m[k];\r\n}));\r\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\r\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\r\n}) : function(o, v) {\r\n    o[\"default\"] = v;\r\n});\r\nvar __importStar = (this && this.__importStar) || function (mod) {\r\n    if (mod && mod.__esModule) return mod;\r\n    var result = {};\r\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\r\n    __setModuleDefault(result, mod);\r\n    return result;\r\n};\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.mixed = exports.orUndefined = exports.toXmlAttributes = exports.formatQS = exports.boolFromAbap = exports.followUrl = exports.parts = exports.btoa = exports.parseJsonDate = exports.toSapDate = exports.parseSapDate = exports.toInt = exports.parse = exports.fullParse = exports.numberParseOptions = exports.bar = exports.typedNodeAttr = exports.xmlNodeAttr = exports.stripNs = exports.xmlRoot = exports.xmlArray = exports.xmlFlatArray = exports.xmlNode = exports.extractXmlArray = exports.xmlArrayType = exports.JSON2AbapXML = exports.isUndefined = exports.isNativeError = exports.isNumber = exports.isString = exports.isArray = exports.isObject = exports.encodeEntity = void 0;\r\nconst fast_xml_parser_1 = require(\"fast-xml-parser\");\r\nconst t = __importStar(require(\"io-ts\"));\r\nvar html_entities_1 = require(\"html-entities\");\r\nObject.defineProperty(exports, \"encodeEntity\", { enumerable: true, get: function () { return html_entities_1.encode; } });\r\nconst html_entities_2 = require(\"html-entities\");\r\nconst isObject = (x) => !!x && typeof x === \"object\";\r\nexports.isObject = isObject;\r\nconst isArray = (x) => Array.isArray(x);\r\nexports.isArray = isArray;\r\nconst isString = (x) => typeof x === \"string\";\r\nexports.isString = isString;\r\nconst isNumber = (x) => typeof x === \"number\";\r\nexports.isNumber = isNumber;\r\nconst isNativeError = (e) => !!e && e instanceof Error;\r\nexports.isNativeError = isNativeError;\r\nconst isUndefined = (x) => typeof x === \"undefined\";\r\nexports.isUndefined = isUndefined;\r\nfunction JSON2AbapXML(original, root = \"DATA\") {\r\n    // only flat objects for now, might extend later...\r\n    let inner = \"\";\r\n    for (const key of Object.keys(original))\r\n        if (original[key])\r\n            inner = `${inner}\\n<${key}>${(0, html_entities_2.encode)(original[key]) || \"\"}</${key}>`;\r\n        else\r\n            inner = `${inner}\\n<${key}/>`;\r\n    return `<?xml version=\"1.0\" encoding=\"UTF-8\"?><asx:abap xmlns:asx=\"http://www.sap.com/abapxml\" version=\"1.0\">\n    <asx:values>\n      <${root}>\n        ${inner}\n      </${root}>\n    </asx:values>\n  </asx:abap>`;\r\n}\r\nexports.JSON2AbapXML = JSON2AbapXML;\r\nconst xmlArrayType = (x) => t.union([t.array(x), x, t.undefined]);\r\nexports.xmlArrayType = xmlArrayType;\r\nconst extractXmlArray = (x) => x ? ((0, exports.isArray)(x) ? x : [x]) : [];\r\nexports.extractXmlArray = extractXmlArray;\r\nfunction xmlNode(xml, ...path) {\r\n    let current = xml;\r\n    path.some(key => {\r\n        // @ts-ignore\r\n        if ((0, exports.isObject)(current))\r\n            current = current[key];\r\n        return !current;\r\n    });\r\n    return current;\r\n}\r\nexports.xmlNode = xmlNode;\r\nfunction xmlFlatArray(xml, ...path) {\r\n    if (!xml)\r\n        return [];\r\n    if (path.length === 0) {\r\n        if ((0, exports.isArray)(xml))\r\n            return xml;\r\n        else\r\n            return [xml];\r\n    }\r\n    if ((0, exports.isArray)(xml))\r\n        return xml.reduce((arr, x) => [...arr, ...xmlFlatArray(x, ...path)], []);\r\n    if ((0, exports.isObject)(xml)) {\r\n        const [idx, ...rest] = path;\r\n        // @ts-ignore\r\n        return xmlFlatArray(xml[idx], ...rest);\r\n    }\r\n    return [];\r\n}\r\nexports.xmlFlatArray = xmlFlatArray;\r\nfunction xmlArray(xml, ...path) {\r\n    const node = xmlNode(xml, ...path);\r\n    if (node) {\r\n        if ((0, exports.isArray)(node))\r\n            return node;\r\n        else\r\n            return [node];\r\n    }\r\n    return [];\r\n}\r\nexports.xmlArray = xmlArray;\r\nconst ok = Object.keys;\r\nconst xmlRoot = (o) => o[ok(o).filter(k => k !== \"?xml\")[0]];\r\nexports.xmlRoot = xmlRoot;\r\nconst stripNs = (x) => x &&\r\n    ok(x).reduce((obj, key) => {\r\n        const nk = key.split(\":\").slice(1).join(\":\") || key;\r\n        if (nk in obj)\r\n            obj[key] = key;\r\n        else\r\n            obj[nk] = x[key];\r\n        return obj;\r\n    }, {});\r\nexports.stripNs = stripNs;\r\nconst stripAttrPrefix = (x) => x.replace(/^@_/, \"\");\r\n// extract XML attributes of a node from its JSON representation\r\nconst xmlNodeAttr = (n) => n &&\r\n    ok(n)\r\n        .filter(k => k.match(/^(?!@_xmlns)@_/))\r\n        .reduce((part, cur) => {\r\n        part[cur.replace(/^@_/, \"\")] = n[cur];\r\n        return part;\r\n    }, {});\r\nexports.xmlNodeAttr = xmlNodeAttr;\r\nconst typedNodeAttr = (n) => n &&\r\n    ok(n)\r\n        .filter(k => k.match(/^(?!@_xmlns)@_/))\r\n        .reduce((part, cur) => {\r\n        // @ts-ignore\r\n        part[cur.replace(/^@_/, \"\")] = n[cur];\r\n        return part;\r\n    }, {});\r\nexports.typedNodeAttr = typedNodeAttr;\r\nexports.bar = stripAttrPrefix(\"@_pip\");\r\nexports.numberParseOptions = {\r\n    leadingZeros: false,\r\n    hex: true,\r\n    skipLike: new RegExp(\"\")\r\n};\r\nconst fullParse = (xml, options = {}) => new fast_xml_parser_1.XMLParser({\r\n    ignoreAttributes: false,\r\n    trimValues: false,\r\n    parseAttributeValue: true,\r\n    ...options\r\n}).parse(xml);\r\nexports.fullParse = fullParse;\r\nconst parse = (xml, options = {}) => new fast_xml_parser_1.XMLParser(options).parse(xml);\r\nexports.parse = parse;\r\nfunction toInt(x) {\r\n    if (!x)\r\n        return 0;\r\n    if (x.match(/^\\s*[+-]?\\d*\\s*$/))\r\n        return Number.parseInt(x, 10);\r\n    return 0;\r\n}\r\nexports.toInt = toInt;\r\nconst parseSapDate = (d) => {\r\n    const match = d.match(/(\\d\\d\\d\\d)(\\d\\d)(\\d\\d)/);\r\n    if (!match)\r\n        return new Date(); // wrong but valid\r\n    const [Y, M, D] = match.slice(1);\r\n    return Date.UTC(toInt(Y), toInt(M) - 1, toInt(D));\r\n};\r\nexports.parseSapDate = parseSapDate;\r\nconst toSapDate = (d) => d.getUTCFullYear() * 10000 + (d.getUTCMonth() + 1) * 100 + d.getUTCDate();\r\nexports.toSapDate = toSapDate;\r\nconst parseJsonDate = (d) => new Date(Date.parse(d));\r\nexports.parseJsonDate = parseJsonDate;\r\nfunction btoa(s) {\r\n    return Buffer.from(s).toString(\"base64\");\r\n}\r\nexports.btoa = btoa;\r\nfunction parts(whole, pattern) {\r\n    if (!(0, exports.isString)(whole))\r\n        return [];\r\n    const match = whole.match(pattern);\r\n    return match ? match.slice(1) : [];\r\n}\r\nexports.parts = parts;\r\nconst followUrl = (base, extra) => {\r\n    if (extra.match(/^\\.\\//)) {\r\n        base = base.replace(/[^\\/]*$/, \"\");\r\n        extra = extra.replace(/^\\.\\//, \"\");\r\n    }\r\n    else\r\n        extra = extra.replace(/^\\//, \"\");\r\n    base = base.replace(/\\/$/, \"\");\r\n    return base + \"/\" + extra;\r\n};\r\nexports.followUrl = followUrl;\r\nconst boolFromAbap = (x) => x === \"X\";\r\nexports.boolFromAbap = boolFromAbap;\r\nfunction formatQS(raw) {\r\n    const val = (key, x) => (0, exports.isArray)(x)\r\n        ? x.map(e => val(key, e)).join(\"&\")\r\n        : `${key}=${encodeURIComponent(x)}`;\r\n    return Object.getOwnPropertyNames(raw)\r\n        .map(k => val(k, raw[k]))\r\n        .join(\"&\");\r\n}\r\nexports.formatQS = formatQS;\r\nconst toXmlAttributes = (o, prefix) => {\r\n    const sep = prefix ? \":\" : \"\";\r\n    return o\r\n        ? Object.getOwnPropertyNames(o)\r\n            .sort()\r\n            .map(k => `${prefix}${sep}${k.replace(/^@_/, \"\")}=\"${o[k]}\"`)\r\n            .join(\" \")\r\n        : \"\";\r\n};\r\nexports.toXmlAttributes = toXmlAttributes;\r\nconst orUndefined = (x) => t.union([t.undefined, x]);\r\nexports.orUndefined = orUndefined;\r\nfunction mixed(required, optional) {\r\n    return t.intersection([t.type(required), t.partial(optional)]);\r\n}\r\nexports.mixed = mixed;\r\n","'use strict';\n\nconst validator = require('./validator');\nconst XMLParser = require('./xmlparser/XMLParser');\nconst XMLBuilder = require('./xmlbuilder/json2xml');\n\nmodule.exports = {\n  XMLParser: XMLParser,\n  XMLValidator: validator,\n  XMLBuilder: XMLBuilder\n}","function getIgnoreAttributesFn(ignoreAttributes) {\n    if (typeof ignoreAttributes === 'function') {\n        return ignoreAttributes\n    }\n    if (Array.isArray(ignoreAttributes)) {\n        return (attrName) => {\n            for (const pattern of ignoreAttributes) {\n                if (typeof pattern === 'string' && attrName === pattern) {\n                    return true\n                }\n                if (pattern instanceof RegExp && pattern.test(attrName)) {\n                    return true\n                }\n            }\n        }\n    }\n    return () => false\n}\n\nmodule.exports = getIgnoreAttributesFn","'use strict';\n\nconst nameStartChar = ':A-Za-z_\\\\u00C0-\\\\u00D6\\\\u00D8-\\\\u00F6\\\\u00F8-\\\\u02FF\\\\u0370-\\\\u037D\\\\u037F-\\\\u1FFF\\\\u200C-\\\\u200D\\\\u2070-\\\\u218F\\\\u2C00-\\\\u2FEF\\\\u3001-\\\\uD7FF\\\\uF900-\\\\uFDCF\\\\uFDF0-\\\\uFFFD';\nconst nameChar = nameStartChar + '\\\\-.\\\\d\\\\u00B7\\\\u0300-\\\\u036F\\\\u203F-\\\\u2040';\nconst nameRegexp = '[' + nameStartChar + '][' + nameChar + ']*'\nconst regexName = new RegExp('^' + nameRegexp + '$');\n\nconst getAllMatches = function(string, regex) {\n  const matches = [];\n  let match = regex.exec(string);\n  while (match) {\n    const allmatches = [];\n    allmatches.startIndex = regex.lastIndex - match[0].length;\n    const len = match.length;\n    for (let index = 0; index < len; index++) {\n      allmatches.push(match[index]);\n    }\n    matches.push(allmatches);\n    match = regex.exec(string);\n  }\n  return matches;\n};\n\nconst isName = function(string) {\n  const match = regexName.exec(string);\n  return !(match === null || typeof match === 'undefined');\n};\n\nexports.isExist = function(v) {\n  return typeof v !== 'undefined';\n};\n\nexports.isEmptyObject = function(obj) {\n  return Object.keys(obj).length === 0;\n};\n\n/**\n * Copy all the properties of a into b.\n * @param {*} target\n * @param {*} a\n */\nexports.merge = function(target, a, arrayMode) {\n  if (a) {\n    const keys = Object.keys(a); // will return an array of own properties\n    const len = keys.length; //don't make it inline\n    for (let i = 0; i < len; i++) {\n      if (arrayMode === 'strict') {\n        target[keys[i]] = [ a[keys[i]] ];\n      } else {\n        target[keys[i]] = a[keys[i]];\n      }\n    }\n  }\n};\n/* exports.merge =function (b,a){\n  return Object.assign(b,a);\n} */\n\nexports.getValue = function(v) {\n  if (exports.isExist(v)) {\n    return v;\n  } else {\n    return '';\n  }\n};\n\n// const fakeCall = function(a) {return a;};\n// const fakeCallNoReturn = function() {};\n\nexports.isName = isName;\nexports.getAllMatches = getAllMatches;\nexports.nameRegexp = nameRegexp;\n","'use strict';\n\nconst util = require('./util');\n\nconst defaultOptions = {\n  allowBooleanAttributes: false, //A tag can have attributes without any value\n  unpairedTags: []\n};\n\n//const tagsPattern = new RegExp(\"<\\\\/?([\\\\w:\\\\-_\\.]+)\\\\s*\\/?>\",\"g\");\nexports.validate = function (xmlData, options) {\n  options = Object.assign({}, defaultOptions, options);\n\n  //xmlData = xmlData.replace(/(\\r\\n|\\n|\\r)/gm,\"\");//make it single line\n  //xmlData = xmlData.replace(/(^\\s*<\\?xml.*?\\?>)/g,\"\");//Remove XML starting tag\n  //xmlData = xmlData.replace(/(<!DOCTYPE[\\s\\w\\\"\\.\\/\\-\\:]+(\\[.*\\])*\\s*>)/g,\"\");//Remove DOCTYPE\n  const tags = [];\n  let tagFound = false;\n\n  //indicates that the root tag has been closed (aka. depth 0 has been reached)\n  let reachedRoot = false;\n\n  if (xmlData[0] === '\\ufeff') {\n    // check for byte order mark (BOM)\n    xmlData = xmlData.substr(1);\n  }\n  \n  for (let i = 0; i < xmlData.length; i++) {\n\n    if (xmlData[i] === '<' && xmlData[i+1] === '?') {\n      i+=2;\n      i = readPI(xmlData,i);\n      if (i.err) return i;\n    }else if (xmlData[i] === '<') {\n      //starting of tag\n      //read until you reach to '>' avoiding any '>' in attribute value\n      let tagStartPos = i;\n      i++;\n      \n      if (xmlData[i] === '!') {\n        i = readCommentAndCDATA(xmlData, i);\n        continue;\n      } else {\n        let closingTag = false;\n        if (xmlData[i] === '/') {\n          //closing tag\n          closingTag = true;\n          i++;\n        }\n        //read tagname\n        let tagName = '';\n        for (; i < xmlData.length &&\n          xmlData[i] !== '>' &&\n          xmlData[i] !== ' ' &&\n          xmlData[i] !== '\\t' &&\n          xmlData[i] !== '\\n' &&\n          xmlData[i] !== '\\r'; i++\n        ) {\n          tagName += xmlData[i];\n        }\n        tagName = tagName.trim();\n        //console.log(tagName);\n\n        if (tagName[tagName.length - 1] === '/') {\n          //self closing tag without attributes\n          tagName = tagName.substring(0, tagName.length - 1);\n          //continue;\n          i--;\n        }\n        if (!validateTagName(tagName)) {\n          let msg;\n          if (tagName.trim().length === 0) {\n            msg = \"Invalid space after '<'.\";\n          } else {\n            msg = \"Tag '\"+tagName+\"' is an invalid name.\";\n          }\n          return getErrorObject('InvalidTag', msg, getLineNumberForPosition(xmlData, i));\n        }\n\n        const result = readAttributeStr(xmlData, i);\n        if (result === false) {\n          return getErrorObject('InvalidAttr', \"Attributes for '\"+tagName+\"' have open quote.\", getLineNumberForPosition(xmlData, i));\n        }\n        let attrStr = result.value;\n        i = result.index;\n\n        if (attrStr[attrStr.length - 1] === '/') {\n          //self closing tag\n          const attrStrStart = i - attrStr.length;\n          attrStr = attrStr.substring(0, attrStr.length - 1);\n          const isValid = validateAttributeString(attrStr, options);\n          if (isValid === true) {\n            tagFound = true;\n            //continue; //text may presents after self closing tag\n          } else {\n            //the result from the nested function returns the position of the error within the attribute\n            //in order to get the 'true' error line, we need to calculate the position where the attribute begins (i - attrStr.length) and then add the position within the attribute\n            //this gives us the absolute index in the entire xml, which we can use to find the line at last\n            return getErrorObject(isValid.err.code, isValid.err.msg, getLineNumberForPosition(xmlData, attrStrStart + isValid.err.line));\n          }\n        } else if (closingTag) {\n          if (!result.tagClosed) {\n            return getErrorObject('InvalidTag', \"Closing tag '\"+tagName+\"' doesn't have proper closing.\", getLineNumberForPosition(xmlData, i));\n          } else if (attrStr.trim().length > 0) {\n            return getErrorObject('InvalidTag', \"Closing tag '\"+tagName+\"' can't have attributes or invalid starting.\", getLineNumberForPosition(xmlData, tagStartPos));\n          } else if (tags.length === 0) {\n            return getErrorObject('InvalidTag', \"Closing tag '\"+tagName+\"' has not been opened.\", getLineNumberForPosition(xmlData, tagStartPos));\n          } else {\n            const otg = tags.pop();\n            if (tagName !== otg.tagName) {\n              let openPos = getLineNumberForPosition(xmlData, otg.tagStartPos);\n              return getErrorObject('InvalidTag',\n                \"Expected closing tag '\"+otg.tagName+\"' (opened in line \"+openPos.line+\", col \"+openPos.col+\") instead of closing tag '\"+tagName+\"'.\",\n                getLineNumberForPosition(xmlData, tagStartPos));\n            }\n\n            //when there are no more tags, we reached the root level.\n            if (tags.length == 0) {\n              reachedRoot = true;\n            }\n          }\n        } else {\n          const isValid = validateAttributeString(attrStr, options);\n          if (isValid !== true) {\n            //the result from the nested function returns the position of the error within the attribute\n            //in order to get the 'true' error line, we need to calculate the position where the attribute begins (i - attrStr.length) and then add the position within the attribute\n            //this gives us the absolute index in the entire xml, which we can use to find the line at last\n            return getErrorObject(isValid.err.code, isValid.err.msg, getLineNumberForPosition(xmlData, i - attrStr.length + isValid.err.line));\n          }\n\n          //if the root level has been reached before ...\n          if (reachedRoot === true) {\n            return getErrorObject('InvalidXml', 'Multiple possible root nodes found.', getLineNumberForPosition(xmlData, i));\n          } else if(options.unpairedTags.indexOf(tagName) !== -1){\n            //don't push into stack\n          } else {\n            tags.push({tagName, tagStartPos});\n          }\n          tagFound = true;\n        }\n\n        //skip tag text value\n        //It may include comments and CDATA value\n        for (i++; i < xmlData.length; i++) {\n          if (xmlData[i] === '<') {\n            if (xmlData[i + 1] === '!') {\n              //comment or CADATA\n              i++;\n              i = readCommentAndCDATA(xmlData, i);\n              continue;\n            } else if (xmlData[i+1] === '?') {\n              i = readPI(xmlData, ++i);\n              if (i.err) return i;\n            } else{\n              break;\n            }\n          } else if (xmlData[i] === '&') {\n            const afterAmp = validateAmpersand(xmlData, i);\n            if (afterAmp == -1)\n              return getErrorObject('InvalidChar', \"char '&' is not expected.\", getLineNumberForPosition(xmlData, i));\n            i = afterAmp;\n          }else{\n            if (reachedRoot === true && !isWhiteSpace(xmlData[i])) {\n              return getErrorObject('InvalidXml', \"Extra text at the end\", getLineNumberForPosition(xmlData, i));\n            }\n          }\n        } //end of reading tag text value\n        if (xmlData[i] === '<') {\n          i--;\n        }\n      }\n    } else {\n      if ( isWhiteSpace(xmlData[i])) {\n        continue;\n      }\n      return getErrorObject('InvalidChar', \"char '\"+xmlData[i]+\"' is not expected.\", getLineNumberForPosition(xmlData, i));\n    }\n  }\n\n  if (!tagFound) {\n    return getErrorObject('InvalidXml', 'Start tag expected.', 1);\n  }else if (tags.length == 1) {\n      return getErrorObject('InvalidTag', \"Unclosed tag '\"+tags[0].tagName+\"'.\", getLineNumberForPosition(xmlData, tags[0].tagStartPos));\n  }else if (tags.length > 0) {\n      return getErrorObject('InvalidXml', \"Invalid '\"+\n          JSON.stringify(tags.map(t => t.tagName), null, 4).replace(/\\r?\\n/g, '')+\n          \"' found.\", {line: 1, col: 1});\n  }\n\n  return true;\n};\n\nfunction isWhiteSpace(char){\n  return char === ' ' || char === '\\t' || char === '\\n'  || char === '\\r';\n}\n/**\n * Read Processing insstructions and skip\n * @param {*} xmlData\n * @param {*} i\n */\nfunction readPI(xmlData, i) {\n  const start = i;\n  for (; i < xmlData.length; i++) {\n    if (xmlData[i] == '?' || xmlData[i] == ' ') {\n      //tagname\n      const tagname = xmlData.substr(start, i - start);\n      if (i > 5 && tagname === 'xml') {\n        return getErrorObject('InvalidXml', 'XML declaration allowed only at the start of the document.', getLineNumberForPosition(xmlData, i));\n      } else if (xmlData[i] == '?' && xmlData[i + 1] == '>') {\n        //check if valid attribut string\n        i++;\n        break;\n      } else {\n        continue;\n      }\n    }\n  }\n  return i;\n}\n\nfunction readCommentAndCDATA(xmlData, i) {\n  if (xmlData.length > i + 5 && xmlData[i + 1] === '-' && xmlData[i + 2] === '-') {\n    //comment\n    for (i += 3; i < xmlData.length; i++) {\n      if (xmlData[i] === '-' && xmlData[i + 1] === '-' && xmlData[i + 2] === '>') {\n        i += 2;\n        break;\n      }\n    }\n  } else if (\n    xmlData.length > i + 8 &&\n    xmlData[i + 1] === 'D' &&\n    xmlData[i + 2] === 'O' &&\n    xmlData[i + 3] === 'C' &&\n    xmlData[i + 4] === 'T' &&\n    xmlData[i + 5] === 'Y' &&\n    xmlData[i + 6] === 'P' &&\n    xmlData[i + 7] === 'E'\n  ) {\n    let angleBracketsCount = 1;\n    for (i += 8; i < xmlData.length; i++) {\n      if (xmlData[i] === '<') {\n        angleBracketsCount++;\n      } else if (xmlData[i] === '>') {\n        angleBracketsCount--;\n        if (angleBracketsCount === 0) {\n          break;\n        }\n      }\n    }\n  } else if (\n    xmlData.length > i + 9 &&\n    xmlData[i + 1] === '[' &&\n    xmlData[i + 2] === 'C' &&\n    xmlData[i + 3] === 'D' &&\n    xmlData[i + 4] === 'A' &&\n    xmlData[i + 5] === 'T' &&\n    xmlData[i + 6] === 'A' &&\n    xmlData[i + 7] === '['\n  ) {\n    for (i += 8; i < xmlData.length; i++) {\n      if (xmlData[i] === ']' && xmlData[i + 1] === ']' && xmlData[i + 2] === '>') {\n        i += 2;\n        break;\n      }\n    }\n  }\n\n  return i;\n}\n\nconst doubleQuote = '\"';\nconst singleQuote = \"'\";\n\n/**\n * Keep reading xmlData until '<' is found outside the attribute value.\n * @param {string} xmlData\n * @param {number} i\n */\nfunction readAttributeStr(xmlData, i) {\n  let attrStr = '';\n  let startChar = '';\n  let tagClosed = false;\n  for (; i < xmlData.length; i++) {\n    if (xmlData[i] === doubleQuote || xmlData[i] === singleQuote) {\n      if (startChar === '') {\n        startChar = xmlData[i];\n      } else if (startChar !== xmlData[i]) {\n        //if vaue is enclosed with double quote then single quotes are allowed inside the value and vice versa\n      } else {\n        startChar = '';\n      }\n    } else if (xmlData[i] === '>') {\n      if (startChar === '') {\n        tagClosed = true;\n        break;\n      }\n    }\n    attrStr += xmlData[i];\n  }\n  if (startChar !== '') {\n    return false;\n  }\n\n  return {\n    value: attrStr,\n    index: i,\n    tagClosed: tagClosed\n  };\n}\n\n/**\n * Select all the attributes whether valid or invalid.\n */\nconst validAttrStrRegxp = new RegExp('(\\\\s*)([^\\\\s=]+)(\\\\s*=)?(\\\\s*([\\'\"])(([\\\\s\\\\S])*?)\\\\5)?', 'g');\n\n//attr, =\"sd\", a=\"amit's\", a=\"sd\"b=\"saf\", ab  cd=\"\"\n\nfunction validateAttributeString(attrStr, options) {\n  //console.log(\"start:\"+attrStr+\":end\");\n\n  //if(attrStr.trim().length === 0) return true; //empty string\n\n  const matches = util.getAllMatches(attrStr, validAttrStrRegxp);\n  const attrNames = {};\n\n  for (let i = 0; i < matches.length; i++) {\n    if (matches[i][1].length === 0) {\n      //nospace before attribute name: a=\"sd\"b=\"saf\"\n      return getErrorObject('InvalidAttr', \"Attribute '\"+matches[i][2]+\"' has no space in starting.\", getPositionFromMatch(matches[i]))\n    } else if (matches[i][3] !== undefined && matches[i][4] === undefined) {\n      return getErrorObject('InvalidAttr', \"Attribute '\"+matches[i][2]+\"' is without value.\", getPositionFromMatch(matches[i]));\n    } else if (matches[i][3] === undefined && !options.allowBooleanAttributes) {\n      //independent attribute: ab\n      return getErrorObject('InvalidAttr', \"boolean attribute '\"+matches[i][2]+\"' is not allowed.\", getPositionFromMatch(matches[i]));\n    }\n    /* else if(matches[i][6] === undefined){//attribute without value: ab=\n                    return { err: { code:\"InvalidAttr\",msg:\"attribute \" + matches[i][2] + \" has no value assigned.\"}};\n                } */\n    const attrName = matches[i][2];\n    if (!validateAttrName(attrName)) {\n      return getErrorObject('InvalidAttr', \"Attribute '\"+attrName+\"' is an invalid name.\", getPositionFromMatch(matches[i]));\n    }\n    if (!attrNames.hasOwnProperty(attrName)) {\n      //check for duplicate attribute.\n      attrNames[attrName] = 1;\n    } else {\n      return getErrorObject('InvalidAttr', \"Attribute '\"+attrName+\"' is repeated.\", getPositionFromMatch(matches[i]));\n    }\n  }\n\n  return true;\n}\n\nfunction validateNumberAmpersand(xmlData, i) {\n  let re = /\\d/;\n  if (xmlData[i] === 'x') {\n    i++;\n    re = /[\\da-fA-F]/;\n  }\n  for (; i < xmlData.length; i++) {\n    if (xmlData[i] === ';')\n      return i;\n    if (!xmlData[i].match(re))\n      break;\n  }\n  return -1;\n}\n\nfunction validateAmpersand(xmlData, i) {\n  // https://www.w3.org/TR/xml/#dt-charref\n  i++;\n  if (xmlData[i] === ';')\n    return -1;\n  if (xmlData[i] === '#') {\n    i++;\n    return validateNumberAmpersand(xmlData, i);\n  }\n  let count = 0;\n  for (; i < xmlData.length; i++, count++) {\n    if (xmlData[i].match(/\\w/) && count < 20)\n      continue;\n    if (xmlData[i] === ';')\n      break;\n    return -1;\n  }\n  return i;\n}\n\nfunction getErrorObject(code, message, lineNumber) {\n  return {\n    err: {\n      code: code,\n      msg: message,\n      line: lineNumber.line || lineNumber,\n      col: lineNumber.col,\n    },\n  };\n}\n\nfunction validateAttrName(attrName) {\n  return util.isName(attrName);\n}\n\n// const startsWithXML = /^xml/i;\n\nfunction validateTagName(tagname) {\n  return util.isName(tagname) /* && !tagname.match(startsWithXML) */;\n}\n\n//this function returns the line number for the character at the given index\nfunction getLineNumberForPosition(xmlData, index) {\n  const lines = xmlData.substring(0, index).split(/\\r?\\n/);\n  return {\n    line: lines.length,\n\n    // column number is last line's length + 1, because column numbering starts at 1:\n    col: lines[lines.length - 1].length + 1\n  };\n}\n\n//this function returns the position of the first character of match within attrStr\nfunction getPositionFromMatch(match) {\n  return match.startIndex + match[1].length;\n}\n","'use strict';\n//parse Empty Node as self closing node\nconst buildFromOrderedJs = require('./orderedJs2Xml');\nconst getIgnoreAttributesFn = require('../ignoreAttributes')\n\nconst defaultOptions = {\n  attributeNamePrefix: '@_',\n  attributesGroupName: false,\n  textNodeName: '#text',\n  ignoreAttributes: true,\n  cdataPropName: false,\n  format: false,\n  indentBy: '  ',\n  suppressEmptyNode: false,\n  suppressUnpairedNode: true,\n  suppressBooleanAttributes: true,\n  tagValueProcessor: function(key, a) {\n    return a;\n  },\n  attributeValueProcessor: function(attrName, a) {\n    return a;\n  },\n  preserveOrder: false,\n  commentPropName: false,\n  unpairedTags: [],\n  entities: [\n    { regex: new RegExp(\"&\", \"g\"), val: \"&amp;\" },//it must be on top\n    { regex: new RegExp(\">\", \"g\"), val: \"&gt;\" },\n    { regex: new RegExp(\"<\", \"g\"), val: \"&lt;\" },\n    { regex: new RegExp(\"\\'\", \"g\"), val: \"&apos;\" },\n    { regex: new RegExp(\"\\\"\", \"g\"), val: \"&quot;\" }\n  ],\n  processEntities: true,\n  stopNodes: [],\n  // transformTagName: false,\n  // transformAttributeName: false,\n  oneListGroup: false\n};\n\nfunction Builder(options) {\n  this.options = Object.assign({}, defaultOptions, options);\n  if (this.options.ignoreAttributes === true || this.options.attributesGroupName) {\n    this.isAttribute = function(/*a*/) {\n      return false;\n    };\n  } else {\n    this.ignoreAttributesFn = getIgnoreAttributesFn(this.options.ignoreAttributes)\n    this.attrPrefixLen = this.options.attributeNamePrefix.length;\n    this.isAttribute = isAttribute;\n  }\n\n  this.processTextOrObjNode = processTextOrObjNode\n\n  if (this.options.format) {\n    this.indentate = indentate;\n    this.tagEndChar = '>\\n';\n    this.newLine = '\\n';\n  } else {\n    this.indentate = function() {\n      return '';\n    };\n    this.tagEndChar = '>';\n    this.newLine = '';\n  }\n}\n\nBuilder.prototype.build = function(jObj) {\n  if(this.options.preserveOrder){\n    return buildFromOrderedJs(jObj, this.options);\n  }else {\n    if(Array.isArray(jObj) && this.options.arrayNodeName && this.options.arrayNodeName.length > 1){\n      jObj = {\n        [this.options.arrayNodeName] : jObj\n      }\n    }\n    return this.j2x(jObj, 0, []).val;\n  }\n};\n\nBuilder.prototype.j2x = function(jObj, level, ajPath) {\n  let attrStr = '';\n  let val = '';\n  const jPath = ajPath.join('.')\n  for (let key in jObj) {\n    if(!Object.prototype.hasOwnProperty.call(jObj, key)) continue;\n    if (typeof jObj[key] === 'undefined') {\n      // supress undefined node only if it is not an attribute\n      if (this.isAttribute(key)) {\n        val += '';\n      }\n    } else if (jObj[key] === null) {\n      // null attribute should be ignored by the attribute list, but should not cause the tag closing\n      if (this.isAttribute(key)) {\n        val += '';\n      } else if (key === this.options.cdataPropName) {\n        val += '';\n      } else if (key[0] === '?') {\n        val += this.indentate(level) + '<' + key + '?' + this.tagEndChar;\n      } else {\n        val += this.indentate(level) + '<' + key + '/' + this.tagEndChar;\n      }\n      // val += this.indentate(level) + '<' + key + '/' + this.tagEndChar;\n    } else if (jObj[key] instanceof Date) {\n      val += this.buildTextValNode(jObj[key], key, '', level);\n    } else if (typeof jObj[key] !== 'object') {\n      //premitive type\n      const attr = this.isAttribute(key);\n      if (attr && !this.ignoreAttributesFn(attr, jPath)) {\n        attrStr += this.buildAttrPairStr(attr, '' + jObj[key]);\n      } else if (!attr) {\n        //tag value\n        if (key === this.options.textNodeName) {\n          let newval = this.options.tagValueProcessor(key, '' + jObj[key]);\n          val += this.replaceEntitiesValue(newval);\n        } else {\n          val += this.buildTextValNode(jObj[key], key, '', level);\n        }\n      }\n    } else if (Array.isArray(jObj[key])) {\n      //repeated nodes\n      const arrLen = jObj[key].length;\n      let listTagVal = \"\";\n      let listTagAttr = \"\";\n      for (let j = 0; j < arrLen; j++) {\n        const item = jObj[key][j];\n        if (typeof item === 'undefined') {\n          // supress undefined node\n        } else if (item === null) {\n          if(key[0] === \"?\") val += this.indentate(level) + '<' + key + '?' + this.tagEndChar;\n          else val += this.indentate(level) + '<' + key + '/' + this.tagEndChar;\n          // val += this.indentate(level) + '<' + key + '/' + this.tagEndChar;\n        } else if (typeof item === 'object') {\n          if(this.options.oneListGroup){\n            const result = this.j2x(item, level + 1, ajPath.concat(key));\n            listTagVal += result.val;\n            if (this.options.attributesGroupName && item.hasOwnProperty(this.options.attributesGroupName)) {\n              listTagAttr += result.attrStr\n            }\n          }else{\n            listTagVal += this.processTextOrObjNode(item, key, level, ajPath)\n          }\n        } else {\n          if (this.options.oneListGroup) {\n            let textValue = this.options.tagValueProcessor(key, item);\n            textValue = this.replaceEntitiesValue(textValue);\n            listTagVal += textValue;\n          } else {\n            listTagVal += this.buildTextValNode(item, key, '', level);\n          }\n        }\n      }\n      if(this.options.oneListGroup){\n        listTagVal = this.buildObjectNode(listTagVal, key, listTagAttr, level);\n      }\n      val += listTagVal;\n    } else {\n      //nested node\n      if (this.options.attributesGroupName && key === this.options.attributesGroupName) {\n        const Ks = Object.keys(jObj[key]);\n        const L = Ks.length;\n        for (let j = 0; j < L; j++) {\n          attrStr += this.buildAttrPairStr(Ks[j], '' + jObj[key][Ks[j]]);\n        }\n      } else {\n        val += this.processTextOrObjNode(jObj[key], key, level, ajPath)\n      }\n    }\n  }\n  return {attrStr: attrStr, val: val};\n};\n\nBuilder.prototype.buildAttrPairStr = function(attrName, val){\n  val = this.options.attributeValueProcessor(attrName, '' + val);\n  val = this.replaceEntitiesValue(val);\n  if (this.options.suppressBooleanAttributes && val === \"true\") {\n    return ' ' + attrName;\n  } else return ' ' + attrName + '=\"' + val + '\"';\n}\n\nfunction processTextOrObjNode (object, key, level, ajPath) {\n  const result = this.j2x(object, level + 1, ajPath.concat(key));\n  if (object[this.options.textNodeName] !== undefined && Object.keys(object).length === 1) {\n    return this.buildTextValNode(object[this.options.textNodeName], key, result.attrStr, level);\n  } else {\n    return this.buildObjectNode(result.val, key, result.attrStr, level);\n  }\n}\n\nBuilder.prototype.buildObjectNode = function(val, key, attrStr, level) {\n  if(val === \"\"){\n    if(key[0] === \"?\") return  this.indentate(level) + '<' + key + attrStr+ '?' + this.tagEndChar;\n    else {\n      return this.indentate(level) + '<' + key + attrStr + this.closeTag(key) + this.tagEndChar;\n    }\n  }else{\n\n    let tagEndExp = '</' + key + this.tagEndChar;\n    let piClosingChar = \"\";\n    \n    if(key[0] === \"?\") {\n      piClosingChar = \"?\";\n      tagEndExp = \"\";\n    }\n  \n    // attrStr is an empty string in case the attribute came as undefined or null\n    if ((attrStr || attrStr === '') && val.indexOf('<') === -1) {\n      return ( this.indentate(level) + '<' +  key + attrStr + piClosingChar + '>' + val + tagEndExp );\n    } else if (this.options.commentPropName !== false && key === this.options.commentPropName && piClosingChar.length === 0) {\n      return this.indentate(level) + `<!--${val}-->` + this.newLine;\n    }else {\n      return (\n        this.indentate(level) + '<' + key + attrStr + piClosingChar + this.tagEndChar +\n        val +\n        this.indentate(level) + tagEndExp    );\n    }\n  }\n}\n\nBuilder.prototype.closeTag = function(key){\n  let closeTag = \"\";\n  if(this.options.unpairedTags.indexOf(key) !== -1){ //unpaired\n    if(!this.options.suppressUnpairedNode) closeTag = \"/\"\n  }else if(this.options.suppressEmptyNode){ //empty\n    closeTag = \"/\";\n  }else{\n    closeTag = `></${key}`\n  }\n  return closeTag;\n}\n\nfunction buildEmptyObjNode(val, key, attrStr, level) {\n  if (val !== '') {\n    return this.buildObjectNode(val, key, attrStr, level);\n  } else {\n    if(key[0] === \"?\") return  this.indentate(level) + '<' + key + attrStr+ '?' + this.tagEndChar;\n    else {\n      return  this.indentate(level) + '<' + key + attrStr + '/' + this.tagEndChar;\n      // return this.buildTagStr(level,key, attrStr);\n    }\n  }\n}\n\nBuilder.prototype.buildTextValNode = function(val, key, attrStr, level) {\n  if (this.options.cdataPropName !== false && key === this.options.cdataPropName) {\n    return this.indentate(level) + `<![CDATA[${val}]]>` +  this.newLine;\n  }else if (this.options.commentPropName !== false && key === this.options.commentPropName) {\n    return this.indentate(level) + `<!--${val}-->` +  this.newLine;\n  }else if(key[0] === \"?\") {//PI tag\n    return  this.indentate(level) + '<' + key + attrStr+ '?' + this.tagEndChar; \n  }else{\n    let textValue = this.options.tagValueProcessor(key, val);\n    textValue = this.replaceEntitiesValue(textValue);\n  \n    if( textValue === ''){\n      return this.indentate(level) + '<' + key + attrStr + this.closeTag(key) + this.tagEndChar;\n    }else{\n      return this.indentate(level) + '<' + key + attrStr + '>' +\n         textValue +\n        '</' + key + this.tagEndChar;\n    }\n  }\n}\n\nBuilder.prototype.replaceEntitiesValue = function(textValue){\n  if(textValue && textValue.length > 0 && this.options.processEntities){\n    for (let i=0; i<this.options.entities.length; i++) {\n      const entity = this.options.entities[i];\n      textValue = textValue.replace(entity.regex, entity.val);\n    }\n  }\n  return textValue;\n}\n\nfunction indentate(level) {\n  return this.options.indentBy.repeat(level);\n}\n\nfunction isAttribute(name /*, options*/) {\n  if (name.startsWith(this.options.attributeNamePrefix) && name !== this.options.textNodeName) {\n    return name.substr(this.attrPrefixLen);\n  } else {\n    return false;\n  }\n}\n\nmodule.exports = Builder;\n","const EOL = \"\\n\";\n\n/**\n * \n * @param {array} jArray \n * @param {any} options \n * @returns \n */\nfunction toXml(jArray, options) {\n    let indentation = \"\";\n    if (options.format && options.indentBy.length > 0) {\n        indentation = EOL;\n    }\n    return arrToStr(jArray, options, \"\", indentation);\n}\n\nfunction arrToStr(arr, options, jPath, indentation) {\n    let xmlStr = \"\";\n    let isPreviousElementTag = false;\n\n    for (let i = 0; i < arr.length; i++) {\n        const tagObj = arr[i];\n        const tagName = propName(tagObj);\n        if(tagName === undefined) continue;\n\n        let newJPath = \"\";\n        if (jPath.length === 0) newJPath = tagName\n        else newJPath = `${jPath}.${tagName}`;\n\n        if (tagName === options.textNodeName) {\n            let tagText = tagObj[tagName];\n            if (!isStopNode(newJPath, options)) {\n                tagText = options.tagValueProcessor(tagName, tagText);\n                tagText = replaceEntitiesValue(tagText, options);\n            }\n            if (isPreviousElementTag) {\n                xmlStr += indentation;\n            }\n            xmlStr += tagText;\n            isPreviousElementTag = false;\n            continue;\n        } else if (tagName === options.cdataPropName) {\n            if (isPreviousElementTag) {\n                xmlStr += indentation;\n            }\n            xmlStr += `<![CDATA[${tagObj[tagName][0][options.textNodeName]}]]>`;\n            isPreviousElementTag = false;\n            continue;\n        } else if (tagName === options.commentPropName) {\n            xmlStr += indentation + `<!--${tagObj[tagName][0][options.textNodeName]}-->`;\n            isPreviousElementTag = true;\n            continue;\n        } else if (tagName[0] === \"?\") {\n            const attStr = attr_to_str(tagObj[\":@\"], options);\n            const tempInd = tagName === \"?xml\" ? \"\" : indentation;\n            let piTextNodeName = tagObj[tagName][0][options.textNodeName];\n            piTextNodeName = piTextNodeName.length !== 0 ? \" \" + piTextNodeName : \"\"; //remove extra spacing\n            xmlStr += tempInd + `<${tagName}${piTextNodeName}${attStr}?>`;\n            isPreviousElementTag = true;\n            continue;\n        }\n        let newIdentation = indentation;\n        if (newIdentation !== \"\") {\n            newIdentation += options.indentBy;\n        }\n        const attStr = attr_to_str(tagObj[\":@\"], options);\n        const tagStart = indentation + `<${tagName}${attStr}`;\n        const tagValue = arrToStr(tagObj[tagName], options, newJPath, newIdentation);\n        if (options.unpairedTags.indexOf(tagName) !== -1) {\n            if (options.suppressUnpairedNode) xmlStr += tagStart + \">\";\n            else xmlStr += tagStart + \"/>\";\n        } else if ((!tagValue || tagValue.length === 0) && options.suppressEmptyNode) {\n            xmlStr += tagStart + \"/>\";\n        } else if (tagValue && tagValue.endsWith(\">\")) {\n            xmlStr += tagStart + `>${tagValue}${indentation}</${tagName}>`;\n        } else {\n            xmlStr += tagStart + \">\";\n            if (tagValue && indentation !== \"\" && (tagValue.includes(\"/>\") || tagValue.includes(\"</\"))) {\n                xmlStr += indentation + options.indentBy + tagValue + indentation;\n            } else {\n                xmlStr += tagValue;\n            }\n            xmlStr += `</${tagName}>`;\n        }\n        isPreviousElementTag = true;\n    }\n\n    return xmlStr;\n}\n\nfunction propName(obj) {\n    const keys = Object.keys(obj);\n    for (let i = 0; i < keys.length; i++) {\n        const key = keys[i];\n        if(!obj.hasOwnProperty(key)) continue;\n        if (key !== \":@\") return key;\n    }\n}\n\nfunction attr_to_str(attrMap, options) {\n    let attrStr = \"\";\n    if (attrMap && !options.ignoreAttributes) {\n        for (let attr in attrMap) {\n            if(!attrMap.hasOwnProperty(attr)) continue;\n            let attrVal = options.attributeValueProcessor(attr, attrMap[attr]);\n            attrVal = replaceEntitiesValue(attrVal, options);\n            if (attrVal === true && options.suppressBooleanAttributes) {\n                attrStr += ` ${attr.substr(options.attributeNamePrefix.length)}`;\n            } else {\n                attrStr += ` ${attr.substr(options.attributeNamePrefix.length)}=\"${attrVal}\"`;\n            }\n        }\n    }\n    return attrStr;\n}\n\nfunction isStopNode(jPath, options) {\n    jPath = jPath.substr(0, jPath.length - options.textNodeName.length - 1);\n    let tagName = jPath.substr(jPath.lastIndexOf(\".\") + 1);\n    for (let index in options.stopNodes) {\n        if (options.stopNodes[index] === jPath || options.stopNodes[index] === \"*.\" + tagName) return true;\n    }\n    return false;\n}\n\nfunction replaceEntitiesValue(textValue, options) {\n    if (textValue && textValue.length > 0 && options.processEntities) {\n        for (let i = 0; i < options.entities.length; i++) {\n            const entity = options.entities[i];\n            textValue = textValue.replace(entity.regex, entity.val);\n        }\n    }\n    return textValue;\n}\nmodule.exports = toXml;\n","const util = require('../util');\n\n//TODO: handle comments\nfunction readDocType(xmlData, i){\n    \n    const entities = {};\n    if( xmlData[i + 3] === 'O' &&\n         xmlData[i + 4] === 'C' &&\n         xmlData[i + 5] === 'T' &&\n         xmlData[i + 6] === 'Y' &&\n         xmlData[i + 7] === 'P' &&\n         xmlData[i + 8] === 'E')\n    {    \n        i = i+9;\n        let angleBracketsCount = 1;\n        let hasBody = false, comment = false;\n        let exp = \"\";\n        for(;i<xmlData.length;i++){\n            if (xmlData[i] === '<' && !comment) { //Determine the tag type\n                if( hasBody && isEntity(xmlData, i)){\n                    i += 7; \n                    let entityName, val;\n                    [entityName, val,i] = readEntityExp(xmlData,i+1);\n                    if(val.indexOf(\"&\") === -1) //Parameter entities are not supported\n                        entities[ validateEntityName(entityName) ] = {\n                            regx : RegExp( `&${entityName};`,\"g\"),\n                            val: val\n                        };\n                }\n                else if( hasBody && isElement(xmlData, i))  i += 8;//Not supported\n                else if( hasBody && isAttlist(xmlData, i))  i += 8;//Not supported\n                else if( hasBody && isNotation(xmlData, i)) i += 9;//Not supported\n                else if( isComment)                         comment = true;\n                else                                        throw new Error(\"Invalid DOCTYPE\");\n\n                angleBracketsCount++;\n                exp = \"\";\n            } else if (xmlData[i] === '>') { //Read tag content\n                if(comment){\n                    if( xmlData[i - 1] === \"-\" && xmlData[i - 2] === \"-\"){\n                        comment = false;\n                        angleBracketsCount--;\n                    }\n                }else{\n                    angleBracketsCount--;\n                }\n                if (angleBracketsCount === 0) {\n                  break;\n                }\n            }else if( xmlData[i] === '['){\n                hasBody = true;\n            }else{\n                exp += xmlData[i];\n            }\n        }\n        if(angleBracketsCount !== 0){\n            throw new Error(`Unclosed DOCTYPE`);\n        }\n    }else{\n        throw new Error(`Invalid Tag instead of DOCTYPE`);\n    }\n    return {entities, i};\n}\n\nfunction readEntityExp(xmlData,i){\n    //External entities are not supported\n    //    <!ENTITY ext SYSTEM \"http://normal-website.com\" >\n\n    //Parameter entities are not supported\n    //    <!ENTITY entityname \"&anotherElement;\">\n\n    //Internal entities are supported\n    //    <!ENTITY entityname \"replacement text\">\n    \n    //read EntityName\n    let entityName = \"\";\n    for (; i < xmlData.length && (xmlData[i] !== \"'\" && xmlData[i] !== '\"' ); i++) {\n        // if(xmlData[i] === \" \") continue;\n        // else \n        entityName += xmlData[i];\n    }\n    entityName = entityName.trim();\n    if(entityName.indexOf(\" \") !== -1) throw new Error(\"External entites are not supported\");\n\n    //read Entity Value\n    const startChar = xmlData[i++];\n    let val = \"\"\n    for (; i < xmlData.length && xmlData[i] !== startChar ; i++) {\n        val += xmlData[i];\n    }\n    return [entityName, val, i];\n}\n\nfunction isComment(xmlData, i){\n    if(xmlData[i+1] === '!' &&\n    xmlData[i+2] === '-' &&\n    xmlData[i+3] === '-') return true\n    return false\n}\nfunction isEntity(xmlData, i){\n    if(xmlData[i+1] === '!' &&\n    xmlData[i+2] === 'E' &&\n    xmlData[i+3] === 'N' &&\n    xmlData[i+4] === 'T' &&\n    xmlData[i+5] === 'I' &&\n    xmlData[i+6] === 'T' &&\n    xmlData[i+7] === 'Y') return true\n    return false\n}\nfunction isElement(xmlData, i){\n    if(xmlData[i+1] === '!' &&\n    xmlData[i+2] === 'E' &&\n    xmlData[i+3] === 'L' &&\n    xmlData[i+4] === 'E' &&\n    xmlData[i+5] === 'M' &&\n    xmlData[i+6] === 'E' &&\n    xmlData[i+7] === 'N' &&\n    xmlData[i+8] === 'T') return true\n    return false\n}\n\nfunction isAttlist(xmlData, i){\n    if(xmlData[i+1] === '!' &&\n    xmlData[i+2] === 'A' &&\n    xmlData[i+3] === 'T' &&\n    xmlData[i+4] === 'T' &&\n    xmlData[i+5] === 'L' &&\n    xmlData[i+6] === 'I' &&\n    xmlData[i+7] === 'S' &&\n    xmlData[i+8] === 'T') return true\n    return false\n}\nfunction isNotation(xmlData, i){\n    if(xmlData[i+1] === '!' &&\n    xmlData[i+2] === 'N' &&\n    xmlData[i+3] === 'O' &&\n    xmlData[i+4] === 'T' &&\n    xmlData[i+5] === 'A' &&\n    xmlData[i+6] === 'T' &&\n    xmlData[i+7] === 'I' &&\n    xmlData[i+8] === 'O' &&\n    xmlData[i+9] === 'N') return true\n    return false\n}\n\nfunction validateEntityName(name){\n    if (util.isName(name))\n\treturn name;\n    else\n        throw new Error(`Invalid entity name ${name}`);\n}\n\nmodule.exports = readDocType;\n","\nconst defaultOptions = {\n    preserveOrder: false,\n    attributeNamePrefix: '@_',\n    attributesGroupName: false,\n    textNodeName: '#text',\n    ignoreAttributes: true,\n    removeNSPrefix: false, // remove NS from tag name or attribute name if true\n    allowBooleanAttributes: false, //a tag can have attributes without any value\n    //ignoreRootElement : false,\n    parseTagValue: true,\n    parseAttributeValue: false,\n    trimValues: true, //Trim string values of tag and attributes\n    cdataPropName: false,\n    numberParseOptions: {\n      hex: true,\n      leadingZeros: true,\n      eNotation: true\n    },\n    tagValueProcessor: function(tagName, val) {\n      return val;\n    },\n    attributeValueProcessor: function(attrName, val) {\n      return val;\n    },\n    stopNodes: [], //nested tags will not be parsed even for errors\n    alwaysCreateTextNode: false,\n    isArray: () => false,\n    commentPropName: false,\n    unpairedTags: [],\n    processEntities: true,\n    htmlEntities: false,\n    ignoreDeclaration: false,\n    ignorePiTags: false,\n    transformTagName: false,\n    transformAttributeName: false,\n    updateTag: function(tagName, jPath, attrs){\n      return tagName\n    },\n    // skipEmptyListItem: false\n};\n   \nconst buildOptions = function(options) {\n    return Object.assign({}, defaultOptions, options);\n};\n\nexports.buildOptions = buildOptions;\nexports.defaultOptions = defaultOptions;","'use strict';\n///@ts-check\n\nconst util = require('../util');\nconst xmlNode = require('./xmlNode');\nconst readDocType = require(\"./DocTypeReader\");\nconst toNumber = require(\"strnum\");\nconst getIgnoreAttributesFn = require('../ignoreAttributes')\n\n// const regx =\n//   '<((!\\\\[CDATA\\\\[([\\\\s\\\\S]*?)(]]>))|((NAME:)?(NAME))([^>]*)>|((\\\\/)(NAME)\\\\s*>))([^<]*)'\n//   .replace(/NAME/g, util.nameRegexp);\n\n//const tagsRegx = new RegExp(\"<(\\\\/?[\\\\w:\\\\-\\._]+)([^>]*)>(\\\\s*\"+cdataRegx+\")*([^<]+)?\",\"g\");\n//const tagsRegx = new RegExp(\"<(\\\\/?)((\\\\w*:)?([\\\\w:\\\\-\\._]+))([^>]*)>([^<]*)(\"+cdataRegx+\"([^<]*))*([^<]+)?\",\"g\");\n\nclass OrderedObjParser{\n  constructor(options){\n    this.options = options;\n    this.currentNode = null;\n    this.tagsNodeStack = [];\n    this.docTypeEntities = {};\n    this.lastEntities = {\n      \"apos\" : { regex: /&(apos|#39|#x27);/g, val : \"'\"},\n      \"gt\" : { regex: /&(gt|#62|#x3E);/g, val : \">\"},\n      \"lt\" : { regex: /&(lt|#60|#x3C);/g, val : \"<\"},\n      \"quot\" : { regex: /&(quot|#34|#x22);/g, val : \"\\\"\"},\n    };\n    this.ampEntity = { regex: /&(amp|#38|#x26);/g, val : \"&\"};\n    this.htmlEntities = {\n      \"space\": { regex: /&(nbsp|#160);/g, val: \" \" },\n      // \"lt\" : { regex: /&(lt|#60);/g, val: \"<\" },\n      // \"gt\" : { regex: /&(gt|#62);/g, val: \">\" },\n      // \"amp\" : { regex: /&(amp|#38);/g, val: \"&\" },\n      // \"quot\" : { regex: /&(quot|#34);/g, val: \"\\\"\" },\n      // \"apos\" : { regex: /&(apos|#39);/g, val: \"'\" },\n      \"cent\" : { regex: /&(cent|#162);/g, val: \"\" },\n      \"pound\" : { regex: /&(pound|#163);/g, val: \"\" },\n      \"yen\" : { regex: /&(yen|#165);/g, val: \"\" },\n      \"euro\" : { regex: /&(euro|#8364);/g, val: \"\" },\n      \"copyright\" : { regex: /&(copy|#169);/g, val: \"\" },\n      \"reg\" : { regex: /&(reg|#174);/g, val: \"\" },\n      \"inr\" : { regex: /&(inr|#8377);/g, val: \"\" },\n      \"num_dec\": { regex: /&#([0-9]{1,7});/g, val : (_, str) => String.fromCharCode(Number.parseInt(str, 10)) },\n      \"num_hex\": { regex: /&#x([0-9a-fA-F]{1,6});/g, val : (_, str) => String.fromCharCode(Number.parseInt(str, 16)) },\n    };\n    this.addExternalEntities = addExternalEntities;\n    this.parseXml = parseXml;\n    this.parseTextData = parseTextData;\n    this.resolveNameSpace = resolveNameSpace;\n    this.buildAttributesMap = buildAttributesMap;\n    this.isItStopNode = isItStopNode;\n    this.replaceEntitiesValue = replaceEntitiesValue;\n    this.readStopNodeData = readStopNodeData;\n    this.saveTextToParentTag = saveTextToParentTag;\n    this.addChild = addChild;\n    this.ignoreAttributesFn = getIgnoreAttributesFn(this.options.ignoreAttributes)\n  }\n\n}\n\nfunction addExternalEntities(externalEntities){\n  const entKeys = Object.keys(externalEntities);\n  for (let i = 0; i < entKeys.length; i++) {\n    const ent = entKeys[i];\n    this.lastEntities[ent] = {\n       regex: new RegExp(\"&\"+ent+\";\",\"g\"),\n       val : externalEntities[ent]\n    }\n  }\n}\n\n/**\n * @param {string} val\n * @param {string} tagName\n * @param {string} jPath\n * @param {boolean} dontTrim\n * @param {boolean} hasAttributes\n * @param {boolean} isLeafNode\n * @param {boolean} escapeEntities\n */\nfunction parseTextData(val, tagName, jPath, dontTrim, hasAttributes, isLeafNode, escapeEntities) {\n  if (val !== undefined) {\n    if (this.options.trimValues && !dontTrim) {\n      val = val.trim();\n    }\n    if(val.length > 0){\n      if(!escapeEntities) val = this.replaceEntitiesValue(val);\n      \n      const newval = this.options.tagValueProcessor(tagName, val, jPath, hasAttributes, isLeafNode);\n      if(newval === null || newval === undefined){\n        //don't parse\n        return val;\n      }else if(typeof newval !== typeof val || newval !== val){\n        //overwrite\n        return newval;\n      }else if(this.options.trimValues){\n        return parseValue(val, this.options.parseTagValue, this.options.numberParseOptions);\n      }else{\n        const trimmedVal = val.trim();\n        if(trimmedVal === val){\n          return parseValue(val, this.options.parseTagValue, this.options.numberParseOptions);\n        }else{\n          return val;\n        }\n      }\n    }\n  }\n}\n\nfunction resolveNameSpace(tagname) {\n  if (this.options.removeNSPrefix) {\n    const tags = tagname.split(':');\n    const prefix = tagname.charAt(0) === '/' ? '/' : '';\n    if (tags[0] === 'xmlns') {\n      return '';\n    }\n    if (tags.length === 2) {\n      tagname = prefix + tags[1];\n    }\n  }\n  return tagname;\n}\n\n//TODO: change regex to capture NS\n//const attrsRegx = new RegExp(\"([\\\\w\\\\-\\\\.\\\\:]+)\\\\s*=\\\\s*(['\\\"])((.|\\n)*?)\\\\2\",\"gm\");\nconst attrsRegx = new RegExp('([^\\\\s=]+)\\\\s*(=\\\\s*([\\'\"])([\\\\s\\\\S]*?)\\\\3)?', 'gm');\n\nfunction buildAttributesMap(attrStr, jPath, tagName) {\n  if (this.options.ignoreAttributes !== true && typeof attrStr === 'string') {\n    // attrStr = attrStr.replace(/\\r?\\n/g, ' ');\n    //attrStr = attrStr || attrStr.trim();\n\n    const matches = util.getAllMatches(attrStr, attrsRegx);\n    const len = matches.length; //don't make it inline\n    const attrs = {};\n    for (let i = 0; i < len; i++) {\n      const attrName = this.resolveNameSpace(matches[i][1]);\n      if (this.ignoreAttributesFn(attrName, jPath)) {\n        continue\n      }\n      let oldVal = matches[i][4];\n      let aName = this.options.attributeNamePrefix + attrName;\n      if (attrName.length) {\n        if (this.options.transformAttributeName) {\n          aName = this.options.transformAttributeName(aName);\n        }\n        if(aName === \"__proto__\") aName  = \"#__proto__\";\n        if (oldVal !== undefined) {\n          if (this.options.trimValues) {\n            oldVal = oldVal.trim();\n          }\n          oldVal = this.replaceEntitiesValue(oldVal);\n          const newVal = this.options.attributeValueProcessor(attrName, oldVal, jPath);\n          if(newVal === null || newVal === undefined){\n            //don't parse\n            attrs[aName] = oldVal;\n          }else if(typeof newVal !== typeof oldVal || newVal !== oldVal){\n            //overwrite\n            attrs[aName] = newVal;\n          }else{\n            //parse\n            attrs[aName] = parseValue(\n              oldVal,\n              this.options.parseAttributeValue,\n              this.options.numberParseOptions\n            );\n          }\n        } else if (this.options.allowBooleanAttributes) {\n          attrs[aName] = true;\n        }\n      }\n    }\n    if (!Object.keys(attrs).length) {\n      return;\n    }\n    if (this.options.attributesGroupName) {\n      const attrCollection = {};\n      attrCollection[this.options.attributesGroupName] = attrs;\n      return attrCollection;\n    }\n    return attrs\n  }\n}\n\nconst parseXml = function(xmlData) {\n  xmlData = xmlData.replace(/\\r\\n?/g, \"\\n\"); //TODO: remove this line\n  const xmlObj = new xmlNode('!xml');\n  let currentNode = xmlObj;\n  let textData = \"\";\n  let jPath = \"\";\n  for(let i=0; i< xmlData.length; i++){//for each char in XML data\n    const ch = xmlData[i];\n    if(ch === '<'){\n      // const nextIndex = i+1;\n      // const _2ndChar = xmlData[nextIndex];\n      if( xmlData[i+1] === '/') {//Closing Tag\n        const closeIndex = findClosingIndex(xmlData, \">\", i, \"Closing Tag is not closed.\")\n        let tagName = xmlData.substring(i+2,closeIndex).trim();\n\n        if(this.options.removeNSPrefix){\n          const colonIndex = tagName.indexOf(\":\");\n          if(colonIndex !== -1){\n            tagName = tagName.substr(colonIndex+1);\n          }\n        }\n\n        if(this.options.transformTagName) {\n          tagName = this.options.transformTagName(tagName);\n        }\n\n        if(currentNode){\n          textData = this.saveTextToParentTag(textData, currentNode, jPath);\n        }\n\n        //check if last tag of nested tag was unpaired tag\n        const lastTagName = jPath.substring(jPath.lastIndexOf(\".\")+1);\n        if(tagName && this.options.unpairedTags.indexOf(tagName) !== -1 ){\n          throw new Error(`Unpaired tag can not be used as closing tag: </${tagName}>`);\n        }\n        let propIndex = 0\n        if(lastTagName && this.options.unpairedTags.indexOf(lastTagName) !== -1 ){\n          propIndex = jPath.lastIndexOf('.', jPath.lastIndexOf('.')-1)\n          this.tagsNodeStack.pop();\n        }else{\n          propIndex = jPath.lastIndexOf(\".\");\n        }\n        jPath = jPath.substring(0, propIndex);\n\n        currentNode = this.tagsNodeStack.pop();//avoid recursion, set the parent tag scope\n        textData = \"\";\n        i = closeIndex;\n      } else if( xmlData[i+1] === '?') {\n\n        let tagData = readTagExp(xmlData,i, false, \"?>\");\n        if(!tagData) throw new Error(\"Pi Tag is not closed.\");\n\n        textData = this.saveTextToParentTag(textData, currentNode, jPath);\n        if( (this.options.ignoreDeclaration && tagData.tagName === \"?xml\") || this.options.ignorePiTags){\n\n        }else{\n  \n          const childNode = new xmlNode(tagData.tagName);\n          childNode.add(this.options.textNodeName, \"\");\n          \n          if(tagData.tagName !== tagData.tagExp && tagData.attrExpPresent){\n            childNode[\":@\"] = this.buildAttributesMap(tagData.tagExp, jPath, tagData.tagName);\n          }\n          this.addChild(currentNode, childNode, jPath)\n\n        }\n\n\n        i = tagData.closeIndex + 1;\n      } else if(xmlData.substr(i + 1, 3) === '!--') {\n        const endIndex = findClosingIndex(xmlData, \"-->\", i+4, \"Comment is not closed.\")\n        if(this.options.commentPropName){\n          const comment = xmlData.substring(i + 4, endIndex - 2);\n\n          textData = this.saveTextToParentTag(textData, currentNode, jPath);\n\n          currentNode.add(this.options.commentPropName, [ { [this.options.textNodeName] : comment } ]);\n        }\n        i = endIndex;\n      } else if( xmlData.substr(i + 1, 2) === '!D') {\n        const result = readDocType(xmlData, i);\n        this.docTypeEntities = result.entities;\n        i = result.i;\n      }else if(xmlData.substr(i + 1, 2) === '![') {\n        const closeIndex = findClosingIndex(xmlData, \"]]>\", i, \"CDATA is not closed.\") - 2;\n        const tagExp = xmlData.substring(i + 9,closeIndex);\n\n        textData = this.saveTextToParentTag(textData, currentNode, jPath);\n\n        let val = this.parseTextData(tagExp, currentNode.tagname, jPath, true, false, true, true);\n        if(val == undefined) val = \"\";\n\n        //cdata should be set even if it is 0 length string\n        if(this.options.cdataPropName){\n          currentNode.add(this.options.cdataPropName, [ { [this.options.textNodeName] : tagExp } ]);\n        }else{\n          currentNode.add(this.options.textNodeName, val);\n        }\n        \n        i = closeIndex + 2;\n      }else {//Opening tag\n        let result = readTagExp(xmlData,i, this.options.removeNSPrefix);\n        let tagName= result.tagName;\n        const rawTagName = result.rawTagName;\n        let tagExp = result.tagExp;\n        let attrExpPresent = result.attrExpPresent;\n        let closeIndex = result.closeIndex;\n\n        if (this.options.transformTagName) {\n          tagName = this.options.transformTagName(tagName);\n        }\n        \n        //save text as child node\n        if (currentNode && textData) {\n          if(currentNode.tagname !== '!xml'){\n            //when nested tag is found\n            textData = this.saveTextToParentTag(textData, currentNode, jPath, false);\n          }\n        }\n\n        //check if last tag was unpaired tag\n        const lastTag = currentNode;\n        if(lastTag && this.options.unpairedTags.indexOf(lastTag.tagname) !== -1 ){\n          currentNode = this.tagsNodeStack.pop();\n          jPath = jPath.substring(0, jPath.lastIndexOf(\".\"));\n        }\n        if(tagName !== xmlObj.tagname){\n          jPath += jPath ? \".\" + tagName : tagName;\n        }\n        if (this.isItStopNode(this.options.stopNodes, jPath, tagName)) {\n          let tagContent = \"\";\n          //self-closing tag\n          if(tagExp.length > 0 && tagExp.lastIndexOf(\"/\") === tagExp.length - 1){\n            if(tagName[tagName.length - 1] === \"/\"){ //remove trailing '/'\n              tagName = tagName.substr(0, tagName.length - 1);\n              jPath = jPath.substr(0, jPath.length - 1);\n              tagExp = tagName;\n            }else{\n              tagExp = tagExp.substr(0, tagExp.length - 1);\n            }\n            i = result.closeIndex;\n          }\n          //unpaired tag\n          else if(this.options.unpairedTags.indexOf(tagName) !== -1){\n            \n            i = result.closeIndex;\n          }\n          //normal tag\n          else{\n            //read until closing tag is found\n            const result = this.readStopNodeData(xmlData, rawTagName, closeIndex + 1);\n            if(!result) throw new Error(`Unexpected end of ${rawTagName}`);\n            i = result.i;\n            tagContent = result.tagContent;\n          }\n\n          const childNode = new xmlNode(tagName);\n          if(tagName !== tagExp && attrExpPresent){\n            childNode[\":@\"] = this.buildAttributesMap(tagExp, jPath, tagName);\n          }\n          if(tagContent) {\n            tagContent = this.parseTextData(tagContent, tagName, jPath, true, attrExpPresent, true, true);\n          }\n          \n          jPath = jPath.substr(0, jPath.lastIndexOf(\".\"));\n          childNode.add(this.options.textNodeName, tagContent);\n          \n          this.addChild(currentNode, childNode, jPath)\n        }else{\n  //selfClosing tag\n          if(tagExp.length > 0 && tagExp.lastIndexOf(\"/\") === tagExp.length - 1){\n            if(tagName[tagName.length - 1] === \"/\"){ //remove trailing '/'\n              tagName = tagName.substr(0, tagName.length - 1);\n              jPath = jPath.substr(0, jPath.length - 1);\n              tagExp = tagName;\n            }else{\n              tagExp = tagExp.substr(0, tagExp.length - 1);\n            }\n            \n            if(this.options.transformTagName) {\n              tagName = this.options.transformTagName(tagName);\n            }\n\n            const childNode = new xmlNode(tagName);\n            if(tagName !== tagExp && attrExpPresent){\n              childNode[\":@\"] = this.buildAttributesMap(tagExp, jPath, tagName);\n            }\n            this.addChild(currentNode, childNode, jPath)\n            jPath = jPath.substr(0, jPath.lastIndexOf(\".\"));\n          }\n    //opening tag\n          else{\n            const childNode = new xmlNode( tagName);\n            this.tagsNodeStack.push(currentNode);\n            \n            if(tagName !== tagExp && attrExpPresent){\n              childNode[\":@\"] = this.buildAttributesMap(tagExp, jPath, tagName);\n            }\n            this.addChild(currentNode, childNode, jPath)\n            currentNode = childNode;\n          }\n          textData = \"\";\n          i = closeIndex;\n        }\n      }\n    }else{\n      textData += xmlData[i];\n    }\n  }\n  return xmlObj.child;\n}\n\nfunction addChild(currentNode, childNode, jPath){\n  const result = this.options.updateTag(childNode.tagname, jPath, childNode[\":@\"])\n  if(result === false){\n  }else if(typeof result === \"string\"){\n    childNode.tagname = result\n    currentNode.addChild(childNode);\n  }else{\n    currentNode.addChild(childNode);\n  }\n}\n\nconst replaceEntitiesValue = function(val){\n\n  if(this.options.processEntities){\n    for(let entityName in this.docTypeEntities){\n      const entity = this.docTypeEntities[entityName];\n      val = val.replace( entity.regx, entity.val);\n    }\n    for(let entityName in this.lastEntities){\n      const entity = this.lastEntities[entityName];\n      val = val.replace( entity.regex, entity.val);\n    }\n    if(this.options.htmlEntities){\n      for(let entityName in this.htmlEntities){\n        const entity = this.htmlEntities[entityName];\n        val = val.replace( entity.regex, entity.val);\n      }\n    }\n    val = val.replace( this.ampEntity.regex, this.ampEntity.val);\n  }\n  return val;\n}\nfunction saveTextToParentTag(textData, currentNode, jPath, isLeafNode) {\n  if (textData) { //store previously collected data as textNode\n    if(isLeafNode === undefined) isLeafNode = currentNode.child.length === 0\n    \n    textData = this.parseTextData(textData,\n      currentNode.tagname,\n      jPath,\n      false,\n      currentNode[\":@\"] ? Object.keys(currentNode[\":@\"]).length !== 0 : false,\n      isLeafNode);\n\n    if (textData !== undefined && textData !== \"\")\n      currentNode.add(this.options.textNodeName, textData);\n    textData = \"\";\n  }\n  return textData;\n}\n\n//TODO: use jPath to simplify the logic\n/**\n * \n * @param {string[]} stopNodes \n * @param {string} jPath\n * @param {string} currentTagName \n */\nfunction isItStopNode(stopNodes, jPath, currentTagName){\n  const allNodesExp = \"*.\" + currentTagName;\n  for (const stopNodePath in stopNodes) {\n    const stopNodeExp = stopNodes[stopNodePath];\n    if( allNodesExp === stopNodeExp || jPath === stopNodeExp  ) return true;\n  }\n  return false;\n}\n\n/**\n * Returns the tag Expression and where it is ending handling single-double quotes situation\n * @param {string} xmlData \n * @param {number} i starting index\n * @returns \n */\nfunction tagExpWithClosingIndex(xmlData, i, closingChar = \">\"){\n  let attrBoundary;\n  let tagExp = \"\";\n  for (let index = i; index < xmlData.length; index++) {\n    let ch = xmlData[index];\n    if (attrBoundary) {\n        if (ch === attrBoundary) attrBoundary = \"\";//reset\n    } else if (ch === '\"' || ch === \"'\") {\n        attrBoundary = ch;\n    } else if (ch === closingChar[0]) {\n      if(closingChar[1]){\n        if(xmlData[index + 1] === closingChar[1]){\n          return {\n            data: tagExp,\n            index: index\n          }\n        }\n      }else{\n        return {\n          data: tagExp,\n          index: index\n        }\n      }\n    } else if (ch === '\\t') {\n      ch = \" \"\n    }\n    tagExp += ch;\n  }\n}\n\nfunction findClosingIndex(xmlData, str, i, errMsg){\n  const closingIndex = xmlData.indexOf(str, i);\n  if(closingIndex === -1){\n    throw new Error(errMsg)\n  }else{\n    return closingIndex + str.length - 1;\n  }\n}\n\nfunction readTagExp(xmlData,i, removeNSPrefix, closingChar = \">\"){\n  const result = tagExpWithClosingIndex(xmlData, i+1, closingChar);\n  if(!result) return;\n  let tagExp = result.data;\n  const closeIndex = result.index;\n  const separatorIndex = tagExp.search(/\\s/);\n  let tagName = tagExp;\n  let attrExpPresent = true;\n  if(separatorIndex !== -1){//separate tag name and attributes expression\n    tagName = tagExp.substring(0, separatorIndex);\n    tagExp = tagExp.substring(separatorIndex + 1).trimStart();\n  }\n\n  const rawTagName = tagName;\n  if(removeNSPrefix){\n    const colonIndex = tagName.indexOf(\":\");\n    if(colonIndex !== -1){\n      tagName = tagName.substr(colonIndex+1);\n      attrExpPresent = tagName !== result.data.substr(colonIndex + 1);\n    }\n  }\n\n  return {\n    tagName: tagName,\n    tagExp: tagExp,\n    closeIndex: closeIndex,\n    attrExpPresent: attrExpPresent,\n    rawTagName: rawTagName,\n  }\n}\n/**\n * find paired tag for a stop node\n * @param {string} xmlData \n * @param {string} tagName \n * @param {number} i \n */\nfunction readStopNodeData(xmlData, tagName, i){\n  const startIndex = i;\n  // Starting at 1 since we already have an open tag\n  let openTagCount = 1;\n\n  for (; i < xmlData.length; i++) {\n    if( xmlData[i] === \"<\"){ \n      if (xmlData[i+1] === \"/\") {//close tag\n          const closeIndex = findClosingIndex(xmlData, \">\", i, `${tagName} is not closed`);\n          let closeTagName = xmlData.substring(i+2,closeIndex).trim();\n          if(closeTagName === tagName){\n            openTagCount--;\n            if (openTagCount === 0) {\n              return {\n                tagContent: xmlData.substring(startIndex, i),\n                i : closeIndex\n              }\n            }\n          }\n          i=closeIndex;\n        } else if(xmlData[i+1] === '?') { \n          const closeIndex = findClosingIndex(xmlData, \"?>\", i+1, \"StopNode is not closed.\")\n          i=closeIndex;\n        } else if(xmlData.substr(i + 1, 3) === '!--') { \n          const closeIndex = findClosingIndex(xmlData, \"-->\", i+3, \"StopNode is not closed.\")\n          i=closeIndex;\n        } else if(xmlData.substr(i + 1, 2) === '![') { \n          const closeIndex = findClosingIndex(xmlData, \"]]>\", i, \"StopNode is not closed.\") - 2;\n          i=closeIndex;\n        } else {\n          const tagData = readTagExp(xmlData, i, '>')\n\n          if (tagData) {\n            const openTagName = tagData && tagData.tagName;\n            if (openTagName === tagName && tagData.tagExp[tagData.tagExp.length-1] !== \"/\") {\n              openTagCount++;\n            }\n            i=tagData.closeIndex;\n          }\n        }\n      }\n  }//end for loop\n}\n\nfunction parseValue(val, shouldParse, options) {\n  if (shouldParse && typeof val === 'string') {\n    //console.log(options)\n    const newval = val.trim();\n    if(newval === 'true' ) return true;\n    else if(newval === 'false' ) return false;\n    else return toNumber(val, options);\n  } else {\n    if (util.isExist(val)) {\n      return val;\n    } else {\n      return '';\n    }\n  }\n}\n\n\nmodule.exports = OrderedObjParser;\n","const { buildOptions} = require(\"./OptionsBuilder\");\nconst OrderedObjParser = require(\"./OrderedObjParser\");\nconst { prettify} = require(\"./node2json\");\nconst validator = require('../validator');\n\nclass XMLParser{\n    \n    constructor(options){\n        this.externalEntities = {};\n        this.options = buildOptions(options);\n        \n    }\n    /**\n     * Parse XML dats to JS object \n     * @param {string|Buffer} xmlData \n     * @param {boolean|Object} validationOption \n     */\n    parse(xmlData,validationOption){\n        if(typeof xmlData === \"string\"){\n        }else if( xmlData.toString){\n            xmlData = xmlData.toString();\n        }else{\n            throw new Error(\"XML data is accepted in String or Bytes[] form.\")\n        }\n        if( validationOption){\n            if(validationOption === true) validationOption = {}; //validate with default options\n            \n            const result = validator.validate(xmlData, validationOption);\n            if (result !== true) {\n              throw Error( `${result.err.msg}:${result.err.line}:${result.err.col}` )\n            }\n          }\n        const orderedObjParser = new OrderedObjParser(this.options);\n        orderedObjParser.addExternalEntities(this.externalEntities);\n        const orderedResult = orderedObjParser.parseXml(xmlData);\n        if(this.options.preserveOrder || orderedResult === undefined) return orderedResult;\n        else return prettify(orderedResult, this.options);\n    }\n\n    /**\n     * Add Entity which is not by default supported by this library\n     * @param {string} key \n     * @param {string} value \n     */\n    addEntity(key, value){\n        if(value.indexOf(\"&\") !== -1){\n            throw new Error(\"Entity value can't have '&'\")\n        }else if(key.indexOf(\"&\") !== -1 || key.indexOf(\";\") !== -1){\n            throw new Error(\"An entity must be set without '&' and ';'. Eg. use '#xD' for '&#xD;'\")\n        }else if(value === \"&\"){\n            throw new Error(\"An entity with value '&' is not permitted\");\n        }else{\n            this.externalEntities[key] = value;\n        }\n    }\n}\n\nmodule.exports = XMLParser;","'use strict';\n\n/**\n * \n * @param {array} node \n * @param {any} options \n * @returns \n */\nfunction prettify(node, options){\n  return compress( node, options);\n}\n\n/**\n * \n * @param {array} arr \n * @param {object} options \n * @param {string} jPath \n * @returns object\n */\nfunction compress(arr, options, jPath){\n  let text;\n  const compressedObj = {};\n  for (let i = 0; i < arr.length; i++) {\n    const tagObj = arr[i];\n    const property = propName(tagObj);\n    let newJpath = \"\";\n    if(jPath === undefined) newJpath = property;\n    else newJpath = jPath + \".\" + property;\n\n    if(property === options.textNodeName){\n      if(text === undefined) text = tagObj[property];\n      else text += \"\" + tagObj[property];\n    }else if(property === undefined){\n      continue;\n    }else if(tagObj[property]){\n      \n      let val = compress(tagObj[property], options, newJpath);\n      const isLeaf = isLeafTag(val, options);\n\n      if(tagObj[\":@\"]){\n        assignAttributes( val, tagObj[\":@\"], newJpath, options);\n      }else if(Object.keys(val).length === 1 && val[options.textNodeName] !== undefined && !options.alwaysCreateTextNode){\n        val = val[options.textNodeName];\n      }else if(Object.keys(val).length === 0){\n        if(options.alwaysCreateTextNode) val[options.textNodeName] = \"\";\n        else val = \"\";\n      }\n\n      if(compressedObj[property] !== undefined && compressedObj.hasOwnProperty(property)) {\n        if(!Array.isArray(compressedObj[property])) {\n            compressedObj[property] = [ compressedObj[property] ];\n        }\n        compressedObj[property].push(val);\n      }else{\n        //TODO: if a node is not an array, then check if it should be an array\n        //also determine if it is a leaf node\n        if (options.isArray(property, newJpath, isLeaf )) {\n          compressedObj[property] = [val];\n        }else{\n          compressedObj[property] = val;\n        }\n      }\n    }\n    \n  }\n  // if(text && text.length > 0) compressedObj[options.textNodeName] = text;\n  if(typeof text === \"string\"){\n    if(text.length > 0) compressedObj[options.textNodeName] = text;\n  }else if(text !== undefined) compressedObj[options.textNodeName] = text;\n  return compressedObj;\n}\n\nfunction propName(obj){\n  const keys = Object.keys(obj);\n  for (let i = 0; i < keys.length; i++) {\n    const key = keys[i];\n    if(key !== \":@\") return key;\n  }\n}\n\nfunction assignAttributes(obj, attrMap, jpath, options){\n  if (attrMap) {\n    const keys = Object.keys(attrMap);\n    const len = keys.length; //don't make it inline\n    for (let i = 0; i < len; i++) {\n      const atrrName = keys[i];\n      if (options.isArray(atrrName, jpath + \".\" + atrrName, true, true)) {\n        obj[atrrName] = [ attrMap[atrrName] ];\n      } else {\n        obj[atrrName] = attrMap[atrrName];\n      }\n    }\n  }\n}\n\nfunction isLeafTag(obj, options){\n  const { textNodeName } = options;\n  const propCount = Object.keys(obj).length;\n  \n  if (propCount === 0) {\n    return true;\n  }\n\n  if (\n    propCount === 1 &&\n    (obj[textNodeName] || typeof obj[textNodeName] === \"boolean\" || obj[textNodeName] === 0)\n  ) {\n    return true;\n  }\n\n  return false;\n}\nexports.prettify = prettify;\n","'use strict';\n\nclass XmlNode{\n  constructor(tagname) {\n    this.tagname = tagname;\n    this.child = []; //nested tags, text, cdata, comments in order\n    this[\":@\"] = {}; //attributes map\n  }\n  add(key,val){\n    // this.child.push( {name : key, val: val, isCdata: isCdata });\n    if(key === \"__proto__\") key = \"#__proto__\";\n    this.child.push( {[key]: val });\n  }\n  addChild(node) {\n    if(node.tagname === \"__proto__\") node.tagname = \"#__proto__\";\n    if(node[\":@\"] && Object.keys(node[\":@\"]).length > 0){\n      this.child.push( { [node.tagname]: node.child, [\":@\"]: node[\":@\"] });\n    }else{\n      this.child.push( { [node.tagname]: node.child });\n    }\n  };\n};\n\n\nmodule.exports = XmlNode;","/**\n * The `Applicative` type class extends the `Apply` type class with a `of` function, which can be used to create values\n * of type `f a` from values of type `a`.\n *\n * Where `Apply` provides the ability to lift functions of two or more arguments to functions whose arguments are\n * wrapped using `f`, and `Functor` provides the ability to lift functions of one argument, `pure` can be seen as the\n * function which lifts functions of _zero_ arguments. That is, `Applicative` functors support a lifting operation for\n * any number of function arguments.\n *\n * Instances must satisfy the following laws in addition to the `Apply` laws:\n *\n * 1. Identity: `A.ap(A.of(a => a), fa) <-> fa`\n * 2. Homomorphism: `A.ap(A.of(ab), A.of(a)) <-> A.of(ab(a))`\n * 3. Interchange: `A.ap(fab, A.of(a)) <-> A.ap(A.of(ab => ab(a)), fab)`\n *\n * Note. `Functor`'s `map` can be derived: `A.map(x, f) = A.ap(A.of(f), x)`\n *\n * @since 2.0.0\n */\nimport { ap, getApplySemigroup } from './Apply';\nimport { pipe } from './function';\nimport { getFunctorComposition } from './Functor';\nexport function getApplicativeMonoid(F) {\n    var f = getApplySemigroup(F);\n    return function (M) { return ({\n        concat: f(M).concat,\n        empty: F.of(M.empty)\n    }); };\n}\n/** @deprecated */\nexport function getApplicativeComposition(F, G) {\n    var map = getFunctorComposition(F, G).map;\n    var _ap = ap(F, G);\n    return {\n        map: map,\n        of: function (a) { return F.of(G.of(a)); },\n        ap: function (fgab, fga) { return pipe(fgab, _ap(fga)); }\n    };\n}\n","/**\n * The `Apply` class provides the `ap` which is used to apply a function to an argument under a type constructor.\n *\n * `Apply` can be used to lift functions of two or more arguments to work on values wrapped with the type constructor\n * `f`.\n *\n * Instances must satisfy the following law in addition to the `Functor` laws:\n *\n * 1. Associative composition: `F.ap(F.ap(F.map(fbc, bc => ab => a => bc(ab(a))), fab), fa) <-> F.ap(fbc, F.ap(fab, fa))`\n *\n * Formally, `Apply` represents a strong lax semi-monoidal endofunctor.\n *\n * @example\n * import * as O from 'fp-ts/Option'\n * import { pipe } from 'fp-ts/function'\n *\n * const f = (a: string) => (b: number) => (c: boolean) => a + String(b) + String(c)\n * const fa: O.Option<string> = O.some('s')\n * const fb: O.Option<number> = O.some(1)\n * const fc: O.Option<boolean> = O.some(true)\n *\n * assert.deepStrictEqual(\n *   pipe(\n *     // lift a function\n *     O.some(f),\n *     // apply the first argument\n *     O.ap(fa),\n *     // apply the second argument\n *     O.ap(fb),\n *     // apply the third argument\n *     O.ap(fc)\n *   ),\n *   O.some('s1true')\n * )\n *\n * @since 2.0.0\n */\nimport { tuple } from './function';\nimport * as _ from './internal';\nexport function ap(F, G) {\n    return function (fa) {\n        return function (fab) {\n            return F.ap(F.map(fab, function (gab) { return function (ga) { return G.ap(gab, ga); }; }), fa);\n        };\n    };\n}\nexport function apFirst(A) {\n    return function (second) { return function (first) {\n        return A.ap(A.map(first, function (a) { return function () { return a; }; }), second);\n    }; };\n}\nexport function apSecond(A) {\n    return function (second) {\n        return function (first) {\n            return A.ap(A.map(first, function () { return function (b) { return b; }; }), second);\n        };\n    };\n}\nexport function apS(F) {\n    return function (name, fb) {\n        return function (fa) {\n            return F.ap(F.map(fa, function (a) { return function (b) {\n                var _a;\n                return Object.assign({}, a, (_a = {}, _a[name] = b, _a));\n            }; }), fb);\n        };\n    };\n}\nexport function getApplySemigroup(F) {\n    return function (S) { return ({\n        concat: function (first, second) {\n            return F.ap(F.map(first, function (x) { return function (y) { return S.concat(x, y); }; }), second);\n        }\n    }); };\n}\nfunction curried(f, n, acc) {\n    return function (x) {\n        var combined = Array(acc.length + 1);\n        for (var i = 0; i < acc.length; i++) {\n            combined[i] = acc[i];\n        }\n        combined[acc.length] = x;\n        return n === 0 ? f.apply(null, combined) : curried(f, n - 1, combined);\n    };\n}\nvar tupleConstructors = {\n    1: function (a) { return [a]; },\n    2: function (a) { return function (b) { return [a, b]; }; },\n    3: function (a) { return function (b) { return function (c) { return [a, b, c]; }; }; },\n    4: function (a) { return function (b) { return function (c) { return function (d) { return [a, b, c, d]; }; }; }; },\n    5: function (a) { return function (b) { return function (c) { return function (d) { return function (e) { return [a, b, c, d, e]; }; }; }; }; }\n};\nfunction getTupleConstructor(len) {\n    if (!_.has.call(tupleConstructors, len)) {\n        tupleConstructors[len] = curried(tuple, len - 1, []);\n    }\n    return tupleConstructors[len];\n}\nexport function sequenceT(F) {\n    return function () {\n        var args = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            args[_i] = arguments[_i];\n        }\n        var len = args.length;\n        var f = getTupleConstructor(len);\n        var fas = F.map(args[0], f);\n        for (var i = 1; i < len; i++) {\n            fas = F.ap(fas, args[i]);\n        }\n        return fas;\n    };\n}\nfunction getRecordConstructor(keys) {\n    var len = keys.length;\n    switch (len) {\n        case 1:\n            return function (a) {\n                var _a;\n                return (_a = {}, _a[keys[0]] = a, _a);\n            };\n        case 2:\n            return function (a) { return function (b) {\n                var _a;\n                return (_a = {}, _a[keys[0]] = a, _a[keys[1]] = b, _a);\n            }; };\n        case 3:\n            return function (a) { return function (b) { return function (c) {\n                var _a;\n                return (_a = {}, _a[keys[0]] = a, _a[keys[1]] = b, _a[keys[2]] = c, _a);\n            }; }; };\n        case 4:\n            return function (a) { return function (b) { return function (c) { return function (d) {\n                var _a;\n                return (_a = {},\n                    _a[keys[0]] = a,\n                    _a[keys[1]] = b,\n                    _a[keys[2]] = c,\n                    _a[keys[3]] = d,\n                    _a);\n            }; }; }; };\n        case 5:\n            return function (a) { return function (b) { return function (c) { return function (d) { return function (e) {\n                var _a;\n                return (_a = {},\n                    _a[keys[0]] = a,\n                    _a[keys[1]] = b,\n                    _a[keys[2]] = c,\n                    _a[keys[3]] = d,\n                    _a[keys[4]] = e,\n                    _a);\n            }; }; }; }; };\n        default:\n            return curried(function () {\n                var args = [];\n                for (var _i = 0; _i < arguments.length; _i++) {\n                    args[_i] = arguments[_i];\n                }\n                var r = {};\n                for (var i = 0; i < len; i++) {\n                    r[keys[i]] = args[i];\n                }\n                return r;\n            }, len - 1, []);\n    }\n}\nexport function sequenceS(F) {\n    return function (r) {\n        var keys = Object.keys(r);\n        var len = keys.length;\n        var f = getRecordConstructor(keys);\n        var fr = F.map(r[keys[0]], f);\n        for (var i = 1; i < len; i++) {\n            fr = F.ap(fr, r[keys[i]]);\n        }\n        return fr;\n    };\n}\n","import { apFirst as apFirst_, apS as apS_, apSecond as apSecond_ } from './Apply';\nimport { bind as bind_, chainFirst as chainFirst_ } from './Chain';\nimport { fromEitherK as fromEitherK_ } from './FromEither';\nimport { dual, identity, pipe } from './function';\nimport { bindTo as bindTo_, flap as flap_, let as let__ } from './Functor';\nimport * as _ from './internal';\nimport * as NEA from './NonEmptyArray';\nimport * as RA from './ReadonlyArray';\nimport { separated } from './Separated';\nimport { filterE as filterE_, wiltDefault, witherDefault } from './Witherable';\nimport { guard as guard_ } from './Zero';\n// -------------------------------------------------------------------------------------\n// refinements\n// -------------------------------------------------------------------------------------\n/**\n * Test whether an array is empty\n *\n * @example\n * import { isEmpty } from 'fp-ts/Array'\n *\n * assert.strictEqual(isEmpty([]), true)\n * assert.strictEqual(isEmpty(['a']), false)\n *\n * @category refinements\n * @since 2.0.0\n */\nexport var isEmpty = function (as) { return as.length === 0; };\n/**\n * Test whether an array is non empty narrowing down the type to `NonEmptyArray<A>`\n *\n * @example\n * import { isNonEmpty } from 'fp-ts/Array'\n *\n * assert.strictEqual(isNonEmpty([]), false)\n * assert.strictEqual(isNonEmpty(['a']), true)\n *\n * @category refinements\n * @since 2.0.0\n */\nexport var isNonEmpty = NEA.isNonEmpty;\n// -------------------------------------------------------------------------------------\n// constructors\n// -------------------------------------------------------------------------------------\n/**\n * Prepend an element to the front of a `Array`, creating a new `NonEmptyArray`.\n *\n * @example\n * import { prepend } from 'fp-ts/Array'\n * import { pipe } from 'fp-ts/function'\n *\n * assert.deepStrictEqual(pipe([2, 3, 4], prepend(1)), [1, 2, 3, 4])\n *\n * @since 2.10.0\n */\nexport var prepend = NEA.prepend;\n/**\n * Less strict version of [`prepend`](#prepend).\n *\n * @example\n * import { prependW } from 'fp-ts/Array'\n * import { pipe } from 'fp-ts/function'\n *\n * assert.deepStrictEqual(pipe([2, 3, 4], prependW(\"a\")), [\"a\", 2, 3, 4]);\n *\n * @since 2.11.0\n */\nexport var prependW = NEA.prependW;\n/**\n * Append an element to the end of a `Array`, creating a new `NonEmptyArray`.\n *\n * @example\n * import { append } from 'fp-ts/Array'\n * import { pipe } from 'fp-ts/function'\n *\n * assert.deepStrictEqual(pipe([1, 2, 3], append(4)), [1, 2, 3, 4])\n *\n * @since 2.10.0\n */\nexport var append = NEA.append;\n/**\n * Less strict version of [`append`](#append).\n *\n * @example\n * import { appendW } from 'fp-ts/Array'\n * import { pipe } from 'fp-ts/function'\n *\n * assert.deepStrictEqual(pipe([1, 2, 3], appendW(\"d\")), [1, 2, 3, \"d\"]);\n *\n * @since 2.11.0\n */\nexport var appendW = NEA.appendW;\n/**\n * Return a `Array` of length `n` with element `i` initialized with `f(i)`.\n *\n * **Note**. `n` is normalized to a non negative integer.\n *\n * @example\n * import { makeBy } from 'fp-ts/Array'\n *\n * const double = (i: number): number => i * 2\n * assert.deepStrictEqual(makeBy(5, double), [0, 2, 4, 6, 8])\n * assert.deepStrictEqual(makeBy(-3, double), [])\n * assert.deepStrictEqual(makeBy(4.32164, double), [0, 2, 4, 6])\n *\n * @category constructors\n * @since 2.0.0\n */\nexport var makeBy = function (n, f) { return (n <= 0 ? [] : NEA.makeBy(f)(n)); };\n/**\n * Create a `Array` containing a value repeated the specified number of times.\n *\n * **Note**. `n` is normalized to a non negative integer.\n *\n * @example\n * import { replicate } from 'fp-ts/Array'\n *\n * assert.deepStrictEqual(replicate(3, 'a'), ['a', 'a', 'a'])\n * assert.deepStrictEqual(replicate(-3, 'a'), [])\n * assert.deepStrictEqual(replicate(2.985647, 'a'), ['a', 'a'])\n *\n * @category constructors\n * @since 2.0.0\n */\nexport var replicate = function (n, a) { return makeBy(n, function () { return a; }); };\nexport function fromPredicate(predicate) {\n    return function (a) { return (predicate(a) ? [a] : []); };\n}\n// -------------------------------------------------------------------------------------\n// conversions\n// -------------------------------------------------------------------------------------\n/**\n * Create an array from an `Option`. The resulting array will contain the content of the\n * `Option` if it is `Some` and it will be empty if the `Option` is `None`.\n *\n * @example\n * import { fromOption } from 'fp-ts/Array'\n * import { option } from \"fp-ts\";\n * import { pipe } from 'fp-ts/function'\n *\n * assert.deepStrictEqual(pipe(option.some(\"a\"), fromOption),[\"a\"])\n * assert.deepStrictEqual(pipe(option.none, fromOption),[])\n *\n * @category conversions\n * @since 2.11.0\n */\nexport var fromOption = function (ma) { return (_.isNone(ma) ? [] : [ma.value]); };\n/**\n * Create an array from an `Either`. The resulting array will contain the content of the\n * `Either` if it is `Right` and it will be empty if the `Either` is `Left`.\n *\n * @example\n * import { fromEither } from 'fp-ts/Array'\n * import { either } from \"fp-ts\";\n * import { pipe } from 'fp-ts/function'\n *\n * assert.deepStrictEqual(pipe(either.right(\"r\"), fromEither), [\"r\"]);\n * assert.deepStrictEqual(pipe(either.left(\"l\"), fromEither), []);\n *\n * @category conversions\n * @since 2.11.0\n */\nexport var fromEither = function (e) { return (_.isLeft(e) ? [] : [e.right]); };\n/**\n * Less strict version of [`match`](#match).\n *\n * The `W` suffix (short for **W**idening) means that the handler return types will be merged.\n *\n * @example\n * import { matchW } from 'fp-ts/Array'\n * import { pipe } from 'fp-ts/function'\n *\n * const matcherW = matchW(\n *   () => \"No elements\",\n *   (as) => as.length\n * );\n * assert.deepStrictEqual(pipe([1, 2, 3, 4], matcherW), 4);\n * assert.deepStrictEqual(pipe([], matcherW), \"No elements\");\n *\n * @category pattern matching\n * @since 2.11.0\n */\nexport var matchW = function (onEmpty, onNonEmpty) {\n    return function (as) {\n        return isNonEmpty(as) ? onNonEmpty(as) : onEmpty();\n    };\n};\n/**\n * Takes an array, if the array is empty it returns the result of `onEmpty`, otherwise\n * it passes the array to `onNonEmpty` and returns the result.\n *\n * @example\n * import { match } from 'fp-ts/Array'\n * import { pipe } from 'fp-ts/function'\n *\n * const matcher = match(\n *   () => \"No elements\",\n *   (as) => `Found ${as.length} element(s)`\n * );\n * assert.deepStrictEqual(pipe([1, 2, 3, 4], matcher), \"Found 4 element(s)\");\n * assert.deepStrictEqual(pipe([], matcher), \"No elements\");\n *\n * @category pattern matching\n * @since 2.11.0\n */\nexport var match = matchW;\n/**\n * Less strict version of [`matchLeft`](#matchleft). It will work when `onEmpty` and\n * `onNonEmpty` have different return types.\n *\n * @example\n * import { matchLeftW } from 'fp-ts/Array'\n *\n * const f = matchLeftW(\n *   () => 0,\n *   (head: string, tail: string[]) => `Found \"${head}\" followed by ${tail.length} elements`\n * );\n * assert.strictEqual(f([\"a\", \"b\", \"c\"]), 'Found \"a\" followed by 2 elements');\n * assert.strictEqual(f([]), 0);\n *\n * @category pattern matching\n * @since 2.11.0\n */\nexport var matchLeftW = function (onEmpty, onNonEmpty) {\n    return function (as) {\n        return isNonEmpty(as) ? onNonEmpty(NEA.head(as), NEA.tail(as)) : onEmpty();\n    };\n};\n/**\n * Takes an array, if the array is empty it returns the result of `onEmpty`, otherwise\n * it passes the array to `onNonEmpty` broken into its first element and remaining elements.\n *\n * @example\n * import { matchLeft } from 'fp-ts/Array'\n *\n * const len: <A>(as: Array<A>) => number = matchLeft(() => 0, (_, tail) => 1 + len(tail))\n * assert.strictEqual(len([1, 2, 3]), 3)\n *\n * @category pattern matching\n * @since 2.10.0\n */\nexport var matchLeft = matchLeftW;\n/**\n * Alias of [`matchLeft`](#matchleft).\n *\n * @category pattern matching\n * @since 2.0.0\n */\nexport var foldLeft = matchLeft;\n/**\n * Less strict version of [`matchRight`](#matchright). It will work when `onEmpty` and\n * `onNonEmpty` have different return types.\n *\n * @example\n * import { matchRightW } from 'fp-ts/Array'\n *\n * const f = matchRightW(\n *   () => 0,\n *   (head: string[], tail: string) => `Found ${head.length} elements folllowed by \"${tail}\"`\n * );\n * assert.strictEqual(f([\"a\", \"b\", \"c\"]), 'Found 2 elements folllowed by \"c\"');\n * assert.strictEqual(f([]), 0);\n *\n * @category pattern matching\n * @since 2.11.0\n */\nexport var matchRightW = function (onEmpty, onNonEmpty) {\n    return function (as) {\n        return isNonEmpty(as) ? onNonEmpty(NEA.init(as), NEA.last(as)) : onEmpty();\n    };\n};\n/**\n * Takes an array, if the array is empty it returns the result of `onEmpty`, otherwise\n * it passes the array to `onNonEmpty` broken  into its initial elements and the last element.\n *\n * @example\n * import { matchRight } from 'fp-ts/Array'\n *\n * const len: <A>(as: Array<A>) => number = matchRight(\n *   () => 0,\n *   (head, _) => 1 + len(head)\n * );\n * assert.strictEqual(len([1, 2, 3]), 3);\n *\n * @category pattern matching\n * @since 2.10.0\n */\nexport var matchRight = matchRightW;\n/**\n * Alias of [`matchRight`](#matchright).\n *\n * @category pattern matching\n * @since 2.0.0\n */\nexport var foldRight = matchRight;\n// -------------------------------------------------------------------------------------\n// combinators\n// -------------------------------------------------------------------------------------\n/**\n * Same as [`chain`](#chain), but passing also the index to the iterating function.\n *\n * @example\n * import { chainWithIndex, replicate } from 'fp-ts/Array'\n * import { pipe } from 'fp-ts/function'\n *\n * const f = (index: number, x: string) => replicate(2, `${x}${index}`);\n * assert.deepStrictEqual(pipe([\"a\", \"b\", \"c\"], chainWithIndex(f)), [\"a0\", \"a0\", \"b1\", \"b1\", \"c2\", \"c2\"]);\n *\n * @category sequencing\n * @since 2.7.0\n */\nexport var chainWithIndex = function (f) {\n    return function (as) {\n        var out = [];\n        for (var i = 0; i < as.length; i++) {\n            var bs = f(i, as[i]);\n            for (var j = 0; j < bs.length; j++) {\n                out.push(bs[j]);\n            }\n        }\n        return out;\n    };\n};\n/**\n * Same as `reduce` but it carries over the intermediate steps\n *\n * @example\n * import { scanLeft } from 'fp-ts/Array'\n *\n * assert.deepStrictEqual(scanLeft(10, (b, a: number) => b - a)([1, 2, 3]), [10, 9, 7, 4])\n *\n * @since 2.0.0\n */\nexport var scanLeft = function (b, f) {\n    return function (as) {\n        var len = as.length;\n        var out = new Array(len + 1);\n        out[0] = b;\n        for (var i = 0; i < len; i++) {\n            out[i + 1] = f(out[i], as[i]);\n        }\n        return out;\n    };\n};\n/**\n * Fold an array from the right, keeping all intermediate results instead of only the final result\n *\n * @example\n * import { scanRight } from 'fp-ts/Array'\n *\n * assert.deepStrictEqual(scanRight(10, (a: number, b) => b - a)([1, 2, 3]), [4, 5, 7, 10])\n *\n * @since 2.0.0\n */\nexport var scanRight = function (b, f) {\n    return function (as) {\n        var len = as.length;\n        var out = new Array(len + 1);\n        out[len] = b;\n        for (var i = len - 1; i >= 0; i--) {\n            out[i] = f(as[i], out[i + 1]);\n        }\n        return out;\n    };\n};\n/**\n * Calculate the number of elements in a `Array`.\n *\n * @example\n * import { size } from 'fp-ts/Array'\n *\n * assert.strictEqual(size([\"a\",\"b\",\"c\"]),3)\n *\n * @since 2.10.0\n */\nexport var size = function (as) { return as.length; };\n/**\n * Test whether an array contains a particular index\n *\n * @example\n * import { isOutOfBound } from 'fp-ts/Array'\n *\n * assert.strictEqual(isOutOfBound(1,[\"a\",\"b\",\"c\"]),false)\n * assert.strictEqual(isOutOfBound(-1,[\"a\",\"b\",\"c\"]),true)\n * assert.strictEqual(isOutOfBound(3,[\"a\",\"b\",\"c\"]),true)\n *\n * @since 2.0.0\n */\nexport var isOutOfBound = NEA.isOutOfBound;\n// TODO: remove non-curried overloading in v3\n/**\n * This function provides a safe way to read a value at a particular index from an array.\n * It returns a `none` if the index is out of bounds, and a `some` of the element if the\n * index is valid.\n *\n * @example\n * import { lookup } from 'fp-ts/Array'\n * import { some, none } from 'fp-ts/Option'\n * import { pipe } from 'fp-ts/function'\n *\n * assert.deepStrictEqual(pipe([1, 2, 3], lookup(1)), some(2))\n * assert.deepStrictEqual(pipe([1, 2, 3], lookup(3)), none)\n *\n * @since 2.0.0\n */\nexport var lookup = RA.lookup;\n/**\n * Get the first element in an array, or `None` if the array is empty\n *\n * @example\n * import { head } from 'fp-ts/Array'\n * import { some, none } from 'fp-ts/Option'\n *\n * assert.deepStrictEqual(head([1, 2, 3]), some(1))\n * assert.deepStrictEqual(head([]), none)\n *\n * @since 2.0.0\n */\nexport var head = RA.head;\n/**\n * Get the last element in an array, or `None` if the array is empty\n *\n * @example\n * import { last } from 'fp-ts/Array'\n * import { some, none } from 'fp-ts/Option'\n *\n * assert.deepStrictEqual(last([1, 2, 3]), some(3))\n * assert.deepStrictEqual(last([]), none)\n *\n * @since 2.0.0\n */\nexport var last = RA.last;\n/**\n * Get all but the first element of an array, creating a new array, or `None` if the array is empty\n *\n * @example\n * import { tail } from 'fp-ts/Array'\n * import { some, none } from 'fp-ts/Option'\n *\n * assert.deepStrictEqual(tail([1, 2, 3]), some([2, 3]))\n * assert.deepStrictEqual(tail([]), none)\n *\n * @since 2.0.0\n */\nexport var tail = function (as) { return (isNonEmpty(as) ? _.some(NEA.tail(as)) : _.none); };\n/**\n * Get all but the last element of an array, creating a new array, or `None` if the array is empty\n *\n * @example\n * import { init } from 'fp-ts/Array'\n * import { some, none } from 'fp-ts/Option'\n *\n * assert.deepStrictEqual(init([1, 2, 3]), some([1, 2]))\n * assert.deepStrictEqual(init([]), none)\n *\n * @since 2.0.0\n */\nexport var init = function (as) { return (isNonEmpty(as) ? _.some(NEA.init(as)) : _.none); };\n/**\n * Keep only a max number of elements from the start of an `Array`, creating a new `Array`.\n *\n * **Note**. `n` is normalized to a non negative integer.\n *\n * @example\n * import { takeLeft } from 'fp-ts/Array'\n *\n * assert.deepStrictEqual(takeLeft(2)([1, 2, 3, 4, 5]), [1, 2]);\n * assert.deepStrictEqual(takeLeft(7)([1, 2, 3, 4, 5]), [1, 2, 3, 4, 5]);\n * assert.deepStrictEqual(takeLeft(0)([1, 2, 3, 4, 5]), []);\n * assert.deepStrictEqual(takeLeft(-1)([1, 2, 3, 4, 5]), [1, 2, 3, 4, 5]);\n *\n * @since 2.0.0\n */\nexport var takeLeft = function (n) {\n    return function (as) {\n        return isOutOfBound(n, as) ? copy(as) : as.slice(0, n);\n    };\n};\n/**\n * Keep only a max number of elements from the end of an `Array`, creating a new `Array`.\n *\n * **Note**. `n` is normalized to a non negative integer.\n *\n * @example\n * import { takeRight } from 'fp-ts/Array'\n *\n * assert.deepStrictEqual(takeRight(2)([1, 2, 3, 4, 5]), [4, 5]);\n * assert.deepStrictEqual(takeRight(7)([1, 2, 3, 4, 5]), [1, 2, 3, 4, 5]);\n * assert.deepStrictEqual(takeRight(0)([1, 2, 3, 4, 5]), []);\n * assert.deepStrictEqual(takeRight(-1)([1, 2, 3, 4, 5]), [1, 2, 3, 4, 5]);\n *\n * @since 2.0.0\n */\nexport var takeRight = function (n) {\n    return function (as) {\n        return isOutOfBound(n, as) ? copy(as) : n === 0 ? [] : as.slice(-n);\n    };\n};\nexport function takeLeftWhile(predicate) {\n    return function (as) {\n        var out = [];\n        for (var _i = 0, as_1 = as; _i < as_1.length; _i++) {\n            var a = as_1[_i];\n            if (!predicate(a)) {\n                break;\n            }\n            out.push(a);\n        }\n        return out;\n    };\n}\nvar spanLeftIndex = function (as, predicate) {\n    var l = as.length;\n    var i = 0;\n    for (; i < l; i++) {\n        if (!predicate(as[i])) {\n            break;\n        }\n    }\n    return i;\n};\nexport function spanLeft(predicate) {\n    return function (as) {\n        var _a = splitAt(spanLeftIndex(as, predicate))(as), init = _a[0], rest = _a[1];\n        return { init: init, rest: rest };\n    };\n}\n/**\n * Creates a new `Array` which is a copy of the input dropping a max number of elements from the start.\n *\n * **Note**. `n` is normalized to a non negative integer.\n *\n * @example\n * import { dropLeft } from 'fp-ts/Array'\n *\n * assert.deepStrictEqual(dropLeft(2)([1, 2, 3]), [3]);\n * assert.deepStrictEqual(dropLeft(5)([1, 2, 3]), []);\n * assert.deepStrictEqual(dropLeft(0)([1, 2, 3]), [1, 2, 3]);\n * assert.deepStrictEqual(dropLeft(-2)([1, 2, 3]), [1, 2, 3]);\n *\n * @since 2.0.0\n */\nexport var dropLeft = function (n) {\n    return function (as) {\n        return n <= 0 || isEmpty(as) ? copy(as) : n >= as.length ? [] : as.slice(n, as.length);\n    };\n};\n/**\n * Creates a new `Array` which is a copy of the input dropping a max number of elements from the end.\n *\n * **Note**. `n` is normalized to a non negative integer.\n *\n * @example\n * import { dropRight } from 'fp-ts/Array'\n *\n * assert.deepStrictEqual(dropRight(2)([1, 2, 3]), [1]);\n * assert.deepStrictEqual(dropRight(5)([1, 2, 3]), []);\n * assert.deepStrictEqual(dropRight(0)([1, 2, 3]), [1, 2, 3]);\n * assert.deepStrictEqual(dropRight(-2)([1, 2, 3]), [1, 2, 3]);\n *\n * @since 2.0.0\n */\nexport var dropRight = function (n) {\n    return function (as) {\n        return n <= 0 || isEmpty(as) ? copy(as) : n >= as.length ? [] : as.slice(0, as.length - n);\n    };\n};\nexport function dropLeftWhile(predicate) {\n    return function (as) { return as.slice(spanLeftIndex(as, predicate)); };\n}\n/**\n * `findIndex` returns an `Option` containing the first index for which a predicate holds.\n * It returns `None` if no element satisfies the predicate.\n * Similar to [`findFirst`](#findFirst) but returning the index instead of the element.\n *\n * @example\n * import { findIndex } from 'fp-ts/Array'\n * import { some, none } from 'fp-ts/Option'\n *\n * assert.deepStrictEqual(findIndex((n: number) => n === 2)([1, 2, 3]), some(1))\n * assert.deepStrictEqual(findIndex((n: number) => n === 2)([]), none)\n *\n * @since 2.0.0\n */\nexport var findIndex = RA.findIndex;\nexport function findFirst(predicate) {\n    return RA.findFirst(predicate);\n}\n/**\n * Given a selector function which takes an element and returns an option,\n * this function applies the selector to each element of the array and\n * returns the first `Some` result. Otherwise it returns `None`.\n *\n * @example\n * import { findFirstMap } from 'fp-ts/Array'\n * import { some, none } from 'fp-ts/Option'\n *\n * interface Person {\n *   readonly name: string;\n *   readonly age: number;\n * }\n *\n * const persons: Array<Person> = [\n *   { name: \"John\", age: 16 },\n *   { name: \"Mary\", age: 45 },\n *   { name: \"Joey\", age: 28 },\n * ];\n *\n * const nameOfPersonAbove18 = (p: Person) => (p.age <= 18 ? none : some(p.name));\n * const nameOfPersonAbove70 = (p: Person) => (p.age <= 70 ? none : some(p.name));\n * assert.deepStrictEqual(findFirstMap(nameOfPersonAbove18)(persons), some(\"Mary\"));\n * assert.deepStrictEqual(findFirstMap(nameOfPersonAbove70)(persons), none);\n *\n * @since 2.0.0\n */\nexport var findFirstMap = RA.findFirstMap;\nexport function findLast(predicate) {\n    return RA.findLast(predicate);\n}\n/**\n * Given a selector function which takes an element and returns an option,\n * this function applies the selector to each element of the array starting from the\n * end and returns the last `Some` result. Otherwise it returns `None`.\n *\n * @example\n * import { findLastMap } from 'fp-ts/Array'\n * import { some, none } from 'fp-ts/Option'\n *\n * interface Person {\n *   readonly name: string;\n *   readonly age: number;\n * }\n *\n * const persons: Array<Person> = [\n *   { name: \"John\", age: 16 },\n *   { name: \"Mary\", age: 45 },\n *   { name: \"Joey\", age: 28 },\n * ];\n *\n * const nameOfPersonAbove18 = (p: Person) => (p.age <= 18 ? none : some(p.name));\n * const nameOfPersonAbove70 = (p: Person) => (p.age <= 70 ? none : some(p.name));\n * assert.deepStrictEqual(findLastMap(nameOfPersonAbove18)(persons), some(\"Joey\"));\n * assert.deepStrictEqual(findLastMap(nameOfPersonAbove70)(persons), none);\n *\n * @since 2.0.0\n */\nexport var findLastMap = RA.findLastMap;\n/**\n * Returns the index of the last element of the list which matches the predicate.\n * It returns an `Option` containing the index or `None` if not found.\n *\n * @example\n * import { findLastIndex } from 'fp-ts/Array'\n * import { some, none } from 'fp-ts/Option'\n *\n * interface X {\n *   readonly a: number\n *   readonly b: number\n * }\n * const xs: Array<X> = [{ a: 1, b: 0 }, { a: 1, b: 1 }]\n * assert.deepStrictEqual(findLastIndex((x: { readonly a: number }) => x.a === 1)(xs), some(1))\n * assert.deepStrictEqual(findLastIndex((x: { readonly a: number }) => x.a === 4)(xs), none)\n *\n * @since 2.0.0\n */\nexport var findLastIndex = RA.findLastIndex;\n/**\n * This function takes an array and makes a new array containing the same elements.\n *\n * @since 2.0.0\n */\nexport var copy = function (as) { return as.slice(); };\n/**\n * Insert an element at the specified index, creating a new array,\n * or returning `None` if the index is out of bounds.\n *\n * @example\n * import { insertAt } from 'fp-ts/Array'\n * import { some } from 'fp-ts/Option'\n *\n * assert.deepStrictEqual(insertAt(2, 5)([1, 2, 3, 4]), some([1, 2, 5, 3, 4]))\n *\n * @since 2.0.0\n */\nexport var insertAt = function (i, a) {\n    return function (as) {\n        return i < 0 || i > as.length ? _.none : _.some(unsafeInsertAt(i, a, as));\n    };\n};\n/**\n * Change the element at the specified index, creating a new array,\n * or returning `None` if the index is out of bounds.\n *\n * @example\n * import { updateAt } from 'fp-ts/Array'\n * import { some, none } from 'fp-ts/Option'\n *\n * assert.deepStrictEqual(updateAt(1, 1)([1, 2, 3]), some([1, 1, 3]))\n * assert.deepStrictEqual(updateAt(1, 1)([]), none)\n *\n * @since 2.0.0\n */\nexport var updateAt = function (i, a) { return modifyAt(i, function () { return a; }); };\n/**\n * Delete the element at the specified index, creating a new array, or returning `None` if the index is out of bounds.\n *\n * @example\n * import { deleteAt } from 'fp-ts/Array'\n * import { some, none } from 'fp-ts/Option'\n *\n * assert.deepStrictEqual(deleteAt(0)([1, 2, 3]), some([2, 3]))\n * assert.deepStrictEqual(deleteAt(1)([]), none)\n *\n * @since 2.0.0\n */\nexport var deleteAt = function (i) {\n    return function (as) {\n        return isOutOfBound(i, as) ? _.none : _.some(unsafeDeleteAt(i, as));\n    };\n};\n/**\n * Apply a function to the element at the specified index, creating a new array, or returning `None` if the index is out\n * of bounds.\n *\n * @example\n * import { modifyAt } from 'fp-ts/Array'\n * import { some, none } from 'fp-ts/Option'\n *\n * const double = (x: number): number => x * 2\n * assert.deepStrictEqual(modifyAt(1, double)([1, 2, 3]), some([1, 4, 3]))\n * assert.deepStrictEqual(modifyAt(1, double)([]), none)\n *\n * @since 2.0.0\n */\nexport var modifyAt = function (i, f) {\n    return function (as) {\n        return isOutOfBound(i, as) ? _.none : _.some(unsafeUpdateAt(i, f(as[i]), as));\n    };\n};\n/**\n * Reverse an array, creating a new array\n *\n * @example\n * import { reverse } from 'fp-ts/Array'\n *\n * assert.deepStrictEqual(reverse([1, 2, 3]), [3, 2, 1])\n *\n * @since 2.0.0\n */\nexport var reverse = function (as) { return (isEmpty(as) ? [] : as.slice().reverse()); };\n/**\n * Takes an `Array` of `Either` and produces a new `Array` containing\n * the values of all the `Right` elements in the same order.\n *\n * @example\n * import { rights } from 'fp-ts/Array'\n * import { right, left } from 'fp-ts/Either'\n *\n * assert.deepStrictEqual(rights([right(1), left('foo'), right(2)]), [1, 2])\n *\n * @since 2.0.0\n */\nexport var rights = function (as) {\n    var r = [];\n    for (var i = 0; i < as.length; i++) {\n        var a = as[i];\n        if (a._tag === 'Right') {\n            r.push(a.right);\n        }\n    }\n    return r;\n};\n/**\n * Takes an `Array` of `Either` and produces a new `Array` containing\n * the values of all the `Left` elements in the same order.\n *\n * @example\n * import { lefts } from 'fp-ts/Array'\n * import { left, right } from 'fp-ts/Either'\n *\n * assert.deepStrictEqual(lefts([right(1), left('foo'), right(2)]), ['foo'])\n *\n * @since 2.0.0\n */\nexport var lefts = function (as) {\n    var r = [];\n    for (var i = 0; i < as.length; i++) {\n        var a = as[i];\n        if (a._tag === 'Left') {\n            r.push(a.left);\n        }\n    }\n    return r;\n};\n/**\n * Sort the elements of an array in increasing order, creating a new array\n *\n * @example\n * import { sort } from 'fp-ts/Array'\n * import * as N from 'fp-ts/number'\n *\n * assert.deepStrictEqual(sort(N.Ord)([3, 2, 1]), [1, 2, 3])\n *\n * @since 2.0.0\n */\nexport var sort = function (O) {\n    return function (as) {\n        return as.length <= 1 ? copy(as) : as.slice().sort(O.compare);\n    };\n};\n/**\n * Apply a function to pairs of elements at the same index in two arrays, collecting the results in a new array. If one\n * input array is short, excess elements of the longer array are discarded.\n *\n * @example\n * import { zipWith } from 'fp-ts/Array'\n *\n * assert.deepStrictEqual(zipWith([1, 2, 3], ['a', 'b', 'c', 'd'], (n, s) => s + n), ['a1', 'b2', 'c3'])\n *\n * @since 2.0.0\n */\nexport var zipWith = function (fa, fb, f) {\n    var fc = [];\n    var len = Math.min(fa.length, fb.length);\n    for (var i = 0; i < len; i++) {\n        fc[i] = f(fa[i], fb[i]);\n    }\n    return fc;\n};\nexport function zip(as, bs) {\n    if (bs === undefined) {\n        return function (bs) { return zip(bs, as); };\n    }\n    return zipWith(as, bs, function (a, b) { return [a, b]; });\n}\n/**\n * The function is reverse of `zip`. Takes an array of pairs and return two corresponding arrays\n *\n * @example\n * import { unzip } from 'fp-ts/Array'\n *\n * assert.deepStrictEqual(unzip([[1, 'a'], [2, 'b'], [3, 'c']]), [[1, 2, 3], ['a', 'b', 'c']])\n *\n * @since 2.0.0\n */\nexport var unzip = function (as) {\n    var fa = [];\n    var fb = [];\n    for (var i = 0; i < as.length; i++) {\n        fa[i] = as[i][0];\n        fb[i] = as[i][1];\n    }\n    return [fa, fb];\n};\n/**\n * Creates a new `Array`, prepending an element to every member of the input `Array`.\n *\n * @example\n * import { prependAll } from 'fp-ts/Array'\n *\n * assert.deepStrictEqual(prependAll(9)([1, 2, 3, 4]), [9, 1, 9, 2, 9, 3, 9, 4])\n *\n * @since 2.10.0\n */\nexport var prependAll = function (middle) {\n    var f = NEA.prependAll(middle);\n    return function (as) { return (isNonEmpty(as) ? f(as) : []); };\n};\n/**\n * Creates a new `Array` placing an element in between members of the input `Array`.\n *\n * @example\n * import { intersperse } from 'fp-ts/Array'\n *\n * assert.deepStrictEqual(intersperse(9)([1, 2, 3, 4]), [1, 9, 2, 9, 3, 9, 4])\n *\n * @since 2.9.0\n */\nexport var intersperse = function (middle) {\n    var f = NEA.intersperse(middle);\n    return function (as) { return (isNonEmpty(as) ? f(as) : copy(as)); };\n};\n/**\n * Creates a new `Array` rotating the input `Array` by `n` steps.\n *\n * @example\n * import { rotate } from 'fp-ts/Array'\n *\n * assert.deepStrictEqual(rotate(2)([1, 2, 3, 4, 5]), [4, 5, 1, 2, 3])\n *\n * @since 2.0.0\n */\nexport var rotate = function (n) {\n    var f = NEA.rotate(n);\n    return function (as) { return (isNonEmpty(as) ? f(as) : copy(as)); };\n};\n// TODO: remove non-curried overloading in v3\n/**\n * Test if a value is a member of an `Array`. Takes a `Eq<A>` as a single\n * argument which returns the function to use to search for a value of type `A` in\n * an `Array<A>`.\n *\n * @example\n * import { elem } from 'fp-ts/Array'\n * import * as N from 'fp-ts/number'\n * import { pipe } from 'fp-ts/function'\n *\n * assert.strictEqual(pipe([1, 2, 3], elem(N.Eq)(2)), true)\n * assert.strictEqual(pipe([1, 2, 3], elem(N.Eq)(0)), false)\n *\n * @since 2.0.0\n */\nexport var elem = RA.elem;\n/**\n * Creates a new `Array` removing duplicate elements, keeping the first occurrence of an element,\n * based on a `Eq<A>`.\n *\n * @example\n * import { uniq } from 'fp-ts/Array'\n * import * as N from 'fp-ts/number'\n *\n * assert.deepStrictEqual(uniq(N.Eq)([1, 2, 1]), [1, 2])\n *\n * @since 2.0.0\n */\nexport var uniq = function (E) {\n    var f = NEA.uniq(E);\n    return function (as) { return (isNonEmpty(as) ? f(as) : copy(as)); };\n};\n/**\n * Sort the elements of an array in increasing order, where elements are compared using first `ords[0]`, then `ords[1]`,\n * etc...\n *\n * @example\n * import { sortBy } from 'fp-ts/Array'\n * import { contramap } from 'fp-ts/Ord'\n * import * as S from 'fp-ts/string'\n * import * as N from 'fp-ts/number'\n * import { pipe } from 'fp-ts/function'\n *\n * interface Person {\n *   readonly name: string\n *   readonly age: number\n * }\n * const byName = pipe(S.Ord, contramap((p: Person) => p.name))\n * const byAge = pipe(N.Ord, contramap((p: Person) => p.age))\n *\n * const sortByNameByAge = sortBy([byName, byAge])\n *\n * const persons = [{ name: 'a', age: 1 }, { name: 'b', age: 3 }, { name: 'c', age: 2 }, { name: 'b', age: 2 }]\n * assert.deepStrictEqual(sortByNameByAge(persons), [\n *   { name: 'a', age: 1 },\n *   { name: 'b', age: 2 },\n *   { name: 'b', age: 3 },\n *   { name: 'c', age: 2 }\n * ])\n *\n * @since 2.0.0\n */\nexport var sortBy = function (ords) {\n    var f = NEA.sortBy(ords);\n    return function (as) { return (isNonEmpty(as) ? f(as) : copy(as)); };\n};\n/**\n * A useful recursion pattern for processing an array to produce a new array, often used for \"chopping\" up the input\n * array. Typically chop is called with some function that will consume an initial prefix of the array and produce a\n * value and the rest of the array.\n *\n * @example\n * import { Eq } from 'fp-ts/Eq'\n * import * as A from 'fp-ts/Array'\n * import * as N from 'fp-ts/number'\n * import { pipe } from 'fp-ts/function'\n *\n * const group = <A>(S: Eq<A>): ((as: Array<A>) => Array<Array<A>>) => {\n *   return A.chop(as => {\n *     const { init, rest } = pipe(as, A.spanLeft((a: A) => S.equals(a, as[0])))\n *     return [init, rest]\n *   })\n * }\n * assert.deepStrictEqual(group(N.Eq)([1, 1, 2, 3, 3, 4]), [[1, 1], [2], [3, 3], [4]])\n *\n * @since 2.0.0\n */\nexport var chop = function (f) {\n    var g = NEA.chop(f);\n    return function (as) { return (isNonEmpty(as) ? g(as) : []); };\n};\n/**\n * Splits an `Array` into two pieces, the first piece has max `n` elements.\n *\n * @example\n * import { splitAt } from 'fp-ts/Array'\n *\n * assert.deepStrictEqual(splitAt(2)([1, 2, 3, 4, 5]), [[1, 2], [3, 4, 5]])\n *\n * @since 2.0.0\n */\nexport var splitAt = function (n) {\n    return function (as) {\n        return n >= 1 && isNonEmpty(as) ? NEA.splitAt(n)(as) : isEmpty(as) ? [copy(as), []] : [[], copy(as)];\n    };\n};\n/**\n * Splits an array into length-`n` pieces. The last piece will be shorter if `n` does not evenly divide the length of\n * the array. Note that `chunksOf(n)([])` is `[]`, not `[[]]`. This is intentional, and is consistent with a recursive\n * definition of `chunksOf`; it satisfies the property that\n *\n * ```ts\n * chunksOf(n)(xs).concat(chunksOf(n)(ys)) == chunksOf(n)(xs.concat(ys)))\n * ```\n *\n * whenever `n` evenly divides the length of `xs`.\n *\n * @example\n * import { chunksOf } from 'fp-ts/Array'\n *\n * assert.deepStrictEqual(chunksOf(2)([1, 2, 3, 4, 5]), [[1, 2], [3, 4], [5]])\n *\n * @since 2.0.0\n */\nexport var chunksOf = function (n) {\n    var f = NEA.chunksOf(n);\n    return function (as) { return (isNonEmpty(as) ? f(as) : []); };\n};\n/**\n * @category lifting\n * @since 2.11.0\n */\nexport var fromOptionK = function (f) {\n    return function () {\n        var a = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            a[_i] = arguments[_i];\n        }\n        return fromOption(f.apply(void 0, a));\n    };\n};\nexport function comprehension(input, f, g) {\n    if (g === void 0) { g = function () { return true; }; }\n    var go = function (scope, input) {\n        return isNonEmpty(input)\n            ? flatMap(NEA.head(input), function (a) { return go(pipe(scope, append(a)), NEA.tail(input)); })\n            : g.apply(void 0, scope) ? [f.apply(void 0, scope)]\n                : [];\n    };\n    return go([], input);\n}\n/**\n * @since 2.11.0\n */\nexport var concatW = function (second) {\n    return function (first) {\n        return isEmpty(first) ? copy(second) : isEmpty(second) ? copy(first) : first.concat(second);\n    };\n};\n/**\n * @since 2.11.0\n */\nexport var concat = concatW;\nexport function union(E) {\n    var unionE = NEA.union(E);\n    return function (first, second) {\n        if (second === undefined) {\n            var unionE_1 = union(E);\n            return function (second) { return unionE_1(second, first); };\n        }\n        return isNonEmpty(first) && isNonEmpty(second)\n            ? unionE(second)(first)\n            : isNonEmpty(first)\n                ? copy(first)\n                : copy(second);\n    };\n}\nexport function intersection(E) {\n    var elemE = elem(E);\n    return function (xs, ys) {\n        if (ys === undefined) {\n            var intersectionE_1 = intersection(E);\n            return function (ys) { return intersectionE_1(ys, xs); };\n        }\n        return xs.filter(function (a) { return elemE(a, ys); });\n    };\n}\nexport function difference(E) {\n    var elemE = elem(E);\n    return function (xs, ys) {\n        if (ys === undefined) {\n            var differenceE_1 = difference(E);\n            return function (ys) { return differenceE_1(ys, xs); };\n        }\n        return xs.filter(function (a) { return !elemE(a, ys); });\n    };\n}\nvar _map = function (fa, f) { return pipe(fa, map(f)); };\n/* istanbul ignore next */\nvar _mapWithIndex = function (fa, f) { return pipe(fa, mapWithIndex(f)); };\nvar _ap = function (fab, fa) { return pipe(fab, ap(fa)); };\n/* istanbul ignore next */\nvar _filter = function (fa, predicate) { return pipe(fa, filter(predicate)); };\n/* istanbul ignore next */\nvar _filterMap = function (fa, f) { return pipe(fa, filterMap(f)); };\n/* istanbul ignore next */\nvar _partition = function (fa, predicate) {\n    return pipe(fa, partition(predicate));\n};\n/* istanbul ignore next */\nvar _partitionMap = function (fa, f) { return pipe(fa, partitionMap(f)); };\n/* istanbul ignore next */\nvar _partitionWithIndex = function (fa, predicateWithIndex) { return pipe(fa, partitionWithIndex(predicateWithIndex)); };\n/* istanbul ignore next */\nvar _partitionMapWithIndex = function (fa, f) { return pipe(fa, partitionMapWithIndex(f)); };\n/* istanbul ignore next */\nvar _alt = function (fa, that) { return pipe(fa, alt(that)); };\nvar _reduce = function (fa, b, f) { return pipe(fa, reduce(b, f)); };\n/* istanbul ignore next */\nvar _foldMap = function (M) {\n    var foldMapM = foldMap(M);\n    return function (fa, f) { return pipe(fa, foldMapM(f)); };\n};\n/* istanbul ignore next */\nvar _reduceRight = function (fa, b, f) { return pipe(fa, reduceRight(b, f)); };\n/* istanbul ignore next */\nvar _reduceWithIndex = function (fa, b, f) {\n    return pipe(fa, reduceWithIndex(b, f));\n};\n/* istanbul ignore next */\nvar _foldMapWithIndex = function (M) {\n    var foldMapWithIndexM = foldMapWithIndex(M);\n    return function (fa, f) { return pipe(fa, foldMapWithIndexM(f)); };\n};\n/* istanbul ignore next */\nvar _reduceRightWithIndex = function (fa, b, f) {\n    return pipe(fa, reduceRightWithIndex(b, f));\n};\n/* istanbul ignore next */\nvar _filterMapWithIndex = function (fa, f) { return pipe(fa, filterMapWithIndex(f)); };\n/* istanbul ignore next */\nvar _filterWithIndex = function (fa, predicateWithIndex) { return pipe(fa, filterWithIndex(predicateWithIndex)); };\n/* istanbul ignore next */\nvar _extend = function (fa, f) { return pipe(fa, extend(f)); };\n/* istanbul ignore next */\nvar _traverse = function (F) {\n    var traverseF = traverse(F);\n    return function (ta, f) { return pipe(ta, traverseF(f)); };\n};\n/* istanbul ignore next */\nvar _traverseWithIndex = function (F) {\n    var traverseWithIndexF = traverseWithIndex(F);\n    return function (ta, f) { return pipe(ta, traverseWithIndexF(f)); };\n};\nvar _chainRecDepthFirst = RA._chainRecDepthFirst;\nvar _chainRecBreadthFirst = RA._chainRecBreadthFirst;\n/**\n * Given an element of the base type, `of` builds an `Array` containing just that\n * element of the base type (this is useful for building a `Monad`).\n *\n * @example\n * import { of } from 'fp-ts/Array'\n *\n * assert.deepStrictEqual(of(\"a\"), [\"a\"]);\n *\n * @category constructors\n * @since 2.0.0\n */\nexport var of = NEA.of;\n/**\n * Makes an empty `Array`, useful for building a [`Monoid`](#Monoid)\n *\n * @since 2.7.0\n */\nexport var zero = function () { return []; };\n/**\n * `map` can be used to turn functions `(a: A) => B` into functions `(fa: Array<A>) => Array<B>`.\n * In practice it applies the base function to each element of the array and collects the\n * results in a new array.\n *\n * @example\n * import { map } from 'fp-ts/Array'\n * import { pipe } from 'fp-ts/function'\n *\n * const f = (n: number) => n * 2;\n * assert.deepStrictEqual(pipe([1, 2, 3], map(f)), [2, 4, 6]);\n *\n * @category mapping\n * @since 2.0.0\n */\nexport var map = function (f) { return function (fa) { return fa.map(function (a) { return f(a); }); }; };\n/**\n * @example\n * import { ap, map, of } from 'fp-ts/Array'\n * import { pipe } from 'fp-ts/function'\n *\n * // a curried function with 3 input parameteres\n * const f = (s1: string) => (n: number) => (s2: string) => s1 + n + s2;\n *\n * // let's use `ap` to iterate `f` over an array for each input parameter\n * assert.deepStrictEqual(pipe([\"a\", \"b\"], map(f), ap([1, 2]), ap([\"\", \"\", \"\"])), [\n *   \"a1\", \"a1\", \"a1\",\n *   \"a2\", \"a2\", \"a2\",\n *   \"b1\", \"b1\", \"b1\",\n *   \"b2\", \"b2\", \"b2\",\n * ]);\n *\n * // given Array implements the Applicative interface with the `of` method,\n * // we can write exactly the same thing in a more symmetric way\n * // using `of` on `f` and `ap` on each array in input\n * assert.deepStrictEqual(\n *   pipe(of(f), ap([\"a\", \"b\"]), ap([1, 2]), ap([\"\", \"\", \"\"])),\n *   pipe([\"a\", \"b\"], map(f), ap([1, 2]), ap([\"\", \"\", \"\"]))\n * );\n *\n * @since 2.0.0\n */\nexport var ap = function (fa) {\n    return flatMap(function (f) { return pipe(fa, map(f)); });\n};\n/**\n * Composes computations in sequence, using the return value of one computation to\n * determine the next computation.\n *\n * In other words it takes a function `f` that produces an array from a single element of\n * the base type `A` and returns a new function which applies `f` to each element of the\n * input array (like [`map`](#map)) and, instead of returning an array of arrays, concatenates the\n * results into a single array (like [`flatten`](#flatten)).\n *\n * @example\n * import { flatMap, map, replicate } from 'fp-ts/Array'\n * import { pipe } from 'fp-ts/function'\n *\n * const f = (n: number) => replicate(n, `${n}`);\n * assert.deepStrictEqual(pipe([1, 2, 3], map(f)), [[\"1\"], [\"2\", \"2\"], [\"3\", \"3\", \"3\"]]);\n * assert.deepStrictEqual(pipe([1, 2, 3], flatMap(f)), [\"1\", \"2\", \"2\", \"3\", \"3\", \"3\"]);\n *\n * @category sequencing\n * @since 2.14.0\n */\nexport var flatMap = /*#__PURE__*/ dual(2, function (ma, f) {\n    return pipe(ma, chainWithIndex(function (i, a) { return f(a, i); }));\n});\n/**\n * Takes an array of arrays of `A` and flattens them into an array of `A`\n * by concatenating the elements of each array in order.\n *\n * @example\n * import { flatten } from 'fp-ts/Array'\n *\n * assert.deepStrictEqual(flatten([[\"a\"], [\"b\", \"c\"], [\"d\", \"e\", \"f\"]]), [\"a\", \"b\", \"c\", \"d\", \"e\", \"f\"]);\n *\n * @category sequencing\n * @since 2.5.0\n */\nexport var flatten = /*#__PURE__*/ flatMap(identity);\n/**\n * Same as [`map`](#map), but the iterating function takes both the index and the value\n * of the element.\n *\n * @example\n * import { mapWithIndex } from 'fp-ts/Array'\n * import { pipe } from 'fp-ts/function'\n *\n * const f = (i: number, s: string) => `${s} - ${i}`;\n * assert.deepStrictEqual(pipe([\"a\", \"b\", \"c\"], mapWithIndex(f)), [\"a - 0\", \"b - 1\", \"c - 2\"]);\n *\n * @category mapping\n * @since 2.0.0\n */\nexport var mapWithIndex = function (f) { return function (fa) {\n    return fa.map(function (a, i) { return f(i, a); });\n}; };\n/**\n * Maps an array with an iterating function that takes the index and the value of\n * each element and returns an `Option`. It keeps only the `Some` values discarding\n * the `None`s.\n *\n * Same as [`filterMap`](#filterMap), but with an iterating function which takes also\n * the index as input.\n *\n * @example\n * import { filterMapWithIndex } from 'fp-ts/Array'\n * import { pipe } from 'fp-ts/function'\n * import { option } from \"fp-ts\";\n *\n * const f = (i: number, s: string) => (i % 2 === 1 ? option.some(s.toUpperCase()) : option.none);\n * assert.deepStrictEqual(pipe([\"a\", \"no\", \"neither\", \"b\"], filterMapWithIndex(f)), [\"NO\", \"B\"]);\n *\n * @category filtering\n * @since 2.0.0\n */\nexport var filterMapWithIndex = function (f) {\n    return function (fa) {\n        var out = [];\n        for (var i = 0; i < fa.length; i++) {\n            var optionB = f(i, fa[i]);\n            if (_.isSome(optionB)) {\n                out.push(optionB.value);\n            }\n        }\n        return out;\n    };\n};\n/**\n * Maps an array with an iterating function that returns an `Option`\n * and it keeps only the `Some` values discarding the `None`s.\n *\n * @example\n * import { filterMap } from 'fp-ts/Array'\n * import { pipe } from 'fp-ts/function'\n * import { option } from \"fp-ts\";\n *\n * const f = (s: string) => s.length === 1 ? option.some(s.toUpperCase()) : option.none;\n * assert.deepStrictEqual(pipe([\"a\", \"no\", \"neither\", \"b\"], filterMap(f)), [\"A\", \"B\"]);\n *\n * @category filtering\n * @since 2.0.0\n */\nexport var filterMap = function (f) {\n    return filterMapWithIndex(function (_, a) { return f(a); });\n};\n/**\n * Compact an array of `Option`s discarding the `None` values and\n * keeping the `Some` values. It returns a new array containing the values of\n * the `Some` options.\n *\n * @example\n * import { compact } from 'fp-ts/Array'\n * import { option } from \"fp-ts\";\n *\n * assert.deepStrictEqual(compact([option.some(\"a\"), option.none, option.some(\"b\")]), [\"a\", \"b\"]);\n *\n * @category filtering\n * @since 2.0.0\n */\nexport var compact = /*#__PURE__*/ filterMap(identity);\n/**\n * Separate an array of `Either`s into `Left`s and `Right`s, creating two new arrays:\n * one containing all the left values and one containing all the right values.\n *\n * @example\n * import { separate } from 'fp-ts/Array'\n * import { either } from \"fp-ts\";\n *\n * assert.deepStrictEqual(separate([either.right(\"r1\"), either.left(\"l1\"), either.right(\"r2\")]), {\n *   left: [\"l1\"],\n *   right: [\"r1\", \"r2\"],\n * });\n *\n * @category filtering\n * @since 2.0.0\n */\nexport var separate = function (fa) {\n    var left = [];\n    var right = [];\n    for (var _i = 0, fa_1 = fa; _i < fa_1.length; _i++) {\n        var e = fa_1[_i];\n        if (e._tag === 'Left') {\n            left.push(e.left);\n        }\n        else {\n            right.push(e.right);\n        }\n    }\n    return separated(left, right);\n};\n/**\n * Given an iterating function that is a `Predicate` or a `Refinement`,\n * `filter` creates a new `Array` containing the elements of the original\n * `Array` for which the iterating function is `true`.\n *\n * @example\n * import { filter } from 'fp-ts/Array'\n * import { isString } from \"fp-ts/string\";\n *\n * assert.deepStrictEqual(filter(isString)([\"a\", 1, {}, \"b\", 5]), [\"a\", \"b\"]);\n * assert.deepStrictEqual(filter((x:number) => x > 0)([-3, 1, -2, 5]), [1, 5]);\n *\n * @category filtering\n * @since 2.0.0\n */\nexport var filter = function (predicate) {\n    return function (as) {\n        return as.filter(predicate);\n    };\n};\n/**\n * Given an iterating function that is a `Predicate` or a `Refinement`,\n * `partition` creates two new `Array`s: `right` containing the elements of the original\n * `Array` for which the iterating function is `true`, `left` containing the elements\n * for which it is false.\n *\n * @example\n * import { partition } from 'fp-ts/Array'\n * import { isString } from \"fp-ts/string\";\n *\n * assert.deepStrictEqual(partition(isString)([\"a\", 1, {}, \"b\", 5]), { left: [1, {}, 5], right: [\"a\", \"b\"] });\n * assert.deepStrictEqual(partition((x: number) => x > 0)([-3, 1, -2, 5]), { left: [-3, -2], right: [1, 5] });\n *\n * @category filtering\n * @since 2.0.0\n */\nexport var partition = function (predicate) {\n    return partitionWithIndex(function (_, a) { return predicate(a); });\n};\n/**\n * Same as [`partition`](#partition), but passing also the index to the iterating function.\n *\n * @example\n * import { partitionWithIndex } from 'fp-ts/Array'\n *\n * assert.deepStrictEqual(partitionWithIndex((index, x: number) => index < 3 && x > 0)([-2, 5, 6, 7]), {\n *   left: [-2, 7],\n *   right: [5, 6],\n * });\n *\n * @category filtering\n * @since 2.0.0\n */\nexport var partitionWithIndex = function (predicateWithIndex) {\n    return function (as) {\n        var left = [];\n        var right = [];\n        for (var i = 0; i < as.length; i++) {\n            var b = as[i];\n            if (predicateWithIndex(i, b)) {\n                right.push(b);\n            }\n            else {\n                left.push(b);\n            }\n        }\n        return separated(left, right);\n    };\n};\n/**\n * Given an iterating function that returns an `Either`,\n * `partitionMap` applies the iterating function to each element and it creates two `Array`s:\n * `right` containing the values of `Right` results, `left` containing the values of `Left` results.\n *\n * @example\n * import { partitionMap } from 'fp-ts/Array'\n * import { Either, left, right } from \"fp-ts/Either\";\n *\n * const upperIfString = <B>(x: B): Either<B, string> =>\n *   typeof x === \"string\" ? right(x.toUpperCase()) : left(x);\n * assert.deepStrictEqual(partitionMap(upperIfString)([-2, \"hello\", 6, 7, \"world\"]), {\n *   left: [-2, 6, 7],\n *   right: [ 'HELLO', 'WORLD' ],\n * });\n *\n * @category filtering\n * @since 2.0.0\n */\nexport var partitionMap = function (f) { return partitionMapWithIndex(function (_, a) { return f(a); }); };\n/**\n * Same as [`partitionMap`](#partitionMap), but passing also the index to the iterating function.\n *\n * @example\n * import { partitionMapWithIndex } from 'fp-ts/Array'\n * import { Either, left, right } from \"fp-ts/Either\";\n *\n * const upperIfStringBefore3 = <B>(index: number, x: B): Either<B, string> =>\n *   index < 3 && typeof x === \"string\" ? right(x.toUpperCase()) : left(x);\n * assert.deepStrictEqual(partitionMapWithIndex(upperIfStringBefore3)([-2, \"hello\", 6, 7, \"world\"]), {\n *   left: [-2, 6, 7, \"world\"],\n *   right: [\"HELLO\"],\n * });\n *\n * @category filtering\n * @since 2.0.0\n */\nexport var partitionMapWithIndex = function (f) {\n    return function (fa) {\n        var left = [];\n        var right = [];\n        for (var i = 0; i < fa.length; i++) {\n            var e = f(i, fa[i]);\n            if (e._tag === 'Left') {\n                left.push(e.left);\n            }\n            else {\n                right.push(e.right);\n            }\n        }\n        return separated(left, right);\n    };\n};\n/**\n * Less strict version of [`alt`](#alt).\n *\n * The `W` suffix (short for **W**idening) means that the return types will be merged.\n *\n * @example\n * import * as A from 'fp-ts/Array'\n * import { pipe } from 'fp-ts/function'\n *\n * assert.deepStrictEqual(\n *   pipe(\n *     [1, 2, 3],\n *     A.altW(() => ['a', 'b'])\n *   ),\n *   [1, 2, 3, 'a', 'b']\n * )\n *\n * @category error handling\n * @since 2.9.0\n */\nexport var altW = function (that) {\n    return function (fa) {\n        return fa.concat(that());\n    };\n};\n/**\n * Identifies an associative operation on a type constructor. It is similar to `Semigroup`, except that it applies to\n * types of kind `* -> *`.\n *\n * In case of `Array` concatenates the inputs into a single array.\n *\n * @example\n * import * as A from 'fp-ts/Array'\n * import { pipe } from 'fp-ts/function'\n *\n * assert.deepStrictEqual(\n *   pipe(\n *     [1, 2, 3],\n *     A.alt(() => [4, 5])\n *   ),\n *   [1, 2, 3, 4, 5]\n * )\n *\n * @category error handling\n * @since 2.0.0\n */\nexport var alt = altW;\n/**\n * Same as [`filter`](#filter), but passing also the index to the iterating function.\n *\n * @example\n * import { filterWithIndex } from 'fp-ts/Array';\n *\n * const f = (index: number, x: number) => x > 0 && index <= 2;\n * assert.deepStrictEqual(filterWithIndex(f)([-3, 1, -2, 5]), [1]);\n *\n * @category filtering\n * @since 2.0.0\n */\nexport var filterWithIndex = function (predicateWithIndex) {\n    return function (as) {\n        return as.filter(function (b, i) { return predicateWithIndex(i, b); });\n    };\n};\n/**\n * Given an iterating function that takes `Array<A>` as input, `extend` returns\n * an array containing the results of the iterating function applied to the whole input\n * `Array`, then to the input `Array` without the first element, then to the input\n * `Array` without the first two elements, etc.\n *\n * @example\n * import { extend } from 'fp-ts/Array'\n *\n * const f = (a: string[]) => a.join(\",\");\n * assert.deepStrictEqual(extend(f)([\"a\", \"b\", \"c\"]), [\"a,b,c\", \"b,c\", \"c\"]);\n *\n * @since 2.0.0\n */\nexport var extend = function (f) { return function (wa) {\n    return wa.map(function (_, i) { return f(wa.slice(i)); });\n}; };\n/**\n * `duplicate` returns an array containing the whole input `Array`,\n * then to the input `Array` dropping the first element, then to the input\n * `Array` dropping the first two elements, etc.\n *\n * @example\n * import { duplicate } from 'fp-ts/Array'\n *\n * assert.deepStrictEqual(duplicate([\"a\", \"b\", \"c\"]), [[\"a\", \"b\", \"c\"], [\"b\", \"c\"], [\"c\"]]);\n *\n * @since 2.0.0\n */\nexport var duplicate = /*#__PURE__*/ extend(identity);\n/**\n * Map and fold an `Array`.\n * Map the `Array` passing each value to the iterating function.\n * Then fold the results using the provided `Monoid`.\n *\n * @example\n * import { foldMap } from 'fp-ts/Array'\n *\n * const monoid = { concat: (a: string, b: string) => a + b, empty: \"\" };\n * const f = (s: string) => s.toUpperCase()\n * assert.deepStrictEqual(foldMap(monoid)(f)([\"a\", \"b\", \"c\"]), \"ABC\");\n *\n * @category folding\n * @since 2.0.0\n */\nexport var foldMap = RA.foldMap;\n/**\n * Same as [`foldMap`](#foldMap) but passing also the index to the iterating function.\n *\n * @example\n * import { foldMapWithIndex } from 'fp-ts/Array'\n *\n * const monoid = { concat: (a: string, b: string) => a + b, empty: \"\" };\n * const f = (index:number, s: string) => `${s.toUpperCase()}(${index})`\n * assert.deepStrictEqual(foldMapWithIndex(monoid)(f)([\"a\", \"b\", \"c\"]), \"A(0)B(1)C(2)\");\n *\n * @category folding\n * @since 2.0.0\n */\nexport var foldMapWithIndex = RA.foldMapWithIndex;\n/**\n * Reduces an `Array`.\n *\n * `reduce` executes the supplied iterating function on each element of the array,\n * in order, passing in the element and the return value from the calculation on the preceding element.\n *\n * The first time that the iterating function is called there is no \"return value of the\n * previous calculation\", the initial value is used in its place.\n *\n * @example\n * import { reduce } from 'fp-ts/Array'\n *\n * assert.deepStrictEqual(reduce(5, (acc: number, cur: number) => acc * cur)([2, 3]), 5 * 2 * 3);\n *\n * @category folding\n * @since 2.0.0\n */\nexport var reduce = RA.reduce;\n/**\n * Same as [`reduce`](#reduce) but passing also the index to the iterating function.\n *\n * @example\n * import { reduceWithIndex } from 'fp-ts/Array'\n *\n * const f = (index: number, acc: string, cur: unknown) =>\n *   acc + (typeof cur === \"string\" ? cur.toUpperCase() + index : \"\");\n * assert.deepStrictEqual(reduceWithIndex(\"\", f)([2, \"a\", \"b\", null]), \"A1B2\");\n *\n * @category folding\n * @since 2.0.0\n */\nexport var reduceWithIndex = RA.reduceWithIndex;\n/**\n * Same as [`reduce`](#reduce) but applied from the end to the start.\n *\n * *Note*: the iterating function in this case takes the accumulator as the last argument.\n *\n * @example\n * import { reduceRight } from 'fp-ts/Array'\n *\n * assert.deepStrictEqual(reduceRight(\"\", (cur: string, acc: string) => acc + cur)([\"a\", \"b\", \"c\"]), \"cba\");\n *\n * @category folding\n * @since 2.0.0\n */\nexport var reduceRight = RA.reduceRight;\n/**\n * Same as [`reduceRight`](#reduceRight) but passing also the index to the iterating function.\n *\n * @example\n * import { reduceRightWithIndex } from 'fp-ts/Array'\n *\n * const f = (index: number, cur: unknown, acc: string) =>\n *   acc + (typeof cur === \"string\" ? cur.toUpperCase() + index : \"\");\n * assert.deepStrictEqual(reduceRightWithIndex(\"\", f)([2, \"a\", \"b\", null]), \"B2A1\");\n *\n * @category folding\n * @since 2.0.0\n */\nexport var reduceRightWithIndex = RA.reduceRightWithIndex;\n/**\n * Given an iterating function that returns a `HKT` (higher kinded type), `traverse`\n * applies the iterating function to each element of the `Array` and then [`sequence`](#sequence)-s\n * the results using the provided `Applicative`.\n *\n * E.g. suppose you have an `Array` and you want to format each element with a function\n * that returns a result or an error as `f = (a: A) => Either<Error, B>`, using `traverse`\n * you can apply `f` to all elements and directly obtain as a result an `Either<Error,Array<B>>`\n * i.e. an `Array<B>` if all the results are `B`, or an `Error` if some of the results\n * are `Error`s.\n *\n * @example\n * import { traverse } from 'fp-ts/Array'\n * import { Applicative, left, right } from \"fp-ts/Either\";\n *\n * const f = (x: unknown) =>\n *   typeof x === \"string\" ? right(x.toUpperCase()) : left(new Error(\"not a string\"));\n * assert.deepStrictEqual(traverse(Applicative)(f)([\"a\", \"b\"]), right([\"A\", \"B\"]));\n * assert.deepStrictEqual(traverse(Applicative)(f)([\"a\", 5]), left(new Error(\"not a string\")));\n *\n * @category traversing\n * @since 2.6.3\n */\nexport var traverse = function (F) {\n    var traverseWithIndexF = traverseWithIndex(F);\n    return function (f) { return traverseWithIndexF(function (_, a) { return f(a); }); };\n};\n/**\n * `sequence` takes an `Array` where elements are `HKT<A>` (higher kinded type) and,\n * using an applicative of that `HKT`, returns an `HKT` of `Array<A>`.\n * E.g. it can turn an `Array<Either<Error, string>>` into an `Either<Error, Array<string>>`.\n *\n * `sequence` requires an `Applicative` of the `HKT` you are targeting, e.g. to turn an\n * `Array<Either<E, A>>` into an `Either<E, Array<A>>`, it needs an\n * `Applicative` for `Either`, to to turn an `Array<Option<A>>` into an `Option<Array<A>>`,\n * it needs an `Applicative` for `Option`.\n *\n * @example\n * import { sequence } from 'fp-ts/Array'\n * import { Applicative, left, right } from \"fp-ts/Either\";\n *\n * assert.deepStrictEqual(sequence(Applicative)([right(\"a\"), right(\"b\")]), right([\"a\", \"b\"]));\n * assert.deepStrictEqual(\n *   sequence(Applicative)([right(\"a\"), left(new Error(\"not a string\"))]),\n *   left(new Error(\"not a string\"))\n * );\n *\n * @category traversing\n * @since 2.6.3\n */\nexport var sequence = function (F) {\n    return function (ta) {\n        return _reduce(ta, F.of(zero()), function (fas, fa) {\n            return F.ap(F.map(fas, function (as) { return function (a) { return pipe(as, append(a)); }; }), fa);\n        });\n    };\n};\n/**\n * Same as [`traverse`](#traverse) but passing also the index to the iterating function.\n *\n * @example\n * import { traverseWithIndex } from 'fp-ts/Array'\n * import { Applicative, left, right } from \"fp-ts/Either\";\n *\n * const f = (index:number, x:unknown) =>\n *   typeof x === \"string\" ? right(x.toUpperCase() + index) : left(new Error(\"not a string\"));\n * assert.deepStrictEqual(traverseWithIndex(Applicative)(f)([\"a\", \"b\"]), right([\"A0\", \"B1\"]));\n * assert.deepStrictEqual(traverseWithIndex(Applicative)(f)([\"a\", 5]), left(new Error(\"not a string\")));\n *\n * @category sequencing\n * @since 2.6.3\n */\nexport var traverseWithIndex = function (F) {\n    return function (f) {\n        return reduceWithIndex(F.of(zero()), function (i, fbs, a) {\n            return F.ap(F.map(fbs, function (bs) { return function (b) { return pipe(bs, append(b)); }; }), f(i, a));\n        });\n    };\n};\n/**\n * @category filtering\n * @since 2.6.5\n */\nexport var wither = function (F) {\n    var _witherF = _wither(F);\n    return function (f) { return function (fa) { return _witherF(fa, f); }; };\n};\n/**\n * @category filtering\n * @since 2.6.5\n */\nexport var wilt = function (F) {\n    var _wiltF = _wilt(F);\n    return function (f) { return function (fa) { return _wiltF(fa, f); }; };\n};\n/**\n * `unfold` takes a function `f` which returns an `Option` of a tuple containing an outcome\n * value and an input for the following iteration.\n * `unfold` applies `f` to the initial value `b` and then recursively to the second\n * element of the tuple contained in the returned `option` of the previous\n * calculation until `f` returns `Option.none`.\n *\n * @example\n * import { unfold } from 'fp-ts/Array'\n * import { option } from 'fp-ts'\n *\n * const f = (n: number) => {\n *   if (n <= 0) return option.none;\n *   const returnValue = n * 2;\n *   const inputForNextRound = n - 1;\n *   return option.some([returnValue, inputForNextRound] as const);\n * };\n * assert.deepStrictEqual(unfold(5, f), [10, 8, 6, 4, 2]);\n *\n * @since 2.6.6\n */\nexport var unfold = function (b, f) {\n    var out = [];\n    var bb = b;\n    // eslint-disable-next-line no-constant-condition\n    while (true) {\n        var mt = f(bb);\n        if (_.isSome(mt)) {\n            var _a = mt.value, a = _a[0], b_1 = _a[1];\n            out.push(a);\n            bb = b_1;\n        }\n        else {\n            break;\n        }\n    }\n    return out;\n};\n/**\n * @category type lambdas\n * @since 2.0.0\n */\nexport var URI = 'Array';\n/**\n * `getShow` makes a `Show` for an `Array<A>` from a `Show` for\n * an `A`.\n *\n * @example\n * import { getShow } from 'fp-ts/Array'\n *\n * const numShow = { show: (n: number) => (n >= 0 ? `${n}` : `(${-n})`) };\n * assert.deepStrictEqual(getShow(numShow).show([-2, -1, 0, 1]), \"[(2), (1), 0, 1]\");\n *\n * @category instances\n * @since 2.0.0\n */\nexport var getShow = RA.getShow;\n/**\n * Get a `Semigroup` based on the concatenation of `Array`s.\n * See also [`getMonoid`](#getMonoid).\n *\n * @example\n * import { getSemigroup } from 'fp-ts/Array'\n *\n * const S = getSemigroup<number>();\n * assert.deepStrictEqual(S.concat([1, 2], [2, 3]), [1, 2, 2, 3]);\n *\n * @category instances\n * @since 2.10.0\n */\nexport var getSemigroup = function () { return ({\n    concat: function (first, second) { return first.concat(second); }\n}); };\n/**\n * Returns a `Monoid` for `Array<A>` based on the concatenation of `Array`s.\n *\n * @example\n * import { getMonoid } from 'fp-ts/Array'\n *\n * const M = getMonoid<number>()\n * assert.deepStrictEqual(M.concat([1, 2], [3, 4]), [1, 2, 3, 4])\n *\n * @category instances\n * @since 2.0.0\n */\nexport var getMonoid = function () { return ({\n    concat: getSemigroup().concat,\n    empty: []\n}); };\n/**\n * Derives an `Eq` over the `Array` of a given element type from the `Eq` of that type. The derived `Eq` defines two\n * arrays as equal if all elements of both arrays are compared equal pairwise with the given `E`. In case of arrays of\n * different lengths, the result is non equality.\n *\n * @example\n * import * as S from 'fp-ts/string'\n * import { getEq } from 'fp-ts/Array'\n *\n * const E = getEq(S.Eq)\n * assert.strictEqual(E.equals(['a', 'b'], ['a', 'b']), true)\n * assert.strictEqual(E.equals(['a'], []), false)\n *\n * @category instances\n * @since 2.0.0\n */\nexport var getEq = RA.getEq;\n/**\n * Derives an `Ord` over the `Array` of a given element type from the `Ord` of that type. The ordering between two such\n * arrays is equal to: the first non equal comparison of each arrays elements taken pairwise in increasing order, in\n * case of equality over all the pairwise elements; the longest array is considered the greatest, if both arrays have\n * the same length, the result is equality.\n *\n * @example\n * import { getOrd } from 'fp-ts/Array'\n * import * as S from 'fp-ts/string'\n *\n * const O = getOrd(S.Ord)\n * assert.strictEqual(O.compare(['b'], ['a']), 1)\n * assert.strictEqual(O.compare(['a'], ['a']), 0)\n * assert.strictEqual(O.compare(['a'], ['b']), -1)\n *\n * @category instances\n * @since 2.0.0\n */\nexport var getOrd = RA.getOrd;\n/**\n * Get a `Semigroup` based on the union of the elements of `Array`s.\n * Elements which equal according to the provided `Eq` are included\n * only once in the result.\n * See also [`getUnionMonoid`](#getUnionMonoid).\n *\n * @example\n * import { getUnionSemigroup } from 'fp-ts/Array';\n * import { Eq } from 'fp-ts/number';\n *\n * const S = getUnionSemigroup<number>(Eq);\n * assert.deepStrictEqual(S.concat([1, 2], [2, 3]), [1, 2, 3]);\n *\n * @category instances\n * @since 2.11.0\n */\nexport var getUnionSemigroup = function (E) {\n    var unionE = union(E);\n    return {\n        concat: function (first, second) { return unionE(second)(first); }\n    };\n};\n/**\n * Get a `Monoid` based on the union of the elements of `Array`s.\n * Elements which equal according to the provided `Eq` are included\n * only once in the result.\n *\n * @example\n * import { getUnionMonoid } from 'fp-ts/Array'\n * import { Eq } from 'fp-ts/number';\n *\n * const M = getUnionMonoid<number>(Eq);\n * assert.deepStrictEqual(M.concat([1, 2], [2, 3]), [1, 2, 3]);\n * assert.deepStrictEqual(M.empty,[]);\n *\n * @category instances\n * @since 2.11.0\n */\nexport var getUnionMonoid = function (E) { return ({\n    concat: getUnionSemigroup(E).concat,\n    empty: []\n}); };\n/**\n * Get a `Semigroup` based on the intersection of the elements of `Array`s.\n * Only elements present in the two arrays which are equal according to the\n * provided `Eq` are included in the result.\n *\n * @example\n * import { getIntersectionSemigroup } from 'fp-ts/Array'\n * import { Eq } from 'fp-ts/number';\n *\n * const S = getIntersectionSemigroup<number>(Eq);\n * assert.deepStrictEqual(S.concat([1, 2], [2, 3]), [2]);\n *\n * @category instances\n * @since 2.11.0\n */\nexport var getIntersectionSemigroup = function (E) {\n    var intersectionE = intersection(E);\n    return {\n        concat: function (first, second) { return intersectionE(second)(first); }\n    };\n};\n/**\n * Get a `Magma` for `Array` where the `concat` function is the differnce between\n * the first and the second array, i.e. the result contains all the elements of the\n * first array for which their is no equal element in the second array according\n * to the `Eq` provided.\n *\n *\n * @example\n * import { getDifferenceMagma } from 'fp-ts/Array'\n * import { Eq } from 'fp-ts/number';\n *\n * const S = getDifferenceMagma<number>(Eq);\n * assert.deepStrictEqual(S.concat([1, 2], [2, 3]), [1]);\n *\n * @category instances\n * @since 2.11.0\n */\nexport var getDifferenceMagma = function (E) {\n    var differenceE = difference(E);\n    return {\n        concat: function (first, second) { return differenceE(second)(first); }\n    };\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Functor = {\n    URI: URI,\n    map: _map\n};\n/**\n * Given an input an `Array` of functions, `flap` returns an `Array` containing\n * the results of applying each function to the given input.\n *\n * @example\n * import { flap } from 'fp-ts/Array'\n *\n * const funs = [\n *   (n: number) => `Double: ${n * 2}`,\n *   (n: number) => `Triple: ${n * 3}`,\n *   (n: number) => `Square: ${n * n}`,\n * ];\n * assert.deepStrictEqual(flap(4)(funs), ['Double: 8', 'Triple: 12', 'Square: 16']);\n *\n * @category mapping\n * @since 2.10.0\n */\nexport var flap = /*#__PURE__*/ flap_(Functor);\n/**\n * @category instances\n * @since 2.10.0\n */\nexport var Pointed = {\n    URI: URI,\n    of: of\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var FunctorWithIndex = {\n    URI: URI,\n    map: _map,\n    mapWithIndex: _mapWithIndex\n};\n/**\n * @category instances\n * @since 2.10.0\n */\nexport var Apply = {\n    URI: URI,\n    map: _map,\n    ap: _ap\n};\n/**\n * Combine two effectful actions, keeping only the result of the first.\n *\n * @since 2.5.0\n */\nexport var apFirst = /*#__PURE__*/ apFirst_(Apply);\n/**\n * Combine two effectful actions, keeping only the result of the second.\n *\n * @since 2.5.0\n */\nexport var apSecond = /*#__PURE__*/ apSecond_(Apply);\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Applicative = {\n    URI: URI,\n    map: _map,\n    ap: _ap,\n    of: of\n};\n/**\n * @category instances\n * @since 2.10.0\n */\nexport var Chain = {\n    URI: URI,\n    map: _map,\n    ap: _ap,\n    chain: flatMap\n};\n/**\n * Composes computations in sequence, using the return value of one computation to determine the next computation and\n * keeping only the result of the first.\n *\n * @example\n * import * as A from 'fp-ts/Array'\n * import { pipe } from 'fp-ts/function'\n *\n * assert.deepStrictEqual(\n *   pipe(\n *     [1, 2, 3],\n *     A.chainFirst(() => ['a', 'b'])\n *   ),\n *   [1, 1, 2, 2, 3, 3]\n * )\n * assert.deepStrictEqual(\n *   pipe(\n *     [1, 2, 3],\n *     A.chainFirst(() => [])\n *   ),\n *   []\n * )\n *\n * @category sequencing\n * @since 2.0.0\n */\nexport var chainFirst = \n/*#__PURE__*/ chainFirst_(Chain);\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Monad = {\n    URI: URI,\n    map: _map,\n    ap: _ap,\n    of: of,\n    chain: flatMap\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Unfoldable = {\n    URI: URI,\n    unfold: unfold\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Alt = {\n    URI: URI,\n    map: _map,\n    alt: _alt\n};\n/**\n * @category instances\n * @since 2.11.0\n */\nexport var Zero = {\n    URI: URI,\n    zero: zero\n};\n/**\n * @category do notation\n * @since 2.11.0\n */\nexport var guard = /*#__PURE__*/ guard_(Zero, Pointed);\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Alternative = {\n    URI: URI,\n    map: _map,\n    ap: _ap,\n    of: of,\n    alt: _alt,\n    zero: zero\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Extend = {\n    URI: URI,\n    map: _map,\n    extend: _extend\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Compactable = {\n    URI: URI,\n    compact: compact,\n    separate: separate\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Filterable = {\n    URI: URI,\n    map: _map,\n    compact: compact,\n    separate: separate,\n    filter: _filter,\n    filterMap: _filterMap,\n    partition: _partition,\n    partitionMap: _partitionMap\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var FilterableWithIndex = {\n    URI: URI,\n    map: _map,\n    mapWithIndex: _mapWithIndex,\n    compact: compact,\n    separate: separate,\n    filter: _filter,\n    filterMap: _filterMap,\n    partition: _partition,\n    partitionMap: _partitionMap,\n    partitionMapWithIndex: _partitionMapWithIndex,\n    partitionWithIndex: _partitionWithIndex,\n    filterMapWithIndex: _filterMapWithIndex,\n    filterWithIndex: _filterWithIndex\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Foldable = {\n    URI: URI,\n    reduce: _reduce,\n    foldMap: _foldMap,\n    reduceRight: _reduceRight\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var FoldableWithIndex = {\n    URI: URI,\n    reduce: _reduce,\n    foldMap: _foldMap,\n    reduceRight: _reduceRight,\n    reduceWithIndex: _reduceWithIndex,\n    foldMapWithIndex: _foldMapWithIndex,\n    reduceRightWithIndex: _reduceRightWithIndex\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Traversable = {\n    URI: URI,\n    map: _map,\n    reduce: _reduce,\n    foldMap: _foldMap,\n    reduceRight: _reduceRight,\n    traverse: _traverse,\n    sequence: sequence\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var TraversableWithIndex = {\n    URI: URI,\n    map: _map,\n    mapWithIndex: _mapWithIndex,\n    reduce: _reduce,\n    foldMap: _foldMap,\n    reduceRight: _reduceRight,\n    reduceWithIndex: _reduceWithIndex,\n    foldMapWithIndex: _foldMapWithIndex,\n    reduceRightWithIndex: _reduceRightWithIndex,\n    traverse: _traverse,\n    sequence: sequence,\n    traverseWithIndex: _traverseWithIndex\n};\nvar _wither = /*#__PURE__*/ witherDefault(Traversable, Compactable);\nvar _wilt = /*#__PURE__*/ wiltDefault(Traversable, Compactable);\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Witherable = {\n    URI: URI,\n    map: _map,\n    compact: compact,\n    separate: separate,\n    filter: _filter,\n    filterMap: _filterMap,\n    partition: _partition,\n    partitionMap: _partitionMap,\n    reduce: _reduce,\n    foldMap: _foldMap,\n    reduceRight: _reduceRight,\n    traverse: _traverse,\n    sequence: sequence,\n    wither: _wither,\n    wilt: _wilt\n};\n/**\n * @category sequencing\n * @since 2.11.0\n */\nexport var chainRecDepthFirst = RA.chainRecDepthFirst;\n/**\n * @category instances\n * @since 2.11.0\n */\nexport var ChainRecDepthFirst = {\n    URI: URI,\n    map: _map,\n    ap: _ap,\n    chain: flatMap,\n    chainRec: _chainRecDepthFirst\n};\n/**\n * @category sequencing\n * @since 2.11.0\n */\nexport var chainRecBreadthFirst = RA.chainRecBreadthFirst;\n/**\n * @category instances\n * @since 2.11.0\n */\nexport var ChainRecBreadthFirst = {\n    URI: URI,\n    map: _map,\n    ap: _ap,\n    chain: flatMap,\n    chainRec: _chainRecBreadthFirst\n};\n/**\n * Filter values inside a context.\n *\n * @since 2.11.0\n */\nexport var filterE = /*#__PURE__*/ filterE_(Witherable);\n/**\n * @category instances\n * @since 2.11.0\n */\nexport var FromEither = {\n    URI: URI,\n    fromEither: fromEither\n};\n/**\n * @category lifting\n * @since 2.11.0\n */\nexport var fromEitherK = /*#__PURE__*/ fromEitherK_(FromEither);\n// -------------------------------------------------------------------------------------\n// unsafe\n// -------------------------------------------------------------------------------------\n/**\n * @category unsafe\n * @since 2.0.0\n */\nexport var unsafeInsertAt = NEA.unsafeInsertAt;\n/**\n * @category unsafe\n * @since 2.0.0\n */\nexport var unsafeUpdateAt = function (i, a, as) {\n    return isNonEmpty(as) ? NEA.unsafeUpdateAt(i, a, as) : [];\n};\n/**\n * @category unsafe\n * @since 2.0.0\n */\nexport var unsafeDeleteAt = function (i, as) {\n    var xs = as.slice();\n    xs.splice(i, 1);\n    return xs;\n};\n// -------------------------------------------------------------------------------------\n// utils\n// -------------------------------------------------------------------------------------\n/**\n * `every` tells if the provided predicate holds true for every element in the `Array`.\n *\n * @example\n * import { every } from 'fp-ts/Array'\n *\n * assert.equal(every((x: number) => x >= 0)([1, 2, 3]), true);\n * assert.equal(every((x: number) => x >= 0)([-1, 2, 3]), false);\n *\n * @since 2.9.0\n */\nexport var every = RA.every;\n/**\n * `some` tells if the provided predicate holds true at least for one element in the `Array`.\n *\n * @example\n * import { some } from 'fp-ts/Array'\n *\n * assert.equal(some((x: number) => x >= 0)([1, 2, 3]), true);\n * assert.equal(some((x: number) => x >= 10)([1, 2, 3]), false);\n *\n * @since 2.9.0\n */\nexport var some = function (predicate) {\n    return function (as) {\n        return as.some(predicate);\n    };\n};\n/**\n * Alias of [`some`](#some)\n *\n * @since 2.11.0\n */\nexport var exists = some;\n/**\n * Places an element in between members of an `Array`, then folds the results using the provided `Monoid`.\n *\n * @example\n * import * as S from 'fp-ts/string'\n * import { intercalate } from 'fp-ts/Array'\n *\n * assert.deepStrictEqual(intercalate(S.Monoid)('-')(['a', 'b', 'c']), 'a-b-c')\n *\n * @since 2.12.0\n */\nexport var intercalate = RA.intercalate;\n// -------------------------------------------------------------------------------------\n// do notation\n// -------------------------------------------------------------------------------------\n/**\n * @category do notation\n * @since 2.9.0\n */\nexport var Do = /*#__PURE__*/ of(_.emptyRecord);\n/**\n * @category do notation\n * @since 2.8.0\n */\nexport var bindTo = /*#__PURE__*/ bindTo_(Functor);\nvar let_ = /*#__PURE__*/ let__(Functor);\nexport { \n/**\n * @category do notation\n * @since 2.13.0\n */\nlet_ as let };\n/**\n * @category do notation\n * @since 2.8.0\n */\nexport var bind = /*#__PURE__*/ bind_(Chain);\n/**\n * @category do notation\n * @since 2.8.0\n */\nexport var apS = /*#__PURE__*/ apS_(Apply);\n// -------------------------------------------------------------------------------------\n// legacy\n// -------------------------------------------------------------------------------------\n/**\n * Alias of `flatMap`.\n *\n * @category legacy\n * @since 2.0.0\n */\nexport var chain = flatMap;\n// -------------------------------------------------------------------------------------\n// deprecated\n// -------------------------------------------------------------------------------------\n/**\n * Use `NonEmptyArray` module instead.\n *\n * @category zone of death\n * @since 2.0.0\n * @deprecated\n */\nexport var range = NEA.range;\n/**\n * Use a new `[]` instead.\n *\n * @category zone of death\n * @since 2.0.0\n * @deprecated\n */\nexport var empty = [];\n/**\n * Use `prepend` instead.\n *\n * @category zone of death\n * @since 2.0.0\n * @deprecated\n */\nexport var cons = NEA.cons;\n/**\n * Use `append` instead.\n *\n * @category zone of death\n * @since 2.0.0\n * @deprecated\n */\nexport var snoc = NEA.snoc;\n/**\n * Use `prependAll` instead\n *\n * @category zone of death\n * @since 2.9.0\n * @deprecated\n */\nexport var prependToAll = prependAll;\n/**\n * This instance is deprecated, use small, specific instances instead.\n * For example if a function needs a `Functor` instance, pass `A.Functor` instead of `A.array`\n * (where `A` is from `import A from 'fp-ts/Array'`)\n *\n * @category zone of death\n * @since 2.0.0\n * @deprecated\n */\nexport var array = {\n    URI: URI,\n    compact: compact,\n    separate: separate,\n    map: _map,\n    ap: _ap,\n    of: of,\n    chain: flatMap,\n    filter: _filter,\n    filterMap: _filterMap,\n    partition: _partition,\n    partitionMap: _partitionMap,\n    mapWithIndex: _mapWithIndex,\n    partitionMapWithIndex: _partitionMapWithIndex,\n    partitionWithIndex: _partitionWithIndex,\n    filterMapWithIndex: _filterMapWithIndex,\n    filterWithIndex: _filterWithIndex,\n    alt: _alt,\n    zero: zero,\n    unfold: unfold,\n    reduce: _reduce,\n    foldMap: _foldMap,\n    reduceRight: _reduceRight,\n    traverse: _traverse,\n    sequence: sequence,\n    reduceWithIndex: _reduceWithIndex,\n    foldMapWithIndex: _foldMapWithIndex,\n    reduceRightWithIndex: _reduceRightWithIndex,\n    traverseWithIndex: _traverseWithIndex,\n    extend: _extend,\n    wither: _wither,\n    wilt: _wilt\n};\n","export function chainFirst(M) {\n    var tapM = tap(M);\n    return function (f) { return function (first) { return tapM(first, f); }; };\n}\n/** @internal */\nexport function tap(M) {\n    return function (first, f) { return M.chain(first, function (a) { return M.map(f(a), function () { return a; }); }); };\n}\nexport function bind(M) {\n    return function (name, f) { return function (ma) { return M.chain(ma, function (a) { return M.map(f(a), function (b) {\n        var _a;\n        return Object.assign({}, a, (_a = {}, _a[name] = b, _a));\n    }); }); }; };\n}\n","/**\n * @since 2.0.0\n */\nexport var tailRec = function (startWith, f) {\n    var ab = f(startWith);\n    while (ab._tag === 'Left') {\n        ab = f(ab.left);\n    }\n    return ab.right;\n};\n","import { getApplicativeMonoid } from './Applicative';\nimport { apFirst as apFirst_, apS as apS_, apSecond as apSecond_, getApplySemigroup as getApplySemigroup_ } from './Apply';\nimport * as chainable from './Chain';\nimport { tailRec } from './ChainRec';\nimport { chainOptionK as chainOptionK_, filterOrElse as filterOrElse_, fromOption as fromOption_, fromOptionK as fromOptionK_, fromPredicate as fromPredicate_ } from './FromEither';\nimport { dual, flow, identity, pipe } from './function';\nimport { as as as_, asUnit as asUnit_, bindTo as bindTo_, flap as flap_, let as let__ } from './Functor';\nimport * as _ from './internal';\nimport { separated } from './Separated';\nimport { wiltDefault, witherDefault } from './Witherable';\n// -------------------------------------------------------------------------------------\n// constructors\n// -------------------------------------------------------------------------------------\n/**\n * Constructs a new `Either` holding a `Left` value. This usually represents a failure, due to the right-bias of this\n * structure.\n *\n * @category constructors\n * @since 2.0.0\n */\nexport var left = _.left;\n/**\n * Constructs a new `Either` holding a `Right` value. This usually represents a successful value due to the right bias\n * of this structure.\n *\n * @category constructors\n * @since 2.0.0\n */\nexport var right = _.right;\n/**\n * @category sequencing\n * @since 2.14.0\n */\nexport var flatMap = /*#__PURE__*/ dual(2, function (ma, f) { return (isLeft(ma) ? ma : f(ma.right)); });\nvar _map = function (fa, f) { return pipe(fa, map(f)); };\nvar _ap = function (fab, fa) { return pipe(fab, ap(fa)); };\n/* istanbul ignore next */\nvar _reduce = function (fa, b, f) { return pipe(fa, reduce(b, f)); };\n/* istanbul ignore next */\nvar _foldMap = function (M) { return function (fa, f) {\n    var foldMapM = foldMap(M);\n    return pipe(fa, foldMapM(f));\n}; };\n/* istanbul ignore next */\nvar _reduceRight = function (fa, b, f) { return pipe(fa, reduceRight(b, f)); };\nvar _traverse = function (F) {\n    var traverseF = traverse(F);\n    return function (ta, f) { return pipe(ta, traverseF(f)); };\n};\nvar _bimap = function (fa, f, g) { return pipe(fa, bimap(f, g)); };\nvar _mapLeft = function (fa, f) { return pipe(fa, mapLeft(f)); };\n/* istanbul ignore next */\nvar _alt = function (fa, that) { return pipe(fa, alt(that)); };\n/* istanbul ignore next */\nvar _extend = function (wa, f) { return pipe(wa, extend(f)); };\nvar _chainRec = function (a, f) {\n    return tailRec(f(a), function (e) {\n        return isLeft(e) ? right(left(e.left)) : isLeft(e.right) ? left(f(e.right.left)) : right(right(e.right.right));\n    });\n};\n/**\n * @category type lambdas\n * @since 2.0.0\n */\nexport var URI = 'Either';\n/**\n * @category instances\n * @since 2.0.0\n */\nexport var getShow = function (SE, SA) { return ({\n    show: function (ma) { return (isLeft(ma) ? \"left(\".concat(SE.show(ma.left), \")\") : \"right(\".concat(SA.show(ma.right), \")\")); }\n}); };\n/**\n * @category instances\n * @since 2.0.0\n */\nexport var getEq = function (EL, EA) { return ({\n    equals: function (x, y) {\n        return x === y || (isLeft(x) ? isLeft(y) && EL.equals(x.left, y.left) : isRight(y) && EA.equals(x.right, y.right));\n    }\n}); };\n/**\n * Semigroup returning the left-most non-`Left` value. If both operands are `Right`s then the inner values are\n * concatenated using the provided `Semigroup`\n *\n * @example\n * import { getSemigroup, left, right } from 'fp-ts/Either'\n * import { SemigroupSum } from 'fp-ts/number'\n *\n * const S = getSemigroup<string, number>(SemigroupSum)\n * assert.deepStrictEqual(S.concat(left('a'), left('b')), left('a'))\n * assert.deepStrictEqual(S.concat(left('a'), right(2)), right(2))\n * assert.deepStrictEqual(S.concat(right(1), left('b')), right(1))\n * assert.deepStrictEqual(S.concat(right(1), right(2)), right(3))\n *\n * @category instances\n * @since 2.0.0\n */\nexport var getSemigroup = function (S) { return ({\n    concat: function (x, y) { return (isLeft(y) ? x : isLeft(x) ? y : right(S.concat(x.right, y.right))); }\n}); };\n/**\n * Builds a `Compactable` instance for `Either` given `Monoid` for the left side.\n *\n * @category filtering\n * @since 2.10.0\n */\nexport var getCompactable = function (M) {\n    var empty = left(M.empty);\n    return {\n        URI: URI,\n        _E: undefined,\n        compact: function (ma) { return (isLeft(ma) ? ma : ma.right._tag === 'None' ? empty : right(ma.right.value)); },\n        separate: function (ma) {\n            return isLeft(ma)\n                ? separated(ma, ma)\n                : isLeft(ma.right)\n                    ? separated(right(ma.right.left), empty)\n                    : separated(empty, right(ma.right.right));\n        }\n    };\n};\n/**\n * Builds a `Filterable` instance for `Either` given `Monoid` for the left side\n *\n * @category filtering\n * @since 2.10.0\n */\nexport var getFilterable = function (M) {\n    var empty = left(M.empty);\n    var _a = getCompactable(M), compact = _a.compact, separate = _a.separate;\n    var filter = function (ma, predicate) {\n        return isLeft(ma) ? ma : predicate(ma.right) ? ma : empty;\n    };\n    var partition = function (ma, p) {\n        return isLeft(ma)\n            ? separated(ma, ma)\n            : p(ma.right)\n                ? separated(empty, right(ma.right))\n                : separated(right(ma.right), empty);\n    };\n    return {\n        URI: URI,\n        _E: undefined,\n        map: _map,\n        compact: compact,\n        separate: separate,\n        filter: filter,\n        filterMap: function (ma, f) {\n            if (isLeft(ma)) {\n                return ma;\n            }\n            var ob = f(ma.right);\n            return ob._tag === 'None' ? empty : right(ob.value);\n        },\n        partition: partition,\n        partitionMap: function (ma, f) {\n            if (isLeft(ma)) {\n                return separated(ma, ma);\n            }\n            var e = f(ma.right);\n            return isLeft(e) ? separated(right(e.left), empty) : separated(empty, right(e.right));\n        }\n    };\n};\n/**\n * Builds `Witherable` instance for `Either` given `Monoid` for the left side\n *\n * @category filtering\n * @since 2.0.0\n */\nexport var getWitherable = function (M) {\n    var F_ = getFilterable(M);\n    var C = getCompactable(M);\n    return {\n        URI: URI,\n        _E: undefined,\n        map: _map,\n        compact: F_.compact,\n        separate: F_.separate,\n        filter: F_.filter,\n        filterMap: F_.filterMap,\n        partition: F_.partition,\n        partitionMap: F_.partitionMap,\n        traverse: _traverse,\n        sequence: sequence,\n        reduce: _reduce,\n        foldMap: _foldMap,\n        reduceRight: _reduceRight,\n        wither: witherDefault(Traversable, C),\n        wilt: wiltDefault(Traversable, C)\n    };\n};\n/**\n * The default [`Applicative`](#applicative) instance returns the first error, if you want to\n * get all errors you need to provide a way to concatenate them via a `Semigroup`.\n *\n * @example\n * import * as A from 'fp-ts/Apply'\n * import * as E from 'fp-ts/Either'\n * import { pipe } from 'fp-ts/function'\n * import * as S from 'fp-ts/Semigroup'\n * import * as string from 'fp-ts/string'\n *\n * const parseString = (u: unknown): E.Either<string, string> =>\n *   typeof u === 'string' ? E.right(u) : E.left('not a string')\n *\n * const parseNumber = (u: unknown): E.Either<string, number> =>\n *   typeof u === 'number' ? E.right(u) : E.left('not a number')\n *\n * interface Person {\n *   readonly name: string\n *   readonly age: number\n * }\n *\n * const parsePerson = (\n *   input: Record<string, unknown>\n * ): E.Either<string, Person> =>\n *   pipe(\n *     E.Do,\n *     E.apS('name', parseString(input.name)),\n *     E.apS('age', parseNumber(input.age))\n *   )\n *\n * assert.deepStrictEqual(parsePerson({}), E.left('not a string')) // <= first error\n *\n * const Applicative = E.getApplicativeValidation(\n *   pipe(string.Semigroup, S.intercalate(', '))\n * )\n *\n * const apS = A.apS(Applicative)\n *\n * const parsePersonAll = (\n *   input: Record<string, unknown>\n * ): E.Either<string, Person> =>\n *   pipe(\n *     E.Do,\n *     apS('name', parseString(input.name)),\n *     apS('age', parseNumber(input.age))\n *   )\n *\n * assert.deepStrictEqual(parsePersonAll({}), E.left('not a string, not a number')) // <= all errors\n *\n * @category error handling\n * @since 2.7.0\n */\nexport var getApplicativeValidation = function (SE) { return ({\n    URI: URI,\n    _E: undefined,\n    map: _map,\n    ap: function (fab, fa) {\n        return isLeft(fab)\n            ? isLeft(fa)\n                ? left(SE.concat(fab.left, fa.left))\n                : fab\n            : isLeft(fa)\n                ? fa\n                : right(fab.right(fa.right));\n    },\n    of: of\n}); };\n/**\n * The default [`Alt`](#alt) instance returns the last error, if you want to\n * get all errors you need to provide a way to concatenate them via a `Semigroup`.\n *\n * @example\n * import * as E from 'fp-ts/Either'\n * import { pipe } from 'fp-ts/function'\n * import * as S from 'fp-ts/Semigroup'\n * import * as string from 'fp-ts/string'\n *\n * const parseString = (u: unknown): E.Either<string, string> =>\n *   typeof u === 'string' ? E.right(u) : E.left('not a string')\n *\n * const parseNumber = (u: unknown): E.Either<string, number> =>\n *   typeof u === 'number' ? E.right(u) : E.left('not a number')\n *\n * const parse = (u: unknown): E.Either<string, string | number> =>\n *   pipe(\n *     parseString(u),\n *     E.alt<string, string | number>(() => parseNumber(u))\n *   )\n *\n * assert.deepStrictEqual(parse(true), E.left('not a number')) // <= last error\n *\n * const Alt = E.getAltValidation(pipe(string.Semigroup, S.intercalate(', ')))\n *\n * const parseAll = (u: unknown): E.Either<string, string | number> =>\n *   Alt.alt<string | number>(parseString(u), () => parseNumber(u))\n *\n * assert.deepStrictEqual(parseAll(true), E.left('not a string, not a number')) // <= all errors\n *\n * @category error handling\n * @since 2.7.0\n */\nexport var getAltValidation = function (SE) { return ({\n    URI: URI,\n    _E: undefined,\n    map: _map,\n    alt: function (me, that) {\n        if (isRight(me)) {\n            return me;\n        }\n        var ea = that();\n        return isLeft(ea) ? left(SE.concat(me.left, ea.left)) : ea;\n    }\n}); };\n/**\n * @category mapping\n * @since 2.0.0\n */\nexport var map = function (f) { return function (fa) {\n    return isLeft(fa) ? fa : right(f(fa.right));\n}; };\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Functor = {\n    URI: URI,\n    map: _map\n};\n/**\n * Maps the `Right` value of this `Either` to the specified constant value.\n *\n * @category mapping\n * @since 2.16.0\n */\nexport var as = dual(2, as_(Functor));\n/**\n * Maps the `Right` value of this `Either` to the void constant value.\n *\n * @category mapping\n * @since 2.16.0\n */\nexport var asUnit = asUnit_(Functor);\n/**\n * @category constructors\n * @since 2.7.0\n */\nexport var of = right;\n/**\n * @category instances\n * @since 2.10.0\n */\nexport var Pointed = {\n    URI: URI,\n    of: of\n};\n/**\n * Less strict version of [`ap`](#ap).\n *\n * The `W` suffix (short for **W**idening) means that the error types will be merged.\n *\n * @since 2.8.0\n */\nexport var apW = function (fa) { return function (fab) {\n    return isLeft(fab) ? fab : isLeft(fa) ? fa : right(fab.right(fa.right));\n}; };\n/**\n * @since 2.0.0\n */\nexport var ap = apW;\n/**\n * @category instances\n * @since 2.10.0\n */\nexport var Apply = {\n    URI: URI,\n    map: _map,\n    ap: _ap\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Applicative = {\n    URI: URI,\n    map: _map,\n    ap: _ap,\n    of: of\n};\n/**\n * @category instances\n * @since 2.10.0\n */\nexport var Chain = {\n    URI: URI,\n    map: _map,\n    ap: _ap,\n    chain: flatMap\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Monad = {\n    URI: URI,\n    map: _map,\n    ap: _ap,\n    of: of,\n    chain: flatMap\n};\n/**\n * Left-associative fold of a structure.\n *\n * @example\n * import { pipe } from 'fp-ts/function'\n * import * as E from 'fp-ts/Either'\n *\n * const startWith = 'prefix'\n * const concat = (a: string, b: string) => `${a}:${b}`\n *\n * assert.deepStrictEqual(\n *   pipe(E.right('a'), E.reduce(startWith, concat)),\n *   'prefix:a'\n * )\n *\n * assert.deepStrictEqual(\n *   pipe(E.left('e'), E.reduce(startWith, concat)),\n *   'prefix'\n * )\n *\n * @category folding\n * @since 2.0.0\n */\nexport var reduce = function (b, f) { return function (fa) {\n    return isLeft(fa) ? b : f(b, fa.right);\n}; };\n/**\n * Map each element of the structure to a monoid, and combine the results.\n *\n * @example\n * import { pipe } from 'fp-ts/function'\n * import * as E from 'fp-ts/Either'\n * import * as S from 'fp-ts/string'\n *\n * const yell = (a: string) => `${a}!`\n *\n * assert.deepStrictEqual(\n *   pipe(E.right('a'), E.foldMap(S.Monoid)(yell)),\n *   'a!'\n * )\n *\n * assert.deepStrictEqual(\n *   pipe(E.left('e'), E.foldMap(S.Monoid)(yell)),\n *   S.Monoid.empty\n * )\n *\n * @category folding\n * @since 2.0.0\n */\nexport var foldMap = function (M) { return function (f) { return function (fa) {\n    return isLeft(fa) ? M.empty : f(fa.right);\n}; }; };\n/**\n * Right-associative fold of a structure.\n *\n * @example\n * import { pipe } from 'fp-ts/function'\n * import * as E from 'fp-ts/Either'\n *\n * const startWith = 'postfix'\n * const concat = (a: string, b: string) => `${a}:${b}`\n *\n * assert.deepStrictEqual(\n *   pipe(E.right('a'), E.reduceRight(startWith, concat)),\n *   'a:postfix'\n * )\n *\n * assert.deepStrictEqual(\n *   pipe(E.left('e'), E.reduceRight(startWith, concat)),\n *   'postfix'\n * )\n *\n * @category folding\n * @since 2.0.0\n */\nexport var reduceRight = function (b, f) { return function (fa) {\n    return isLeft(fa) ? b : f(fa.right, b);\n}; };\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Foldable = {\n    URI: URI,\n    reduce: _reduce,\n    foldMap: _foldMap,\n    reduceRight: _reduceRight\n};\n/**\n * Map each element of a structure to an action, evaluate these actions from left to right, and collect the results.\n *\n * @example\n * import { pipe } from 'fp-ts/function'\n * import * as RA from 'fp-ts/ReadonlyArray'\n * import * as E from 'fp-ts/Either'\n * import * as O from 'fp-ts/Option'\n *\n * assert.deepStrictEqual(\n *   pipe(E.right(['a']), E.traverse(O.Applicative)(RA.head)),\n *   O.some(E.right('a'))\n *  )\n *\n * assert.deepStrictEqual(\n *   pipe(E.right([]), E.traverse(O.Applicative)(RA.head)),\n *   O.none\n * )\n *\n * @category traversing\n * @since 2.6.3\n */\nexport var traverse = function (F) {\n    return function (f) {\n        return function (ta) {\n            return isLeft(ta) ? F.of(left(ta.left)) : F.map(f(ta.right), right);\n        };\n    };\n};\n/**\n * Evaluate each monadic action in the structure from left to right, and collect the results.\n *\n * @example\n * import { pipe } from 'fp-ts/function'\n * import * as E from 'fp-ts/Either'\n * import * as O from 'fp-ts/Option'\n *\n * assert.deepStrictEqual(\n *   pipe(E.right(O.some('a')), E.sequence(O.Applicative)),\n *   O.some(E.right('a'))\n *  )\n *\n * assert.deepStrictEqual(\n *   pipe(E.right(O.none), E.sequence(O.Applicative)),\n *   O.none\n * )\n *\n * @category traversing\n * @since 2.6.3\n */\nexport var sequence = function (F) {\n    return function (ma) {\n        return isLeft(ma) ? F.of(left(ma.left)) : F.map(ma.right, right);\n    };\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Traversable = {\n    URI: URI,\n    map: _map,\n    reduce: _reduce,\n    foldMap: _foldMap,\n    reduceRight: _reduceRight,\n    traverse: _traverse,\n    sequence: sequence\n};\n/**\n * Map a pair of functions over the two type arguments of the bifunctor.\n *\n * @category mapping\n * @since 2.0.0\n */\nexport var bimap = function (f, g) { return function (fa) {\n    return isLeft(fa) ? left(f(fa.left)) : right(g(fa.right));\n}; };\n/**\n * Map a function over the first type argument of a bifunctor.\n *\n * @category error handling\n * @since 2.0.0\n */\nexport var mapLeft = function (f) { return function (fa) {\n    return isLeft(fa) ? left(f(fa.left)) : fa;\n}; };\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Bifunctor = {\n    URI: URI,\n    bimap: _bimap,\n    mapLeft: _mapLeft\n};\n/**\n * Less strict version of [`alt`](#alt).\n *\n * The `W` suffix (short for **W**idening) means that the error and the return types will be merged.\n *\n * @category error handling\n * @since 2.9.0\n */\nexport var altW = function (that) { return function (fa) {\n    return isLeft(fa) ? that() : fa;\n}; };\n/**\n * Identifies an associative operation on a type constructor. It is similar to `Semigroup`, except that it applies to\n * types of kind `* -> *`.\n *\n * In case of `Either` returns the left-most non-`Left` value (or the right-most `Left` value if both values are `Left`).\n *\n * | x        | y        | pipe(x, alt(() => y) |\n * | -------- | -------- | -------------------- |\n * | left(a)  | left(b)  | left(b)              |\n * | left(a)  | right(2) | right(2)             |\n * | right(1) | left(b)  | right(1)             |\n * | right(1) | right(2) | right(1)             |\n *\n * @example\n * import * as E from 'fp-ts/Either'\n * import { pipe } from 'fp-ts/function'\n *\n * assert.deepStrictEqual(\n *   pipe(\n *     E.left('a'),\n *     E.alt(() => E.left('b'))\n *   ),\n *   E.left('b')\n * )\n * assert.deepStrictEqual(\n *   pipe(\n *     E.left('a'),\n *     E.alt(() => E.right(2))\n *   ),\n *   E.right(2)\n * )\n * assert.deepStrictEqual(\n *   pipe(\n *     E.right(1),\n *     E.alt(() => E.left('b'))\n *   ),\n *   E.right(1)\n * )\n * assert.deepStrictEqual(\n *   pipe(\n *     E.right(1),\n *     E.alt(() => E.right(2))\n *   ),\n *   E.right(1)\n * )\n *\n * @category error handling\n * @since 2.0.0\n */\nexport var alt = altW;\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Alt = {\n    URI: URI,\n    map: _map,\n    alt: _alt\n};\n/**\n * @since 2.0.0\n */\nexport var extend = function (f) { return function (wa) {\n    return isLeft(wa) ? wa : right(f(wa));\n}; };\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Extend = {\n    URI: URI,\n    map: _map,\n    extend: _extend\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var ChainRec = {\n    URI: URI,\n    map: _map,\n    ap: _ap,\n    chain: flatMap,\n    chainRec: _chainRec\n};\n/**\n * @since 2.6.3\n */\nexport var throwError = left;\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var MonadThrow = {\n    URI: URI,\n    map: _map,\n    ap: _ap,\n    of: of,\n    chain: flatMap,\n    throwError: throwError\n};\n/**\n * @category instances\n * @since 2.10.0\n */\nexport var FromEither = {\n    URI: URI,\n    fromEither: identity\n};\n/**\n * @example\n * import { fromPredicate, left, right } from 'fp-ts/Either'\n * import { pipe } from 'fp-ts/function'\n *\n * assert.deepStrictEqual(\n *   pipe(\n *     1,\n *     fromPredicate(\n *       (n) => n > 0,\n *       () => 'error'\n *     )\n *   ),\n *   right(1)\n * )\n * assert.deepStrictEqual(\n *   pipe(\n *     -1,\n *     fromPredicate(\n *       (n) => n > 0,\n *       () => 'error'\n *     )\n *   ),\n *   left('error')\n * )\n *\n * @category lifting\n * @since 2.0.0\n */\nexport var fromPredicate = /*#__PURE__*/ fromPredicate_(FromEither);\n// -------------------------------------------------------------------------------------\n// conversions\n// -------------------------------------------------------------------------------------\n/**\n * @example\n * import * as E from 'fp-ts/Either'\n * import { pipe } from 'fp-ts/function'\n * import * as O from 'fp-ts/Option'\n *\n * assert.deepStrictEqual(\n *   pipe(\n *     O.some(1),\n *     E.fromOption(() => 'error')\n *   ),\n *   E.right(1)\n * )\n * assert.deepStrictEqual(\n *   pipe(\n *     O.none,\n *     E.fromOption(() => 'error')\n *   ),\n *   E.left('error')\n * )\n *\n * @category conversions\n * @since 2.0.0\n */\nexport var fromOption = \n/*#__PURE__*/ fromOption_(FromEither);\n// -------------------------------------------------------------------------------------\n// refinements\n// -------------------------------------------------------------------------------------\n/**\n * Returns `true` if the either is an instance of `Left`, `false` otherwise.\n *\n * @category refinements\n * @since 2.0.0\n */\nexport var isLeft = _.isLeft;\n/**\n * Returns `true` if the either is an instance of `Right`, `false` otherwise.\n *\n * @category refinements\n * @since 2.0.0\n */\nexport var isRight = _.isRight;\n/**\n * Less strict version of [`match`](#match).\n *\n * The `W` suffix (short for **W**idening) means that the handler return types will be merged.\n *\n * @category pattern matching\n * @since 2.10.0\n */\nexport var matchW = function (onLeft, onRight) {\n    return function (ma) {\n        return isLeft(ma) ? onLeft(ma.left) : onRight(ma.right);\n    };\n};\n/**\n * Alias of [`matchW`](#matchw).\n *\n * @category pattern matching\n * @since 2.10.0\n */\nexport var foldW = matchW;\n/**\n * Takes two functions and an `Either` value, if the value is a `Left` the inner value is applied to the first function,\n * if the value is a `Right` the inner value is applied to the second function.\n *\n * @example\n * import { match, left, right } from 'fp-ts/Either'\n * import { pipe } from 'fp-ts/function'\n *\n * function onLeft(errors: Array<string>): string {\n *   return `Errors: ${errors.join(', ')}`\n * }\n *\n * function onRight(value: number): string {\n *   return `Ok: ${value}`\n * }\n *\n * assert.strictEqual(\n *   pipe(\n *     right(1),\n *     match(onLeft, onRight)\n *   ),\n *   'Ok: 1'\n * )\n * assert.strictEqual(\n *   pipe(\n *     left(['error 1', 'error 2']),\n *     match(onLeft, onRight)\n *   ),\n *   'Errors: error 1, error 2'\n * )\n *\n * @category pattern matching\n * @since 2.10.0\n */\nexport var match = matchW;\n/**\n * Alias of [`match`](#match).\n *\n * @category pattern matching\n * @since 2.0.0\n */\nexport var fold = match;\n/**\n * Less strict version of [`getOrElse`](#getorelse).\n *\n * The `W` suffix (short for **W**idening) means that the handler return type will be merged.\n *\n * @category error handling\n * @since 2.6.0\n */\nexport var getOrElseW = function (onLeft) {\n    return function (ma) {\n        return isLeft(ma) ? onLeft(ma.left) : ma.right;\n    };\n};\n/**\n * Returns the wrapped value if it's a `Right` or a default value if is a `Left`.\n *\n * @example\n * import { getOrElse, left, right } from 'fp-ts/Either'\n * import { pipe } from 'fp-ts/function'\n *\n * assert.deepStrictEqual(\n *   pipe(\n *     right(1),\n *     getOrElse(() => 0)\n *   ),\n *   1\n * )\n * assert.deepStrictEqual(\n *   pipe(\n *     left('error'),\n *     getOrElse(() => 0)\n *   ),\n *   0\n * )\n *\n * @category error handling\n * @since 2.0.0\n */\nexport var getOrElse = getOrElseW;\n// -------------------------------------------------------------------------------------\n// combinators\n// -------------------------------------------------------------------------------------\n/**\n * @category mapping\n * @since 2.10.0\n */\nexport var flap = /*#__PURE__*/ flap_(Functor);\n/**\n * Combine two effectful actions, keeping only the result of the first.\n *\n * @since 2.0.0\n */\nexport var apFirst = /*#__PURE__*/ apFirst_(Apply);\n/**\n * Less strict version of [`apFirst`](#apfirst)\n *\n * The `W` suffix (short for **W**idening) means that the error types will be merged.\n *\n * @since 2.12.0\n */\nexport var apFirstW = apFirst;\n/**\n * Combine two effectful actions, keeping only the result of the second.\n *\n * @since 2.0.0\n */\nexport var apSecond = /*#__PURE__*/ apSecond_(Apply);\n/**\n * Less strict version of [`apSecond`](#apsecond)\n *\n * The `W` suffix (short for **W**idening) means that the error types will be merged.\n *\n * @since 2.12.0\n */\nexport var apSecondW = apSecond;\n/**\n * Composes computations in sequence, using the return value of one computation to determine the next computation and\n * keeping only the result of the first.\n *\n * @category combinators\n * @since 2.15.0\n */\nexport var tap = /*#__PURE__*/ dual(2, chainable.tap(Chain));\n/**\n * Less strict version of [`flatten`](#flatten).\n *\n * The `W` suffix (short for **W**idening) means that the error types will be merged.\n *\n * @category sequencing\n * @since 2.11.0\n */\nexport var flattenW = \n/*#__PURE__*/ flatMap(identity);\n/**\n * The `flatten` function is the conventional monad join operator. It is used to remove one level of monadic structure, projecting its bound argument into the outer level.\n *\n * @example\n * import * as E from 'fp-ts/Either'\n *\n * assert.deepStrictEqual(E.flatten(E.right(E.right('a'))), E.right('a'))\n * assert.deepStrictEqual(E.flatten(E.right(E.left('e'))), E.left('e'))\n * assert.deepStrictEqual(E.flatten(E.left('e')), E.left('e'))\n *\n * @category sequencing\n * @since 2.0.0\n */\nexport var flatten = flattenW;\n/**\n * @since 2.0.0\n */\nexport var duplicate = /*#__PURE__*/ extend(identity);\n/**\n * Use `liftOption`.\n *\n * @category legacy\n * @since 2.10.0\n */\nexport var fromOptionK = \n/*#__PURE__*/ fromOptionK_(FromEither);\n/**\n * Use `flatMapOption`.\n *\n * @category legacy\n * @since 2.11.0\n */\nexport var chainOptionK = /*#__PURE__*/ chainOptionK_(FromEither, Chain);\n/**\n * Use `flatMapOption`.\n *\n * @category legacy\n * @since 2.13.2\n */\nexport var chainOptionKW = chainOptionK;\n/** @internal */\nvar _FromEither = {\n    fromEither: FromEither.fromEither\n};\n/**\n * @category lifting\n * @since 2.15.0\n */\nexport var liftNullable = /*#__PURE__*/ _.liftNullable(_FromEither);\n/**\n * @category lifting\n * @since 2.15.0\n */\nexport var liftOption = /*#__PURE__*/ _.liftOption(_FromEither);\n/** @internal */\nvar _FlatMap = {\n    flatMap: flatMap\n};\n/**\n * @category sequencing\n * @since 2.15.0\n */\nexport var flatMapNullable = /*#__PURE__*/ _.flatMapNullable(_FromEither, _FlatMap);\n/**\n * @category sequencing\n * @since 2.15.0\n */\nexport var flatMapOption = /*#__PURE__*/ _.flatMapOption(_FromEither, _FlatMap);\n/**\n * @example\n * import * as E from 'fp-ts/Either'\n * import { pipe } from 'fp-ts/function'\n *\n * assert.deepStrictEqual(\n *   pipe(\n *     E.right(1),\n *     E.filterOrElse(\n *       (n) => n > 0,\n *       () => 'error'\n *     )\n *   ),\n *   E.right(1)\n * )\n * assert.deepStrictEqual(\n *   pipe(\n *     E.right(-1),\n *     E.filterOrElse(\n *       (n) => n > 0,\n *       () => 'error'\n *     )\n *   ),\n *   E.left('error')\n * )\n * assert.deepStrictEqual(\n *   pipe(\n *     E.left('a'),\n *     E.filterOrElse(\n *       (n) => n > 0,\n *       () => 'error'\n *     )\n *   ),\n *   E.left('a')\n * )\n *\n * @category filtering\n * @since 2.0.0\n */\nexport var filterOrElse = /*#__PURE__*/ filterOrElse_(FromEither, Chain);\n/**\n * Less strict version of [`filterOrElse`](#filterorelse).\n *\n * The `W` suffix (short for **W**idening) means that the error types will be merged.\n *\n * @category filtering\n * @since 2.9.0\n */\nexport var filterOrElseW = filterOrElse;\n/**\n * Returns a `Right` if is a `Left` (and vice versa).\n *\n * @since 2.0.0\n */\nexport var swap = function (ma) { return (isLeft(ma) ? right(ma.left) : left(ma.right)); };\n/**\n * Less strict version of [`orElse`](#orelse).\n *\n * The `W` suffix (short for **W**idening) means that the return types will be merged.\n *\n * @category error handling\n * @since 2.10.0\n */\nexport var orElseW = function (onLeft) {\n    return function (ma) {\n        return isLeft(ma) ? onLeft(ma.left) : ma;\n    };\n};\n/**\n * Useful for recovering from errors.\n *\n * @category error handling\n * @since 2.0.0\n */\nexport var orElse = orElseW;\n/**\n * Takes a default and a nullable value, if the value is not nully, turn it into a `Right`, if the value is nully use\n * the provided default as a `Left`.\n *\n * @example\n * import { fromNullable, left, right } from 'fp-ts/Either'\n *\n * const parse = fromNullable('nully')\n *\n * assert.deepStrictEqual(parse(1), right(1))\n * assert.deepStrictEqual(parse(null), left('nully'))\n *\n * @category conversions\n * @since 2.0.0\n */\nexport var fromNullable = function (e) {\n    return function (a) {\n        return a == null ? left(e) : right(a);\n    };\n};\n/**\n * Constructs a new `Either` from a function that might throw.\n *\n * See also [`tryCatchK`](#trycatchk).\n *\n * @example\n * import * as E from 'fp-ts/Either'\n *\n * const unsafeHead = <A>(as: ReadonlyArray<A>): A => {\n *   if (as.length > 0) {\n *     return as[0]\n *   } else {\n *     throw new Error('empty array')\n *   }\n * }\n *\n * const head = <A>(as: ReadonlyArray<A>): E.Either<Error, A> =>\n *   E.tryCatch(() => unsafeHead(as), e => (e instanceof Error ? e : new Error('unknown error')))\n *\n * assert.deepStrictEqual(head([]), E.left(new Error('empty array')))\n * assert.deepStrictEqual(head([1, 2, 3]), E.right(1))\n *\n * @category interop\n * @since 2.0.0\n */\nexport var tryCatch = function (f, onThrow) {\n    try {\n        return right(f());\n    }\n    catch (e) {\n        return left(onThrow(e));\n    }\n};\n/**\n * Converts a function that may throw to one returning a `Either`.\n *\n * @category interop\n * @since 2.10.0\n */\nexport var tryCatchK = function (f, onThrow) {\n    return function () {\n        var a = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            a[_i] = arguments[_i];\n        }\n        return tryCatch(function () { return f.apply(void 0, a); }, onThrow);\n    };\n};\n/**\n * Use `liftNullable`.\n *\n * @category legacy\n * @since 2.9.0\n */\nexport var fromNullableK = function (e) {\n    var from = fromNullable(e);\n    return function (f) { return flow(f, from); };\n};\n/**\n * Use `flatMapNullable`.\n *\n * @category legacy\n * @since 2.9.0\n */\nexport var chainNullableK = function (e) {\n    var from = fromNullableK(e);\n    return function (f) { return flatMap(from(f)); };\n};\n/**\n * @category conversions\n * @since 2.10.0\n */\nexport var toUnion = /*#__PURE__*/ foldW(identity, identity);\n// -------------------------------------------------------------------------------------\n// utils\n// -------------------------------------------------------------------------------------\n/**\n * Default value for the `onError` argument of `tryCatch`\n *\n * @since 2.0.0\n */\nexport function toError(e) {\n    try {\n        return e instanceof Error ? e : new Error(String(e));\n    }\n    catch (error) {\n        return new Error();\n    }\n}\nexport function elem(E) {\n    return function (a, ma) {\n        if (ma === undefined) {\n            var elemE_1 = elem(E);\n            return function (ma) { return elemE_1(a, ma); };\n        }\n        return isLeft(ma) ? false : E.equals(a, ma.right);\n    };\n}\n/**\n * Returns `false` if `Left` or returns the result of the application of the given predicate to the `Right` value.\n *\n * @example\n * import { exists, left, right } from 'fp-ts/Either'\n *\n * const gt2 = exists((n: number) => n > 2)\n *\n * assert.strictEqual(gt2(left('a')), false)\n * assert.strictEqual(gt2(right(1)), false)\n * assert.strictEqual(gt2(right(3)), true)\n *\n * @since 2.0.0\n */\nexport var exists = function (predicate) {\n    return function (ma) {\n        return isLeft(ma) ? false : predicate(ma.right);\n    };\n};\n// -------------------------------------------------------------------------------------\n// do notation\n// -------------------------------------------------------------------------------------\n/**\n * @category do notation\n * @since 2.9.0\n */\nexport var Do = /*#__PURE__*/ of(_.emptyRecord);\n/**\n * @category do notation\n * @since 2.8.0\n */\nexport var bindTo = /*#__PURE__*/ bindTo_(Functor);\nvar let_ = /*#__PURE__*/ let__(Functor);\nexport { \n/**\n * @category do notation\n * @since 2.13.0\n */\nlet_ as let };\n/**\n * @category do notation\n * @since 2.8.0\n */\nexport var bind = /*#__PURE__*/ chainable.bind(Chain);\n/**\n * The `W` suffix (short for **W**idening) means that the error types will be merged.\n *\n * @category do notation\n * @since 2.8.0\n */\nexport var bindW = bind;\n/**\n * @category do notation\n * @since 2.8.0\n */\nexport var apS = /*#__PURE__*/ apS_(Apply);\n/**\n * Less strict version of [`apS`](#aps).\n *\n * The `W` suffix (short for **W**idening) means that the error types will be merged.\n *\n * @category do notation\n * @since 2.8.0\n */\nexport var apSW = apS;\n/**\n * @since 2.11.0\n */\nexport var ApT = /*#__PURE__*/ of(_.emptyReadonlyArray);\n// -------------------------------------------------------------------------------------\n// array utils\n// -------------------------------------------------------------------------------------\n/**\n * Equivalent to `ReadonlyNonEmptyArray#traverseWithIndex(Applicative)`.\n *\n * @category traversing\n * @since 2.11.0\n */\nexport var traverseReadonlyNonEmptyArrayWithIndex = function (f) {\n    return function (as) {\n        var e = f(0, _.head(as));\n        if (isLeft(e)) {\n            return e;\n        }\n        var out = [e.right];\n        for (var i = 1; i < as.length; i++) {\n            var e_1 = f(i, as[i]);\n            if (isLeft(e_1)) {\n                return e_1;\n            }\n            out.push(e_1.right);\n        }\n        return right(out);\n    };\n};\n/**\n * Equivalent to `ReadonlyArray#traverseWithIndex(Applicative)`.\n *\n * @category traversing\n * @since 2.11.0\n */\nexport var traverseReadonlyArrayWithIndex = function (f) {\n    var g = traverseReadonlyNonEmptyArrayWithIndex(f);\n    return function (as) { return (_.isNonEmpty(as) ? g(as) : ApT); };\n};\n/**\n * Equivalent to `ReadonlyArray#traverseWithIndex(Applicative)`.\n *\n * @category traversing\n * @since 2.9.0\n */\nexport var traverseArrayWithIndex = traverseReadonlyArrayWithIndex;\n/**\n * Equivalent to `ReadonlyArray#traverse(Applicative)`.\n *\n * @category traversing\n * @since 2.9.0\n */\nexport var traverseArray = function (f) { return traverseReadonlyArrayWithIndex(function (_, a) { return f(a); }); };\n/**\n * Equivalent to `ReadonlyArray#sequence(Applicative)`.\n *\n * @category traversing\n * @since 2.9.0\n */\nexport var sequenceArray = \n/*#__PURE__*/ traverseArray(identity);\n// -------------------------------------------------------------------------------------\n// legacy\n// -------------------------------------------------------------------------------------\n/**\n * Alias of `flatMap`.\n *\n * @category legacy\n * @since 2.6.0\n */\nexport var chainW = flatMap;\n/**\n * Alias of `flatMap`.\n *\n * @category legacy\n * @since 2.0.0\n */\nexport var chain = flatMap;\n/**\n * Alias of `tap`.\n *\n * @category legacy\n * @since 2.0.0\n */\nexport var chainFirst = tap;\n/**\n * Alias of `tap`.\n *\n * @category legacy\n * @since 2.8.0\n */\nexport var chainFirstW = tap;\n/**\n * Use [`parse`](./Json.ts.html#parse) instead.\n *\n * @category zone of death\n * @since 2.0.0\n * @deprecated\n */\nexport function parseJSON(s, onError) {\n    return tryCatch(function () { return JSON.parse(s); }, onError);\n}\n/**\n * Use [`stringify`](./Json.ts.html#stringify) instead.\n *\n * @category zone of death\n * @since 2.0.0\n * @deprecated\n */\nexport var stringifyJSON = function (u, onError) {\n    return tryCatch(function () {\n        var s = JSON.stringify(u);\n        if (typeof s !== 'string') {\n            throw new Error('Converting unsupported structure to JSON');\n        }\n        return s;\n    }, onError);\n};\n/**\n * This instance is deprecated, use small, specific instances instead.\n * For example if a function needs a `Functor` instance, pass `E.Functor` instead of `E.either`\n * (where `E` is from `import E from 'fp-ts/Either'`)\n *\n * @category zone of death\n * @since 2.0.0\n * @deprecated\n */\nexport var either = {\n    URI: URI,\n    map: _map,\n    of: of,\n    ap: _ap,\n    chain: flatMap,\n    reduce: _reduce,\n    foldMap: _foldMap,\n    reduceRight: _reduceRight,\n    traverse: _traverse,\n    sequence: sequence,\n    bimap: _bimap,\n    mapLeft: _mapLeft,\n    alt: _alt,\n    extend: _extend,\n    chainRec: _chainRec,\n    throwError: throwError\n};\n/**\n * Use [`getApplySemigroup`](./Apply.ts.html#getapplysemigroup) instead.\n *\n * Semigroup returning the left-most `Left` value. If both operands are `Right`s then the inner values\n * are concatenated using the provided `Semigroup`\n *\n * @category zone of death\n * @since 2.0.0\n * @deprecated\n */\nexport var getApplySemigroup = \n/*#__PURE__*/ getApplySemigroup_(Apply);\n/**\n * Use [`getApplicativeMonoid`](./Applicative.ts.html#getapplicativemonoid) instead.\n *\n * @category zone of death\n * @since 2.0.0\n * @deprecated\n */\nexport var getApplyMonoid = \n/*#__PURE__*/ getApplicativeMonoid(Applicative);\n/**\n * Use [`getApplySemigroup`](./Apply.ts.html#getapplysemigroup) instead.\n *\n * @category zone of death\n * @since 2.0.0\n * @deprecated\n */\nexport var getValidationSemigroup = function (SE, SA) {\n    return getApplySemigroup_(getApplicativeValidation(SE))(SA);\n};\n/**\n * Use [`getApplicativeMonoid`](./Applicative.ts.html#getapplicativemonoid) instead.\n *\n * @category zone of death\n * @since 2.0.0\n * @deprecated\n */\nexport var getValidationMonoid = function (SE, MA) {\n    return getApplicativeMonoid(getApplicativeValidation(SE))(MA);\n};\n/**\n * Use [`getApplicativeValidation`](#getapplicativevalidation) and [`getAltValidation`](#getaltvalidation) instead.\n *\n * @category zone of death\n * @since 2.0.0\n * @deprecated\n */\nexport function getValidation(SE) {\n    var ap = getApplicativeValidation(SE).ap;\n    var alt = getAltValidation(SE).alt;\n    return {\n        URI: URI,\n        _E: undefined,\n        map: _map,\n        of: of,\n        chain: flatMap,\n        bimap: _bimap,\n        mapLeft: _mapLeft,\n        reduce: _reduce,\n        foldMap: _foldMap,\n        reduceRight: _reduceRight,\n        extend: _extend,\n        traverse: _traverse,\n        sequence: sequence,\n        chainRec: _chainRec,\n        throwError: throwError,\n        ap: ap,\n        alt: alt\n    };\n}\n","import { pipe } from './function';\n// -------------------------------------------------------------------------------------\n// constructors\n// -------------------------------------------------------------------------------------\n/**\n * @category constructors\n * @since 2.0.0\n */\nexport var fromEquals = function (equals) { return ({\n    equals: function (x, y) { return x === y || equals(x, y); }\n}); };\n// -------------------------------------------------------------------------------------\n// combinators\n// -------------------------------------------------------------------------------------\n/**\n * @since 2.10.0\n */\nexport var struct = function (eqs) {\n    return fromEquals(function (first, second) {\n        for (var key in eqs) {\n            if (!eqs[key].equals(first[key], second[key])) {\n                return false;\n            }\n        }\n        return true;\n    });\n};\n/**\n * Given a tuple of `Eq`s returns a `Eq` for the tuple\n *\n * @example\n * import { tuple } from 'fp-ts/Eq'\n * import * as S from 'fp-ts/string'\n * import * as N from 'fp-ts/number'\n * import * as B from 'fp-ts/boolean'\n *\n * const E = tuple(S.Eq, N.Eq, B.Eq)\n * assert.strictEqual(E.equals(['a', 1, true], ['a', 1, true]), true)\n * assert.strictEqual(E.equals(['a', 1, true], ['b', 1, true]), false)\n * assert.strictEqual(E.equals(['a', 1, true], ['a', 2, true]), false)\n * assert.strictEqual(E.equals(['a', 1, true], ['a', 1, false]), false)\n *\n * @since 2.10.0\n */\nexport var tuple = function () {\n    var eqs = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        eqs[_i] = arguments[_i];\n    }\n    return fromEquals(function (first, second) { return eqs.every(function (E, i) { return E.equals(first[i], second[i]); }); });\n};\n/* istanbul ignore next */\nvar contramap_ = function (fa, f) { return pipe(fa, contramap(f)); };\n/**\n * A typical use case for `contramap` would be like, given some `User` type, to construct an `Eq<User>`.\n *\n * We can do so with a function from `User -> X` where `X` is some value that we know how to compare\n * for equality (meaning we have an `Eq<X>`)\n *\n * For example, given the following `User` type, we want to construct an `Eq<User>` that just looks at the `key` field\n * for each user (since it's known to be unique).\n *\n * If we have a way of comparing `UUID`s for equality (`eqUUID: Eq<UUID>`) and we know how to go from `User -> UUID`,\n * using `contramap` we can do this\n *\n * @example\n * import { contramap, Eq } from 'fp-ts/Eq'\n * import { pipe } from 'fp-ts/function'\n * import * as S from 'fp-ts/string'\n *\n * type UUID = string\n *\n * interface User {\n *   readonly key: UUID\n *   readonly firstName: string\n *   readonly lastName: string\n * }\n *\n * const eqUUID: Eq<UUID> = S.Eq\n *\n * const eqUserByKey: Eq<User> = pipe(\n *   eqUUID,\n *   contramap((user) => user.key)\n * )\n *\n * assert.deepStrictEqual(\n *   eqUserByKey.equals(\n *     { key: 'k1', firstName: 'a1', lastName: 'b1' },\n *     { key: 'k2', firstName: 'a1', lastName: 'b1' }\n *   ),\n *   false\n * )\n * assert.deepStrictEqual(\n *   eqUserByKey.equals(\n *     { key: 'k1', firstName: 'a1', lastName: 'b1' },\n *     { key: 'k1', firstName: 'a2', lastName: 'b1' }\n *   ),\n *   true\n * )\n *\n * @since 2.0.0\n */\nexport var contramap = function (f) { return function (fa) {\n    return fromEquals(function (x, y) { return fa.equals(f(x), f(y)); });\n}; };\n/**\n * @category type lambdas\n * @since 2.0.0\n */\nexport var URI = 'Eq';\n/**\n * @category instances\n * @since 2.5.0\n */\nexport var eqStrict = {\n    equals: function (a, b) { return a === b; }\n};\nvar empty = {\n    equals: function () { return true; }\n};\n/**\n * @category instances\n * @since 2.10.0\n */\nexport var getSemigroup = function () { return ({\n    concat: function (x, y) { return fromEquals(function (a, b) { return x.equals(a, b) && y.equals(a, b); }); }\n}); };\n/**\n * @category instances\n * @since 2.6.0\n */\nexport var getMonoid = function () { return ({\n    concat: getSemigroup().concat,\n    empty: empty\n}); };\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Contravariant = {\n    URI: URI,\n    contramap: contramap_\n};\n// -------------------------------------------------------------------------------------\n// deprecated\n// -------------------------------------------------------------------------------------\n/**\n * Use [`tuple`](#tuple) instead.\n *\n * @category zone of death\n * @since 2.0.0\n * @deprecated\n */\nexport var getTupleEq = tuple;\n/**\n * Use [`struct`](#struct) instead.\n *\n * @category zone of death\n * @since 2.0.0\n * @deprecated\n */\nexport var getStructEq = struct;\n/**\n * Use [`eqStrict`](#eqstrict) instead\n *\n * @category zone of death\n * @since 2.0.0\n * @deprecated\n */\nexport var strictEqual = eqStrict.equals;\n/**\n * This instance is deprecated, use small, specific instances instead.\n * For example if a function needs a `Contravariant` instance, pass `E.Contravariant` instead of `E.eq`\n * (where `E` is from `import E from 'fp-ts/Eq'`)\n *\n * @category zone of death\n * @since 2.0.0\n * @deprecated\n */\nexport var eq = Contravariant;\n/**\n * Use [`Eq`](./boolean.ts.html#eq) instead.\n *\n * @category zone of death\n * @since 2.0.0\n * @deprecated\n */\nexport var eqBoolean = eqStrict;\n/**\n * Use [`Eq`](./string.ts.html#eq) instead.\n *\n * @category zone of death\n * @since 2.0.0\n * @deprecated\n */\nexport var eqString = eqStrict;\n/**\n * Use [`Eq`](./number.ts.html#eq) instead.\n *\n * @category zone of death\n * @since 2.0.0\n * @deprecated\n */\nexport var eqNumber = eqStrict;\n/**\n * Use [`Eq`](./Date.ts.html#eq) instead.\n *\n * @category zone of death\n * @since 2.0.0\n * @deprecated\n */\nexport var eqDate = {\n    equals: function (first, second) { return first.valueOf() === second.valueOf(); }\n};\n","/**\n * The `FromEither` type class represents those data types which support errors.\n *\n * @since 2.10.0\n */\nimport { tap } from './Chain';\nimport { flow } from './function';\nimport * as _ from './internal';\nexport function fromOption(F) {\n    return function (onNone) { return function (ma) { return F.fromEither(_.isNone(ma) ? _.left(onNone()) : _.right(ma.value)); }; };\n}\nexport function fromPredicate(F) {\n    return function (predicate, onFalse) {\n        return function (a) {\n            return F.fromEither(predicate(a) ? _.right(a) : _.left(onFalse(a)));\n        };\n    };\n}\nexport function fromOptionK(F) {\n    var fromOptionF = fromOption(F);\n    return function (onNone) {\n        var from = fromOptionF(onNone);\n        return function (f) { return flow(f, from); };\n    };\n}\nexport function chainOptionK(F, M) {\n    var fromOptionKF = fromOptionK(F);\n    return function (onNone) {\n        var from = fromOptionKF(onNone);\n        return function (f) { return function (ma) { return M.chain(ma, from(f)); }; };\n    };\n}\nexport function fromEitherK(F) {\n    return function (f) { return flow(f, F.fromEither); };\n}\nexport function chainEitherK(F, M) {\n    var fromEitherKF = fromEitherK(F);\n    return function (f) { return function (ma) { return M.chain(ma, fromEitherKF(f)); }; };\n}\nexport function chainFirstEitherK(F, M) {\n    var tapEitherM = tapEither(F, M);\n    return function (f) { return function (ma) { return tapEitherM(ma, f); }; };\n}\nexport function filterOrElse(F, M) {\n    return function (predicate, onFalse) {\n        return function (ma) {\n            return M.chain(ma, function (a) { return F.fromEither(predicate(a) ? _.right(a) : _.left(onFalse(a))); });\n        };\n    };\n}\n/** @internal */\nexport function tapEither(F, M) {\n    var fromEither = fromEitherK(F);\n    var tapM = tap(M);\n    return function (self, f) { return tapM(self, fromEither(f)); };\n}\n","/**\n * A `Functor` is a type constructor which supports a mapping operation `map`.\n *\n * `map` can be used to turn functions `a -> b` into functions `f a -> f b` whose argument and return types use the type\n * constructor `f` to represent some computational context.\n *\n * Instances must satisfy the following laws:\n *\n * 1. Identity: `F.map(fa, a => a) <-> fa`\n * 2. Composition: `F.map(fa, a => bc(ab(a))) <-> F.map(F.map(fa, ab), bc)`\n *\n * @since 2.0.0\n */\nimport { pipe } from './function';\nexport function map(F, G) {\n    return function (f) { return function (fa) { return F.map(fa, function (ga) { return G.map(ga, f); }); }; };\n}\nexport function flap(F) {\n    return function (a) { return function (fab) { return F.map(fab, function (f) { return f(a); }); }; };\n}\nexport function bindTo(F) {\n    return function (name) { return function (fa) { return F.map(fa, function (a) {\n        var _a;\n        return (_a = {}, _a[name] = a, _a);\n    }); }; };\n}\nfunction let_(F) {\n    return function (name, f) { return function (fa) { return F.map(fa, function (a) {\n        var _a;\n        return Object.assign({}, a, (_a = {}, _a[name] = f(a), _a));\n    }); }; };\n}\nexport { \n/**\n * @since 2.13.0\n */\nlet_ as let };\n/** @deprecated */\nexport function getFunctorComposition(F, G) {\n    var _map = map(F, G);\n    return {\n        map: function (fga, f) { return pipe(fga, _map(f)); }\n    };\n}\n/** @internal */\nexport function as(F) {\n    return function (self, b) { return F.map(self, function () { return b; }); };\n}\n/** @internal */\nexport function asUnit(F) {\n    var asM = as(F);\n    return function (self) { return asM(self, undefined); };\n}\n","/**\n * A `Magma` is a pair `(A, concat)` in which `A` is a non-empty set and `concat` is a binary operation on `A`\n *\n * See [Semigroup](https://gcanti.github.io/fp-ts/modules/Semigroup.ts.html) for some instances.\n *\n * @since 2.0.0\n */\n// -------------------------------------------------------------------------------------\n// combinators\n// -------------------------------------------------------------------------------------\n/**\n * The dual of a `Magma`, obtained by swapping the arguments of `concat`.\n *\n * @example\n * import { reverse, concatAll } from 'fp-ts/Magma'\n * import * as N from 'fp-ts/number'\n *\n * const subAll = concatAll(reverse(N.MagmaSub))(0)\n *\n * assert.deepStrictEqual(subAll([1, 2, 3]), 2)\n *\n * @since 2.11.0\n */\nexport var reverse = function (M) { return ({\n    concat: function (first, second) { return M.concat(second, first); }\n}); };\n/**\n * @since 2.11.0\n */\nexport var filterFirst = function (predicate) {\n    return function (M) { return ({\n        concat: function (first, second) { return (predicate(first) ? M.concat(first, second) : second); }\n    }); };\n};\n/**\n * @since 2.11.0\n */\nexport var filterSecond = function (predicate) {\n    return function (M) { return ({\n        concat: function (first, second) { return (predicate(second) ? M.concat(first, second) : first); }\n    }); };\n};\n/**\n * @since 2.11.0\n */\nexport var endo = function (f) {\n    return function (M) { return ({\n        concat: function (first, second) { return M.concat(f(first), f(second)); }\n    }); };\n};\n// -------------------------------------------------------------------------------------\n// utils\n// -------------------------------------------------------------------------------------\n/**\n * Given a sequence of `as`, concat them and return the total.\n *\n * If `as` is empty, return the provided `startWith` value.\n *\n * @example\n * import { concatAll } from 'fp-ts/Magma'\n * import * as N from 'fp-ts/number'\n *\n * const subAll = concatAll(N.MagmaSub)(0)\n *\n * assert.deepStrictEqual(subAll([1, 2, 3]), -6)\n *\n * @since 2.11.0\n */\nexport var concatAll = function (M) {\n    return function (startWith) {\n        return function (as) {\n            return as.reduce(function (a, acc) { return M.concat(a, acc); }, startWith);\n        };\n    };\n};\n","var __spreadArray = (this && this.__spreadArray) || function (to, from, pack) {\n    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {\n        if (ar || !(i in from)) {\n            if (!ar) ar = Array.prototype.slice.call(from, 0, i);\n            ar[i] = from[i];\n        }\n    }\n    return to.concat(ar || Array.prototype.slice.call(from));\n};\nimport { apFirst as apFirst_, apS as apS_, apSecond as apSecond_ } from './Apply';\nimport { bind as bind_, chainFirst as chainFirst_ } from './Chain';\nimport { dual, identity, pipe } from './function';\nimport { bindTo as bindTo_, flap as flap_, let as let__ } from './Functor';\nimport * as _ from './internal';\nimport { getMonoid } from './Ord';\nimport * as RNEA from './ReadonlyNonEmptyArray';\n// -------------------------------------------------------------------------------------\n// internal\n// -------------------------------------------------------------------------------------\n/**\n * @internal\n */\nexport var isNonEmpty = function (as) { return as.length > 0; };\n/**\n * @internal\n */\nexport var isOutOfBound = function (i, as) { return i < 0 || i >= as.length; };\n/**\n * @internal\n */\nexport var prependW = function (head) {\n    return function (tail) {\n        return __spreadArray([head], tail, true);\n    };\n};\n/**\n * @internal\n */\nexport var prepend = prependW;\n/**\n * @internal\n */\nexport var appendW = function (end) {\n    return function (init) {\n        return __spreadArray(__spreadArray([], init, true), [end], false);\n    };\n};\n/**\n * @internal\n */\nexport var append = appendW;\n/**\n * @internal\n */\nexport var unsafeInsertAt = function (i, a, as) {\n    if (isNonEmpty(as)) {\n        var xs = fromReadonlyNonEmptyArray(as);\n        xs.splice(i, 0, a);\n        return xs;\n    }\n    return [a];\n};\n/**\n * @internal\n */\nexport var unsafeUpdateAt = function (i, a, as) {\n    var xs = fromReadonlyNonEmptyArray(as);\n    xs[i] = a;\n    return xs;\n};\n/**\n * Remove duplicates from a `NonEmptyArray`, keeping the first occurrence of an element.\n *\n * @example\n * import { uniq } from 'fp-ts/NonEmptyArray'\n * import * as N from 'fp-ts/number'\n *\n * assert.deepStrictEqual(uniq(N.Eq)([1, 2, 1]), [1, 2])\n *\n * @since 2.11.0\n */\nexport var uniq = function (E) {\n    return function (as) {\n        if (as.length === 1) {\n            return copy(as);\n        }\n        var out = [head(as)];\n        var rest = tail(as);\n        var _loop_1 = function (a) {\n            if (out.every(function (o) { return !E.equals(o, a); })) {\n                out.push(a);\n            }\n        };\n        for (var _i = 0, rest_1 = rest; _i < rest_1.length; _i++) {\n            var a = rest_1[_i];\n            _loop_1(a);\n        }\n        return out;\n    };\n};\n/**\n * Sort the elements of a `NonEmptyArray` in increasing order, where elements are compared using first `ords[0]`, then `ords[1]`,\n * etc...\n *\n * @example\n * import * as NEA from 'fp-ts/NonEmptyArray'\n * import { contramap } from 'fp-ts/Ord'\n * import * as S from 'fp-ts/string'\n * import * as N from 'fp-ts/number'\n * import { pipe } from 'fp-ts/function'\n *\n * interface Person {\n *   name: string\n *   age: number\n * }\n *\n * const byName = pipe(S.Ord, contramap((p: Person) => p.name))\n *\n * const byAge = pipe(N.Ord, contramap((p: Person) => p.age))\n *\n * const sortByNameByAge = NEA.sortBy([byName, byAge])\n *\n * const persons: NEA.NonEmptyArray<Person> = [\n *   { name: 'a', age: 1 },\n *   { name: 'b', age: 3 },\n *   { name: 'c', age: 2 },\n *   { name: 'b', age: 2 }\n * ]\n *\n * assert.deepStrictEqual(sortByNameByAge(persons), [\n *   { name: 'a', age: 1 },\n *   { name: 'b', age: 2 },\n *   { name: 'b', age: 3 },\n *   { name: 'c', age: 2 }\n * ])\n *\n * @since 2.11.0\n */\nexport var sortBy = function (ords) {\n    if (isNonEmpty(ords)) {\n        var M = getMonoid();\n        return sort(ords.reduce(M.concat, M.empty));\n    }\n    return copy;\n};\n/**\n * @since 2.11.0\n */\nexport var union = function (E) {\n    var uniqE = uniq(E);\n    return function (second) { return function (first) { return uniqE(pipe(first, concat(second))); }; };\n};\n/**\n * Rotate a `NonEmptyArray` by `n` steps.\n *\n * @example\n * import { rotate } from 'fp-ts/NonEmptyArray'\n *\n * assert.deepStrictEqual(rotate(2)([1, 2, 3, 4, 5]), [4, 5, 1, 2, 3])\n * assert.deepStrictEqual(rotate(-2)([1, 2, 3, 4, 5]), [3, 4, 5, 1, 2])\n *\n * @since 2.11.0\n */\nexport var rotate = function (n) {\n    return function (as) {\n        var len = as.length;\n        var m = Math.round(n) % len;\n        if (isOutOfBound(Math.abs(m), as) || m === 0) {\n            return copy(as);\n        }\n        if (m < 0) {\n            var _a = splitAt(-m)(as), f = _a[0], s = _a[1];\n            return pipe(s, concat(f));\n        }\n        else {\n            return rotate(m - len)(as);\n        }\n    };\n};\n// -------------------------------------------------------------------------------------\n// constructors\n// -------------------------------------------------------------------------------------\n/**\n * @category conversions\n * @since 2.10.0\n */\nexport var fromReadonlyNonEmptyArray = _.fromReadonlyNonEmptyArray;\n/**\n * Builds a `NonEmptyArray` from an `Array` returning `none` if `as` is an empty array\n *\n * @category conversions\n * @since 2.0.0\n */\nexport var fromArray = function (as) { return (isNonEmpty(as) ? _.some(as) : _.none); };\n/**\n * Return a `NonEmptyArray` of length `n` with element `i` initialized with `f(i)`.\n *\n * **Note**. `n` is normalized to a natural number.\n *\n * @example\n * import { makeBy } from 'fp-ts/NonEmptyArray'\n * import { pipe } from 'fp-ts/function'\n *\n * const double = (n: number): number => n * 2\n * assert.deepStrictEqual(pipe(5, makeBy(double)), [0, 2, 4, 6, 8])\n *\n * @category constructors\n * @since 2.11.0\n */\nexport var makeBy = function (f) {\n    return function (n) {\n        var j = Math.max(0, Math.floor(n));\n        var out = [f(0)];\n        for (var i = 1; i < j; i++) {\n            out.push(f(i));\n        }\n        return out;\n    };\n};\n/**\n * Create a `NonEmptyArray` containing a value repeated the specified number of times.\n *\n * **Note**. `n` is normalized to a natural number.\n *\n * @example\n * import { replicate } from 'fp-ts/NonEmptyArray'\n * import { pipe } from 'fp-ts/function'\n *\n * assert.deepStrictEqual(pipe(3, replicate('a')), ['a', 'a', 'a'])\n *\n * @category constructors\n * @since 2.11.0\n */\nexport var replicate = function (a) { return makeBy(function () { return a; }); };\n/**\n * Create a `NonEmptyArray` containing a range of integers, including both endpoints.\n *\n * @example\n * import { range } from 'fp-ts/NonEmptyArray'\n *\n * assert.deepStrictEqual(range(1, 5), [1, 2, 3, 4, 5])\n *\n * @category constructors\n * @since 2.11.0\n */\nexport var range = function (start, end) {\n    return start <= end ? makeBy(function (i) { return start + i; })(end - start + 1) : [start];\n};\n/**\n * Return the tuple of the `head` and the `tail`.\n *\n * @example\n * import { unprepend } from 'fp-ts/NonEmptyArray'\n *\n * assert.deepStrictEqual(unprepend([1, 2, 3]), [1, [2, 3]])\n *\n * @since 2.9.0\n */\nexport var unprepend = function (as) { return [head(as), tail(as)]; };\n/**\n * Return the tuple of the `init` and the `last`.\n *\n * @example\n * import { unappend } from 'fp-ts/NonEmptyArray'\n *\n * assert.deepStrictEqual(unappend([1, 2, 3, 4]), [[1, 2, 3], 4])\n *\n * @since 2.9.0\n */\nexport var unappend = function (as) { return [init(as), last(as)]; };\nexport function concatW(second) {\n    return function (first) { return first.concat(second); };\n}\nexport function concat(x, y) {\n    return y ? x.concat(y) : function (y) { return y.concat(x); };\n}\n/**\n * @since 2.0.0\n */\nexport var reverse = function (as) { return __spreadArray([last(as)], as.slice(0, -1).reverse(), true); };\nexport function group(E) {\n    return function (as) {\n        var len = as.length;\n        if (len === 0) {\n            return [];\n        }\n        var out = [];\n        var head = as[0];\n        var nea = [head];\n        for (var i = 1; i < len; i++) {\n            var a = as[i];\n            if (E.equals(a, head)) {\n                nea.push(a);\n            }\n            else {\n                out.push(nea);\n                head = a;\n                nea = [head];\n            }\n        }\n        out.push(nea);\n        return out;\n    };\n}\n/**\n * Splits an array into sub-non-empty-arrays stored in an object, based on the result of calling a `string`-returning\n * function on each element, and grouping the results according to values returned\n *\n * @example\n * import { groupBy } from 'fp-ts/NonEmptyArray'\n *\n * assert.deepStrictEqual(groupBy((s: string) => String(s.length))(['a', 'b', 'ab']), {\n *   '1': ['a', 'b'],\n *   '2': ['ab']\n * })\n *\n * @since 2.0.0\n */\nexport var groupBy = function (f) {\n    return function (as) {\n        var out = {};\n        for (var _i = 0, as_1 = as; _i < as_1.length; _i++) {\n            var a = as_1[_i];\n            var k = f(a);\n            if (_.has.call(out, k)) {\n                out[k].push(a);\n            }\n            else {\n                out[k] = [a];\n            }\n        }\n        return out;\n    };\n};\n/**\n * @since 2.0.0\n */\nexport var sort = function (O) {\n    return function (as) {\n        return as.slice().sort(O.compare);\n    };\n};\n/**\n * @since 2.0.0\n */\nexport var insertAt = function (i, a) {\n    return function (as) {\n        return i < 0 || i > as.length ? _.none : _.some(unsafeInsertAt(i, a, as));\n    };\n};\n/**\n * @since 2.0.0\n */\nexport var updateAt = function (i, a) {\n    return modifyAt(i, function () { return a; });\n};\n/**\n * @since 2.0.0\n */\nexport var modifyAt = function (i, f) {\n    return function (as) {\n        return isOutOfBound(i, as) ? _.none : _.some(unsafeUpdateAt(i, f(as[i]), as));\n    };\n};\n/**\n * @since 2.0.0\n */\nexport var copy = fromReadonlyNonEmptyArray;\n/**\n * @category constructors\n * @since 2.0.0\n */\nexport var of = function (a) { return [a]; };\n/**\n * @since 2.5.1\n */\nexport var zipWith = function (as, bs, f) {\n    var cs = [f(as[0], bs[0])];\n    var len = Math.min(as.length, bs.length);\n    for (var i = 1; i < len; i++) {\n        cs[i] = f(as[i], bs[i]);\n    }\n    return cs;\n};\nexport function zip(as, bs) {\n    if (bs === undefined) {\n        return function (bs) { return zip(bs, as); };\n    }\n    return zipWith(as, bs, function (a, b) { return [a, b]; });\n}\n/**\n * @since 2.5.1\n */\nexport var unzip = function (abs) {\n    var fa = [abs[0][0]];\n    var fb = [abs[0][1]];\n    for (var i = 1; i < abs.length; i++) {\n        fa[i] = abs[i][0];\n        fb[i] = abs[i][1];\n    }\n    return [fa, fb];\n};\n/**\n * Prepend an element to every member of an array\n *\n * @example\n * import { prependAll } from 'fp-ts/NonEmptyArray'\n *\n * assert.deepStrictEqual(prependAll(9)([1, 2, 3, 4]), [9, 1, 9, 2, 9, 3, 9, 4])\n *\n * @since 2.10.0\n */\nexport var prependAll = function (middle) {\n    return function (as) {\n        var out = [middle, as[0]];\n        for (var i = 1; i < as.length; i++) {\n            out.push(middle, as[i]);\n        }\n        return out;\n    };\n};\n/**\n * Places an element in between members of an array\n *\n * @example\n * import { intersperse } from 'fp-ts/NonEmptyArray'\n *\n * assert.deepStrictEqual(intersperse(9)([1, 2, 3, 4]), [1, 9, 2, 9, 3, 9, 4])\n *\n * @since 2.9.0\n */\nexport var intersperse = function (middle) {\n    return function (as) {\n        var rest = tail(as);\n        return isNonEmpty(rest) ? pipe(rest, prependAll(middle), prepend(head(as))) : copy(as);\n    };\n};\n/**\n * @category folding\n * @since 2.0.0\n */\nexport var foldMapWithIndex = RNEA.foldMapWithIndex;\n/**\n * @category folding\n * @since 2.0.0\n */\nexport var foldMap = RNEA.foldMap;\n/**\n * @category sequencing\n * @since 2.10.0\n */\nexport var chainWithIndex = function (f) {\n    return function (as) {\n        var out = fromReadonlyNonEmptyArray(f(0, head(as)));\n        for (var i = 1; i < as.length; i++) {\n            var bs = f(i, as[i]);\n            for (var j = 0; j < bs.length; j++) {\n                out.push(bs[j]);\n            }\n        }\n        return out;\n    };\n};\n/**\n * @since 2.10.0\n */\nexport var chop = function (f) {\n    return function (as) {\n        var _a = f(as), b = _a[0], rest = _a[1];\n        var out = [b];\n        var next = rest;\n        while (isNonEmpty(next)) {\n            var _b = f(next), b_1 = _b[0], rest_2 = _b[1];\n            out.push(b_1);\n            next = rest_2;\n        }\n        return out;\n    };\n};\n/**\n * Splits a `NonEmptyArray` into two pieces, the first piece has max `n` elements.\n *\n * @since 2.10.0\n */\nexport var splitAt = function (n) {\n    return function (as) {\n        var m = Math.max(1, n);\n        return m >= as.length ? [copy(as), []] : [pipe(as.slice(1, m), prepend(head(as))), as.slice(m)];\n    };\n};\n/**\n * @since 2.10.0\n */\nexport var chunksOf = function (n) { return chop(splitAt(n)); };\n/* istanbul ignore next */\nvar _map = function (fa, f) { return pipe(fa, map(f)); };\n/* istanbul ignore next */\nvar _mapWithIndex = function (fa, f) { return pipe(fa, mapWithIndex(f)); };\n/* istanbul ignore next */\nvar _ap = function (fab, fa) { return pipe(fab, ap(fa)); };\n/* istanbul ignore next */\nvar _extend = function (wa, f) { return pipe(wa, extend(f)); };\n/* istanbul ignore next */\nvar _reduce = function (fa, b, f) { return pipe(fa, reduce(b, f)); };\n/* istanbul ignore next */\nvar _foldMap = function (M) {\n    var foldMapM = foldMap(M);\n    return function (fa, f) { return pipe(fa, foldMapM(f)); };\n};\n/* istanbul ignore next */\nvar _reduceRight = function (fa, b, f) { return pipe(fa, reduceRight(b, f)); };\n/* istanbul ignore next */\nvar _traverse = function (F) {\n    var traverseF = traverse(F);\n    return function (ta, f) { return pipe(ta, traverseF(f)); };\n};\n/* istanbul ignore next */\nvar _alt = function (fa, that) { return pipe(fa, alt(that)); };\n/* istanbul ignore next */\nvar _reduceWithIndex = function (fa, b, f) {\n    return pipe(fa, reduceWithIndex(b, f));\n};\n/* istanbul ignore next */\nvar _foldMapWithIndex = function (M) {\n    var foldMapWithIndexM = foldMapWithIndex(M);\n    return function (fa, f) { return pipe(fa, foldMapWithIndexM(f)); };\n};\n/* istanbul ignore next */\nvar _reduceRightWithIndex = function (fa, b, f) {\n    return pipe(fa, reduceRightWithIndex(b, f));\n};\n/* istanbul ignore next */\nvar _traverseWithIndex = function (F) {\n    var traverseWithIndexF = traverseWithIndex(F);\n    return function (ta, f) { return pipe(ta, traverseWithIndexF(f)); };\n};\n/**\n * Less strict version of [`alt`](#alt).\n *\n * The `W` suffix (short for **W**idening) means that the return types will be merged.\n *\n * @example\n * import * as NEA from 'fp-ts/NonEmptyArray'\n * import { pipe } from 'fp-ts/function'\n *\n * assert.deepStrictEqual(\n *   pipe(\n *     [1, 2, 3] as NEA.NonEmptyArray<number>,\n *     NEA.altW(() => ['a', 'b'])\n *   ),\n *   [1, 2, 3, 'a', 'b']\n * )\n *\n * @category error handling\n * @since 2.9.0\n */\nexport var altW = function (that) {\n    return function (as) {\n        return pipe(as, concatW(that()));\n    };\n};\n/**\n * Identifies an associative operation on a type constructor. It is similar to `Semigroup`, except that it applies to\n * types of kind `* -> *`.\n *\n * In case of `NonEmptyArray` concatenates the inputs into a single array.\n *\n * @example\n * import * as NEA from 'fp-ts/NonEmptyArray'\n * import { pipe } from 'fp-ts/function'\n *\n * assert.deepStrictEqual(\n *   pipe(\n *     [1, 2, 3],\n *     NEA.alt(() => [4, 5])\n *   ),\n *   [1, 2, 3, 4, 5]\n * )\n *\n * @category error handling\n * @since 2.6.2\n */\nexport var alt = altW;\n/**\n * Apply a function to an argument under a type constructor.\n *\n * @since 2.0.0\n */\nexport var ap = function (as) {\n    return flatMap(function (f) { return pipe(as, map(f)); });\n};\n/**\n * @example\n * import * as NEA from 'fp-ts/NonEmptyArray'\n * import { pipe } from 'fp-ts/function'\n *\n * assert.deepStrictEqual(\n *   pipe(\n *     [1, 2, 3],\n *     NEA.flatMap((n) => [`a${n}`, `b${n}`])\n *   ),\n *   ['a1', 'b1', 'a2', 'b2', 'a3', 'b3']\n * )\n *\n * @category sequencing\n * @since 2.14.0\n */\nexport var flatMap = /*#__PURE__*/ dual(2, function (ma, f) {\n    return pipe(ma, chainWithIndex(function (i, a) { return f(a, i); }));\n});\n/**\n * @since 2.0.0\n */\nexport var extend = function (f) {\n    return function (as) {\n        var next = tail(as);\n        var out = [f(as)];\n        while (isNonEmpty(next)) {\n            out.push(f(next));\n            next = tail(next);\n        }\n        return out;\n    };\n};\n/**\n * @since 2.5.0\n */\nexport var duplicate = /*#__PURE__*/ extend(identity);\n/**\n * @category sequencing\n * @since 2.5.0\n */\nexport var flatten = /*#__PURE__*/ flatMap(identity);\n/**\n * `map` can be used to turn functions `(a: A) => B` into functions `(fa: F<A>) => F<B>` whose argument and return types\n * use the type constructor `F` to represent some computational context.\n *\n * @category mapping\n * @since 2.0.0\n */\nexport var map = function (f) { return mapWithIndex(function (_, a) { return f(a); }); };\n/**\n * @category mapping\n * @since 2.0.0\n */\nexport var mapWithIndex = function (f) {\n    return function (as) {\n        var out = [f(0, head(as))];\n        for (var i = 1; i < as.length; i++) {\n            out.push(f(i, as[i]));\n        }\n        return out;\n    };\n};\n/**\n * @category folding\n * @since 2.0.0\n */\nexport var reduce = RNEA.reduce;\n/**\n * @category folding\n * @since 2.0.0\n */\nexport var reduceWithIndex = RNEA.reduceWithIndex;\n/**\n * @category folding\n * @since 2.0.0\n */\nexport var reduceRight = RNEA.reduceRight;\n/**\n * @category folding\n * @since 2.0.0\n */\nexport var reduceRightWithIndex = RNEA.reduceRightWithIndex;\n/**\n * @category traversing\n * @since 2.6.3\n */\nexport var traverse = function (F) {\n    var traverseWithIndexF = traverseWithIndex(F);\n    return function (f) { return traverseWithIndexF(function (_, a) { return f(a); }); };\n};\n/**\n * @category traversing\n * @since 2.6.3\n */\nexport var sequence = function (F) { return traverseWithIndex(F)(function (_, a) { return a; }); };\n/**\n * @category sequencing\n * @since 2.6.3\n */\nexport var traverseWithIndex = function (F) {\n    return function (f) {\n        return function (as) {\n            var out = F.map(f(0, head(as)), of);\n            for (var i = 1; i < as.length; i++) {\n                out = F.ap(F.map(out, function (bs) { return function (b) { return pipe(bs, append(b)); }; }), f(i, as[i]));\n            }\n            return out;\n        };\n    };\n};\n/**\n * @since 2.7.0\n */\nexport var extract = RNEA.head;\n/**\n * @category type lambdas\n * @since 2.0.0\n */\nexport var URI = 'NonEmptyArray';\n/**\n * @category instances\n * @since 2.0.0\n */\nexport var getShow = RNEA.getShow;\n/**\n * Builds a `Semigroup` instance for `NonEmptyArray`\n *\n * @category instances\n * @since 2.0.0\n */\nexport var getSemigroup = function () { return ({\n    concat: concat\n}); };\n/**\n * @example\n * import { getEq } from 'fp-ts/NonEmptyArray'\n * import * as N from 'fp-ts/number'\n *\n * const E = getEq(N.Eq)\n * assert.strictEqual(E.equals([1, 2], [1, 2]), true)\n * assert.strictEqual(E.equals([1, 2], [1, 3]), false)\n *\n * @category instances\n * @since 2.0.0\n */\nexport var getEq = RNEA.getEq;\n/**\n * @since 2.11.0\n */\nexport var getUnionSemigroup = function (E) {\n    var unionE = union(E);\n    return {\n        concat: function (first, second) { return unionE(second)(first); }\n    };\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Functor = {\n    URI: URI,\n    map: _map\n};\n/**\n * @category mapping\n * @since 2.10.0\n */\nexport var flap = /*#__PURE__*/ flap_(Functor);\n/**\n * @category instances\n * @since 2.10.0\n */\nexport var Pointed = {\n    URI: URI,\n    of: of\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var FunctorWithIndex = {\n    URI: URI,\n    map: _map,\n    mapWithIndex: _mapWithIndex\n};\n/**\n * @category instances\n * @since 2.10.0\n */\nexport var Apply = {\n    URI: URI,\n    map: _map,\n    ap: _ap\n};\n/**\n * Combine two effectful actions, keeping only the result of the first.\n *\n * @since 2.5.0\n */\nexport var apFirst = /*#__PURE__*/ apFirst_(Apply);\n/**\n * Combine two effectful actions, keeping only the result of the second.\n *\n * @since 2.5.0\n */\nexport var apSecond = /*#__PURE__*/ apSecond_(Apply);\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Applicative = {\n    URI: URI,\n    map: _map,\n    ap: _ap,\n    of: of\n};\n/**\n * @category instances\n * @since 2.10.0\n */\nexport var Chain = {\n    URI: URI,\n    map: _map,\n    ap: _ap,\n    chain: flatMap\n};\n/**\n * Composes computations in sequence, using the return value of one computation to determine the next computation and\n * keeping only the result of the first.\n *\n * @category sequencing\n * @since 2.5.0\n */\nexport var chainFirst = \n/*#__PURE__*/ chainFirst_(Chain);\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Monad = {\n    URI: URI,\n    map: _map,\n    ap: _ap,\n    of: of,\n    chain: flatMap\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Foldable = {\n    URI: URI,\n    reduce: _reduce,\n    foldMap: _foldMap,\n    reduceRight: _reduceRight\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var FoldableWithIndex = {\n    URI: URI,\n    reduce: _reduce,\n    foldMap: _foldMap,\n    reduceRight: _reduceRight,\n    reduceWithIndex: _reduceWithIndex,\n    foldMapWithIndex: _foldMapWithIndex,\n    reduceRightWithIndex: _reduceRightWithIndex\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Traversable = {\n    URI: URI,\n    map: _map,\n    reduce: _reduce,\n    foldMap: _foldMap,\n    reduceRight: _reduceRight,\n    traverse: _traverse,\n    sequence: sequence\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var TraversableWithIndex = {\n    URI: URI,\n    map: _map,\n    mapWithIndex: _mapWithIndex,\n    reduce: _reduce,\n    foldMap: _foldMap,\n    reduceRight: _reduceRight,\n    traverse: _traverse,\n    sequence: sequence,\n    reduceWithIndex: _reduceWithIndex,\n    foldMapWithIndex: _foldMapWithIndex,\n    reduceRightWithIndex: _reduceRightWithIndex,\n    traverseWithIndex: _traverseWithIndex\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Alt = {\n    URI: URI,\n    map: _map,\n    alt: _alt\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Comonad = {\n    URI: URI,\n    map: _map,\n    extend: _extend,\n    extract: extract\n};\n// -------------------------------------------------------------------------------------\n// do notation\n// -------------------------------------------------------------------------------------\n/**\n * @category do notation\n * @since 2.9.0\n */\nexport var Do = /*#__PURE__*/ of(_.emptyRecord);\n/**\n * @category do notation\n * @since 2.8.0\n */\nexport var bindTo = /*#__PURE__*/ bindTo_(Functor);\nvar let_ = /*#__PURE__*/ let__(Functor);\nexport { \n/**\n * @category do notation\n * @since 2.13.0\n */\nlet_ as let };\n/**\n * @category do notation\n * @since 2.8.0\n */\nexport var bind = /*#__PURE__*/ bind_(Chain);\n/**\n * @category do notation\n * @since 2.8.0\n */\nexport var apS = /*#__PURE__*/ apS_(Apply);\n// -------------------------------------------------------------------------------------\n// utils\n// -------------------------------------------------------------------------------------\n/**\n * @since 2.0.0\n */\nexport var head = RNEA.head;\n/**\n * @since 2.0.0\n */\nexport var tail = function (as) { return as.slice(1); };\n/**\n * @since 2.0.0\n */\nexport var last = RNEA.last;\n/**\n * Get all but the last element of a non empty array, creating a new array.\n *\n * @example\n * import { init } from 'fp-ts/NonEmptyArray'\n *\n * assert.deepStrictEqual(init([1, 2, 3]), [1, 2])\n * assert.deepStrictEqual(init([1]), [])\n *\n * @since 2.2.0\n */\nexport var init = function (as) { return as.slice(0, -1); };\n/**\n * @since 2.0.0\n */\nexport var min = RNEA.min;\n/**\n * @since 2.0.0\n */\nexport var max = RNEA.max;\n/**\n * @since 2.10.0\n */\nexport var concatAll = function (S) {\n    return function (as) {\n        return as.reduce(S.concat);\n    };\n};\n/**\n * Break an `Array` into its first element and remaining elements.\n *\n * @category pattern matching\n * @since 2.11.0\n */\nexport var matchLeft = function (f) {\n    return function (as) {\n        return f(head(as), tail(as));\n    };\n};\n/**\n * Break an `Array` into its initial elements and the last element.\n *\n * @category pattern matching\n * @since 2.11.0\n */\nexport var matchRight = function (f) {\n    return function (as) {\n        return f(init(as), last(as));\n    };\n};\n/**\n * Apply a function to the head, creating a new `NonEmptyArray`.\n *\n * @since 2.11.0\n */\nexport var modifyHead = function (f) {\n    return function (as) {\n        return __spreadArray([f(head(as))], tail(as), true);\n    };\n};\n/**\n * Change the head, creating a new `NonEmptyArray`.\n *\n * @since 2.11.0\n */\nexport var updateHead = function (a) { return modifyHead(function () { return a; }); };\n/**\n * Apply a function to the last element, creating a new `NonEmptyArray`.\n *\n * @since 2.11.0\n */\nexport var modifyLast = function (f) {\n    return function (as) {\n        return pipe(init(as), append(f(last(as))));\n    };\n};\n/**\n * Change the last element, creating a new `NonEmptyArray`.\n *\n * @since 2.11.0\n */\nexport var updateLast = function (a) { return modifyLast(function () { return a; }); };\n/**\n * Places an element in between members of a `NonEmptyArray`, then folds the results using the provided `Semigroup`.\n *\n * @example\n * import * as S from 'fp-ts/string'\n * import { intercalate } from 'fp-ts/NonEmptyArray'\n *\n * assert.deepStrictEqual(intercalate(S.Semigroup)('-')(['a', 'b', 'c']), 'a-b-c')\n *\n * @since 2.12.0\n */\nexport var intercalate = RNEA.intercalate;\n// -------------------------------------------------------------------------------------\n// legacy\n// -------------------------------------------------------------------------------------\n/**\n * Alias of `flatMap`.\n *\n * @category legacy\n * @since 2.0.0\n */\nexport var chain = flatMap;\nexport function groupSort(O) {\n    var sortO = sort(O);\n    var groupO = group(O);\n    return function (as) { return (isNonEmpty(as) ? groupO(sortO(as)) : []); };\n}\nexport function filter(predicate) {\n    return filterWithIndex(function (_, a) { return predicate(a); });\n}\n/**\n * Use [`filterWithIndex`](./Array.ts.html#filterwithindex) instead.\n *\n * @category zone of death\n * @since 2.0.0\n * @deprecated\n */\nexport var filterWithIndex = function (predicate) {\n    return function (as) {\n        return fromArray(as.filter(function (a, i) { return predicate(i, a); }));\n    };\n};\n/**\n * Use [`unprepend`](#unprepend) instead.\n *\n * @category zone of death\n * @since 2.9.0\n * @deprecated\n */\nexport var uncons = unprepend;\n/**\n * Use [`unappend`](#unappend) instead.\n *\n * @category zone of death\n * @since 2.9.0\n * @deprecated\n */\nexport var unsnoc = unappend;\nexport function cons(head, tail) {\n    return tail === undefined ? prepend(head) : pipe(tail, prepend(head));\n}\n/**\n * Use [`append`](./Array.ts.html#append) instead.\n *\n * @category zone of death\n * @since 2.0.0\n * @deprecated\n */\nexport var snoc = function (init, end) { return pipe(init, append(end)); };\n/**\n * Use [`prependAll`](#prependall) instead.\n *\n * @category zone of death\n * @since 2.9.0\n * @deprecated\n */\nexport var prependToAll = prependAll;\n/**\n * Use [`concatAll`](#concatall) instead.\n *\n * @category zone of death\n * @since 2.5.0\n * @deprecated\n */\nexport var fold = RNEA.concatAll;\n/**\n * This instance is deprecated, use small, specific instances instead.\n * For example if a function needs a `Functor` instance, pass `NEA.Functor` instead of `NEA.nonEmptyArray`\n * (where `NEA` is from `import NEA from 'fp-ts/NonEmptyArray'`)\n *\n * @category zone of death\n * @since 2.0.0\n * @deprecated\n */\nexport var nonEmptyArray = {\n    URI: URI,\n    of: of,\n    map: _map,\n    mapWithIndex: _mapWithIndex,\n    ap: _ap,\n    chain: flatMap,\n    extend: _extend,\n    extract: extract,\n    reduce: _reduce,\n    foldMap: _foldMap,\n    reduceRight: _reduceRight,\n    traverse: _traverse,\n    sequence: sequence,\n    reduceWithIndex: _reduceWithIndex,\n    foldMapWithIndex: _foldMapWithIndex,\n    reduceRightWithIndex: _reduceRightWithIndex,\n    traverseWithIndex: _traverseWithIndex,\n    alt: _alt\n};\n","import { getApplicativeMonoid } from './Applicative';\nimport { apFirst as apFirst_, apS as apS_, apSecond as apSecond_, getApplySemigroup as getApplySemigroup_ } from './Apply';\nimport * as chainable from './Chain';\nimport { chainEitherK as chainEitherK_, fromEitherK as fromEitherK_, tapEither as tapEither_ } from './FromEither';\nimport { constNull, constUndefined, dual, flow, identity, pipe } from './function';\nimport { as as as_, asUnit as asUnit_, bindTo as bindTo_, flap as flap_, let as let__ } from './Functor';\nimport * as _ from './internal';\nimport { not } from './Predicate';\nimport { first, last } from './Semigroup';\nimport { separated } from './Separated';\nimport { wiltDefault, witherDefault } from './Witherable';\nimport { guard as guard_ } from './Zero';\n// -------------------------------------------------------------------------------------\n// constructors\n// -------------------------------------------------------------------------------------\n/**\n * `None` doesn't have a constructor, instead you can use it directly as a value. Represents a missing value.\n *\n * @category constructors\n * @since 2.0.0\n */\nexport var none = _.none;\n/**\n * Constructs a `Some`. Represents an optional value that exists.\n *\n * @category constructors\n * @since 2.0.0\n */\nexport var some = _.some;\nexport function fromPredicate(predicate) {\n    return function (a) { return (predicate(a) ? some(a) : none); };\n}\n/**\n * Returns the `Left` value of an `Either` if possible.\n *\n * @example\n * import { getLeft, none, some } from 'fp-ts/Option'\n * import { right, left } from 'fp-ts/Either'\n *\n * assert.deepStrictEqual(getLeft(right(1)), none)\n * assert.deepStrictEqual(getLeft(left('a')), some('a'))\n *\n * @category constructors\n * @since 2.0.0\n */\nexport var getLeft = function (ma) { return (ma._tag === 'Right' ? none : some(ma.left)); };\n/**\n * Returns the `Right` value of an `Either` if possible.\n *\n * @example\n * import { getRight, none, some } from 'fp-ts/Option'\n * import { right, left } from 'fp-ts/Either'\n *\n * assert.deepStrictEqual(getRight(right(1)), some(1))\n * assert.deepStrictEqual(getRight(left('a')), none)\n *\n * @category constructors\n * @since 2.0.0\n */\nexport var getRight = function (ma) { return (ma._tag === 'Left' ? none : some(ma.right)); };\nvar _map = function (fa, f) { return pipe(fa, map(f)); };\nvar _ap = function (fab, fa) { return pipe(fab, ap(fa)); };\nvar _reduce = function (fa, b, f) { return pipe(fa, reduce(b, f)); };\nvar _foldMap = function (M) {\n    var foldMapM = foldMap(M);\n    return function (fa, f) { return pipe(fa, foldMapM(f)); };\n};\nvar _reduceRight = function (fa, b, f) { return pipe(fa, reduceRight(b, f)); };\nvar _traverse = function (F) {\n    var traverseF = traverse(F);\n    return function (ta, f) { return pipe(ta, traverseF(f)); };\n};\n/* istanbul ignore next */\nvar _alt = function (fa, that) { return pipe(fa, alt(that)); };\nvar _filter = function (fa, predicate) { return pipe(fa, filter(predicate)); };\n/* istanbul ignore next */\nvar _filterMap = function (fa, f) { return pipe(fa, filterMap(f)); };\n/* istanbul ignore next */\nvar _extend = function (wa, f) { return pipe(wa, extend(f)); };\n/* istanbul ignore next */\nvar _partition = function (fa, predicate) {\n    return pipe(fa, partition(predicate));\n};\n/* istanbul ignore next */\nvar _partitionMap = function (fa, f) { return pipe(fa, partitionMap(f)); };\n/**\n * @category type lambdas\n * @since 2.0.0\n */\nexport var URI = 'Option';\n/**\n * @category instances\n * @since 2.0.0\n */\nexport var getShow = function (S) { return ({\n    show: function (ma) { return (isNone(ma) ? 'none' : \"some(\".concat(S.show(ma.value), \")\")); }\n}); };\n/**\n * @example\n * import { none, some, getEq } from 'fp-ts/Option'\n * import * as N from 'fp-ts/number'\n *\n * const E = getEq(N.Eq)\n * assert.strictEqual(E.equals(none, none), true)\n * assert.strictEqual(E.equals(none, some(1)), false)\n * assert.strictEqual(E.equals(some(1), none), false)\n * assert.strictEqual(E.equals(some(1), some(2)), false)\n * assert.strictEqual(E.equals(some(1), some(1)), true)\n *\n * @category instances\n * @since 2.0.0\n */\nexport var getEq = function (E) { return ({\n    equals: function (x, y) { return x === y || (isNone(x) ? isNone(y) : isNone(y) ? false : E.equals(x.value, y.value)); }\n}); };\n/**\n * The `Ord` instance allows `Option` values to be compared with\n * `compare`, whenever there is an `Ord` instance for\n * the type the `Option` contains.\n *\n * `None` is considered to be less than any `Some` value.\n *\n *\n * @example\n * import { none, some, getOrd } from 'fp-ts/Option'\n * import * as N from 'fp-ts/number'\n *\n * const O = getOrd(N.Ord)\n * assert.strictEqual(O.compare(none, none), 0)\n * assert.strictEqual(O.compare(none, some(1)), -1)\n * assert.strictEqual(O.compare(some(1), none), 1)\n * assert.strictEqual(O.compare(some(1), some(2)), -1)\n * assert.strictEqual(O.compare(some(1), some(1)), 0)\n *\n * @category instances\n * @since 2.0.0\n */\nexport var getOrd = function (O) { return ({\n    equals: getEq(O).equals,\n    compare: function (x, y) { return (x === y ? 0 : isSome(x) ? (isSome(y) ? O.compare(x.value, y.value) : 1) : -1); }\n}); };\n/**\n * Monoid returning the left-most non-`None` value. If both operands are `Some`s then the inner values are\n * concatenated using the provided `Semigroup`\n *\n * | x       | y       | concat(x, y)       |\n * | ------- | ------- | ------------------ |\n * | none    | none    | none               |\n * | some(a) | none    | some(a)            |\n * | none    | some(b) | some(b)            |\n * | some(a) | some(b) | some(concat(a, b)) |\n *\n * @example\n * import { getMonoid, some, none } from 'fp-ts/Option'\n * import { SemigroupSum } from 'fp-ts/number'\n *\n * const M = getMonoid(SemigroupSum)\n * assert.deepStrictEqual(M.concat(none, none), none)\n * assert.deepStrictEqual(M.concat(some(1), none), some(1))\n * assert.deepStrictEqual(M.concat(none, some(1)), some(1))\n * assert.deepStrictEqual(M.concat(some(1), some(2)), some(3))\n *\n * @category instances\n * @since 2.0.0\n */\nexport var getMonoid = function (S) { return ({\n    concat: function (x, y) { return (isNone(x) ? y : isNone(y) ? x : some(S.concat(x.value, y.value))); },\n    empty: none\n}); };\n/**\n * @category mapping\n * @since 2.0.0\n */\nexport var map = function (f) { return function (fa) {\n    return isNone(fa) ? none : some(f(fa.value));\n}; };\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Functor = {\n    URI: URI,\n    map: _map\n};\n/**\n * Maps the `Some` value of this `Option` to the specified constant value.\n *\n * @category mapping\n * @since 2.16.0\n */\nexport var as = dual(2, as_(Functor));\n/**\n * Maps the `Some` value of this `Option` to the void constant value.\n *\n * @category mapping\n * @since 2.16.0\n */\nexport var asUnit = asUnit_(Functor);\n/**\n * @category constructors\n * @since 2.7.0\n */\nexport var of = some;\n/**\n * @category instances\n * @since 2.10.0\n */\nexport var Pointed = {\n    URI: URI,\n    of: of\n};\n/**\n * @since 2.0.0\n */\nexport var ap = function (fa) { return function (fab) {\n    return isNone(fab) ? none : isNone(fa) ? none : some(fab.value(fa.value));\n}; };\n/**\n * @category instances\n * @since 2.10.0\n */\nexport var Apply = {\n    URI: URI,\n    map: _map,\n    ap: _ap\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Applicative = {\n    URI: URI,\n    map: _map,\n    ap: _ap,\n    of: of\n};\n/**\n * @category sequencing\n * @since 2.14.0\n */\nexport var flatMap = /*#__PURE__*/ dual(2, function (ma, f) { return (isNone(ma) ? none : f(ma.value)); });\n/**\n * @category instances\n * @since 2.10.0\n */\nexport var Chain = {\n    URI: URI,\n    map: _map,\n    ap: _ap,\n    chain: flatMap\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Monad = {\n    URI: URI,\n    map: _map,\n    ap: _ap,\n    of: of,\n    chain: flatMap\n};\n/**\n * @category folding\n * @since 2.0.0\n */\nexport var reduce = function (b, f) { return function (fa) {\n    return isNone(fa) ? b : f(b, fa.value);\n}; };\n/**\n * @category folding\n * @since 2.0.0\n */\nexport var foldMap = function (M) { return function (f) { return function (fa) {\n    return isNone(fa) ? M.empty : f(fa.value);\n}; }; };\n/**\n * @category folding\n * @since 2.0.0\n */\nexport var reduceRight = function (b, f) { return function (fa) {\n    return isNone(fa) ? b : f(fa.value, b);\n}; };\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Foldable = {\n    URI: URI,\n    reduce: _reduce,\n    foldMap: _foldMap,\n    reduceRight: _reduceRight\n};\n/**\n * Returns the provided `Option` `that` if `self` is `None`, otherwise returns `self`.\n *\n * @param self - The first `Option` to be checked.\n * @param that - The `Option` to return if `self` is `None`.\n *\n * @example\n * import * as O from \"fp-ts/Option\"\n *\n * assert.deepStrictEqual(O.orElse(O.none, () => O.none), O.none)\n * assert.deepStrictEqual(O.orElse(O.some(1), () => O.none), O.some(1))\n * assert.deepStrictEqual(O.orElse(O.none, () => O.some('b')), O.some('b'))\n * assert.deepStrictEqual(O.orElse(O.some(1), () => O.some('b')), O.some(1))\n *\n * @category error handling\n * @since 2.16.0\n */\nexport var orElse = dual(2, function (self, that) { return (isNone(self) ? that() : self); });\n/**\n * Alias of `orElse`.\n *\n * Less strict version of [`alt`](#alt).\n *\n * The `W` suffix (short for **W**idening) means that the return types will be merged.\n *\n * @category legacy\n * @since 2.9.0\n */\nexport var altW = orElse;\n/**\n * Alias of `orElse`.\n *\n * @category legacy\n * @since 2.0.0\n */\nexport var alt = orElse;\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Alt = {\n    URI: URI,\n    map: _map,\n    alt: _alt\n};\n/**\n * @since 2.7.0\n */\nexport var zero = function () { return none; };\n/**\n * @category instances\n * @since 2.11.0\n */\nexport var Zero = {\n    URI: URI,\n    zero: zero\n};\n/**\n * @category do notation\n * @since 2.11.0\n */\nexport var guard = /*#__PURE__*/ guard_(Zero, Pointed);\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Alternative = {\n    URI: URI,\n    map: _map,\n    ap: _ap,\n    of: of,\n    alt: _alt,\n    zero: zero\n};\n/**\n * @since 2.0.0\n */\nexport var extend = function (f) { return function (wa) {\n    return isNone(wa) ? none : some(f(wa));\n}; };\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Extend = {\n    URI: URI,\n    map: _map,\n    extend: _extend\n};\n/**\n * @category filtering\n * @since 2.0.0\n */\nexport var compact = /*#__PURE__*/ flatMap(identity);\nvar defaultSeparated = /*#__PURE__*/ separated(none, none);\n/**\n * @category filtering\n * @since 2.0.0\n */\nexport var separate = function (ma) {\n    return isNone(ma) ? defaultSeparated : separated(getLeft(ma.value), getRight(ma.value));\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Compactable = {\n    URI: URI,\n    compact: compact,\n    separate: separate\n};\n/**\n * @category filtering\n * @since 2.0.0\n */\nexport var filter = function (predicate) {\n    return function (fa) {\n        return isNone(fa) ? none : predicate(fa.value) ? fa : none;\n    };\n};\n/**\n * @category filtering\n * @since 2.0.0\n */\nexport var filterMap = function (f) { return function (fa) {\n    return isNone(fa) ? none : f(fa.value);\n}; };\n/**\n * @category filtering\n * @since 2.0.0\n */\nexport var partition = function (predicate) {\n    return function (fa) {\n        return separated(_filter(fa, not(predicate)), _filter(fa, predicate));\n    };\n};\n/**\n * @category filtering\n * @since 2.0.0\n */\nexport var partitionMap = function (f) { return flow(map(f), separate); };\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Filterable = {\n    URI: URI,\n    map: _map,\n    compact: compact,\n    separate: separate,\n    filter: _filter,\n    filterMap: _filterMap,\n    partition: _partition,\n    partitionMap: _partitionMap\n};\n/**\n * @category traversing\n * @since 2.6.3\n */\nexport var traverse = function (F) {\n    return function (f) {\n        return function (ta) {\n            return isNone(ta) ? F.of(none) : F.map(f(ta.value), some);\n        };\n    };\n};\n/**\n * @category traversing\n * @since 2.6.3\n */\nexport var sequence = function (F) {\n    return function (ta) {\n        return isNone(ta) ? F.of(none) : F.map(ta.value, some);\n    };\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Traversable = {\n    URI: URI,\n    map: _map,\n    reduce: _reduce,\n    foldMap: _foldMap,\n    reduceRight: _reduceRight,\n    traverse: _traverse,\n    sequence: sequence\n};\nvar _wither = /*#__PURE__*/ witherDefault(Traversable, Compactable);\nvar _wilt = /*#__PURE__*/ wiltDefault(Traversable, Compactable);\n/**\n * @category filtering\n * @since 2.6.5\n */\nexport var wither = function (F) {\n    var _witherF = _wither(F);\n    return function (f) { return function (fa) { return _witherF(fa, f); }; };\n};\n/**\n * @category filtering\n * @since 2.6.5\n */\nexport var wilt = function (F) {\n    var _wiltF = _wilt(F);\n    return function (f) { return function (fa) { return _wiltF(fa, f); }; };\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Witherable = {\n    URI: URI,\n    map: _map,\n    reduce: _reduce,\n    foldMap: _foldMap,\n    reduceRight: _reduceRight,\n    traverse: _traverse,\n    sequence: sequence,\n    compact: compact,\n    separate: separate,\n    filter: _filter,\n    filterMap: _filterMap,\n    partition: _partition,\n    partitionMap: _partitionMap,\n    wither: _wither,\n    wilt: _wilt\n};\n/**\n * @since 2.7.0\n */\nexport var throwError = function () { return none; };\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var MonadThrow = {\n    URI: URI,\n    map: _map,\n    ap: _ap,\n    of: of,\n    chain: flatMap,\n    throwError: throwError\n};\n/**\n * Transforms an `Either` to an `Option` discarding the error.\n *\n * Alias of [getRight](#getright)\n *\n * @category conversions\n * @since 2.0.0\n */\nexport var fromEither = getRight;\n/**\n * @category instances\n * @since 2.11.0\n */\nexport var FromEither = {\n    URI: URI,\n    fromEither: fromEither\n};\n// -------------------------------------------------------------------------------------\n// refinements\n// -------------------------------------------------------------------------------------\n/**\n * Returns `true` if the option is an instance of `Some`, `false` otherwise.\n *\n * @example\n * import { some, none, isSome } from 'fp-ts/Option'\n *\n * assert.strictEqual(isSome(some(1)), true)\n * assert.strictEqual(isSome(none), false)\n *\n * @category refinements\n * @since 2.0.0\n */\nexport var isSome = _.isSome;\n/**\n * Returns `true` if the option is `None`, `false` otherwise.\n *\n * @example\n * import { some, none, isNone } from 'fp-ts/Option'\n *\n * assert.strictEqual(isNone(some(1)), false)\n * assert.strictEqual(isNone(none), true)\n *\n * @category refinements\n * @since 2.0.0\n */\nexport var isNone = function (fa) { return fa._tag === 'None'; };\n/**\n * Less strict version of [`match`](#match).\n *\n * The `W` suffix (short for **W**idening) means that the handler return types will be merged.\n *\n * @category pattern matching\n * @since 2.10.0\n */\nexport var matchW = function (onNone, onSome) {\n    return function (ma) {\n        return isNone(ma) ? onNone() : onSome(ma.value);\n    };\n};\n/**\n * Alias of [`matchW`](#matchw).\n *\n * @category pattern matching\n * @since 2.10.0\n */\nexport var foldW = matchW;\n/**\n * Takes a (lazy) default value, a function, and an `Option` value, if the `Option` value is `None` the default value is\n * returned, otherwise the function is applied to the value inside the `Some` and the result is returned.\n *\n * @example\n * import { some, none, match } from 'fp-ts/Option'\n * import { pipe } from 'fp-ts/function'\n *\n * assert.strictEqual(\n *   pipe(\n *     some(1),\n *     match(() => 'a none', a => `a some containing ${a}`)\n *   ),\n *   'a some containing 1'\n * )\n *\n * assert.strictEqual(\n *   pipe(\n *     none,\n *     match(() => 'a none', a => `a some containing ${a}`)\n *   ),\n *   'a none'\n * )\n *\n * @category pattern matching\n * @since 2.10.0\n */\nexport var match = matchW;\n/**\n * Alias of [`match`](#match).\n *\n * @category pattern matching\n * @since 2.0.0\n */\nexport var fold = match;\n/**\n * Less strict version of [`getOrElse`](#getorelse).\n *\n * The `W` suffix (short for **W**idening) means that the handler return type will be merged.\n *\n * @category error handling\n * @since 2.6.0\n */\nexport var getOrElseW = function (onNone) {\n    return function (ma) {\n        return isNone(ma) ? onNone() : ma.value;\n    };\n};\n/**\n * Extracts the value out of the structure, if it exists. Otherwise returns the given default value\n *\n * @example\n * import { some, none, getOrElse } from 'fp-ts/Option'\n * import { pipe } from 'fp-ts/function'\n *\n * assert.strictEqual(\n *   pipe(\n *     some(1),\n *     getOrElse(() => 0)\n *   ),\n *   1\n * )\n * assert.strictEqual(\n *   pipe(\n *     none,\n *     getOrElse(() => 0)\n *   ),\n *   0\n * )\n *\n * @category error handling\n * @since 2.0.0\n */\nexport var getOrElse = getOrElseW;\n/**\n * @category mapping\n * @since 2.10.0\n */\nexport var flap = /*#__PURE__*/ flap_(Functor);\n/**\n * Combine two effectful actions, keeping only the result of the first.\n *\n * @since 2.0.0\n */\nexport var apFirst = /*#__PURE__*/ apFirst_(Apply);\n/**\n * Combine two effectful actions, keeping only the result of the second.\n *\n * @since 2.0.0\n */\nexport var apSecond = /*#__PURE__*/ apSecond_(Apply);\n/**\n * @category sequencing\n * @since 2.0.0\n */\nexport var flatten = compact;\n/**\n * Composes computations in sequence, using the return value of one computation to determine the next computation and\n * keeping only the result of the first.\n *\n * @category combinators\n * @since 2.15.0\n */\nexport var tap = /*#__PURE__*/ dual(2, chainable.tap(Chain));\n/**\n * Composes computations in sequence, using the return value of one computation to determine the next computation and\n * keeping only the result of the first.\n *\n * @example\n * import { pipe } from 'fp-ts/function'\n * import * as O from 'fp-ts/Option'\n * import * as E from 'fp-ts/Either'\n *\n * const compute = (value: number) => pipe(\n *   O.of(value),\n *   O.tapEither((value) => value > 0 ? E.right('ok') : E.left('error')),\n * )\n *\n * assert.deepStrictEqual(compute(1), O.of(1))\n * assert.deepStrictEqual(compute(-42), O.none)\n *\n * @category combinators\n * @since 2.16.0\n */\nexport var tapEither = /*#__PURE__*/ dual(2, tapEither_(FromEither, Chain));\n/**\n * @since 2.0.0\n */\nexport var duplicate = /*#__PURE__*/ extend(identity);\n/**\n * @category lifting\n * @since 2.11.0\n */\nexport var fromEitherK = /*#__PURE__*/ fromEitherK_(FromEither);\n/**\n * @category sequencing\n * @since 2.11.0\n */\nexport var chainEitherK = \n/*#__PURE__*/ chainEitherK_(FromEither, Chain);\n/**\n * Alias of `tapEither`.\n *\n * @category legacy\n * @since 2.12.0\n */\nexport var chainFirstEitherK = tapEither;\n/**\n * Constructs a new `Option` from a nullable type. If the value is `null` or `undefined`, returns `None`, otherwise\n * returns the value wrapped in a `Some`.\n *\n * @example\n * import { none, some, fromNullable } from 'fp-ts/Option'\n *\n * assert.deepStrictEqual(fromNullable(undefined), none)\n * assert.deepStrictEqual(fromNullable(null), none)\n * assert.deepStrictEqual(fromNullable(1), some(1))\n *\n * @category conversions\n * @since 2.0.0\n */\nexport var fromNullable = function (a) { return (a == null ? none : some(a)); };\n/**\n * Transforms an exception into an `Option`. If `f` throws, returns `None`, otherwise returns the output wrapped in a\n * `Some`.\n *\n * See also [`tryCatchK`](#trycatchk).\n *\n * @example\n * import { none, some, tryCatch } from 'fp-ts/Option'\n *\n * assert.deepStrictEqual(\n *   tryCatch(() => {\n *     throw new Error()\n *   }),\n *   none\n * )\n * assert.deepStrictEqual(tryCatch(() => 1), some(1))\n *\n * @category interop\n * @since 2.0.0\n */\nexport var tryCatch = function (f) {\n    try {\n        return some(f());\n    }\n    catch (e) {\n        return none;\n    }\n};\n/**\n * Converts a function that may throw to one returning a `Option`.\n *\n * @category interop\n * @since 2.10.0\n */\nexport var tryCatchK = function (f) {\n    return function () {\n        var a = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            a[_i] = arguments[_i];\n        }\n        return tryCatch(function () { return f.apply(void 0, a); });\n    };\n};\n/**\n * Returns a *smart constructor* from a function that returns a nullable value.\n *\n * @example\n * import { fromNullableK, none, some } from 'fp-ts/Option'\n *\n * const f = (s: string): number | undefined => {\n *   const n = parseFloat(s)\n *   return isNaN(n) ? undefined : n\n * }\n *\n * const g = fromNullableK(f)\n *\n * assert.deepStrictEqual(g('1'), some(1))\n * assert.deepStrictEqual(g('a'), none)\n *\n * @category lifting\n * @since 2.9.0\n */\nexport var fromNullableK = function (f) { return flow(f, fromNullable); };\n/**\n * This is `chain` + `fromNullable`, useful when working with optional values.\n *\n * @example\n * import { some, none, fromNullable, chainNullableK } from 'fp-ts/Option'\n * import { pipe } from 'fp-ts/function'\n *\n * interface Employee {\n *   readonly company?: {\n *     readonly address?: {\n *       readonly street?: {\n *         readonly name?: string\n *       }\n *     }\n *   }\n * }\n *\n * const employee1: Employee = { company: { address: { street: { name: 'high street' } } } }\n *\n * assert.deepStrictEqual(\n *   pipe(\n *     fromNullable(employee1.company),\n *     chainNullableK(company => company.address),\n *     chainNullableK(address => address.street),\n *     chainNullableK(street => street.name)\n *   ),\n *   some('high street')\n * )\n *\n * const employee2: Employee = { company: { address: { street: {} } } }\n *\n * assert.deepStrictEqual(\n *   pipe(\n *     fromNullable(employee2.company),\n *     chainNullableK(company => company.address),\n *     chainNullableK(address => address.street),\n *     chainNullableK(street => street.name)\n *   ),\n *   none\n * )\n *\n * @category sequencing\n * @since 2.9.0\n */\nexport var chainNullableK = function (f) {\n    return function (ma) {\n        return isNone(ma) ? none : fromNullable(f(ma.value));\n    };\n};\n/**\n * Extracts the value out of the structure, if it exists. Otherwise returns `null`.\n *\n * @example\n * import { some, none, toNullable } from 'fp-ts/Option'\n * import { pipe } from 'fp-ts/function'\n *\n * assert.strictEqual(\n *   pipe(\n *     some(1),\n *     toNullable\n *   ),\n *   1\n * )\n * assert.strictEqual(\n *   pipe(\n *     none,\n *     toNullable\n *   ),\n *   null\n * )\n *\n * @category conversions\n * @since 2.0.0\n */\nexport var toNullable = /*#__PURE__*/ match(constNull, identity);\n/**\n * Extracts the value out of the structure, if it exists. Otherwise returns `undefined`.\n *\n * @example\n * import { some, none, toUndefined } from 'fp-ts/Option'\n * import { pipe } from 'fp-ts/function'\n *\n * assert.strictEqual(\n *   pipe(\n *     some(1),\n *     toUndefined\n *   ),\n *   1\n * )\n * assert.strictEqual(\n *   pipe(\n *     none,\n *     toUndefined\n *   ),\n *   undefined\n * )\n *\n * @category conversions\n * @since 2.0.0\n */\nexport var toUndefined = /*#__PURE__*/ match(constUndefined, identity);\nexport function elem(E) {\n    return function (a, ma) {\n        if (ma === undefined) {\n            var elemE_1 = elem(E);\n            return function (ma) { return elemE_1(a, ma); };\n        }\n        return isNone(ma) ? false : E.equals(a, ma.value);\n    };\n}\n/**\n * Returns `true` if the predicate is satisfied by the wrapped value\n *\n * @example\n * import { some, none, exists } from 'fp-ts/Option'\n * import { pipe } from 'fp-ts/function'\n *\n * assert.strictEqual(\n *   pipe(\n *     some(1),\n *     exists(n => n > 0)\n *   ),\n *   true\n * )\n * assert.strictEqual(\n *   pipe(\n *     some(1),\n *     exists(n => n > 1)\n *   ),\n *   false\n * )\n * assert.strictEqual(\n *   pipe(\n *     none,\n *     exists(n => n > 0)\n *   ),\n *   false\n * )\n *\n * @since 2.0.0\n */\nexport var exists = function (predicate) {\n    return function (ma) {\n        return isNone(ma) ? false : predicate(ma.value);\n    };\n};\n// -------------------------------------------------------------------------------------\n// do notation\n// -------------------------------------------------------------------------------------\n/**\n * @category do notation\n * @since 2.9.0\n */\nexport var Do = /*#__PURE__*/ of(_.emptyRecord);\n/**\n * @category do notation\n * @since 2.8.0\n */\nexport var bindTo = /*#__PURE__*/ bindTo_(Functor);\nvar let_ = /*#__PURE__*/ let__(Functor);\nexport { \n/**\n * @category do notation\n * @since 2.13.0\n */\nlet_ as let };\n/**\n * @category do notation\n * @since 2.8.0\n */\nexport var bind = /*#__PURE__*/ chainable.bind(Chain);\n/**\n * @category do notation\n * @since 2.8.0\n */\nexport var apS = /*#__PURE__*/ apS_(Apply);\n/**\n * @since 2.11.0\n */\nexport var ApT = /*#__PURE__*/ of(_.emptyReadonlyArray);\n// -------------------------------------------------------------------------------------\n// array utils\n// -------------------------------------------------------------------------------------\n/**\n * Equivalent to `ReadonlyNonEmptyArray#traverseWithIndex(Applicative)`.\n *\n * @category traversing\n * @since 2.11.0\n */\nexport var traverseReadonlyNonEmptyArrayWithIndex = function (f) {\n    return function (as) {\n        var o = f(0, _.head(as));\n        if (isNone(o)) {\n            return none;\n        }\n        var out = [o.value];\n        for (var i = 1; i < as.length; i++) {\n            var o_1 = f(i, as[i]);\n            if (isNone(o_1)) {\n                return none;\n            }\n            out.push(o_1.value);\n        }\n        return some(out);\n    };\n};\n/**\n * Equivalent to `ReadonlyArray#traverseWithIndex(Applicative)`.\n *\n * @category traversing\n * @since 2.11.0\n */\nexport var traverseReadonlyArrayWithIndex = function (f) {\n    var g = traverseReadonlyNonEmptyArrayWithIndex(f);\n    return function (as) { return (_.isNonEmpty(as) ? g(as) : ApT); };\n};\n/**\n * Equivalent to `ReadonlyArray#traverseWithIndex(Applicative)`.\n *\n * @category traversing\n * @since 2.9.0\n */\nexport var traverseArrayWithIndex = traverseReadonlyArrayWithIndex;\n/**\n * Equivalent to `ReadonlyArray#traverse(Applicative)`.\n *\n * @category traversing\n * @since 2.9.0\n */\nexport var traverseArray = function (f) {\n    return traverseReadonlyArrayWithIndex(function (_, a) { return f(a); });\n};\n/**\n * Equivalent to `ReadonlyArray#sequence(Applicative)`.\n *\n * @category traversing\n * @since 2.9.0\n */\nexport var sequenceArray = \n/*#__PURE__*/ traverseArray(identity);\n// -------------------------------------------------------------------------------------\n// legacy\n// -------------------------------------------------------------------------------------\n/**\n * Alias of `flatMap`.\n *\n * @category legacy\n * @since 2.0.0\n */\nexport var chain = flatMap;\n/**\n * Alias of `tap`.\n *\n * @category legacy\n * @since 2.0.0\n */\nexport var chainFirst = tap;\n// -------------------------------------------------------------------------------------\n// deprecated\n// -------------------------------------------------------------------------------------\n/**\n * Use `Refinement` module instead.\n *\n * @category zone of death\n * @since 2.0.0\n * @deprecated\n */\nexport function getRefinement(getOption) {\n    return function (a) { return isSome(getOption(a)); };\n}\n/**\n * Use [`chainNullableK`](#chainnullablek) instead.\n *\n * @category zone of death\n * @since 2.0.0\n * @deprecated\n */\nexport var mapNullable = chainNullableK;\n/**\n * This instance is deprecated, use small, specific instances instead.\n * For example if a function needs a `Functor` instance, pass `O.Functor` instead of `O.option`\n * (where `O` is from `import O from 'fp-ts/Option'`)\n *\n * @category zone of death\n * @since 2.0.0\n * @deprecated\n */\nexport var option = {\n    URI: URI,\n    map: _map,\n    of: of,\n    ap: _ap,\n    chain: flatMap,\n    reduce: _reduce,\n    foldMap: _foldMap,\n    reduceRight: _reduceRight,\n    traverse: _traverse,\n    sequence: sequence,\n    zero: zero,\n    alt: _alt,\n    extend: _extend,\n    compact: compact,\n    separate: separate,\n    filter: _filter,\n    filterMap: _filterMap,\n    partition: _partition,\n    partitionMap: _partitionMap,\n    wither: _wither,\n    wilt: _wilt,\n    throwError: throwError\n};\n/**\n * Use [`getApplySemigroup`](./Apply.ts.html#getapplysemigroup) instead.\n *\n * @category zone of death\n * @since 2.0.0\n * @deprecated\n */\nexport var getApplySemigroup = /*#__PURE__*/ getApplySemigroup_(Apply);\n/**\n * Use [`getApplicativeMonoid`](./Applicative.ts.html#getapplicativemonoid) instead.\n *\n * @category zone of death\n * @since 2.0.0\n * @deprecated\n */\nexport var getApplyMonoid = /*#__PURE__*/ getApplicativeMonoid(Applicative);\n/**\n * Use\n *\n * ```ts\n * import { first } from 'fp-ts/Semigroup'\n * import { getMonoid } from 'fp-ts/Option'\n *\n * getMonoid(first())\n * ```\n *\n * instead.\n *\n * Monoid returning the left-most non-`None` value\n *\n * | x       | y       | concat(x, y) |\n * | ------- | ------- | ------------ |\n * | none    | none    | none         |\n * | some(a) | none    | some(a)      |\n * | none    | some(b) | some(b)      |\n * | some(a) | some(b) | some(a)      |\n *\n * @example\n * import { getFirstMonoid, some, none } from 'fp-ts/Option'\n *\n * const M = getFirstMonoid<number>()\n * assert.deepStrictEqual(M.concat(none, none), none)\n * assert.deepStrictEqual(M.concat(some(1), none), some(1))\n * assert.deepStrictEqual(M.concat(none, some(2)), some(2))\n * assert.deepStrictEqual(M.concat(some(1), some(2)), some(1))\n *\n * @category zone of death\n * @since 2.0.0\n * @deprecated\n */\nexport var getFirstMonoid = function () { return getMonoid(first()); };\n/**\n * Use\n *\n * ```ts\n * import { last } from 'fp-ts/Semigroup'\n * import { getMonoid } from 'fp-ts/Option'\n *\n * getMonoid(last())\n * ```\n *\n * instead.\n *\n * Monoid returning the right-most non-`None` value\n *\n * | x       | y       | concat(x, y) |\n * | ------- | ------- | ------------ |\n * | none    | none    | none         |\n * | some(a) | none    | some(a)      |\n * | none    | some(b) | some(b)      |\n * | some(a) | some(b) | some(b)      |\n *\n * @example\n * import { getLastMonoid, some, none } from 'fp-ts/Option'\n *\n * const M = getLastMonoid<number>()\n * assert.deepStrictEqual(M.concat(none, none), none)\n * assert.deepStrictEqual(M.concat(some(1), none), some(1))\n * assert.deepStrictEqual(M.concat(none, some(2)), some(2))\n * assert.deepStrictEqual(M.concat(some(1), some(2)), some(2))\n *\n * @category zone of death\n * @since 2.0.0\n * @deprecated\n */\nexport var getLastMonoid = function () { return getMonoid(last()); };\n","import { eqStrict } from './Eq';\nimport { constant, constTrue, pipe } from './function';\n// -------------------------------------------------------------------------------------\n// defaults\n// -------------------------------------------------------------------------------------\n/**\n * @category defaults\n * @since 2.10.0\n */\nexport var equalsDefault = function (compare) {\n    return function (first, second) {\n        return first === second || compare(first, second) === 0;\n    };\n};\n// -------------------------------------------------------------------------------------\n// constructors\n// -------------------------------------------------------------------------------------\n/**\n * @category constructors\n * @since 2.0.0\n */\nexport var fromCompare = function (compare) { return ({\n    equals: equalsDefault(compare),\n    compare: function (first, second) { return (first === second ? 0 : compare(first, second)); }\n}); };\n// -------------------------------------------------------------------------------------\n// combinators\n// -------------------------------------------------------------------------------------\n/**\n * Given a tuple of `Ord`s returns an `Ord` for the tuple.\n *\n * @example\n * import { tuple } from 'fp-ts/Ord'\n * import * as B from 'fp-ts/boolean'\n * import * as S from 'fp-ts/string'\n * import * as N from 'fp-ts/number'\n *\n * const O = tuple(S.Ord, N.Ord, B.Ord)\n * assert.strictEqual(O.compare(['a', 1, true], ['b', 2, true]), -1)\n * assert.strictEqual(O.compare(['a', 1, true], ['a', 2, true]), -1)\n * assert.strictEqual(O.compare(['a', 1, true], ['a', 1, false]), 1)\n *\n * @since 2.10.0\n */\nexport var tuple = function () {\n    var ords = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        ords[_i] = arguments[_i];\n    }\n    return fromCompare(function (first, second) {\n        var i = 0;\n        for (; i < ords.length - 1; i++) {\n            var r = ords[i].compare(first[i], second[i]);\n            if (r !== 0) {\n                return r;\n            }\n        }\n        return ords[i].compare(first[i], second[i]);\n    });\n};\n/**\n * @since 2.10.0\n */\nexport var reverse = function (O) { return fromCompare(function (first, second) { return O.compare(second, first); }); };\n/* istanbul ignore next */\nvar contramap_ = function (fa, f) { return pipe(fa, contramap(f)); };\n/**\n * A typical use case for `contramap` would be like, given some `User` type, to construct an `Ord<User>`.\n *\n * We can do so with a function from `User -> X` where `X` is some value that we know how to compare\n * for ordering (meaning we have an `Ord<X>`)\n *\n * For example, given the following `User` type, there are lots of possible choices for `X`,\n * but let's say we want to sort a list of users by `lastName`.\n *\n * If we have a way of comparing `lastName`s for ordering (`ordLastName: Ord<string>`) and we know how to go from `User -> string`,\n * using `contramap` we can do this\n *\n * @example\n * import { pipe } from 'fp-ts/function'\n * import { contramap, Ord } from 'fp-ts/Ord'\n * import * as RA from 'fp-ts/ReadonlyArray'\n * import * as S from 'fp-ts/string'\n *\n * interface User {\n *   readonly firstName: string\n *   readonly lastName: string\n * }\n *\n * const ordLastName: Ord<string> = S.Ord\n *\n * const ordByLastName: Ord<User> = pipe(\n *   ordLastName,\n *   contramap((user) => user.lastName)\n * )\n *\n * assert.deepStrictEqual(\n *   RA.sort(ordByLastName)([\n *     { firstName: 'a', lastName: 'd' },\n *     { firstName: 'c', lastName: 'b' }\n *   ]),\n *   [\n *     { firstName: 'c', lastName: 'b' },\n *     { firstName: 'a', lastName: 'd' }\n *   ]\n * )\n *\n * @since 2.0.0\n */\nexport var contramap = function (f) { return function (fa) {\n    return fromCompare(function (first, second) { return fa.compare(f(first), f(second)); });\n}; };\n/**\n * @category type lambdas\n * @since 2.0.0\n */\nexport var URI = 'Ord';\n/**\n * A typical use case for the `Semigroup` instance of `Ord` is merging two or more orderings.\n *\n * For example the following snippet builds an `Ord` for a type `User` which\n * sorts by `created` date descending, and **then** `lastName`\n *\n * @example\n * import * as D from 'fp-ts/Date'\n * import { pipe } from 'fp-ts/function'\n * import { contramap, getSemigroup, Ord, reverse } from 'fp-ts/Ord'\n * import * as RA from 'fp-ts/ReadonlyArray'\n * import * as S from 'fp-ts/string'\n *\n * interface User {\n *   readonly id: string\n *   readonly lastName: string\n *   readonly created: Date\n * }\n *\n * const ordByLastName: Ord<User> = pipe(\n *   S.Ord,\n *   contramap((user) => user.lastName)\n * )\n *\n * const ordByCreated: Ord<User> = pipe(\n *   D.Ord,\n *   contramap((user) => user.created)\n * )\n *\n * const ordUserByCreatedDescThenLastName = getSemigroup<User>().concat(\n *   reverse(ordByCreated),\n *   ordByLastName\n * )\n *\n * assert.deepStrictEqual(\n *   RA.sort(ordUserByCreatedDescThenLastName)([\n *     { id: 'c', lastName: 'd', created: new Date(1973, 10, 30) },\n *     { id: 'a', lastName: 'b', created: new Date(1973, 10, 30) },\n *     { id: 'e', lastName: 'f', created: new Date(1980, 10, 30) }\n *   ]),\n *   [\n *     { id: 'e', lastName: 'f', created: new Date(1980, 10, 30) },\n *     { id: 'a', lastName: 'b', created: new Date(1973, 10, 30) },\n *     { id: 'c', lastName: 'd', created: new Date(1973, 10, 30) }\n *   ]\n * )\n *\n * @category instances\n * @since 2.0.0\n */\nexport var getSemigroup = function () { return ({\n    concat: function (first, second) {\n        return fromCompare(function (a, b) {\n            var ox = first.compare(a, b);\n            return ox !== 0 ? ox : second.compare(a, b);\n        });\n    }\n}); };\n/**\n * Returns a `Monoid` such that:\n *\n * - its `concat(ord1, ord2)` operation will order first by `ord1`, and then by `ord2`\n * - its `empty` value is an `Ord` that always considers compared elements equal\n *\n * @example\n * import { sort } from 'fp-ts/Array'\n * import { contramap, reverse, getMonoid } from 'fp-ts/Ord'\n * import * as S from 'fp-ts/string'\n * import * as B from 'fp-ts/boolean'\n * import { pipe } from 'fp-ts/function'\n * import { concatAll } from 'fp-ts/Monoid'\n * import * as N from 'fp-ts/number'\n *\n * interface User {\n *   readonly id: number\n *   readonly name: string\n *   readonly age: number\n *   readonly rememberMe: boolean\n * }\n *\n * const byName = pipe(\n *   S.Ord,\n *   contramap((p: User) => p.name)\n * )\n *\n * const byAge = pipe(\n *   N.Ord,\n *   contramap((p: User) => p.age)\n * )\n *\n * const byRememberMe = pipe(\n *   B.Ord,\n *   contramap((p: User) => p.rememberMe)\n * )\n *\n * const M = getMonoid<User>()\n *\n * const users: Array<User> = [\n *   { id: 1, name: 'Guido', age: 47, rememberMe: false },\n *   { id: 2, name: 'Guido', age: 46, rememberMe: true },\n *   { id: 3, name: 'Giulio', age: 44, rememberMe: false },\n *   { id: 4, name: 'Giulio', age: 44, rememberMe: true }\n * ]\n *\n * // sort by name, then by age, then by `rememberMe`\n * const O1 = concatAll(M)([byName, byAge, byRememberMe])\n * assert.deepStrictEqual(sort(O1)(users), [\n *   { id: 3, name: 'Giulio', age: 44, rememberMe: false },\n *   { id: 4, name: 'Giulio', age: 44, rememberMe: true },\n *   { id: 2, name: 'Guido', age: 46, rememberMe: true },\n *   { id: 1, name: 'Guido', age: 47, rememberMe: false }\n * ])\n *\n * // now `rememberMe = true` first, then by name, then by age\n * const O2 = concatAll(M)([reverse(byRememberMe), byName, byAge])\n * assert.deepStrictEqual(sort(O2)(users), [\n *   { id: 4, name: 'Giulio', age: 44, rememberMe: true },\n *   { id: 2, name: 'Guido', age: 46, rememberMe: true },\n *   { id: 3, name: 'Giulio', age: 44, rememberMe: false },\n *   { id: 1, name: 'Guido', age: 47, rememberMe: false }\n * ])\n *\n * @category instances\n * @since 2.4.0\n */\nexport var getMonoid = function () { return ({\n    concat: getSemigroup().concat,\n    empty: fromCompare(function () { return 0; })\n}); };\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Contravariant = {\n    URI: URI,\n    contramap: contramap_\n};\n// -------------------------------------------------------------------------------------\n// utils\n// -------------------------------------------------------------------------------------\n/**\n * @since 2.11.0\n */\nexport var trivial = {\n    equals: constTrue,\n    compare: /*#__PURE__*/ constant(0)\n};\n/**\n * @since 2.11.0\n */\nexport var equals = function (O) {\n    return function (second) {\n        return function (first) {\n            return first === second || O.compare(first, second) === 0;\n        };\n    };\n};\n// TODO: curry in v3\n/**\n * Test whether one value is _strictly less than_ another\n *\n * @since 2.0.0\n */\nexport var lt = function (O) {\n    return function (first, second) {\n        return O.compare(first, second) === -1;\n    };\n};\n// TODO: curry in v3\n/**\n * Test whether one value is _strictly greater than_ another\n *\n * @since 2.0.0\n */\nexport var gt = function (O) {\n    return function (first, second) {\n        return O.compare(first, second) === 1;\n    };\n};\n// TODO: curry in v3\n/**\n * Test whether one value is _non-strictly less than_ another\n *\n * @since 2.0.0\n */\nexport var leq = function (O) {\n    return function (first, second) {\n        return O.compare(first, second) !== 1;\n    };\n};\n// TODO: curry in v3\n/**\n * Test whether one value is _non-strictly greater than_ another\n *\n * @since 2.0.0\n */\nexport var geq = function (O) {\n    return function (first, second) {\n        return O.compare(first, second) !== -1;\n    };\n};\n// TODO: curry in v3\n/**\n * Take the minimum of two values. If they are considered equal, the first argument is chosen\n *\n * @since 2.0.0\n */\nexport var min = function (O) {\n    return function (first, second) {\n        return first === second || O.compare(first, second) < 1 ? first : second;\n    };\n};\n// TODO: curry in v3\n/**\n * Take the maximum of two values. If they are considered equal, the first argument is chosen\n *\n * @since 2.0.0\n */\nexport var max = function (O) {\n    return function (first, second) {\n        return first === second || O.compare(first, second) > -1 ? first : second;\n    };\n};\n/**\n * Clamp a value between a minimum and a maximum\n *\n * @since 2.0.0\n */\nexport var clamp = function (O) {\n    var minO = min(O);\n    var maxO = max(O);\n    return function (low, hi) { return function (a) { return maxO(minO(a, hi), low); }; };\n};\n/**\n * Test whether a value is between a minimum and a maximum (inclusive)\n *\n * @since 2.0.0\n */\nexport var between = function (O) {\n    var ltO = lt(O);\n    var gtO = gt(O);\n    return function (low, hi) { return function (a) { return ltO(a, low) || gtO(a, hi) ? false : true; }; };\n};\n// -------------------------------------------------------------------------------------\n// deprecated\n// -------------------------------------------------------------------------------------\n/**\n * Use [`tuple`](#tuple) instead.\n *\n * @category zone of death\n * @since 2.0.0\n * @deprecated\n */\nexport var getTupleOrd = tuple;\n/**\n * Use [`reverse`](#reverse) instead.\n *\n * @category zone of death\n * @since 2.0.0\n * @deprecated\n */\nexport var getDualOrd = reverse;\n/**\n * Use [`Contravariant`](#contravariant) instead.\n *\n * @category zone of death\n * @since 2.0.0\n * @deprecated\n */\nexport var ord = Contravariant;\n// default compare for primitive types\nfunction compare(first, second) {\n    return first < second ? -1 : first > second ? 1 : 0;\n}\nvar strictOrd = {\n    equals: eqStrict.equals,\n    compare: compare\n};\n/**\n * Use [`Ord`](./boolean.ts.html#ord) instead.\n *\n * @category zone of death\n * @since 2.0.0\n * @deprecated\n */\nexport var ordBoolean = strictOrd;\n/**\n * Use [`Ord`](./string.ts.html#ord) instead.\n *\n * @category zone of death\n * @since 2.0.0\n * @deprecated\n */\nexport var ordString = strictOrd;\n/**\n * Use [`Ord`](./number.ts.html#ord) instead.\n *\n * @category zone of death\n * @since 2.0.0\n * @deprecated\n */\nexport var ordNumber = strictOrd;\n/**\n * Use [`Ord`](./Date.ts.html#ord) instead.\n *\n * @category zone of death\n * @since 2.0.0\n * @deprecated\n */\nexport var ordDate = /*#__PURE__*/ pipe(ordNumber, \n/*#__PURE__*/\ncontramap(function (date) { return date.valueOf(); }));\n","import { constFalse, constTrue, flow, pipe } from './function';\nvar contramap_ = function (predicate, f) { return pipe(predicate, contramap(f)); };\n/**\n * @since 2.11.0\n */\nexport var contramap = function (f) {\n    return function (predicate) {\n        return flow(f, predicate);\n    };\n};\n/**\n * @category type lambdas\n * @since 2.11.0\n */\nexport var URI = 'Predicate';\n/**\n * @category instances\n * @since 2.11.0\n */\nexport var getSemigroupAny = function () { return ({\n    concat: function (first, second) { return pipe(first, or(second)); }\n}); };\n/**\n * @category instances\n * @since 2.11.0\n */\nexport var getMonoidAny = function () { return ({\n    concat: getSemigroupAny().concat,\n    empty: constFalse\n}); };\n/**\n * @category instances\n * @since 2.11.0\n */\nexport var getSemigroupAll = function () { return ({\n    concat: function (first, second) { return pipe(first, and(second)); }\n}); };\n/**\n * @category instances\n * @since 2.11.0\n */\nexport var getMonoidAll = function () { return ({\n    concat: getSemigroupAll().concat,\n    empty: constTrue\n}); };\n/**\n * @category instances\n * @since 2.11.0\n */\nexport var Contravariant = {\n    URI: URI,\n    contramap: contramap_\n};\n// -------------------------------------------------------------------------------------\n// utils\n// -------------------------------------------------------------------------------------\n/**\n * @since 2.11.0\n */\nexport var not = function (predicate) {\n    return function (a) {\n        return !predicate(a);\n    };\n};\n/**\n * @since 2.11.0\n */\nexport var or = function (second) {\n    return function (first) {\n        return function (a) {\n            return first(a) || second(a);\n        };\n    };\n};\n/**\n * @since 2.11.0\n */\nexport var and = function (second) {\n    return function (first) {\n        return function (a) {\n            return first(a) && second(a);\n        };\n    };\n};\n","var __spreadArray = (this && this.__spreadArray) || function (to, from, pack) {\n    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {\n        if (ar || !(i in from)) {\n            if (!ar) ar = Array.prototype.slice.call(from, 0, i);\n            ar[i] = from[i];\n        }\n    }\n    return to.concat(ar || Array.prototype.slice.call(from));\n};\nimport { apFirst as apFirst_, apS as apS_, apSecond as apSecond_ } from './Apply';\nimport { bind as bind_, chainFirst as chainFirst_ } from './Chain';\nimport { fromEquals } from './Eq';\nimport { fromEitherK as fromEitherK_ } from './FromEither';\nimport { dual, identity, pipe } from './function';\nimport { bindTo as bindTo_, flap as flap_, let as let__ } from './Functor';\nimport * as _ from './internal';\nimport * as N from './number';\nimport { fromCompare } from './Ord';\nimport * as RNEA from './ReadonlyNonEmptyArray';\nimport { separated } from './Separated';\nimport { filterE as filterE_, wiltDefault, witherDefault } from './Witherable';\nimport { guard as guard_ } from './Zero';\n// -------------------------------------------------------------------------------------\n// refinements\n// -------------------------------------------------------------------------------------\n/**\n * Test whether a `ReadonlyArray` is empty.\n *\n * @example\n * import { isEmpty } from 'fp-ts/ReadonlyArray'\n *\n * assert.strictEqual(isEmpty([]), true)\n *\n * @category refinements\n * @since 2.5.0\n */\nexport var isEmpty = function (as) { return as.length === 0; };\n/**\n * Test whether a `ReadonlyArray` is non empty.\n *\n * @category refinements\n * @since 2.5.0\n */\nexport var isNonEmpty = RNEA.isNonEmpty;\n// -------------------------------------------------------------------------------------\n// constructors\n// -------------------------------------------------------------------------------------\n/**\n * Prepend an element to the front of a `ReadonlyArray`, creating a new `ReadonlyNonEmptyArray`.\n *\n * @example\n * import { prepend } from 'fp-ts/ReadonlyArray'\n * import { pipe } from 'fp-ts/function'\n *\n * assert.deepStrictEqual(pipe([2, 3, 4], prepend(1)), [1, 2, 3, 4])\n *\n * @since 2.10.0\n */\nexport var prepend = RNEA.prepend;\n/**\n * Less strict version of [`prepend`](#prepend).\n *\n * @since 2.11.0\n */\nexport var prependW = RNEA.prependW;\n/**\n * Append an element to the end of a `ReadonlyArray`, creating a new `ReadonlyNonEmptyArray`.\n *\n * @example\n * import { append } from 'fp-ts/ReadonlyArray'\n * import { pipe } from 'fp-ts/function'\n *\n * assert.deepStrictEqual(pipe([1, 2, 3], append(4)), [1, 2, 3, 4])\n *\n * @since 2.10.0\n */\nexport var append = RNEA.append;\n/**\n * Less strict version of [`append`](#append).\n *\n * @since 2.11.0\n */\nexport var appendW = RNEA.appendW;\n/**\n * Return a `ReadonlyArray` of length `n` with element `i` initialized with `f(i)`.\n *\n * **Note**. `n` is normalized to a non negative integer.\n *\n * @example\n * import { makeBy } from 'fp-ts/ReadonlyArray'\n *\n * const double = (n: number): number => n * 2\n * assert.deepStrictEqual(makeBy(5, double), [0, 2, 4, 6, 8])\n *\n * @category constructors\n * @since 2.5.0\n */\nexport var makeBy = function (n, f) { return (n <= 0 ? empty : RNEA.makeBy(f)(n)); };\n/**\n * Create a `ReadonlyArray` containing a value repeated the specified number of times.\n *\n * **Note**. `n` is normalized to a non negative integer.\n *\n * @example\n * import { replicate } from 'fp-ts/ReadonlyArray'\n *\n * assert.deepStrictEqual(replicate(3, 'a'), ['a', 'a', 'a'])\n *\n * @category constructors\n * @since 2.5.0\n */\nexport var replicate = function (n, a) { return makeBy(n, function () { return a; }); };\nexport function fromPredicate(predicate) {\n    return function (a) { return (predicate(a) ? [a] : empty); };\n}\n// -------------------------------------------------------------------------------------\n// conversions\n// -------------------------------------------------------------------------------------\n/**\n * @category conversions\n * @since 2.11.0\n */\nexport var fromOption = function (ma) { return (_.isNone(ma) ? empty : [ma.value]); };\n/**\n * Transforms an `Either` to a `ReadonlyArray`.\n *\n * @category conversions\n * @since 2.11.0\n */\nexport var fromEither = function (e) { return (_.isLeft(e) ? empty : [e.right]); };\n/**\n * Less strict version of [`match`](#match).\n *\n * The `W` suffix (short for **W**idening) means that the handler return types will be merged.\n *\n * @category pattern matching\n * @since 2.11.0\n */\nexport var matchW = function (onEmpty, onNonEmpty) {\n    return function (as) {\n        return isNonEmpty(as) ? onNonEmpty(as) : onEmpty();\n    };\n};\n/**\n * @category pattern matching\n * @since 2.11.0\n */\nexport var match = matchW;\n/**\n * Less strict version of [`matchLeft`](#matchleft).\n *\n * @category pattern matching\n * @since 2.11.0\n */\nexport var matchLeftW = function (onEmpty, onNonEmpty) {\n    return function (as) {\n        return isNonEmpty(as) ? onNonEmpty(RNEA.head(as), RNEA.tail(as)) : onEmpty();\n    };\n};\n/**\n * Break a `ReadonlyArray` into its first element and remaining elements.\n *\n * @example\n * import { matchLeft } from 'fp-ts/ReadonlyArray'\n *\n * const len: <A>(as: ReadonlyArray<A>) => number = matchLeft(() => 0, (_, tail) => 1 + len(tail))\n * assert.strictEqual(len([1, 2, 3]), 3)\n *\n * @category pattern matching\n * @since 2.10.0\n */\nexport var matchLeft = matchLeftW;\n/**\n * Alias of [`matchLeft`](#matchleft).\n *\n * @category pattern matching\n * @since 2.5.0\n */\nexport var foldLeft = matchLeft;\n/**\n * Less strict version of [`matchRight`](#matchright).\n *\n * @category pattern matching\n * @since 2.11.0\n */\nexport var matchRightW = function (onEmpty, onNonEmpty) {\n    return function (as) {\n        return isNonEmpty(as) ? onNonEmpty(RNEA.init(as), RNEA.last(as)) : onEmpty();\n    };\n};\n/**\n * Break a `ReadonlyArray` into its initial elements and the last element.\n *\n * @category pattern matching\n * @since 2.10.0\n */\nexport var matchRight = matchRightW;\n/**\n * Alias of [`matchRight`](#matchright).\n *\n * @category pattern matching\n * @since 2.5.0\n */\nexport var foldRight = matchRight;\n// -------------------------------------------------------------------------------------\n// combinators\n// -------------------------------------------------------------------------------------\n/**\n * @category sequencing\n * @since 2.7.0\n */\nexport var chainWithIndex = function (f) {\n    return function (as) {\n        if (isEmpty(as)) {\n            return empty;\n        }\n        var out = [];\n        for (var i = 0; i < as.length; i++) {\n            var bs = f(i, as[i]);\n            for (var j = 0; j < bs.length; j++) {\n                out.push(bs[j]);\n            }\n        }\n        return out;\n    };\n};\n/**\n * Same as `reduce` but it carries over the intermediate steps.\n *\n * @example\n * import { scanLeft } from 'fp-ts/ReadonlyArray'\n *\n * assert.deepStrictEqual(scanLeft(10, (b, a: number) => b - a)([1, 2, 3]), [10, 9, 7, 4])\n *\n * @since 2.5.0\n */\nexport var scanLeft = function (b, f) {\n    return function (as) {\n        var len = as.length;\n        var out = new Array(len + 1);\n        out[0] = b;\n        for (var i = 0; i < len; i++) {\n            out[i + 1] = f(out[i], as[i]);\n        }\n        return out;\n    };\n};\n/**\n * Fold an array from the right, keeping all intermediate results instead of only the final result\n *\n * @example\n * import { scanRight } from 'fp-ts/ReadonlyArray'\n *\n * assert.deepStrictEqual(scanRight(10, (a: number, b) => b - a)([1, 2, 3]), [4, 5, 7, 10])\n *\n * @since 2.5.0\n */\nexport var scanRight = function (b, f) {\n    return function (as) {\n        var len = as.length;\n        var out = new Array(len + 1);\n        out[len] = b;\n        for (var i = len - 1; i >= 0; i--) {\n            out[i] = f(as[i], out[i + 1]);\n        }\n        return out;\n    };\n};\n/**\n * Calculate the number of elements in a `ReadonlyArray`.\n *\n * @since 2.10.0\n */\nexport var size = function (as) { return as.length; };\n/**\n * Test whether an array contains a particular index\n *\n * @since 2.5.0\n */\nexport var isOutOfBound = RNEA.isOutOfBound;\nexport function lookup(i, as) {\n    return as === undefined ? function (as) { return lookup(i, as); } : isOutOfBound(i, as) ? _.none : _.some(as[i]);\n}\n/**\n * Get the first element in an array, or `None` if the array is empty\n *\n * @example\n * import { head } from 'fp-ts/ReadonlyArray'\n * import { some, none } from 'fp-ts/Option'\n *\n * assert.deepStrictEqual(head([1, 2, 3]), some(1))\n * assert.deepStrictEqual(head([]), none)\n *\n * @since 2.5.0\n */\nexport var head = function (as) { return (isNonEmpty(as) ? _.some(RNEA.head(as)) : _.none); };\n/**\n * Get the last element in an array, or `None` if the array is empty\n *\n * @example\n * import { last } from 'fp-ts/ReadonlyArray'\n * import { some, none } from 'fp-ts/Option'\n *\n * assert.deepStrictEqual(last([1, 2, 3]), some(3))\n * assert.deepStrictEqual(last([]), none)\n *\n * @since 2.5.0\n */\nexport var last = function (as) { return (isNonEmpty(as) ? _.some(RNEA.last(as)) : _.none); };\n/**\n * Get all but the first element of an array, creating a new array, or `None` if the array is empty\n *\n * @example\n * import { tail } from 'fp-ts/ReadonlyArray'\n * import { some, none } from 'fp-ts/Option'\n *\n * assert.deepStrictEqual(tail([1, 2, 3]), some([2, 3]))\n * assert.deepStrictEqual(tail([]), none)\n *\n * @since 2.5.0\n */\nexport var tail = function (as) {\n    return isNonEmpty(as) ? _.some(RNEA.tail(as)) : _.none;\n};\n/**\n * Get all but the last element of an array, creating a new array, or `None` if the array is empty\n *\n * @example\n * import { init } from 'fp-ts/ReadonlyArray'\n * import { some, none } from 'fp-ts/Option'\n *\n * assert.deepStrictEqual(init([1, 2, 3]), some([1, 2]))\n * assert.deepStrictEqual(init([]), none)\n *\n * @since 2.5.0\n */\nexport var init = function (as) {\n    return isNonEmpty(as) ? _.some(RNEA.init(as)) : _.none;\n};\n/**\n * Keep only a max number of elements from the start of an `ReadonlyArray`, creating a new `ReadonlyArray`.\n *\n * **Note**. `n` is normalized to a non negative integer.\n *\n * @example\n * import * as RA from 'fp-ts/ReadonlyArray'\n * import { pipe } from 'fp-ts/function'\n *\n * const input: ReadonlyArray<number> = [1, 2, 3]\n * assert.deepStrictEqual(pipe(input, RA.takeLeft(2)), [1, 2])\n *\n * // out of bounds\n * assert.strictEqual(pipe(input, RA.takeLeft(4)), input)\n * assert.strictEqual(pipe(input, RA.takeLeft(-1)), input)\n *\n * @since 2.5.0\n */\nexport var takeLeft = function (n) {\n    return function (as) {\n        return isOutOfBound(n, as) ? as : n === 0 ? empty : as.slice(0, n);\n    };\n};\n/**\n * Keep only a max number of elements from the end of an `ReadonlyArray`, creating a new `ReadonlyArray`.\n *\n * **Note**. `n` is normalized to a non negative integer.\n *\n * @example\n * import * as RA from 'fp-ts/ReadonlyArray'\n * import { pipe } from 'fp-ts/function'\n *\n * const input: ReadonlyArray<number> = [1, 2, 3]\n * assert.deepStrictEqual(pipe(input, RA.takeRight(2)), [2, 3])\n *\n * // out of bounds\n * assert.strictEqual(pipe(input, RA.takeRight(4)), input)\n * assert.strictEqual(pipe(input, RA.takeRight(-1)), input)\n *\n * @since 2.5.0\n */\nexport var takeRight = function (n) {\n    return function (as) {\n        return isOutOfBound(n, as) ? as : n === 0 ? empty : as.slice(-n);\n    };\n};\nexport function takeLeftWhile(predicate) {\n    return function (as) {\n        var out = [];\n        for (var _i = 0, as_1 = as; _i < as_1.length; _i++) {\n            var a = as_1[_i];\n            if (!predicate(a)) {\n                break;\n            }\n            out.push(a);\n        }\n        var len = out.length;\n        return len === as.length ? as : len === 0 ? empty : out;\n    };\n}\nvar spanLeftIndex = function (as, predicate) {\n    var l = as.length;\n    var i = 0;\n    for (; i < l; i++) {\n        if (!predicate(as[i])) {\n            break;\n        }\n    }\n    return i;\n};\nexport function spanLeft(predicate) {\n    return function (as) {\n        var _a = splitAt(spanLeftIndex(as, predicate))(as), init = _a[0], rest = _a[1];\n        return { init: init, rest: rest };\n    };\n}\n/**\n * Drop a max number of elements from the start of an `ReadonlyArray`, creating a new `ReadonlyArray`.\n *\n * **Note**. `n` is normalized to a non negative integer.\n *\n * @example\n * import * as RA from 'fp-ts/ReadonlyArray'\n * import { pipe } from 'fp-ts/function'\n *\n * const input: ReadonlyArray<number> = [1, 2, 3]\n * assert.deepStrictEqual(pipe(input, RA.dropLeft(2)), [3])\n * assert.strictEqual(pipe(input, RA.dropLeft(0)), input)\n * assert.strictEqual(pipe(input, RA.dropLeft(-1)), input)\n *\n * @since 2.5.0\n */\nexport var dropLeft = function (n) {\n    return function (as) {\n        return n <= 0 || isEmpty(as) ? as : n >= as.length ? empty : as.slice(n, as.length);\n    };\n};\n/**\n * Drop a max number of elements from the end of an `ReadonlyArray`, creating a new `ReadonlyArray`.\n *\n * **Note**. `n` is normalized to a non negative integer.\n *\n * @example\n * import * as RA from 'fp-ts/ReadonlyArray'\n * import { pipe } from 'fp-ts/function'\n *\n * const input: ReadonlyArray<number> = [1, 2, 3]\n * assert.deepStrictEqual(pipe(input, RA.dropRight(2)), [1])\n * assert.strictEqual(pipe(input, RA.dropRight(0)), input)\n * assert.strictEqual(pipe(input, RA.dropRight(-1)), input)\n *\n * @since 2.5.0\n */\nexport var dropRight = function (n) {\n    return function (as) {\n        return n <= 0 || isEmpty(as) ? as : n >= as.length ? empty : as.slice(0, as.length - n);\n    };\n};\nexport function dropLeftWhile(predicate) {\n    return function (as) {\n        var i = spanLeftIndex(as, predicate);\n        return i === 0 ? as : i === as.length ? empty : as.slice(i);\n    };\n}\n/**\n * Find the first index for which a predicate holds\n *\n * @example\n * import { findIndex } from 'fp-ts/ReadonlyArray'\n * import { some, none } from 'fp-ts/Option'\n *\n * assert.deepStrictEqual(findIndex((n: number) => n === 2)([1, 2, 3]), some(1))\n * assert.deepStrictEqual(findIndex((n: number) => n === 2)([]), none)\n *\n * @since 2.5.0\n */\nexport var findIndex = function (predicate) {\n    return function (as) {\n        for (var i = 0; i < as.length; i++) {\n            if (predicate(as[i])) {\n                return _.some(i);\n            }\n        }\n        return _.none;\n    };\n};\nexport function findFirst(predicate) {\n    return function (as) {\n        for (var i = 0; i < as.length; i++) {\n            if (predicate(as[i])) {\n                return _.some(as[i]);\n            }\n        }\n        return _.none;\n    };\n}\n/**\n * Find the first element returned by an option based selector function\n *\n * @example\n * import { findFirstMap } from 'fp-ts/ReadonlyArray'\n * import { some, none } from 'fp-ts/Option'\n *\n * interface Person {\n *   readonly name: string\n *   readonly age?: number\n * }\n *\n * const persons: ReadonlyArray<Person> = [{ name: 'John' }, { name: 'Mary', age: 45 }, { name: 'Joey', age: 28 }]\n *\n * // returns the name of the first person that has an age\n * assert.deepStrictEqual(findFirstMap((p: Person) => (p.age === undefined ? none : some(p.name)))(persons), some('Mary'))\n *\n * @since 2.5.0\n */\nexport var findFirstMap = function (f) {\n    return function (as) {\n        for (var i = 0; i < as.length; i++) {\n            var out = f(as[i]);\n            if (_.isSome(out)) {\n                return out;\n            }\n        }\n        return _.none;\n    };\n};\nexport function findLast(predicate) {\n    return function (as) {\n        for (var i = as.length - 1; i >= 0; i--) {\n            if (predicate(as[i])) {\n                return _.some(as[i]);\n            }\n        }\n        return _.none;\n    };\n}\n/**\n * Find the last element returned by an option based selector function\n *\n * @example\n * import { findLastMap } from 'fp-ts/ReadonlyArray'\n * import { some, none } from 'fp-ts/Option'\n *\n * interface Person {\n *   readonly name: string\n *   readonly age?: number\n * }\n *\n * const persons: ReadonlyArray<Person> = [{ name: 'John' }, { name: 'Mary', age: 45 }, { name: 'Joey', age: 28 }]\n *\n * // returns the name of the last person that has an age\n * assert.deepStrictEqual(findLastMap((p: Person) => (p.age === undefined ? none : some(p.name)))(persons), some('Joey'))\n *\n * @since 2.5.0\n */\nexport var findLastMap = function (f) {\n    return function (as) {\n        for (var i = as.length - 1; i >= 0; i--) {\n            var out = f(as[i]);\n            if (_.isSome(out)) {\n                return out;\n            }\n        }\n        return _.none;\n    };\n};\n/**\n * Returns the index of the last element of the list which matches the predicate\n *\n * @example\n * import { findLastIndex } from 'fp-ts/ReadonlyArray'\n * import { some, none } from 'fp-ts/Option'\n *\n * interface X {\n *   readonly a: number\n *   readonly b: number\n * }\n * const xs: ReadonlyArray<X> = [{ a: 1, b: 0 }, { a: 1, b: 1 }]\n * assert.deepStrictEqual(findLastIndex((x: { readonly a: number }) => x.a === 1)(xs), some(1))\n * assert.deepStrictEqual(findLastIndex((x: { readonly a: number }) => x.a === 4)(xs), none)\n *\n *\n * @since 2.5.0\n */\nexport var findLastIndex = function (predicate) {\n    return function (as) {\n        for (var i = as.length - 1; i >= 0; i--) {\n            if (predicate(as[i])) {\n                return _.some(i);\n            }\n        }\n        return _.none;\n    };\n};\n/**\n * Insert an element at the specified index, creating a new array, or returning `None` if the index is out of bounds\n *\n * @example\n * import { insertAt } from 'fp-ts/ReadonlyArray'\n * import { some } from 'fp-ts/Option'\n *\n * assert.deepStrictEqual(insertAt(2, 5)([1, 2, 3, 4]), some([1, 2, 5, 3, 4]))\n *\n * @since 2.5.0\n */\nexport var insertAt = function (i, a) {\n    return function (as) {\n        return i < 0 || i > as.length ? _.none : _.some(RNEA.unsafeInsertAt(i, a, as));\n    };\n};\n/**\n * Change the element at the specified index, creating a new array, or returning `None` if the index is out of bounds\n *\n * @example\n * import { updateAt } from 'fp-ts/ReadonlyArray'\n * import { some, none } from 'fp-ts/Option'\n *\n * assert.deepStrictEqual(updateAt(1, 1)([1, 2, 3]), some([1, 1, 3]))\n * assert.deepStrictEqual(updateAt(1, 1)([]), none)\n *\n * @since 2.5.0\n */\nexport var updateAt = function (i, a) {\n    return modifyAt(i, function () { return a; });\n};\n/**\n * Delete the element at the specified index, creating a new array, or returning `None` if the index is out of bounds\n *\n * @example\n * import { deleteAt } from 'fp-ts/ReadonlyArray'\n * import { some, none } from 'fp-ts/Option'\n *\n * assert.deepStrictEqual(deleteAt(0)([1, 2, 3]), some([2, 3]))\n * assert.deepStrictEqual(deleteAt(1)([]), none)\n *\n * @since 2.5.0\n */\nexport var deleteAt = function (i) {\n    return function (as) {\n        return isOutOfBound(i, as) ? _.none : _.some(unsafeDeleteAt(i, as));\n    };\n};\n/**\n * Apply a function to the element at the specified index, creating a new array, or returning `None` if the index is out\n * of bounds\n *\n * @example\n * import { modifyAt } from 'fp-ts/ReadonlyArray'\n * import { some, none } from 'fp-ts/Option'\n *\n * const double = (x: number): number => x * 2\n * assert.deepStrictEqual(modifyAt(1, double)([1, 2, 3]), some([1, 4, 3]))\n * assert.deepStrictEqual(modifyAt(1, double)([]), none)\n *\n * @since 2.5.0\n */\nexport var modifyAt = function (i, f) {\n    return function (as) {\n        return isOutOfBound(i, as) ? _.none : _.some(unsafeUpdateAt(i, f(as[i]), as));\n    };\n};\n/**\n * Reverse an array, creating a new array\n *\n * @example\n * import { reverse } from 'fp-ts/ReadonlyArray'\n *\n * assert.deepStrictEqual(reverse([1, 2, 3]), [3, 2, 1])\n *\n * @since 2.5.0\n */\nexport var reverse = function (as) { return (as.length <= 1 ? as : as.slice().reverse()); };\n/**\n * Extracts from an array of `Either` all the `Right` elements. All the `Right` elements are extracted in order\n *\n * @example\n * import { rights } from 'fp-ts/ReadonlyArray'\n * import { right, left } from 'fp-ts/Either'\n *\n * assert.deepStrictEqual(rights([right(1), left('foo'), right(2)]), [1, 2])\n *\n * @since 2.5.0\n */\nexport var rights = function (as) {\n    var r = [];\n    for (var i = 0; i < as.length; i++) {\n        var a = as[i];\n        if (a._tag === 'Right') {\n            r.push(a.right);\n        }\n    }\n    return r;\n};\n/**\n * Extracts from an array of `Either` all the `Left` elements. All the `Left` elements are extracted in order\n *\n * @example\n * import { lefts } from 'fp-ts/ReadonlyArray'\n * import { left, right } from 'fp-ts/Either'\n *\n * assert.deepStrictEqual(lefts([right(1), left('foo'), right(2)]), ['foo'])\n *\n * @since 2.5.0\n */\nexport var lefts = function (as) {\n    var r = [];\n    for (var i = 0; i < as.length; i++) {\n        var a = as[i];\n        if (a._tag === 'Left') {\n            r.push(a.left);\n        }\n    }\n    return r;\n};\n/**\n * Sort the elements of an array in increasing order, creating a new array\n *\n * @example\n * import { sort } from 'fp-ts/ReadonlyArray'\n * import * as N from 'fp-ts/number'\n *\n * assert.deepStrictEqual(sort(N.Ord)([3, 2, 1]), [1, 2, 3])\n *\n * @since 2.5.0\n */\nexport var sort = function (O) {\n    return function (as) {\n        return as.length <= 1 ? as : as.slice().sort(O.compare);\n    };\n};\n// TODO: curry and make data-last in v3\n/**\n * Apply a function to pairs of elements at the same index in two arrays, collecting the results in a new array. If one\n * input array is short, excess elements of the longer array are discarded.\n *\n * @example\n * import { zipWith } from 'fp-ts/ReadonlyArray'\n *\n * assert.deepStrictEqual(zipWith([1, 2, 3], ['a', 'b', 'c', 'd'], (n, s) => s + n), ['a1', 'b2', 'c3'])\n *\n * @since 2.5.0\n */\nexport var zipWith = function (fa, fb, f) {\n    var fc = [];\n    var len = Math.min(fa.length, fb.length);\n    for (var i = 0; i < len; i++) {\n        fc[i] = f(fa[i], fb[i]);\n    }\n    return fc;\n};\nexport function zip(as, bs) {\n    if (bs === undefined) {\n        return function (bs) { return zip(bs, as); };\n    }\n    return zipWith(as, bs, function (a, b) { return [a, b]; });\n}\n/**\n * The function is reverse of `zip`. Takes an array of pairs and return two corresponding arrays\n *\n * @example\n * import { unzip } from 'fp-ts/ReadonlyArray'\n *\n * assert.deepStrictEqual(unzip([[1, 'a'], [2, 'b'], [3, 'c']]), [[1, 2, 3], ['a', 'b', 'c']])\n *\n * @since 2.5.0\n */\nexport var unzip = function (as) {\n    var fa = [];\n    var fb = [];\n    for (var i = 0; i < as.length; i++) {\n        fa[i] = as[i][0];\n        fb[i] = as[i][1];\n    }\n    return [fa, fb];\n};\n/**\n * Prepend an element to every member of an array\n *\n * @example\n * import { prependAll } from 'fp-ts/ReadonlyArray'\n *\n * assert.deepStrictEqual(prependAll(9)([1, 2, 3, 4]), [9, 1, 9, 2, 9, 3, 9, 4])\n *\n * @since 2.10.0\n */\nexport var prependAll = function (middle) {\n    var f = RNEA.prependAll(middle);\n    return function (as) { return (isNonEmpty(as) ? f(as) : as); };\n};\n/**\n * Places an element in between members of an array\n *\n * @example\n * import { intersperse } from 'fp-ts/ReadonlyArray'\n *\n * assert.deepStrictEqual(intersperse(9)([1, 2, 3, 4]), [1, 9, 2, 9, 3, 9, 4])\n *\n * @since 2.9.0\n */\nexport var intersperse = function (middle) {\n    var f = RNEA.intersperse(middle);\n    return function (as) { return (isNonEmpty(as) ? f(as) : as); };\n};\n/**\n * Rotate a `ReadonlyArray` by `n` steps.\n *\n * @example\n * import { rotate } from 'fp-ts/ReadonlyArray'\n *\n * assert.deepStrictEqual(rotate(2)([1, 2, 3, 4, 5]), [4, 5, 1, 2, 3])\n *\n * @since 2.5.0\n */\nexport var rotate = function (n) {\n    var f = RNEA.rotate(n);\n    return function (as) { return (isNonEmpty(as) ? f(as) : as); };\n};\nexport function elem(E) {\n    return function (a, as) {\n        if (as === undefined) {\n            var elemE_1 = elem(E);\n            return function (as) { return elemE_1(a, as); };\n        }\n        var predicate = function (element) { return E.equals(element, a); };\n        var i = 0;\n        for (; i < as.length; i++) {\n            if (predicate(as[i])) {\n                return true;\n            }\n        }\n        return false;\n    };\n}\n/**\n * Remove duplicates from an array, keeping the first occurrence of an element.\n *\n * @example\n * import { uniq } from 'fp-ts/ReadonlyArray'\n * import * as N from 'fp-ts/number'\n *\n * assert.deepStrictEqual(uniq(N.Eq)([1, 2, 1]), [1, 2])\n *\n * @since 2.5.0\n */\nexport var uniq = function (E) {\n    var f = RNEA.uniq(E);\n    return function (as) { return (isNonEmpty(as) ? f(as) : as); };\n};\n/**\n * Sort the elements of an array in increasing order, where elements are compared using first `ords[0]`, then `ords[1]`,\n * etc...\n *\n * @example\n * import { sortBy } from 'fp-ts/ReadonlyArray'\n * import { contramap } from 'fp-ts/Ord'\n * import * as S from 'fp-ts/string'\n * import * as N from 'fp-ts/number'\n * import { pipe } from 'fp-ts/function'\n *\n * interface Person {\n *   readonly name: string\n *   readonly age: number\n * }\n * const byName = pipe(S.Ord, contramap((p: Person) => p.name))\n * const byAge = pipe(N.Ord, contramap((p: Person) => p.age))\n *\n * const sortByNameByAge = sortBy([byName, byAge])\n *\n * const persons = [{ name: 'a', age: 1 }, { name: 'b', age: 3 }, { name: 'c', age: 2 }, { name: 'b', age: 2 }]\n * assert.deepStrictEqual(sortByNameByAge(persons), [\n *   { name: 'a', age: 1 },\n *   { name: 'b', age: 2 },\n *   { name: 'b', age: 3 },\n *   { name: 'c', age: 2 }\n * ])\n *\n * @since 2.5.0\n */\nexport var sortBy = function (ords) {\n    var f = RNEA.sortBy(ords);\n    return function (as) { return (isNonEmpty(as) ? f(as) : as); };\n};\n/**\n * A useful recursion pattern for processing a `ReadonlyArray` to produce a new `ReadonlyArray`, often used for \"chopping\" up the input\n * `ReadonlyArray`. Typically `chop` is called with some function that will consume an initial prefix of the `ReadonlyArray` and produce a\n * value and the tail of the `ReadonlyArray`.\n *\n * @example\n * import { Eq } from 'fp-ts/Eq'\n * import * as RA from 'fp-ts/ReadonlyArray'\n * import * as N from 'fp-ts/number'\n * import { pipe } from 'fp-ts/function'\n *\n * const group = <A>(S: Eq<A>): ((as: ReadonlyArray<A>) => ReadonlyArray<ReadonlyArray<A>>) => {\n *   return RA.chop(as => {\n *     const { init, rest } = pipe(as, RA.spanLeft((a: A) => S.equals(a, as[0])))\n *     return [init, rest]\n *   })\n * }\n * assert.deepStrictEqual(group(N.Eq)([1, 1, 2, 3, 3, 4]), [[1, 1], [2], [3, 3], [4]])\n *\n * @since 2.5.0\n */\nexport var chop = function (f) {\n    var g = RNEA.chop(f);\n    return function (as) { return (isNonEmpty(as) ? g(as) : empty); };\n};\n/**\n * Splits a `ReadonlyArray` into two pieces, the first piece has max `n` elements.\n *\n * @example\n * import { splitAt } from 'fp-ts/ReadonlyArray'\n *\n * assert.deepStrictEqual(splitAt(2)([1, 2, 3, 4, 5]), [[1, 2], [3, 4, 5]])\n *\n * @since 2.5.0\n */\nexport var splitAt = function (n) {\n    return function (as) {\n        return n >= 1 && isNonEmpty(as) ? RNEA.splitAt(n)(as) : isEmpty(as) ? [as, empty] : [empty, as];\n    };\n};\n/**\n * Splits a `ReadonlyArray` into length-`n` pieces. The last piece will be shorter if `n` does not evenly divide the length of\n * the `ReadonlyArray`. Note that `chunksOf(n)([])` is `[]`, not `[[]]`. This is intentional, and is consistent with a recursive\n * definition of `chunksOf`; it satisfies the property that:\n *\n * ```ts\n * chunksOf(n)(xs).concat(chunksOf(n)(ys)) == chunksOf(n)(xs.concat(ys)))\n * ```\n *\n * whenever `n` evenly divides the length of `as`.\n *\n * @example\n * import { chunksOf } from 'fp-ts/ReadonlyArray'\n *\n * assert.deepStrictEqual(chunksOf(2)([1, 2, 3, 4, 5]), [[1, 2], [3, 4], [5]])\n *\n * @since 2.5.0\n */\nexport var chunksOf = function (n) {\n    var f = RNEA.chunksOf(n);\n    return function (as) { return (isNonEmpty(as) ? f(as) : empty); };\n};\n/**\n * @category lifting\n * @since 2.11.0\n */\nexport var fromOptionK = function (f) {\n    return function () {\n        var a = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            a[_i] = arguments[_i];\n        }\n        return fromOption(f.apply(void 0, a));\n    };\n};\nexport function comprehension(input, f, g) {\n    if (g === void 0) { g = function () { return true; }; }\n    var go = function (scope, input) {\n        return isNonEmpty(input)\n            ? flatMap(RNEA.head(input), function (a) { return go(pipe(scope, append(a)), RNEA.tail(input)); })\n            : g.apply(void 0, scope) ? [f.apply(void 0, scope)]\n                : empty;\n    };\n    return go(empty, input);\n}\n/**\n * @since 2.11.0\n */\nexport var concatW = function (second) {\n    return function (first) {\n        return isEmpty(first) ? second : isEmpty(second) ? first : first.concat(second);\n    };\n};\n/**\n * @since 2.11.0\n */\nexport var concat = concatW;\nexport function union(E) {\n    var unionE = RNEA.union(E);\n    return function (first, second) {\n        if (second === undefined) {\n            var unionE_1 = union(E);\n            return function (second) { return unionE_1(second, first); };\n        }\n        return isNonEmpty(first) && isNonEmpty(second) ? unionE(second)(first) : isNonEmpty(first) ? first : second;\n    };\n}\nexport function intersection(E) {\n    var elemE = elem(E);\n    return function (xs, ys) {\n        if (ys === undefined) {\n            var intersectionE_1 = intersection(E);\n            return function (ys) { return intersectionE_1(ys, xs); };\n        }\n        return xs.filter(function (a) { return elemE(a, ys); });\n    };\n}\nexport function difference(E) {\n    var elemE = elem(E);\n    return function (xs, ys) {\n        if (ys === undefined) {\n            var differenceE_1 = difference(E);\n            return function (ys) { return differenceE_1(ys, xs); };\n        }\n        return xs.filter(function (a) { return !elemE(a, ys); });\n    };\n}\nvar _map = function (fa, f) { return pipe(fa, map(f)); };\nvar _mapWithIndex = function (fa, f) { return pipe(fa, mapWithIndex(f)); };\nvar _ap = function (fab, fa) { return pipe(fab, ap(fa)); };\nvar _filter = function (fa, predicate) {\n    return pipe(fa, filter(predicate));\n};\nvar _filterMap = function (fa, f) { return pipe(fa, filterMap(f)); };\nvar _partition = function (fa, predicate) {\n    return pipe(fa, partition(predicate));\n};\nvar _partitionMap = function (fa, f) { return pipe(fa, partitionMap(f)); };\nvar _partitionWithIndex = function (fa, predicateWithIndex) { return pipe(fa, partitionWithIndex(predicateWithIndex)); };\nvar _partitionMapWithIndex = function (fa, f) { return pipe(fa, partitionMapWithIndex(f)); };\nvar _alt = function (fa, that) { return pipe(fa, alt(that)); };\nvar _reduce = function (fa, b, f) { return pipe(fa, reduce(b, f)); };\nvar _foldMap = function (M) {\n    var foldMapM = foldMap(M);\n    return function (fa, f) { return pipe(fa, foldMapM(f)); };\n};\nvar _reduceRight = function (fa, b, f) { return pipe(fa, reduceRight(b, f)); };\nvar _reduceWithIndex = function (fa, b, f) {\n    return pipe(fa, reduceWithIndex(b, f));\n};\nvar _foldMapWithIndex = function (M) {\n    var foldMapWithIndexM = foldMapWithIndex(M);\n    return function (fa, f) { return pipe(fa, foldMapWithIndexM(f)); };\n};\nvar _reduceRightWithIndex = function (fa, b, f) {\n    return pipe(fa, reduceRightWithIndex(b, f));\n};\nvar _filterMapWithIndex = function (fa, f) { return pipe(fa, filterMapWithIndex(f)); };\nvar _filterWithIndex = function (fa, predicateWithIndex) { return pipe(fa, filterWithIndex(predicateWithIndex)); };\nvar _extend = function (fa, f) { return pipe(fa, extend(f)); };\nvar _traverse = function (F) {\n    var traverseF = traverse(F);\n    return function (ta, f) { return pipe(ta, traverseF(f)); };\n};\n/* istanbul ignore next */\nvar _traverseWithIndex = function (F) {\n    var traverseWithIndexF = traverseWithIndex(F);\n    return function (ta, f) { return pipe(ta, traverseWithIndexF(f)); };\n};\n/** @internal */\nexport var _chainRecDepthFirst = function (a, f) { return pipe(a, chainRecDepthFirst(f)); };\n/** @internal */\nexport var _chainRecBreadthFirst = function (a, f) { return pipe(a, chainRecBreadthFirst(f)); };\n/**\n * @category constructors\n * @since 2.5.0\n */\nexport var of = RNEA.of;\n/**\n * @since 2.7.0\n */\nexport var zero = function () { return empty; };\n/**\n * Less strict version of [`alt`](#alt).\n *\n * The `W` suffix (short for **W**idening) means that the return types will be merged.\n *\n * @example\n * import * as RA from 'fp-ts/ReadonlyArray'\n * import { pipe } from 'fp-ts/function'\n *\n * assert.deepStrictEqual(\n *   pipe(\n *     [1, 2, 3],\n *     RA.altW(() => ['a', 'b'])\n *   ),\n *   [1, 2, 3, 'a', 'b']\n * )\n *\n * @category error handling\n * @since 2.9.0\n */\nexport var altW = function (that) {\n    return function (fa) {\n        return fa.concat(that());\n    };\n};\n/**\n * Identifies an associative operation on a type constructor. It is similar to `Semigroup`, except that it applies to\n * types of kind `* -> *`.\n *\n * In case of `ReadonlyArray` concatenates the inputs into a single array.\n *\n * @example\n * import * as RA from 'fp-ts/ReadonlyArray'\n * import { pipe } from 'fp-ts/function'\n *\n * assert.deepStrictEqual(\n *   pipe(\n *     [1, 2, 3],\n *     RA.alt(() => [4, 5])\n *   ),\n *   [1, 2, 3, 4, 5]\n * )\n *\n * @category error handling\n * @since 2.5.0\n */\nexport var alt = altW;\n/**\n * @since 2.5.0\n */\nexport var ap = function (fa) {\n    return flatMap(function (f) { return pipe(fa, map(f)); });\n};\n/**\n * Composes computations in sequence, using the return value of one computation to determine the next computation.\n *\n * @example\n * import * as RA from 'fp-ts/ReadonlyArray'\n * import { pipe } from 'fp-ts/function'\n *\n * assert.deepStrictEqual(\n *   pipe(\n *     [1, 2, 3],\n *     RA.flatMap((n) => [`a${n}`, `b${n}`])\n *   ),\n *   ['a1', 'b1', 'a2', 'b2', 'a3', 'b3']\n * )\n * assert.deepStrictEqual(\n *   pipe(\n *     [1, 2, 3],\n *     RA.flatMap(() => [])\n *   ),\n *   []\n * )\n *\n * @category sequencing\n * @since 2.14.0\n */\nexport var flatMap = /*#__PURE__*/ dual(2, function (ma, f) {\n    return pipe(ma, chainWithIndex(function (i, a) { return f(a, i); }));\n});\n/**\n * @category sequencing\n * @since 2.5.0\n */\nexport var flatten = /*#__PURE__*/ flatMap(identity);\n/**\n * `map` can be used to turn functions `(a: A) => B` into functions `(fa: F<A>) => F<B>` whose argument and return types\n * use the type constructor `F` to represent some computational context.\n *\n * @category mapping\n * @since 2.5.0\n */\nexport var map = function (f) { return function (fa) {\n    return fa.map(function (a) { return f(a); });\n}; };\n/**\n * @category mapping\n * @since 2.5.0\n */\nexport var mapWithIndex = function (f) { return function (fa) {\n    return fa.map(function (a, i) { return f(i, a); });\n}; };\n/**\n * @category filtering\n * @since 2.5.0\n */\nexport var separate = function (fa) {\n    var left = [];\n    var right = [];\n    for (var _i = 0, fa_1 = fa; _i < fa_1.length; _i++) {\n        var e = fa_1[_i];\n        if (e._tag === 'Left') {\n            left.push(e.left);\n        }\n        else {\n            right.push(e.right);\n        }\n    }\n    return separated(left, right);\n};\n/**\n * @category filtering\n * @since 2.5.0\n */\nexport var filter = function (predicate) {\n    return function (as) {\n        return as.filter(predicate);\n    };\n};\n/**\n * @category filtering\n * @since 2.5.0\n */\nexport var filterMapWithIndex = function (f) {\n    return function (fa) {\n        var out = [];\n        for (var i = 0; i < fa.length; i++) {\n            var optionB = f(i, fa[i]);\n            if (_.isSome(optionB)) {\n                out.push(optionB.value);\n            }\n        }\n        return out;\n    };\n};\n/**\n * @category filtering\n * @since 2.5.0\n */\nexport var filterMap = function (f) {\n    return filterMapWithIndex(function (_, a) { return f(a); });\n};\n/**\n * @category filtering\n * @since 2.5.0\n */\nexport var compact = /*#__PURE__*/ filterMap(identity);\n/**\n * @category filtering\n * @since 2.5.0\n */\nexport var partition = function (predicate) {\n    return partitionWithIndex(function (_, a) { return predicate(a); });\n};\n/**\n * @category filtering\n * @since 2.5.0\n */\nexport var partitionWithIndex = function (predicateWithIndex) {\n    return function (as) {\n        var left = [];\n        var right = [];\n        for (var i = 0; i < as.length; i++) {\n            var a = as[i];\n            if (predicateWithIndex(i, a)) {\n                right.push(a);\n            }\n            else {\n                left.push(a);\n            }\n        }\n        return separated(left, right);\n    };\n};\n/**\n * @category filtering\n * @since 2.5.0\n */\nexport var partitionMap = function (f) {\n    return partitionMapWithIndex(function (_, a) { return f(a); });\n};\n/**\n * @category filtering\n * @since 2.5.0\n */\nexport var partitionMapWithIndex = function (f) {\n    return function (fa) {\n        var left = [];\n        var right = [];\n        for (var i = 0; i < fa.length; i++) {\n            var e = f(i, fa[i]);\n            if (e._tag === 'Left') {\n                left.push(e.left);\n            }\n            else {\n                right.push(e.right);\n            }\n        }\n        return separated(left, right);\n    };\n};\n/**\n * @category filtering\n * @since 2.5.0\n */\nexport var filterWithIndex = function (predicateWithIndex) {\n    return function (as) {\n        return as.filter(function (a, i) { return predicateWithIndex(i, a); });\n    };\n};\n/**\n * @since 2.5.0\n */\nexport var extend = function (f) { return function (wa) {\n    return wa.map(function (_, i) { return f(wa.slice(i)); });\n}; };\n/**\n * @since 2.5.0\n */\nexport var duplicate = /*#__PURE__*/ extend(identity);\n/**\n * @category folding\n * @since 2.5.0\n */\nexport var foldMapWithIndex = function (M) {\n    return function (f) {\n        return function (fa) {\n            return fa.reduce(function (b, a, i) { return M.concat(b, f(i, a)); }, M.empty);\n        };\n    };\n};\n/**\n * @category folding\n * @since 2.5.0\n */\nexport var reduce = function (b, f) {\n    return reduceWithIndex(b, function (_, b, a) { return f(b, a); });\n};\n/**\n * @category folding\n * @since 2.5.0\n */\nexport var foldMap = function (M) {\n    var foldMapWithIndexM = foldMapWithIndex(M);\n    return function (f) { return foldMapWithIndexM(function (_, a) { return f(a); }); };\n};\n/**\n * @category folding\n * @since 2.5.0\n */\nexport var reduceWithIndex = function (b, f) { return function (fa) {\n    var len = fa.length;\n    var out = b;\n    for (var i = 0; i < len; i++) {\n        out = f(i, out, fa[i]);\n    }\n    return out;\n}; };\n/**\n * @category folding\n * @since 2.5.0\n */\nexport var reduceRight = function (b, f) {\n    return reduceRightWithIndex(b, function (_, a, b) { return f(a, b); });\n};\n/**\n * @category folding\n * @since 2.5.0\n */\nexport var reduceRightWithIndex = function (b, f) { return function (fa) {\n    return fa.reduceRight(function (b, a, i) { return f(i, a, b); }, b);\n}; };\n/**\n * @category traversing\n * @since 2.6.3\n */\nexport var traverse = function (F) {\n    var traverseWithIndexF = traverseWithIndex(F);\n    return function (f) { return traverseWithIndexF(function (_, a) { return f(a); }); };\n};\n/**\n * @category traversing\n * @since 2.6.3\n */\nexport var sequence = function (F) {\n    return function (ta) {\n        return _reduce(ta, F.of(zero()), function (fas, fa) {\n            return F.ap(F.map(fas, function (as) { return function (a) { return pipe(as, append(a)); }; }), fa);\n        });\n    };\n};\n/**\n * @category sequencing\n * @since 2.6.3\n */\nexport var traverseWithIndex = function (F) {\n    return function (f) {\n        return reduceWithIndex(F.of(zero()), function (i, fbs, a) {\n            return F.ap(F.map(fbs, function (bs) { return function (b) { return pipe(bs, append(b)); }; }), f(i, a));\n        });\n    };\n};\n/**\n * @category filtering\n * @since 2.6.5\n */\nexport var wither = function (F) {\n    var _witherF = _wither(F);\n    return function (f) { return function (fa) { return _witherF(fa, f); }; };\n};\n/**\n * @category filtering\n * @since 2.6.5\n */\nexport var wilt = function (F) {\n    var _wiltF = _wilt(F);\n    return function (f) { return function (fa) { return _wiltF(fa, f); }; };\n};\n/**\n * @since 2.6.6\n */\nexport var unfold = function (b, f) {\n    var out = [];\n    var bb = b;\n    // eslint-disable-next-line no-constant-condition\n    while (true) {\n        var mt = f(bb);\n        if (_.isSome(mt)) {\n            var _a = mt.value, a = _a[0], b_1 = _a[1];\n            out.push(a);\n            bb = b_1;\n        }\n        else {\n            break;\n        }\n    }\n    return out;\n};\n/**\n * @category type lambdas\n * @since 2.5.0\n */\nexport var URI = 'ReadonlyArray';\n/**\n * @category instances\n * @since 2.5.0\n */\nexport var getShow = function (S) { return ({\n    show: function (as) { return \"[\".concat(as.map(S.show).join(', '), \"]\"); }\n}); };\n/**\n * @category instances\n * @since 2.5.0\n */\nexport var getSemigroup = function () { return ({\n    concat: function (first, second) { return (isEmpty(first) ? second : isEmpty(second) ? first : first.concat(second)); }\n}); };\n/**\n * Returns a `Monoid` for `ReadonlyArray<A>`.\n *\n * @example\n * import { getMonoid } from 'fp-ts/ReadonlyArray'\n *\n * const M = getMonoid<number>()\n * assert.deepStrictEqual(M.concat([1, 2], [3, 4]), [1, 2, 3, 4])\n *\n * @category instances\n * @since 2.5.0\n */\nexport var getMonoid = function () { return ({\n    concat: getSemigroup().concat,\n    empty: empty\n}); };\n/**\n * Derives an `Eq` over the `ReadonlyArray` of a given element type from the `Eq` of that type. The derived `Eq` defines two\n * arrays as equal if all elements of both arrays are compared equal pairwise with the given `E`. In case of arrays of\n * different lengths, the result is non equality.\n *\n * @example\n * import * as S from 'fp-ts/string'\n * import { getEq } from 'fp-ts/ReadonlyArray'\n *\n * const E = getEq(S.Eq)\n * assert.strictEqual(E.equals(['a', 'b'], ['a', 'b']), true)\n * assert.strictEqual(E.equals(['a'], []), false)\n *\n * @category instances\n * @since 2.5.0\n */\nexport var getEq = function (E) {\n    return fromEquals(function (xs, ys) { return xs.length === ys.length && xs.every(function (x, i) { return E.equals(x, ys[i]); }); });\n};\n/**\n * Derives an `Ord` over the `ReadonlyArray` of a given element type from the `Ord` of that type. The ordering between two such\n * arrays is equal to: the first non equal comparison of each arrays elements taken pairwise in increasing order, in\n * case of equality over all the pairwise elements; the longest array is considered the greatest, if both arrays have\n * the same length, the result is equality.\n *\n * @example\n * import { getOrd } from 'fp-ts/ReadonlyArray'\n * import * as S from 'fp-ts/string'\n *\n * const O = getOrd(S.Ord)\n * assert.strictEqual(O.compare(['b'], ['a']), 1)\n * assert.strictEqual(O.compare(['a'], ['a']), 0)\n * assert.strictEqual(O.compare(['a'], ['b']), -1)\n *\n *\n * @category instances\n * @since 2.5.0\n */\nexport var getOrd = function (O) {\n    return fromCompare(function (a, b) {\n        var aLen = a.length;\n        var bLen = b.length;\n        var len = Math.min(aLen, bLen);\n        for (var i = 0; i < len; i++) {\n            var ordering = O.compare(a[i], b[i]);\n            if (ordering !== 0) {\n                return ordering;\n            }\n        }\n        return N.Ord.compare(aLen, bLen);\n    });\n};\n/**\n * @category instances\n * @since 2.11.0\n */\nexport var getUnionSemigroup = function (E) {\n    var unionE = union(E);\n    return {\n        concat: function (first, second) { return unionE(second)(first); }\n    };\n};\n/**\n * @category instances\n * @since 2.11.0\n */\nexport var getUnionMonoid = function (E) { return ({\n    concat: getUnionSemigroup(E).concat,\n    empty: empty\n}); };\n/**\n * @category instances\n * @since 2.11.0\n */\nexport var getIntersectionSemigroup = function (E) {\n    var intersectionE = intersection(E);\n    return {\n        concat: function (first, second) { return intersectionE(second)(first); }\n    };\n};\n/**\n * @category instances\n * @since 2.11.0\n */\nexport var getDifferenceMagma = function (E) {\n    var differenceE = difference(E);\n    return {\n        concat: function (first, second) { return differenceE(second)(first); }\n    };\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Functor = {\n    URI: URI,\n    map: _map\n};\n/**\n * @category mapping\n * @since 2.10.0\n */\nexport var flap = /*#__PURE__*/ flap_(Functor);\n/**\n * @category instances\n * @since 2.10.0\n */\nexport var Pointed = {\n    URI: URI,\n    of: of\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var FunctorWithIndex = {\n    URI: URI,\n    map: _map,\n    mapWithIndex: _mapWithIndex\n};\n/**\n * @category instances\n * @since 2.10.0\n */\nexport var Apply = {\n    URI: URI,\n    map: _map,\n    ap: _ap\n};\n/**\n * Combine two effectful actions, keeping only the result of the first.\n *\n * @since 2.5.0\n */\nexport var apFirst = /*#__PURE__*/ apFirst_(Apply);\n/**\n * Combine two effectful actions, keeping only the result of the second.\n *\n * @since 2.5.0\n */\nexport var apSecond = /*#__PURE__*/ apSecond_(Apply);\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Applicative = {\n    URI: URI,\n    map: _map,\n    ap: _ap,\n    of: of\n};\n/**\n * @category instances\n * @since 2.10.0\n */\nexport var Chain = {\n    URI: URI,\n    map: _map,\n    ap: _ap,\n    chain: flatMap\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Monad = {\n    URI: URI,\n    map: _map,\n    ap: _ap,\n    of: of,\n    chain: flatMap\n};\n/**\n * Composes computations in sequence, using the return value of one computation to determine the next computation and\n * keeping only the result of the first.\n *\n * @example\n * import * as RA from 'fp-ts/ReadonlyArray'\n * import { pipe } from 'fp-ts/function'\n *\n * assert.deepStrictEqual(\n *   pipe(\n *     [1, 2, 3],\n *     RA.chainFirst(() => ['a', 'b'])\n *   ),\n *   [1, 1, 2, 2, 3, 3]\n * )\n * assert.deepStrictEqual(\n *   pipe(\n *     [1, 2, 3],\n *     RA.chainFirst(() => [])\n *   ),\n *   []\n * )\n *\n * @category sequencing\n * @since 2.5.0\n */\nexport var chainFirst = \n/*#__PURE__*/ chainFirst_(Chain);\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Unfoldable = {\n    URI: URI,\n    unfold: unfold\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Alt = {\n    URI: URI,\n    map: _map,\n    alt: _alt\n};\n/**\n * @category instances\n * @since 2.11.0\n */\nexport var Zero = {\n    URI: URI,\n    zero: zero\n};\n/**\n * @category do notation\n * @since 2.11.0\n */\nexport var guard = /*#__PURE__*/ guard_(Zero, Pointed);\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Alternative = {\n    URI: URI,\n    map: _map,\n    ap: _ap,\n    of: of,\n    alt: _alt,\n    zero: zero\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Extend = {\n    URI: URI,\n    map: _map,\n    extend: _extend\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Compactable = {\n    URI: URI,\n    compact: compact,\n    separate: separate\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Filterable = {\n    URI: URI,\n    map: _map,\n    compact: compact,\n    separate: separate,\n    filter: _filter,\n    filterMap: _filterMap,\n    partition: _partition,\n    partitionMap: _partitionMap\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var FilterableWithIndex = {\n    URI: URI,\n    map: _map,\n    mapWithIndex: _mapWithIndex,\n    compact: compact,\n    separate: separate,\n    filter: _filter,\n    filterMap: _filterMap,\n    partition: _partition,\n    partitionMap: _partitionMap,\n    partitionMapWithIndex: _partitionMapWithIndex,\n    partitionWithIndex: _partitionWithIndex,\n    filterMapWithIndex: _filterMapWithIndex,\n    filterWithIndex: _filterWithIndex\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Foldable = {\n    URI: URI,\n    reduce: _reduce,\n    foldMap: _foldMap,\n    reduceRight: _reduceRight\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var FoldableWithIndex = {\n    URI: URI,\n    reduce: _reduce,\n    foldMap: _foldMap,\n    reduceRight: _reduceRight,\n    reduceWithIndex: _reduceWithIndex,\n    foldMapWithIndex: _foldMapWithIndex,\n    reduceRightWithIndex: _reduceRightWithIndex\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Traversable = {\n    URI: URI,\n    map: _map,\n    reduce: _reduce,\n    foldMap: _foldMap,\n    reduceRight: _reduceRight,\n    traverse: _traverse,\n    sequence: sequence\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var TraversableWithIndex = {\n    URI: URI,\n    map: _map,\n    mapWithIndex: _mapWithIndex,\n    reduce: _reduce,\n    foldMap: _foldMap,\n    reduceRight: _reduceRight,\n    reduceWithIndex: _reduceWithIndex,\n    foldMapWithIndex: _foldMapWithIndex,\n    reduceRightWithIndex: _reduceRightWithIndex,\n    traverse: _traverse,\n    sequence: sequence,\n    traverseWithIndex: _traverseWithIndex\n};\n/**\n * @category sequencing\n * @since 2.11.0\n */\nexport var chainRecDepthFirst = function (f) {\n    return function (a) {\n        var todo = __spreadArray([], f(a), true);\n        var out = [];\n        while (todo.length > 0) {\n            var e = todo.shift();\n            if (_.isLeft(e)) {\n                todo.unshift.apply(todo, f(e.left));\n            }\n            else {\n                out.push(e.right);\n            }\n        }\n        return out;\n    };\n};\n/**\n * @category instances\n * @since 2.11.0\n */\nexport var ChainRecDepthFirst = {\n    URI: URI,\n    map: _map,\n    ap: _ap,\n    chain: flatMap,\n    chainRec: _chainRecDepthFirst\n};\n/**\n * @category sequencing\n * @since 2.11.0\n */\nexport var chainRecBreadthFirst = function (f) {\n    return function (a) {\n        var initial = f(a);\n        var todo = [];\n        var out = [];\n        function go(e) {\n            if (_.isLeft(e)) {\n                f(e.left).forEach(function (v) { return todo.push(v); });\n            }\n            else {\n                out.push(e.right);\n            }\n        }\n        for (var _i = 0, initial_1 = initial; _i < initial_1.length; _i++) {\n            var e = initial_1[_i];\n            go(e);\n        }\n        while (todo.length > 0) {\n            go(todo.shift());\n        }\n        return out;\n    };\n};\n/**\n * @category instances\n * @since 2.11.0\n */\nexport var ChainRecBreadthFirst = {\n    URI: URI,\n    map: _map,\n    ap: _ap,\n    chain: flatMap,\n    chainRec: _chainRecBreadthFirst\n};\nvar _wither = /*#__PURE__*/ witherDefault(Traversable, Compactable);\nvar _wilt = /*#__PURE__*/ wiltDefault(Traversable, Compactable);\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Witherable = {\n    URI: URI,\n    map: _map,\n    compact: compact,\n    separate: separate,\n    filter: _filter,\n    filterMap: _filterMap,\n    partition: _partition,\n    partitionMap: _partitionMap,\n    reduce: _reduce,\n    foldMap: _foldMap,\n    reduceRight: _reduceRight,\n    traverse: _traverse,\n    sequence: sequence,\n    wither: _wither,\n    wilt: _wilt\n};\n/**\n * Filter values inside a context.\n *\n * @example\n * import { pipe } from 'fp-ts/function'\n * import * as RA from 'fp-ts/ReadonlyArray'\n * import * as T from 'fp-ts/Task'\n *\n * const filterE = RA.filterE(T.ApplicativePar)\n * async function test() {\n *   assert.deepStrictEqual(\n *     await pipe(\n *       [-1, 2, 3],\n *       filterE((n) => T.of(n > 0))\n *     )(),\n *     [2, 3]\n *   )\n * }\n * test()\n *\n * @since 2.11.0\n */\nexport var filterE = /*#__PURE__*/ filterE_(Witherable);\n/**\n * @category instances\n * @since 2.11.0\n */\nexport var FromEither = {\n    URI: URI,\n    fromEither: fromEither\n};\n/**\n * @category lifting\n * @since 2.11.0\n */\nexport var fromEitherK = /*#__PURE__*/ fromEitherK_(FromEither);\n// -------------------------------------------------------------------------------------\n// unsafe\n// -------------------------------------------------------------------------------------\n/**\n * @category unsafe\n * @since 2.5.0\n */\nexport var unsafeInsertAt = RNEA.unsafeInsertAt;\n/**\n * @category unsafe\n * @since 2.5.0\n */\nexport var unsafeUpdateAt = function (i, a, as) {\n    return isNonEmpty(as) ? RNEA.unsafeUpdateAt(i, a, as) : as;\n};\n/**\n * @category unsafe\n * @since 2.5.0\n */\nexport var unsafeDeleteAt = function (i, as) {\n    var xs = as.slice();\n    xs.splice(i, 1);\n    return xs;\n};\n/**\n * @category conversions\n * @since 2.5.0\n */\nexport var toArray = function (as) { return as.slice(); };\n/**\n * @category conversions\n * @since 2.5.0\n */\nexport var fromArray = function (as) { return (isEmpty(as) ? empty : as.slice()); };\n// -------------------------------------------------------------------------------------\n// utils\n// -------------------------------------------------------------------------------------\n/**\n * An empty array\n *\n * @since 2.5.0\n */\nexport var empty = RNEA.empty;\nexport function every(predicate) {\n    return function (as) { return as.every(predicate); };\n}\n/**\n * Check if a predicate holds true for any array member.\n *\n * @example\n * import { some } from 'fp-ts/ReadonlyArray'\n * import { pipe } from 'fp-ts/function'\n *\n * const isPositive = (n: number): boolean => n > 0\n *\n * assert.deepStrictEqual(pipe([-1, -2, 3], some(isPositive)), true)\n * assert.deepStrictEqual(pipe([-1, -2, -3], some(isPositive)), false)\n *\n * @since 2.9.0\n */\nexport var some = function (predicate) {\n    return function (as) {\n        return as.some(predicate);\n    };\n};\n/**\n * Alias of [`some`](#some)\n *\n * @since 2.11.0\n */\nexport var exists = some;\n/**\n * Places an element in between members of a `ReadonlyArray`, then folds the results using the provided `Monoid`.\n *\n * @example\n * import * as S from 'fp-ts/string'\n * import { intercalate } from 'fp-ts/ReadonlyArray'\n *\n * assert.deepStrictEqual(intercalate(S.Monoid)('-')(['a', 'b', 'c']), 'a-b-c')\n *\n * @since 2.12.0\n */\nexport var intercalate = function (M) {\n    var intercalateM = RNEA.intercalate(M);\n    return function (middle) { return match(function () { return M.empty; }, intercalateM(middle)); };\n};\n// -------------------------------------------------------------------------------------\n// do notation\n// -------------------------------------------------------------------------------------\n/**\n * @category do notation\n * @since 2.9.0\n */\nexport var Do = /*#__PURE__*/ of(_.emptyRecord);\n/**\n * @category do notation\n * @since 2.8.0\n */\nexport var bindTo = /*#__PURE__*/ bindTo_(Functor);\nvar let_ = /*#__PURE__*/ let__(Functor);\nexport { \n/**\n * @category do notation\n * @since 2.13.0\n */\nlet_ as let };\n/**\n * @category do notation\n * @since 2.8.0\n */\nexport var bind = /*#__PURE__*/ bind_(Chain);\n/**\n * @category do notation\n * @since 2.8.0\n */\nexport var apS = /*#__PURE__*/ apS_(Apply);\n// -------------------------------------------------------------------------------------\n// legacy\n// -------------------------------------------------------------------------------------\n/**\n * Alias of `flatMap`.\n *\n * @category legacy\n * @since 2.5.0\n */\nexport var chain = flatMap;\n// -------------------------------------------------------------------------------------\n// deprecated\n// -------------------------------------------------------------------------------------\n/**\n * Use `ReadonlyNonEmptyArray` module instead.\n *\n * @category zone of death\n * @since 2.5.0\n * @deprecated\n */\nexport var range = RNEA.range;\n/**\n * Use [`prepend`](#prepend) instead.\n *\n * @category zone of death\n * @since 2.5.0\n * @deprecated\n */\nexport var cons = RNEA.cons;\n/**\n * Use [`append`](#append) instead.\n *\n * @category zone of death\n * @since 2.5.0\n * @deprecated\n */\nexport var snoc = RNEA.snoc;\n/**\n * Use [`prependAll`](#prependall) instead.\n *\n * @category zone of death\n * @since 2.9.0\n * @deprecated\n */\nexport var prependToAll = prependAll;\n/**\n * This instance is deprecated, use small, specific instances instead.\n * For example if a function needs a `Functor` instance, pass `RA.Functor` instead of `RA.readonlyArray`\n * (where `RA` is from `import RA from 'fp-ts/ReadonlyArray'`)\n *\n * @category zone of death\n * @since 2.5.0\n * @deprecated\n */\nexport var readonlyArray = {\n    URI: URI,\n    compact: compact,\n    separate: separate,\n    map: _map,\n    ap: _ap,\n    of: of,\n    chain: flatMap,\n    filter: _filter,\n    filterMap: _filterMap,\n    partition: _partition,\n    partitionMap: _partitionMap,\n    mapWithIndex: _mapWithIndex,\n    partitionMapWithIndex: _partitionMapWithIndex,\n    partitionWithIndex: _partitionWithIndex,\n    filterMapWithIndex: _filterMapWithIndex,\n    filterWithIndex: _filterWithIndex,\n    alt: _alt,\n    zero: zero,\n    unfold: unfold,\n    reduce: _reduce,\n    foldMap: _foldMap,\n    reduceRight: _reduceRight,\n    traverse: _traverse,\n    sequence: sequence,\n    reduceWithIndex: _reduceWithIndex,\n    foldMapWithIndex: _foldMapWithIndex,\n    reduceRightWithIndex: _reduceRightWithIndex,\n    traverseWithIndex: _traverseWithIndex,\n    extend: _extend,\n    wither: _wither,\n    wilt: _wilt\n};\n","var __spreadArray = (this && this.__spreadArray) || function (to, from, pack) {\n    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {\n        if (ar || !(i in from)) {\n            if (!ar) ar = Array.prototype.slice.call(from, 0, i);\n            ar[i] = from[i];\n        }\n    }\n    return to.concat(ar || Array.prototype.slice.call(from));\n};\nimport { apFirst as apFirst_, apS as apS_, apSecond as apSecond_ } from './Apply';\nimport { bind as bind_, chainFirst as chainFirst_ } from './Chain';\nimport { fromEquals } from './Eq';\nimport { dual, flow, identity, pipe, SK } from './function';\nimport { bindTo as bindTo_, flap as flap_, let as let__ } from './Functor';\nimport * as _ from './internal';\nimport { getMonoid } from './Ord';\nimport * as Se from './Semigroup';\n// -------------------------------------------------------------------------------------\n// internal\n// -------------------------------------------------------------------------------------\n/**\n * @internal\n */\nexport var empty = _.emptyReadonlyArray;\n/**\n * @internal\n */\nexport var isNonEmpty = _.isNonEmpty;\n/**\n * @internal\n */\nexport var isOutOfBound = function (i, as) { return i < 0 || i >= as.length; };\n/**\n * @internal\n */\nexport var prependW = function (head) {\n    return function (tail) {\n        return __spreadArray([head], tail, true);\n    };\n};\n/**\n * @internal\n */\nexport var prepend = prependW;\n/**\n * @internal\n */\nexport var appendW = function (end) {\n    return function (init) {\n        return __spreadArray(__spreadArray([], init, true), [end], false);\n    };\n};\n/**\n * @internal\n */\nexport var append = appendW;\n/**\n * @internal\n */\nexport var unsafeInsertAt = function (i, a, as) {\n    if (isNonEmpty(as)) {\n        var xs = _.fromReadonlyNonEmptyArray(as);\n        xs.splice(i, 0, a);\n        return xs;\n    }\n    return [a];\n};\n/**\n * @internal\n */\nexport var unsafeUpdateAt = function (i, a, as) {\n    if (as[i] === a) {\n        return as;\n    }\n    else {\n        var xs = _.fromReadonlyNonEmptyArray(as);\n        xs[i] = a;\n        return xs;\n    }\n};\n/**\n * Remove duplicates from a `ReadonlyNonEmptyArray`, keeping the first occurrence of an element.\n *\n * @example\n * import { uniq } from 'fp-ts/ReadonlyNonEmptyArray'\n * import * as N from 'fp-ts/number'\n *\n * assert.deepStrictEqual(uniq(N.Eq)([1, 2, 1]), [1, 2])\n *\n * @since 2.11.0\n */\nexport var uniq = function (E) {\n    return function (as) {\n        if (as.length === 1) {\n            return as;\n        }\n        var out = [head(as)];\n        var rest = tail(as);\n        var _loop_1 = function (a) {\n            if (out.every(function (o) { return !E.equals(o, a); })) {\n                out.push(a);\n            }\n        };\n        for (var _i = 0, rest_1 = rest; _i < rest_1.length; _i++) {\n            var a = rest_1[_i];\n            _loop_1(a);\n        }\n        return out;\n    };\n};\n/**\n * Sort the elements of a `ReadonlyNonEmptyArray` in increasing order, where elements are compared using first `ords[0]`, then `ords[1]`,\n * etc...\n *\n * @example\n * import * as RNEA from 'fp-ts/ReadonlyNonEmptyArray'\n * import { contramap } from 'fp-ts/Ord'\n * import * as S from 'fp-ts/string'\n * import * as N from 'fp-ts/number'\n * import { pipe } from 'fp-ts/function'\n *\n * interface Person {\n *   name: string\n *   age: number\n * }\n *\n * const byName = pipe(S.Ord, contramap((p: Person) => p.name))\n *\n * const byAge = pipe(N.Ord, contramap((p: Person) => p.age))\n *\n * const sortByNameByAge = RNEA.sortBy([byName, byAge])\n *\n * const persons: RNEA.ReadonlyNonEmptyArray<Person> = [\n *   { name: 'a', age: 1 },\n *   { name: 'b', age: 3 },\n *   { name: 'c', age: 2 },\n *   { name: 'b', age: 2 }\n * ]\n *\n * assert.deepStrictEqual(sortByNameByAge(persons), [\n *   { name: 'a', age: 1 },\n *   { name: 'b', age: 2 },\n *   { name: 'b', age: 3 },\n *   { name: 'c', age: 2 }\n * ])\n *\n * @since 2.11.0\n */\nexport var sortBy = function (ords) {\n    if (isNonEmpty(ords)) {\n        var M = getMonoid();\n        return sort(ords.reduce(M.concat, M.empty));\n    }\n    return identity;\n};\n/**\n * @since 2.11.0\n */\nexport var union = function (E) {\n    var uniqE = uniq(E);\n    return function (second) { return function (first) { return uniqE(pipe(first, concat(second))); }; };\n};\n/**\n * Rotate a `ReadonlyNonEmptyArray` by `n` steps.\n *\n * @example\n * import { rotate } from 'fp-ts/ReadonlyNonEmptyArray'\n *\n * assert.deepStrictEqual(rotate(2)([1, 2, 3, 4, 5]), [4, 5, 1, 2, 3])\n * assert.deepStrictEqual(rotate(-2)([1, 2, 3, 4, 5]), [3, 4, 5, 1, 2])\n *\n * @since 2.11.0\n */\nexport var rotate = function (n) {\n    return function (as) {\n        var len = as.length;\n        var m = Math.round(n) % len;\n        if (isOutOfBound(Math.abs(m), as) || m === 0) {\n            return as;\n        }\n        if (m < 0) {\n            var _a = splitAt(-m)(as), f = _a[0], s = _a[1];\n            return pipe(s, concat(f));\n        }\n        else {\n            return rotate(m - len)(as);\n        }\n    };\n};\n// -------------------------------------------------------------------------------------\n// constructors\n// -------------------------------------------------------------------------------------\n/**\n * Return a `ReadonlyNonEmptyArray` from a `ReadonlyArray` returning `none` if the input is empty.\n *\n * @category conversions\n * @since 2.5.0\n */\nexport var fromReadonlyArray = function (as) {\n    return isNonEmpty(as) ? _.some(as) : _.none;\n};\n/**\n * Return a `ReadonlyNonEmptyArray` of length `n` with element `i` initialized with `f(i)`.\n *\n * **Note**. `n` is normalized to a natural number.\n *\n * @example\n * import { makeBy } from 'fp-ts/ReadonlyNonEmptyArray'\n * import { pipe } from 'fp-ts/function'\n *\n * const double = (n: number): number => n * 2\n * assert.deepStrictEqual(pipe(5, makeBy(double)), [0, 2, 4, 6, 8])\n *\n * @category constructors\n * @since 2.11.0\n */\nexport var makeBy = function (f) {\n    return function (n) {\n        var j = Math.max(0, Math.floor(n));\n        var out = [f(0)];\n        for (var i = 1; i < j; i++) {\n            out.push(f(i));\n        }\n        return out;\n    };\n};\n/**\n * Create a `ReadonlyNonEmptyArray` containing a value repeated the specified number of times.\n *\n * **Note**. `n` is normalized to a natural number.\n *\n * @example\n * import { replicate } from 'fp-ts/ReadonlyNonEmptyArray'\n * import { pipe } from 'fp-ts/function'\n *\n * assert.deepStrictEqual(pipe(3, replicate('a')), ['a', 'a', 'a'])\n *\n * @category constructors\n * @since 2.11.0\n */\nexport var replicate = function (a) { return makeBy(function () { return a; }); };\n/**\n * Create a `ReadonlyNonEmptyArray` containing a range of integers, including both endpoints.\n *\n * @example\n * import { range } from 'fp-ts/ReadonlyNonEmptyArray'\n *\n * assert.deepStrictEqual(range(1, 5), [1, 2, 3, 4, 5])\n *\n * @category constructors\n * @since 2.11.0\n */\nexport var range = function (start, end) {\n    return start <= end ? makeBy(function (i) { return start + i; })(end - start + 1) : [start];\n};\n/**\n * Return the tuple of the `head` and the `tail`.\n *\n * @example\n * import { unprepend } from 'fp-ts/ReadonlyNonEmptyArray'\n *\n * assert.deepStrictEqual(unprepend([1, 2, 3, 4]), [1, [2, 3, 4]])\n *\n * @since 2.9.0\n */\nexport var unprepend = function (as) { return [head(as), tail(as)]; };\n/**\n * Return the tuple of the `init` and the `last`.\n *\n * @example\n * import { unappend } from 'fp-ts/ReadonlyNonEmptyArray'\n *\n * assert.deepStrictEqual(unappend([1, 2, 3, 4]), [[1, 2, 3], 4])\n *\n * @since 2.9.0\n */\nexport var unappend = function (as) { return [init(as), last(as)]; };\n/**\n * @category conversions\n * @since 2.5.0\n */\nexport var fromArray = function (as) { return fromReadonlyArray(as.slice()); };\nexport function concatW(second) {\n    return function (first) { return first.concat(second); };\n}\nexport function concat(x, y) {\n    return y ? x.concat(y) : function (y) { return y.concat(x); };\n}\n/**\n * @since 2.5.0\n */\nexport var reverse = function (as) {\n    return as.length === 1 ? as : __spreadArray([last(as)], as.slice(0, -1).reverse(), true);\n};\nexport function group(E) {\n    return function (as) {\n        var len = as.length;\n        if (len === 0) {\n            return empty;\n        }\n        var out = [];\n        var head = as[0];\n        var nea = [head];\n        for (var i = 1; i < len; i++) {\n            var a = as[i];\n            if (E.equals(a, head)) {\n                nea.push(a);\n            }\n            else {\n                out.push(nea);\n                head = a;\n                nea = [head];\n            }\n        }\n        out.push(nea);\n        return out;\n    };\n}\n/**\n * Splits an array into sub-non-empty-arrays stored in an object, based on the result of calling a `string`-returning\n * function on each element, and grouping the results according to values returned\n *\n * @example\n * import { groupBy } from 'fp-ts/ReadonlyNonEmptyArray'\n *\n * assert.deepStrictEqual(groupBy((s: string) => String(s.length))(['a', 'b', 'ab']), {\n *   '1': ['a', 'b'],\n *   '2': ['ab']\n * })\n *\n * @since 2.5.0\n */\nexport var groupBy = function (f) {\n    return function (as) {\n        var out = {};\n        for (var _i = 0, as_1 = as; _i < as_1.length; _i++) {\n            var a = as_1[_i];\n            var k = f(a);\n            if (_.has.call(out, k)) {\n                out[k].push(a);\n            }\n            else {\n                out[k] = [a];\n            }\n        }\n        return out;\n    };\n};\n/**\n * @since 2.5.0\n */\nexport var sort = function (O) {\n    return function (as) {\n        return as.length === 1 ? as : as.slice().sort(O.compare);\n    };\n};\n/**\n * @since 2.5.0\n */\nexport var updateAt = function (i, a) {\n    return modifyAt(i, function () { return a; });\n};\n/**\n * @since 2.5.0\n */\nexport var modifyAt = function (i, f) {\n    return function (as) {\n        return isOutOfBound(i, as) ? _.none : _.some(unsafeUpdateAt(i, f(as[i]), as));\n    };\n};\n/**\n * @since 2.5.1\n */\nexport var zipWith = function (as, bs, f) {\n    var cs = [f(as[0], bs[0])];\n    var len = Math.min(as.length, bs.length);\n    for (var i = 1; i < len; i++) {\n        cs[i] = f(as[i], bs[i]);\n    }\n    return cs;\n};\nexport function zip(as, bs) {\n    if (bs === undefined) {\n        return function (bs) { return zip(bs, as); };\n    }\n    return zipWith(as, bs, function (a, b) { return [a, b]; });\n}\n/**\n * @since 2.5.1\n */\nexport var unzip = function (abs) {\n    var fa = [abs[0][0]];\n    var fb = [abs[0][1]];\n    for (var i = 1; i < abs.length; i++) {\n        fa[i] = abs[i][0];\n        fb[i] = abs[i][1];\n    }\n    return [fa, fb];\n};\n/**\n * Prepend an element to every member of a `ReadonlyNonEmptyArray`.\n *\n * @example\n * import { prependAll } from 'fp-ts/ReadonlyNonEmptyArray'\n *\n * assert.deepStrictEqual(prependAll(9)([1, 2, 3, 4]), [9, 1, 9, 2, 9, 3, 9, 4])\n *\n * @since 2.10.0\n */\nexport var prependAll = function (middle) {\n    return function (as) {\n        var out = [middle, as[0]];\n        for (var i = 1; i < as.length; i++) {\n            out.push(middle, as[i]);\n        }\n        return out;\n    };\n};\n/**\n * Places an element in between members of a `ReadonlyNonEmptyArray`.\n *\n * @example\n * import { intersperse } from 'fp-ts/ReadonlyNonEmptyArray'\n *\n * assert.deepStrictEqual(intersperse(9)([1, 2, 3, 4]), [1, 9, 2, 9, 3, 9, 4])\n *\n * @since 2.9.0\n */\nexport var intersperse = function (middle) {\n    return function (as) {\n        var rest = tail(as);\n        return isNonEmpty(rest) ? pipe(rest, prependAll(middle), prepend(head(as))) : as;\n    };\n};\n/**\n * @category sequencing\n * @since 2.10.0\n */\nexport var chainWithIndex = function (f) {\n    return function (as) {\n        var out = _.fromReadonlyNonEmptyArray(f(0, head(as)));\n        for (var i = 1; i < as.length; i++) {\n            var bs = f(i, as[i]);\n            for (var j = 0; j < bs.length; j++) {\n                out.push(bs[j]);\n            }\n        }\n        return out;\n    };\n};\n/**\n * A useful recursion pattern for processing a `ReadonlyNonEmptyArray` to produce a new `ReadonlyNonEmptyArray`, often used for \"chopping\" up the input\n * `ReadonlyNonEmptyArray`. Typically `chop` is called with some function that will consume an initial prefix of the `ReadonlyNonEmptyArray` and produce a\n * value and the tail of the `ReadonlyNonEmptyArray`.\n *\n * @since 2.10.0\n */\nexport var chop = function (f) {\n    return function (as) {\n        var _a = f(as), b = _a[0], rest = _a[1];\n        var out = [b];\n        var next = rest;\n        while (isNonEmpty(next)) {\n            var _b = f(next), b_1 = _b[0], rest_2 = _b[1];\n            out.push(b_1);\n            next = rest_2;\n        }\n        return out;\n    };\n};\n/**\n * Splits a `ReadonlyNonEmptyArray` into two pieces, the first piece has max `n` elements.\n *\n * @since 2.10.0\n */\nexport var splitAt = function (n) {\n    return function (as) {\n        var m = Math.max(1, n);\n        return m >= as.length ? [as, empty] : [pipe(as.slice(1, m), prepend(head(as))), as.slice(m)];\n    };\n};\n/**\n * Splits a `ReadonlyNonEmptyArray` into length-`n` pieces. The last piece will be shorter if `n` does not evenly divide the length of\n * the `ReadonlyNonEmptyArray`.\n *\n * @since 2.10.0\n */\nexport var chunksOf = function (n) { return chop(splitAt(n)); };\nvar _map = function (fa, f) { return pipe(fa, map(f)); };\n/* istanbul ignore next */\nvar _mapWithIndex = function (fa, f) { return pipe(fa, mapWithIndex(f)); };\nvar _ap = function (fab, fa) { return pipe(fab, ap(fa)); };\n/* istanbul ignore next */\nvar _extend = function (wa, f) { return pipe(wa, extend(f)); };\n/* istanbul ignore next */\nvar _reduce = function (fa, b, f) { return pipe(fa, reduce(b, f)); };\n/* istanbul ignore next */\nvar _foldMap = function (M) {\n    var foldMapM = foldMap(M);\n    return function (fa, f) { return pipe(fa, foldMapM(f)); };\n};\n/* istanbul ignore next */\nvar _reduceRight = function (fa, b, f) { return pipe(fa, reduceRight(b, f)); };\n/* istanbul ignore next */\nvar _traverse = function (F) {\n    var traverseF = traverse(F);\n    return function (ta, f) { return pipe(ta, traverseF(f)); };\n};\n/* istanbul ignore next */\nvar _alt = function (fa, that) { return pipe(fa, alt(that)); };\n/* istanbul ignore next */\nvar _reduceWithIndex = function (fa, b, f) {\n    return pipe(fa, reduceWithIndex(b, f));\n};\n/* istanbul ignore next */\nvar _foldMapWithIndex = function (M) {\n    var foldMapWithIndexM = foldMapWithIndex(M);\n    return function (fa, f) { return pipe(fa, foldMapWithIndexM(f)); };\n};\n/* istanbul ignore next */\nvar _reduceRightWithIndex = function (fa, b, f) {\n    return pipe(fa, reduceRightWithIndex(b, f));\n};\n/* istanbul ignore next */\nvar _traverseWithIndex = function (F) {\n    var traverseWithIndexF = traverseWithIndex(F);\n    return function (ta, f) { return pipe(ta, traverseWithIndexF(f)); };\n};\n/**\n * @category constructors\n * @since 2.5.0\n */\nexport var of = _.singleton;\n/**\n * Less strict version of [`alt`](#alt).\n *\n * The `W` suffix (short for **W**idening) means that the return types will be merged.\n *\n * @example\n * import * as RNEA from 'fp-ts/ReadonlyNonEmptyArray'\n * import { pipe } from 'fp-ts/function'\n *\n * assert.deepStrictEqual(\n *   pipe(\n *     [1, 2, 3] as RNEA.ReadonlyNonEmptyArray<number>,\n *     RNEA.altW(() => ['a', 'b'])\n *   ),\n *   [1, 2, 3, 'a', 'b']\n * )\n *\n * @category error handling\n * @since 2.9.0\n */\nexport var altW = function (that) {\n    return function (as) {\n        return pipe(as, concatW(that()));\n    };\n};\n/**\n * Identifies an associative operation on a type constructor. It is similar to `Semigroup`, except that it applies to\n * types of kind `* -> *`.\n *\n * In case of `ReadonlyNonEmptyArray` concatenates the inputs into a single array.\n *\n * @example\n * import * as RNEA from 'fp-ts/ReadonlyNonEmptyArray'\n * import { pipe } from 'fp-ts/function'\n *\n * assert.deepStrictEqual(\n *   pipe(\n *     [1, 2, 3],\n *     RNEA.alt(() => [4, 5])\n *   ),\n *   [1, 2, 3, 4, 5]\n * )\n *\n * @category error handling\n * @since 2.6.2\n */\nexport var alt = altW;\n/**\n * @since 2.5.0\n */\nexport var ap = function (as) { return flatMap(function (f) { return pipe(as, map(f)); }); };\n/**\n * @example\n * import * as RNEA from 'fp-ts/ReadonlyNonEmptyArray'\n * import { pipe } from 'fp-ts/function'\n *\n * assert.deepStrictEqual(\n *   pipe(\n *     [1, 2, 3],\n *     RNEA.flatMap((n) => [`a${n}`, `b${n}`])\n *   ),\n *   ['a1', 'b1', 'a2', 'b2', 'a3', 'b3']\n * )\n *\n * @category sequencing\n * @since 2.14.0\n */\nexport var flatMap = /*#__PURE__*/ dual(2, function (ma, f) {\n    return pipe(ma, chainWithIndex(function (i, a) { return f(a, i); }));\n});\n/**\n * @since 2.5.0\n */\nexport var extend = function (f) {\n    return function (as) {\n        var next = tail(as);\n        var out = [f(as)];\n        while (isNonEmpty(next)) {\n            out.push(f(next));\n            next = tail(next);\n        }\n        return out;\n    };\n};\n/**\n * @since 2.5.0\n */\nexport var duplicate = \n/*#__PURE__*/ extend(identity);\n/**\n * @category sequencing\n * @since 2.5.0\n */\nexport var flatten = \n/*#__PURE__*/ flatMap(identity);\n/**\n * `map` can be used to turn functions `(a: A) => B` into functions `(fa: F<A>) => F<B>` whose argument and return types\n * use the type constructor `F` to represent some computational context.\n *\n * @category mapping\n * @since 2.5.0\n */\nexport var map = function (f) {\n    return mapWithIndex(function (_, a) { return f(a); });\n};\n/**\n * @category mapping\n * @since 2.5.0\n */\nexport var mapWithIndex = function (f) {\n    return function (as) {\n        var out = [f(0, head(as))];\n        for (var i = 1; i < as.length; i++) {\n            out.push(f(i, as[i]));\n        }\n        return out;\n    };\n};\n/**\n * @category folding\n * @since 2.5.0\n */\nexport var reduce = function (b, f) {\n    return reduceWithIndex(b, function (_, b, a) { return f(b, a); });\n};\n/**\n * **Note**. The constraint is relaxed: a `Semigroup` instead of a `Monoid`.\n *\n * @category folding\n * @since 2.5.0\n */\nexport var foldMap = function (S) {\n    return function (f) {\n        return function (as) {\n            return as.slice(1).reduce(function (s, a) { return S.concat(s, f(a)); }, f(as[0]));\n        };\n    };\n};\n/**\n * @category folding\n * @since 2.5.0\n */\nexport var reduceRight = function (b, f) {\n    return reduceRightWithIndex(b, function (_, b, a) { return f(b, a); });\n};\n/**\n * @category folding\n * @since 2.5.0\n */\nexport var reduceWithIndex = function (b, f) {\n    return function (as) {\n        return as.reduce(function (b, a, i) { return f(i, b, a); }, b);\n    };\n};\n/**\n * **Note**. The constraint is relaxed: a `Semigroup` instead of a `Monoid`.\n *\n * @category folding\n * @since 2.5.0\n */\nexport var foldMapWithIndex = function (S) {\n    return function (f) {\n        return function (as) {\n            return as.slice(1).reduce(function (s, a, i) { return S.concat(s, f(i + 1, a)); }, f(0, as[0]));\n        };\n    };\n};\n/**\n * @category folding\n * @since 2.5.0\n */\nexport var reduceRightWithIndex = function (b, f) {\n    return function (as) {\n        return as.reduceRight(function (b, a, i) { return f(i, a, b); }, b);\n    };\n};\n/**\n * @category traversing\n * @since 2.6.3\n */\nexport var traverse = function (F) {\n    var traverseWithIndexF = traverseWithIndex(F);\n    return function (f) { return traverseWithIndexF(function (_, a) { return f(a); }); };\n};\n/**\n * @category traversing\n * @since 2.6.3\n */\nexport var sequence = function (F) { return traverseWithIndex(F)(SK); };\n/**\n * @category sequencing\n * @since 2.6.3\n */\nexport var traverseWithIndex = function (F) {\n    return function (f) {\n        return function (as) {\n            var out = F.map(f(0, head(as)), of);\n            for (var i = 1; i < as.length; i++) {\n                out = F.ap(F.map(out, function (bs) { return function (b) { return pipe(bs, append(b)); }; }), f(i, as[i]));\n            }\n            return out;\n        };\n    };\n};\n/**\n * @category Comonad\n * @since 2.6.3\n */\nexport var extract = _.head;\n/**\n * @category type lambdas\n * @since 2.5.0\n */\nexport var URI = 'ReadonlyNonEmptyArray';\n/**\n * @category instances\n * @since 2.5.0\n */\nexport var getShow = function (S) { return ({\n    show: function (as) { return \"[\".concat(as.map(S.show).join(', '), \"]\"); }\n}); };\n/**\n * Builds a `Semigroup` instance for `ReadonlyNonEmptyArray`\n *\n * @category instances\n * @since 2.5.0\n */\nexport var getSemigroup = function () { return ({\n    concat: concat\n}); };\n/**\n * @example\n * import { getEq } from 'fp-ts/ReadonlyNonEmptyArray'\n * import * as N from 'fp-ts/number'\n *\n * const E = getEq(N.Eq)\n * assert.strictEqual(E.equals([1, 2], [1, 2]), true)\n * assert.strictEqual(E.equals([1, 2], [1, 3]), false)\n *\n * @category instances\n * @since 2.5.0\n */\nexport var getEq = function (E) {\n    return fromEquals(function (xs, ys) { return xs.length === ys.length && xs.every(function (x, i) { return E.equals(x, ys[i]); }); });\n};\n/**\n * @since 2.11.0\n */\nexport var getUnionSemigroup = function (E) {\n    var unionE = union(E);\n    return {\n        concat: function (first, second) { return unionE(second)(first); }\n    };\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Functor = {\n    URI: URI,\n    map: _map\n};\n/**\n * @category mapping\n * @since 2.10.0\n */\nexport var flap = /*#__PURE__*/ flap_(Functor);\n/**\n * @category instances\n * @since 2.10.0\n */\nexport var Pointed = {\n    URI: URI,\n    of: of\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var FunctorWithIndex = {\n    URI: URI,\n    map: _map,\n    mapWithIndex: _mapWithIndex\n};\n/**\n * @category instances\n * @since 2.10.0\n */\nexport var Apply = {\n    URI: URI,\n    map: _map,\n    ap: _ap\n};\n/**\n * Combine two effectful actions, keeping only the result of the first.\n *\n * @since 2.5.0\n */\nexport var apFirst = /*#__PURE__*/ apFirst_(Apply);\n/**\n * Combine two effectful actions, keeping only the result of the second.\n *\n * @since 2.5.0\n */\nexport var apSecond = /*#__PURE__*/ apSecond_(Apply);\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Applicative = {\n    URI: URI,\n    map: _map,\n    ap: _ap,\n    of: of\n};\n/**\n * @category instances\n * @since 2.10.0\n */\nexport var Chain = {\n    URI: URI,\n    map: _map,\n    ap: _ap,\n    chain: flatMap\n};\n/**\n * Composes computations in sequence, using the return value of one computation to determine the next computation and\n * keeping only the result of the first.\n *\n * @example\n * import * as RA from 'fp-ts/ReadonlyArray'\n * import { pipe } from 'fp-ts/function'\n *\n * assert.deepStrictEqual(\n *   pipe(\n *     [1, 2, 3],\n *     RA.chainFirst(() => ['a', 'b'])\n *   ),\n *   [1, 1, 2, 2, 3, 3]\n * )\n *\n * @category sequencing\n * @since 2.5.0\n */\nexport var chainFirst = /*#__PURE__*/ chainFirst_(Chain);\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Monad = {\n    URI: URI,\n    map: _map,\n    ap: _ap,\n    of: of,\n    chain: flatMap\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Foldable = {\n    URI: URI,\n    reduce: _reduce,\n    foldMap: _foldMap,\n    reduceRight: _reduceRight\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var FoldableWithIndex = {\n    URI: URI,\n    reduce: _reduce,\n    foldMap: _foldMap,\n    reduceRight: _reduceRight,\n    reduceWithIndex: _reduceWithIndex,\n    foldMapWithIndex: _foldMapWithIndex,\n    reduceRightWithIndex: _reduceRightWithIndex\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Traversable = {\n    URI: URI,\n    map: _map,\n    reduce: _reduce,\n    foldMap: _foldMap,\n    reduceRight: _reduceRight,\n    traverse: _traverse,\n    sequence: sequence\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var TraversableWithIndex = {\n    URI: URI,\n    map: _map,\n    mapWithIndex: _mapWithIndex,\n    reduce: _reduce,\n    foldMap: _foldMap,\n    reduceRight: _reduceRight,\n    traverse: _traverse,\n    sequence: sequence,\n    reduceWithIndex: _reduceWithIndex,\n    foldMapWithIndex: _foldMapWithIndex,\n    reduceRightWithIndex: _reduceRightWithIndex,\n    traverseWithIndex: _traverseWithIndex\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Alt = {\n    URI: URI,\n    map: _map,\n    alt: _alt\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Comonad = {\n    URI: URI,\n    map: _map,\n    extend: _extend,\n    extract: extract\n};\n// -------------------------------------------------------------------------------------\n// do notation\n// -------------------------------------------------------------------------------------\n/**\n * @category do notation\n * @since 2.9.0\n */\nexport var Do = /*#__PURE__*/ of(_.emptyRecord);\n/**\n * @category do notation\n * @since 2.8.0\n */\nexport var bindTo = /*#__PURE__*/ bindTo_(Functor);\nvar let_ = /*#__PURE__*/ let__(Functor);\nexport { \n/**\n * @category do notation\n * @since 2.13.0\n */\nlet_ as let };\n/**\n * @category do notation\n * @since 2.8.0\n */\nexport var bind = /*#__PURE__*/ bind_(Chain);\n/**\n * @category do notation\n * @since 2.8.0\n */\nexport var apS = /*#__PURE__*/ apS_(Apply);\n// -------------------------------------------------------------------------------------\n// utils\n// -------------------------------------------------------------------------------------\n/**\n * @since 2.5.0\n */\nexport var head = extract;\n/**\n * @since 2.5.0\n */\nexport var tail = _.tail;\n/**\n * @since 2.5.0\n */\nexport var last = function (as) { return as[as.length - 1]; };\n/**\n * Get all but the last element of a non empty array, creating a new array.\n *\n * @example\n * import { init } from 'fp-ts/ReadonlyNonEmptyArray'\n *\n * assert.deepStrictEqual(init([1, 2, 3]), [1, 2])\n * assert.deepStrictEqual(init([1]), [])\n *\n * @since 2.5.0\n */\nexport var init = function (as) { return as.slice(0, -1); };\n/**\n * @since 2.5.0\n */\nexport var min = function (O) {\n    var S = Se.min(O);\n    return function (as) { return as.reduce(S.concat); };\n};\n/**\n * @since 2.5.0\n */\nexport var max = function (O) {\n    var S = Se.max(O);\n    return function (as) { return as.reduce(S.concat); };\n};\n/**\n * @since 2.10.0\n */\nexport var concatAll = function (S) {\n    return function (as) {\n        return as.reduce(S.concat);\n    };\n};\n/**\n * Break a `ReadonlyArray` into its first element and remaining elements.\n *\n * @category pattern matching\n * @since 2.11.0\n */\nexport var matchLeft = function (f) {\n    return function (as) {\n        return f(head(as), tail(as));\n    };\n};\n/**\n * Break a `ReadonlyArray` into its initial elements and the last element.\n *\n * @category pattern matching\n * @since 2.11.0\n */\nexport var matchRight = function (f) {\n    return function (as) {\n        return f(init(as), last(as));\n    };\n};\n/**\n * Apply a function to the head, creating a new `ReadonlyNonEmptyArray`.\n *\n * @since 2.11.0\n */\nexport var modifyHead = function (f) {\n    return function (as) {\n        return __spreadArray([f(head(as))], tail(as), true);\n    };\n};\n/**\n * Change the head, creating a new `ReadonlyNonEmptyArray`.\n *\n * @since 2.11.0\n */\nexport var updateHead = function (a) { return modifyHead(function () { return a; }); };\n/**\n * Apply a function to the last element, creating a new `ReadonlyNonEmptyArray`.\n *\n * @since 2.11.0\n */\nexport var modifyLast = function (f) {\n    return function (as) {\n        return pipe(init(as), append(f(last(as))));\n    };\n};\n/**\n * Change the last element, creating a new `ReadonlyNonEmptyArray`.\n *\n * @since 2.11.0\n */\nexport var updateLast = function (a) { return modifyLast(function () { return a; }); };\n/**\n * Places an element in between members of a `ReadonlyNonEmptyArray`, then folds the results using the provided `Semigroup`.\n *\n * @example\n * import * as S from 'fp-ts/string'\n * import { intercalate } from 'fp-ts/ReadonlyNonEmptyArray'\n *\n * assert.deepStrictEqual(intercalate(S.Semigroup)('-')(['a', 'b', 'c']), 'a-b-c')\n *\n * @since 2.12.0\n */\nexport var intercalate = function (S) {\n    var concatAllS = concatAll(S);\n    return function (middle) { return flow(intersperse(middle), concatAllS); };\n};\n// -------------------------------------------------------------------------------------\n// legacy\n// -------------------------------------------------------------------------------------\n/**\n * Alias of `flatMap`.\n *\n * @category legacy\n * @since 2.5.0\n */\nexport var chain = flatMap;\nexport function groupSort(O) {\n    var sortO = sort(O);\n    var groupO = group(O);\n    return function (as) { return (isNonEmpty(as) ? groupO(sortO(as)) : empty); };\n}\nexport function filter(predicate) {\n    return filterWithIndex(function (_, a) { return predicate(a); });\n}\n/**\n * Use [`filterWithIndex`](./ReadonlyArray.ts.html#filterwithindex) instead.\n *\n * @category zone of death\n * @since 2.5.0\n * @deprecated\n */\nexport var filterWithIndex = function (predicate) {\n    return function (as) {\n        return fromReadonlyArray(as.filter(function (a, i) { return predicate(i, a); }));\n    };\n};\n/**\n * Use [`unprepend`](#unprepend) instead.\n *\n * @category zone of death\n * @since 2.10.0\n * @deprecated\n */\nexport var uncons = unprepend;\n/**\n * Use [`unappend`](#unappend) instead.\n *\n * @category zone of death\n * @since 2.10.0\n * @deprecated\n */\nexport var unsnoc = unappend;\nexport function cons(head, tail) {\n    return tail === undefined ? prepend(head) : pipe(tail, prepend(head));\n}\n/**\n * Use [`append`](./ReadonlyArray.ts.html#append) instead.\n *\n * @category zone of death\n * @since 2.5.0\n * @deprecated\n */\nexport var snoc = function (init, end) { return pipe(init, concat([end])); };\n/**\n * Use [`insertAt`](./ReadonlyArray.ts.html#insertat) instead.\n *\n * @category zone of death\n * @since 2.5.0\n * @deprecated\n */\nexport var insertAt = function (i, a) {\n    return function (as) {\n        return i < 0 || i > as.length ? _.none : _.some(unsafeInsertAt(i, a, as));\n    };\n};\n/**\n * Use [`prependAll`](#prependall) instead.\n *\n * @category zone of death\n * @since 2.9.0\n * @deprecated\n */\nexport var prependToAll = prependAll;\n/**\n * Use [`concatAll`](#concatall) instead.\n *\n * @category zone of death\n * @since 2.5.0\n * @deprecated\n */\nexport var fold = concatAll;\n/**\n * This instance is deprecated, use small, specific instances instead.\n * For example if a function needs a `Functor` instance, pass `RNEA.Functor` instead of `RNEA.readonlyNonEmptyArray`\n * (where `RNEA` is from `import RNEA from 'fp-ts/ReadonlyNonEmptyArray'`)\n *\n * @category zone of death\n * @since 2.5.0\n * @deprecated\n */\nexport var readonlyNonEmptyArray = {\n    URI: URI,\n    of: of,\n    map: _map,\n    mapWithIndex: _mapWithIndex,\n    ap: _ap,\n    chain: flatMap,\n    extend: _extend,\n    extract: extract,\n    reduce: _reduce,\n    foldMap: _foldMap,\n    reduceRight: _reduceRight,\n    traverse: _traverse,\n    sequence: sequence,\n    reduceWithIndex: _reduceWithIndex,\n    foldMapWithIndex: _foldMapWithIndex,\n    reduceRightWithIndex: _reduceRightWithIndex,\n    traverseWithIndex: _traverseWithIndex,\n    alt: _alt\n};\n","import { fromEquals } from './Eq';\nimport { flow, identity, pipe, SK } from './function';\nimport { flap as flap_ } from './Functor';\nimport * as _ from './internal';\nimport { separated } from './Separated';\nimport * as S from './string';\nimport { wiltDefault, witherDefault } from './Witherable';\n/**\n * Builds a `ReadonlyRecord` by copying a `Record`.\n *\n * @example\n * import { ReadonlyRecord, fromRecord } from \"fp-ts/ReadonlyRecord\"\n *\n * const x: Record<string, number> = { a: 1, b: 2 };\n * const y: ReadonlyRecord<string, number> = fromRecord(x);\n * assert.deepStrictEqual(x,y);\n * // `y.a = 5` gives compiler error\n *\n * @category conversions\n * @since 2.5.0\n */\nexport var fromRecord = function (r) { return Object.assign({}, r); };\n/**\n * Builds a mutable `Record` from a `ReadonlyRecord`.\n *\n * @example\n * import { ReadonlyRecord, toRecord } from \"fp-ts/ReadonlyRecord\"\n *\n * const x: ReadonlyRecord<string, number> = { a: 1, b: 2 };\n * const y: Record<string, number> = toRecord(x);\n * assert.deepStrictEqual(x,y);\n * y.a = 5; // it's ok, y is mutable\n *\n * @category conversions\n * @since 2.5.0\n */\nexport var toRecord = function (r) { return Object.assign({}, r); };\n/**\n * Calculate the number of key/value pairs in a `ReadonlyRecord`,\n *\n * @example\n * import { size } from \"fp-ts/ReadonlyRecord\";\n *\n * assert.deepStrictEqual(size({ a: true, b: 2, c: \"three\" }), 3);\n *\n * @since 2.5.0\n */\nexport var size = function (r) { return Object.keys(r).length; };\n/**\n * Test whether a `ReadonlyRecord` is empty.\n *\n * @example\n * import { isEmpty } from \"fp-ts/ReadonlyRecord\"\n *\n * assert.deepStrictEqual(isEmpty({}), true);\n * assert.deepStrictEqual(isEmpty({ a: 3 }), false);\n * @since 2.5.0\n */\nexport var isEmpty = function (r) {\n    for (var k in r) {\n        if (_.has.call(r, k)) {\n            return false;\n        }\n    }\n    return true;\n};\nvar keys_ = function (O) {\n    return function (r) {\n        return Object.keys(r).sort(O.compare);\n    };\n};\n/**\n * @since 2.5.0\n */\nexport var keys = /*#__PURE__*/ keys_(S.Ord);\nexport function collect(O) {\n    if (typeof O === 'function') {\n        return collect(S.Ord)(O);\n    }\n    var keysO = keys_(O);\n    return function (f) {\n        return function (r) {\n            var out = [];\n            for (var _i = 0, _a = keysO(r); _i < _a.length; _i++) {\n                var key = _a[_i];\n                out.push(f(key, r[key]));\n            }\n            return out;\n        };\n    };\n}\n/**\n * Get a sorted `ReadonlyArray` of the key/value pairs contained in a `ReadonlyRecord`.\n *\n * @example\n * import { toReadonlyArray } from 'fp-ts/ReadonlyRecord'\n *\n * const x = { c: 3, a: \"foo\", b: false };\n * assert.deepStrictEqual(toReadonlyArray(x), [\n *   [\"a\", \"foo\"],\n *   [\"b\", false],\n *   [\"c\", 3],\n * ]);\n *\n * @category conversions\n * @since 2.5.0\n */\nexport var toReadonlyArray = \n/*#__PURE__*/ collect(S.Ord)(function (k, a) { return [k, a]; });\nexport function toUnfoldable(U) {\n    return function (r) {\n        var sas = toReadonlyArray(r);\n        var len = sas.length;\n        return U.unfold(0, function (b) { return (b < len ? _.some([sas[b], b + 1]) : _.none); });\n    };\n}\n/**\n * Insert or replace a key/value pair in a `ReadonlyRecord`.\n *\n * @example\n * import { upsertAt } from 'fp-ts/ReadonlyRecord'\n *\n * assert.deepStrictEqual(upsertAt(\"a\", 5)({ a: 1, b: 2 }), { a: 5, b: 2 });\n * assert.deepStrictEqual(upsertAt(\"c\", 5)({ a: 1, b: 2 }), { a: 1, b: 2, c: 5 });\n *\n * @since 2.10.0\n */\nexport var upsertAt = function (k, a) {\n    return function (r) {\n        if (_.has.call(r, k) && r[k] === a) {\n            return r;\n        }\n        var out = Object.assign({}, r);\n        out[k] = a;\n        return out;\n    };\n};\n/**\n * Test whether or not a key exists in a `ReadonlyRecord`.\n *\n * Note. This function is not pipeable because is a `Refinement`.\n *\n * @example\n * import { has } from 'fp-ts/ReadonlyRecord'\n *\n * assert.deepStrictEqual(has(\"a\", { a: 1, b: 2 }), true);\n * assert.deepStrictEqual(has(\"c\", { a: 1, b: 2 }), false);\n *\n * @since 2.10.0\n */\nexport var has = function (k, r) { return _.has.call(r, k); };\nexport function deleteAt(k) {\n    return function (r) {\n        if (!_.has.call(r, k)) {\n            return r;\n        }\n        var out = Object.assign({}, r);\n        delete out[k];\n        return out;\n    };\n}\n/**\n * Replace a key/value pair in a `ReadonlyRecord`.\n *\n * @returns If the specified key exists it returns an `Option` containing a new `Record`\n * with the entry updated, otherwise it returns `None`\n *\n * @example\n * import { updateAt } from 'fp-ts/ReadonlyRecord'\n * import { option } from 'fp-ts'\n *\n * assert.deepStrictEqual(updateAt(\"a\", 3)({ a: 1, b: 2 }), option.some({ a: 3, b: 2 }));\n * assert.deepStrictEqual(updateAt(\"c\", 3)({ a: 1, b: 2 }), option.none);\n *\n * @since 2.5.0\n */\nexport var updateAt = function (k, a) {\n    return function (r) {\n        if (!has(k, r)) {\n            return _.none;\n        }\n        if (r[k] === a) {\n            return _.some(r);\n        }\n        var out = Object.assign({}, r);\n        out[k] = a;\n        return _.some(out);\n    };\n};\n/**\n * Applies a mapping function to one specific key/value pair in a `ReadonlyRecord`.\n *\n * @returns If the specified key exists it returns an `Option` containing a new `Record`\n * with the entry updated, otherwise it returns `None`\n *\n * @example\n * import { modifyAt } from 'fp-ts/ReadonlyRecord'\n * import { option } from 'fp-ts'\n *\n * assert.deepStrictEqual(modifyAt(\"a\", (x: number) => x * 3)({ a: 1, b: 2 }), option.some({ a: 3, b: 2 }));\n * assert.deepStrictEqual(modifyAt(\"c\", (x: number) => x * 3)({ a: 1, b: 2 }), option.none);\n *\n * @since 2.5.0\n */\nexport var modifyAt = function (k, f) {\n    return function (r) {\n        if (!has(k, r)) {\n            return _.none;\n        }\n        var next = f(r[k]);\n        if (next === r[k]) {\n            return _.some(r);\n        }\n        var out = Object.assign({}, r);\n        out[k] = next;\n        return _.some(out);\n    };\n};\nexport function pop(k) {\n    var deleteAtk = deleteAt(k);\n    return function (r) {\n        var oa = lookup(k, r);\n        return _.isNone(oa) ? _.none : _.some([oa.value, deleteAtk(r)]);\n    };\n}\nexport function isSubrecord(E) {\n    return function (me, that) {\n        if (that === undefined) {\n            var isSubrecordE_1 = isSubrecord(E);\n            return function (that) { return isSubrecordE_1(that, me); };\n        }\n        for (var k in me) {\n            if (!_.has.call(that, k) || !E.equals(me[k], that[k])) {\n                return false;\n            }\n        }\n        return true;\n    };\n}\nexport function lookup(k, r) {\n    if (r === undefined) {\n        return function (r) { return lookup(k, r); };\n    }\n    return _.has.call(r, k) ? _.some(r[k]) : _.none;\n}\n/**\n * @since 2.5.0\n */\nexport var empty = {};\nexport function mapWithIndex(f) {\n    return function (r) {\n        var out = {};\n        for (var k in r) {\n            if (_.has.call(r, k)) {\n                out[k] = f(k, r[k]);\n            }\n        }\n        return out;\n    };\n}\nexport function map(f) {\n    return mapWithIndex(function (_, a) { return f(a); });\n}\nexport function reduceWithIndex() {\n    var args = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        args[_i] = arguments[_i];\n    }\n    if (args.length === 2) {\n        return reduceWithIndex(S.Ord).apply(void 0, args);\n    }\n    var keysO = keys_(args[0]);\n    return function (b, f) { return function (fa) {\n        var out = b;\n        var ks = keysO(fa);\n        var len = ks.length;\n        for (var i = 0; i < len; i++) {\n            var k = ks[i];\n            out = f(k, out, fa[k]);\n        }\n        return out;\n    }; };\n}\nexport function foldMapWithIndex(O) {\n    if ('compare' in O) {\n        var keysO_1 = keys_(O);\n        return function (M) {\n            return function (f) {\n                return function (fa) {\n                    var out = M.empty;\n                    var ks = keysO_1(fa);\n                    var len = ks.length;\n                    for (var i = 0; i < len; i++) {\n                        var k = ks[i];\n                        out = M.concat(out, f(k, fa[k]));\n                    }\n                    return out;\n                };\n            };\n        };\n    }\n    return foldMapWithIndex(S.Ord)(O);\n}\nexport function reduceRightWithIndex() {\n    var args = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        args[_i] = arguments[_i];\n    }\n    if (args.length === 2) {\n        return reduceRightWithIndex(S.Ord).apply(void 0, args);\n    }\n    var keysO = keys_(args[0]);\n    return function (b, f) { return function (fa) {\n        var out = b;\n        var ks = keysO(fa);\n        var len = ks.length;\n        for (var i = len - 1; i >= 0; i--) {\n            var k = ks[i];\n            out = f(k, fa[k], out);\n        }\n        return out;\n    }; };\n}\n/**\n * Create a `ReadonlyRecord` with one key/value pair.\n *\n * @example\n * import { singleton } from \"fp-ts/ReadonlyRecord\";\n *\n * assert.deepStrictEqual(singleton(\"a\", 1), { a: 1 });\n *\n * @category constructors\n * @since 2.5.0\n */\nexport var singleton = function (k, a) {\n    var _a;\n    return (_a = {}, _a[k] = a, _a);\n};\nexport function traverseWithIndex(F) {\n    var traverseWithIndexOF = _traverseWithIndex(S.Ord)(F);\n    return function (f) { return function (ta) { return traverseWithIndexOF(ta, f); }; };\n}\nexport function traverse(F) {\n    var traverseOF = _traverse(S.Ord)(F);\n    return function (f) { return function (ta) { return traverseOF(ta, f); }; };\n}\nexport function sequence(F) {\n    return _sequence(S.Ord)(F);\n}\n/**\n * @category filtering\n * @since 2.6.5\n */\nexport var wither = function (F) {\n    var traverseF = traverse(F);\n    return function (f) { return function (fa) { return F.map(pipe(fa, traverseF(f)), compact); }; };\n};\n/**\n * @category filtering\n * @since 2.6.5\n */\nexport var wilt = function (F) {\n    var traverseF = traverse(F);\n    return function (f) { return function (fa) { return F.map(pipe(fa, traverseF(f)), separate); }; };\n};\nexport function partitionMapWithIndex(f) {\n    return function (r) {\n        var left = {};\n        var right = {};\n        for (var k in r) {\n            if (_.has.call(r, k)) {\n                var e = f(k, r[k]);\n                switch (e._tag) {\n                    case 'Left':\n                        left[k] = e.left;\n                        break;\n                    case 'Right':\n                        right[k] = e.right;\n                        break;\n                }\n            }\n        }\n        return separated(left, right);\n    };\n}\nexport function partitionWithIndex(predicateWithIndex) {\n    return function (r) {\n        var left = {};\n        var right = {};\n        for (var k in r) {\n            if (_.has.call(r, k)) {\n                var a = r[k];\n                if (predicateWithIndex(k, a)) {\n                    right[k] = a;\n                }\n                else {\n                    left[k] = a;\n                }\n            }\n        }\n        return separated(left, right);\n    };\n}\nexport function filterMapWithIndex(f) {\n    return function (r) {\n        var out = {};\n        for (var k in r) {\n            if (_.has.call(r, k)) {\n                var ob = f(k, r[k]);\n                if (_.isSome(ob)) {\n                    out[k] = ob.value;\n                }\n            }\n        }\n        return out;\n    };\n}\nexport function filterWithIndex(predicateWithIndex) {\n    return function (fa) {\n        var out = {};\n        var changed = false;\n        for (var key in fa) {\n            if (_.has.call(fa, key)) {\n                var a = fa[key];\n                if (predicateWithIndex(key, a)) {\n                    out[key] = a;\n                }\n                else {\n                    changed = true;\n                }\n            }\n        }\n        return changed ? out : fa;\n    };\n}\nexport function fromFoldable(M, F) {\n    var fromFoldableMapM = fromFoldableMap(M, F);\n    return function (fka) { return fromFoldableMapM(fka, identity); };\n}\nexport function fromFoldableMap(M, F) {\n    return function (ta, f) {\n        return F.reduce(ta, {}, function (r, a) {\n            var _a = f(a), k = _a[0], b = _a[1];\n            r[k] = _.has.call(r, k) ? M.concat(r[k], b) : b;\n            return r;\n        });\n    };\n}\n/**\n * Alias of [`toReadonlyArray`](#toreadonlyarray).\n *\n * @example\n * import { toEntries } from 'fp-ts/ReadonlyRecord'\n *\n * assert.deepStrictEqual(toEntries({ b: 2, a: 1 }), [['a', 1], ['b', 2]])\n *\n * @category conversions\n * @since 2.12.0\n */\nexport var toEntries = toReadonlyArray;\n/**\n * Converts a `ReadonlyArray` of `[key, value]` tuples into a `ReadonlyRecord`.\n *\n * @example\n * import { fromEntries } from 'fp-ts/ReadonlyRecord'\n *\n * assert.deepStrictEqual(fromEntries([['a', 1], ['b', 2], ['a', 3]]), { b: 2, a: 3 })\n *\n * @since 2.12.0\n * @category conversions\n */\nexport var fromEntries = function (fa) {\n    var out = {};\n    for (var _i = 0, fa_1 = fa; _i < fa_1.length; _i++) {\n        var a = fa_1[_i];\n        out[a[0]] = a[1];\n    }\n    return out;\n};\nexport function every(predicate) {\n    return function (r) {\n        for (var k in r) {\n            if (!predicate(r[k])) {\n                return false;\n            }\n        }\n        return true;\n    };\n}\n/**\n * Test if at least one value in a `ReadonlyRecord` satisfies the predicate.\n *\n * @example\n * import { some } from \"fp-ts/ReadonlyRecord\"\n *\n * assert.deepStrictEqual(some((n: number) => n >= 0)({ a: 1, b: -2 }), true);\n * assert.deepStrictEqual(some((n: number) => n >= 0)({ a: -1, b: -2 }), false);\n *\n * @since 2.5.0\n */\nexport function some(predicate) {\n    return function (r) {\n        for (var k in r) {\n            if (predicate(r[k])) {\n                return true;\n            }\n        }\n        return false;\n    };\n}\nexport function elem(E) {\n    return function (a, fa) {\n        if (fa === undefined) {\n            var elemE_1 = elem(E);\n            return function (fa) { return elemE_1(a, fa); };\n        }\n        for (var k in fa) {\n            if (E.equals(fa[k], a)) {\n                return true;\n            }\n        }\n        return false;\n    };\n}\n/**\n * Union of two `ReadonlyRecord`s.\n * Takes two `ReadonlyRecord`s and produces a `ReadonlyRecord` combining all the\n * entries of the two inputs.\n * It uses the `concat` function of the provided `Magma` to\n * combine the elements with the same key.\n *\n * @example\n * import { union } from \"fp-ts/ReadonlyRecord\";\n * import { Magma } from \"fp-ts/Magma\";\n *\n * const m1: Magma<number> = { concat: (x: number, y: number) => x + y };\n * assert.deepStrictEqual(union(m1)({ a: 3, c: 3 })({ a: 1, b: 2 }), { a: 4, b: 2, c: 3 });\n * const m2: Magma<number> = { concat: (x: number) => x };\n * assert.deepStrictEqual(union(m2)({ a: 3, c: 3 })({ a: 1, b: 2 }), { a: 1, b: 2, c: 3 });\n *\n * @since 2.11.0\n */\nexport var union = function (M) {\n    return function (second) {\n        return function (first) {\n            if (isEmpty(first)) {\n                return second;\n            }\n            if (isEmpty(second)) {\n                return first;\n            }\n            var out = {};\n            for (var k in first) {\n                if (has(k, second)) {\n                    out[k] = M.concat(first[k], second[k]);\n                }\n                else {\n                    out[k] = first[k];\n                }\n            }\n            for (var k in second) {\n                if (!has(k, out)) {\n                    out[k] = second[k];\n                }\n            }\n            return out;\n        };\n    };\n};\n/**\n * Intersection of two `ReadonlyRecord`s.\n * Takes two `ReadonlyRecord`s and produces a `ReadonlyRecord` combining only the\n * entries of the two inputswith the same key.\n * It uses the `concat` function of the provided `Magma` to\n * combine the elements.\n *\n * @example\n * import { intersection } from \"fp-ts/ReadonlyRecord\";\n * import { Magma } from \"fp-ts/Magma\";\n *\n * const m1: Magma<number> = { concat: (x: number, y: number) => x + y };\n * assert.deepStrictEqual(intersection(m1)({ a: 3, c: 3 })({ a: 1, b: 2 }), { a: 4});\n * const m2: Magma<number> = { concat: (x: number) => x };\n * assert.deepStrictEqual(intersection(m2)({ a: 3, c: 3 })({ a: 1, b: 2 }), { a: 1});\n *\n * @since 2.11.0\n */\nexport var intersection = function (M) {\n    return function (second) {\n        return function (first) {\n            if (isEmpty(first) || isEmpty(second)) {\n                return empty;\n            }\n            var out = {};\n            for (var k in first) {\n                if (has(k, second)) {\n                    out[k] = M.concat(first[k], second[k]);\n                }\n            }\n            return out;\n        };\n    };\n};\n/**\n * Difference between two `ReadonlyRecord`s.\n * Takes two `ReadonlyRecord`s and produces a `ReadonlyRecord` composed by the\n * entries of the two inputs, removing the entries with the same\n * key in both inputs.\n *\n * @example\n * import { difference } from \"fp-ts/ReadonlyRecord\";\n *\n * assert.deepStrictEqual(difference({ a: 1 })({ a: 1, b: 2 }), { b: 2 });\n * assert.deepStrictEqual(difference({ a: 3 })({ a: 1, b: 2 }), { b: 2 });\n * assert.deepStrictEqual(difference({ a: 3, c: 3 })({ a: 1, b: 2 }), { b: 2, c: 3 });\n *\n * @since 2.11.0\n */\nexport var difference = function (second) {\n    return function (first) {\n        if (isEmpty(first)) {\n            return second;\n        }\n        if (isEmpty(second)) {\n            return first;\n        }\n        var out = {};\n        for (var k in first) {\n            if (!has(k, second)) {\n                out[k] = first[k];\n            }\n        }\n        for (var k in second) {\n            if (!has(k, first)) {\n                out[k] = second[k];\n            }\n        }\n        return out;\n    };\n};\n/** @internal */\nexport var _map = function (fa, f) { return pipe(fa, map(f)); };\n/** @internal */\n/* istanbul ignore next */\nexport var _mapWithIndex = function (fa, f) { return pipe(fa, mapWithIndex(f)); };\n/** @internal */\n/* istanbul ignore next */\nexport var _reduce = function (O) {\n    var reduceO = reduce(O);\n    return function (fa, b, f) { return pipe(fa, reduceO(b, f)); };\n};\n/** @internal */\nexport var _foldMap = function (O) { return function (M) {\n    var foldMapM = foldMap(O)(M);\n    return function (fa, f) { return pipe(fa, foldMapM(f)); };\n}; };\n/** @internal */\n/* istanbul ignore next */\nexport var _reduceRight = function (O) {\n    var reduceRightO = reduceRight(O);\n    return function (fa, b, f) { return pipe(fa, reduceRightO(b, f)); };\n};\n/** @internal */\n/* istanbul ignore next */\nexport var _filter = function (fa, predicate) {\n    return pipe(fa, filter(predicate));\n};\n/** @internal */\n/* istanbul ignore next */\nexport var _filterMap = function (fa, f) { return pipe(fa, filterMap(f)); };\n/** @internal */\n/* istanbul ignore next */\nexport var _partition = function (fa, predicate) { return pipe(fa, partition(predicate)); };\n/** @internal */\n/* istanbul ignore next */\nexport var _partitionMap = function (fa, f) { return pipe(fa, partitionMap(f)); };\n/** @internal */\n/* istanbul ignore next */\nexport var _reduceWithIndex = function (O) {\n    var reduceWithIndexO = reduceWithIndex(O);\n    return function (fa, b, f) { return pipe(fa, reduceWithIndexO(b, f)); };\n};\n/** @internal */\nexport var _foldMapWithIndex = function (O) {\n    var foldMapWithIndexO = foldMapWithIndex(O);\n    return function (M) {\n        var foldMapWithIndexM = foldMapWithIndexO(M);\n        return function (fa, f) { return pipe(fa, foldMapWithIndexM(f)); };\n    };\n};\n/** @internal */\n/* istanbul ignore next */\nexport var _reduceRightWithIndex = function (O) {\n    var reduceRightWithIndexO = reduceRightWithIndex(O);\n    return function (fa, b, f) { return pipe(fa, reduceRightWithIndexO(b, f)); };\n};\n/** @internal */\n/* istanbul ignore next */\nexport var _partitionMapWithIndex = function (fa, f) { return pipe(fa, partitionMapWithIndex(f)); };\n/** @internal */\n/* istanbul ignore next */\nexport var _partitionWithIndex = function (fa, predicateWithIndex) {\n    return pipe(fa, partitionWithIndex(predicateWithIndex));\n};\n/** @internal */\n/* istanbul ignore next */\nexport var _filterMapWithIndex = function (fa, f) { return pipe(fa, filterMapWithIndex(f)); };\n/** @internal */\n/* istanbul ignore next */\nexport var _filterWithIndex = function (fa, predicateWithIndex) { return pipe(fa, filterWithIndex(predicateWithIndex)); };\n/** @internal */\nexport var _traverse = function (O) {\n    var traverseWithIndexO = _traverseWithIndex(O);\n    return function (F) {\n        var traverseWithIndexOF = traverseWithIndexO(F);\n        return function (ta, f) { return traverseWithIndexOF(ta, flow(SK, f)); };\n    };\n};\n/** @internal */\nexport var _sequence = function (O) {\n    var traverseO = _traverse(O);\n    return function (F) {\n        var traverseOF = traverseO(F);\n        return function (ta) { return traverseOF(ta, identity); };\n    };\n};\nvar _traverseWithIndex = function (O) {\n    return function (F) {\n        var keysO = keys_(O);\n        return function (ta, f) {\n            var ks = keysO(ta);\n            if (ks.length === 0) {\n                return F.of(empty);\n            }\n            var fr = F.of({});\n            var _loop_1 = function (key) {\n                fr = F.ap(F.map(fr, function (r) { return function (b) {\n                    var _a;\n                    return Object.assign({}, r, (_a = {}, _a[key] = b, _a));\n                }; }), f(key, ta[key]));\n            };\n            for (var _i = 0, ks_1 = ks; _i < ks_1.length; _i++) {\n                var key = ks_1[_i];\n                _loop_1(key);\n            }\n            return fr;\n        };\n    };\n};\n/**\n * Given a `Predicate`, it produces a new `ReadonlyRecord` keeping only the entries with a\n * value that satisfies the provided predicate.\n *\n * @example\n * import { filter } from \"fp-ts/ReadonlyRecord\"\n *\n * assert.deepStrictEqual(filter((s: string) => s.length < 4)({ a: \"foo\", b: \"bar\", c: \"verylong\" }), {\n *   a: \"foo\",\n *   b: \"bar\",\n * });\n *\n * @category filtering\n * @since 2.5.0\n */\nexport var filter = function (predicate) {\n    return filterWithIndex(function (_, a) { return predicate(a); });\n};\n/**\n * Maps a `ReadonlyRecord` with an iterating function that returns an `Option`\n * and it keeps only the `Some` values discarding the `None`s.\n *\n * @example\n * import { filterMap } from \"fp-ts/ReadonlyRecord\"\n * import { option } from \"fp-ts\"\n *\n * const f = (s: string) => s.length < 4 ? option.some(`${s} is short`): option.none\n * assert.deepStrictEqual(filterMap(f)({ a: \"foo\", b: \"bar\", c: \"verylong\" }), {\n *   a: \"foo is short\",\n *   b: \"bar is short\",\n * });\n *\n * @category filtering\n * @since 2.5.0\n */\nexport var filterMap = function (f) { return filterMapWithIndex(function (_, a) { return f(a); }); };\n/**\n * Partition a `ReadonlyRecord` into two parts according to a `Predicate`.\n *\n * @example\n * import { partition } from \"fp-ts/ReadonlyRecord\"\n *\n * assert.deepStrictEqual(partition((s: string) => s.length < 4)({ a: \"foo\", b: \"bar\", c: \"verylong\" }), {\n *   left:{\n *     c: \"verylong\"\n *   },\n *   right: {\n *     a: \"foo\",\n *     b: \"bar\",\n *   },\n * });\n *\n * @category filtering\n * @since 2.5.0\n */\nexport var partition = function (predicate) {\n    return partitionWithIndex(function (_, a) { return predicate(a); });\n};\n/**\n * Maps a `ReadonlyRecord` with a function returning an `Either` and\n * partitions the resulting `ReadonlyRecord` into `Left`s and `Right`s.\n *\n * @example\n * import { partitionMap } from \"fp-ts/ReadonlyRecord\"\n * import { either } from \"fp-ts\"\n *\n * const f = (s: string) => (s.length < 4 ? either.right(`${s} is short`) : either.left(`${s} is not short`));\n * assert.deepStrictEqual(partitionMap(f)({ a: \"foo\", b: \"bar\", c: \"verylong\" }), {\n *   left: {\n *     c: \"verylong is not short\",\n *   },\n *   right: {\n *     a: \"foo is short\",\n *     b: \"bar is short\",\n *   },\n * });\n *\n * @category filtering\n * @since 2.5.0\n */\nexport var partitionMap = function (f) {\n    return partitionMapWithIndex(function (_, a) { return f(a); });\n};\nexport function reduce() {\n    var args = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        args[_i] = arguments[_i];\n    }\n    if (args.length === 1) {\n        var reduceWithIndexO_1 = reduceWithIndex(args[0]);\n        return function (b, f) { return reduceWithIndexO_1(b, function (_, b, a) { return f(b, a); }); };\n    }\n    return reduce(S.Ord).apply(void 0, args);\n}\nexport function foldMap(O) {\n    if ('compare' in O) {\n        var foldMapWithIndexO_1 = foldMapWithIndex(O);\n        return function (M) {\n            var foldMapWithIndexM = foldMapWithIndexO_1(M);\n            return function (f) { return foldMapWithIndexM(function (_, a) { return f(a); }); };\n        };\n    }\n    return foldMap(S.Ord)(O);\n}\nexport function reduceRight() {\n    var args = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        args[_i] = arguments[_i];\n    }\n    if (args.length === 1) {\n        var reduceRightWithIndexO_1 = reduceRightWithIndex(args[0]);\n        return function (b, f) { return reduceRightWithIndexO_1(b, function (_, b, a) { return f(b, a); }); };\n    }\n    return reduceRight(S.Ord).apply(void 0, args);\n}\n/**\n * Compact a `ReadonlyRecord` of `Option`s discarding the `None` values and\n * keeping the `Some` values.\n *\n * @example\n * import { compact } from 'fp-ts/ReadonlyRecord'\n * import { option } from 'fp-ts'\n *\n * assert.deepStrictEqual(compact({ a: option.some(\"foo\"), b: option.none, c: option.some(\"bar\") }), {\n *   a: \"foo\",\n *   c: \"bar\",\n * });\n *\n * @category filtering\n * @since 2.5.0\n */\nexport var compact = function (r) {\n    var out = {};\n    for (var k in r) {\n        if (_.has.call(r, k)) {\n            var oa = r[k];\n            if (_.isSome(oa)) {\n                out[k] = oa.value;\n            }\n        }\n    }\n    return out;\n};\n/**\n * Separate a `ReadonlyRecord` of `Either`s into `Left`s and `Right`s.\n *\n * @example\n * import { separate } from 'fp-ts/ReadonlyRecord'\n * import { either } from 'fp-ts'\n *\n * assert.deepStrictEqual(\n *   separate({ a: either.right(\"foo\"), b: either.left(\"bar\"), c: either.right(\"baz\") }),\n *   {\n *     right: {\n *       a: \"foo\",\n *       c: \"baz\",\n *     },\n *     left: {\n *       b: \"bar\",\n *     },\n *   }\n * );\n *\n * @category filtering\n * @since 2.5.0\n */\nexport var separate = function (r) {\n    var left = {};\n    var right = {};\n    for (var k in r) {\n        if (_.has.call(r, k)) {\n            var e = r[k];\n            if (_.isLeft(e)) {\n                left[k] = e.left;\n            }\n            else {\n                right[k] = e.right;\n            }\n        }\n    }\n    return separated(left, right);\n};\n/**\n * @category type lambdas\n * @since 2.5.0\n */\nexport var URI = 'ReadonlyRecord';\nexport function getShow(O) {\n    if ('compare' in O) {\n        return function (S) { return ({\n            show: function (r) {\n                var elements = collect(O)(function (k, a) { return \"\".concat(JSON.stringify(k), \": \").concat(S.show(a)); })(r).join(', ');\n                return elements === '' ? '{}' : \"{ \".concat(elements, \" }\");\n            }\n        }); };\n    }\n    return getShow(S.Ord)(O);\n}\nexport function getEq(E) {\n    var isSubrecordE = isSubrecord(E);\n    return fromEquals(function (x, y) { return isSubrecordE(x)(y) && isSubrecordE(y)(x); });\n}\nexport function getMonoid(S) {\n    return {\n        concat: function (first, second) {\n            if (isEmpty(first)) {\n                return second;\n            }\n            if (isEmpty(second)) {\n                return first;\n            }\n            var r = Object.assign({}, first);\n            for (var k in second) {\n                if (_.has.call(second, k)) {\n                    r[k] = _.has.call(first, k) ? S.concat(first[k], second[k]) : second[k];\n                }\n            }\n            return r;\n        },\n        empty: empty\n    };\n}\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Functor = {\n    URI: URI,\n    map: _map\n};\n/**\n * Takes a value and a `ReadonlyRecord` of functions and returns a\n * `ReadonlyRecord` by applying each function to the input value.\n *\n * @example\n * import { flap } from \"fp-ts/ReadonlyRecord\"\n *\n * const fab = { x: (n: number) => `${n} times 2`, y: (n: number) => `${n * 2}` };\n * assert.deepStrictEqual(flap(3)(fab), {\n *   x: \"3 times 2\",\n *   y: \"6\",\n * });\n *\n * @category mapping\n * @since 2.10.0\n */\nexport var flap = /*#__PURE__*/ flap_(Functor);\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var FunctorWithIndex = {\n    URI: URI,\n    map: _map,\n    mapWithIndex: _mapWithIndex\n};\n/**\n * Produces a `Foldable` instance for a `ReadonlyRecord`, using the\n * provided `Ord` to sort the `ReadonlyRecord`'s entries by key.\n *\n * @category folding\n * @since 2.11.0\n */\nexport var getFoldable = function (O) { return ({\n    URI: URI,\n    reduce: _reduce(O),\n    foldMap: _foldMap(O),\n    reduceRight: _reduceRight(O)\n}); };\n/**\n * Produces a `FoldableWithIndex1` instance for a `ReadonlyRecord`, using the\n * provided `Ord` to sort the `ReadonlyRecord`'s entries by key.\n *\n * @category folding\n * @since 2.11.0\n */\nexport var getFoldableWithIndex = function (O) { return ({\n    URI: URI,\n    reduce: _reduce(O),\n    foldMap: _foldMap(O),\n    reduceRight: _reduceRight(O),\n    reduceWithIndex: _reduceWithIndex(O),\n    foldMapWithIndex: _foldMapWithIndex(O),\n    reduceRightWithIndex: _reduceRightWithIndex(O)\n}); };\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Compactable = {\n    URI: URI,\n    compact: compact,\n    separate: separate\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Filterable = {\n    URI: URI,\n    map: _map,\n    compact: compact,\n    separate: separate,\n    filter: _filter,\n    filterMap: _filterMap,\n    partition: _partition,\n    partitionMap: _partitionMap\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var FilterableWithIndex = {\n    URI: URI,\n    map: _map,\n    mapWithIndex: _mapWithIndex,\n    compact: compact,\n    separate: separate,\n    filter: _filter,\n    filterMap: _filterMap,\n    partition: _partition,\n    partitionMap: _partitionMap,\n    filterMapWithIndex: _filterMapWithIndex,\n    filterWithIndex: _filterWithIndex,\n    partitionMapWithIndex: _partitionMapWithIndex,\n    partitionWithIndex: _partitionWithIndex\n};\n/**\n * Produces a `Traversable` instance for a `ReadonlyRecord`, using the\n * provided `Ord` to sort the `ReadonlyRecord`'s entries by key.\n *\n * @category traversing\n * @since 2.11.0\n */\nexport var getTraversable = function (O) { return ({\n    URI: URI,\n    map: _map,\n    reduce: _reduce(O),\n    foldMap: _foldMap(O),\n    reduceRight: _reduceRight(O),\n    traverse: _traverse(O),\n    sequence: _sequence(O)\n}); };\n/**\n * Produces a `TraversableWithIndex` instance for a `ReadonlyRecord`, using the\n * provided `Ord` to sort the `ReadonlyRecord`'s entries by key.\n *\n * @category traversing\n * @since 2.11.0\n */\nexport var getTraversableWithIndex = function (O) { return ({\n    URI: URI,\n    map: _map,\n    mapWithIndex: _mapWithIndex,\n    reduce: _reduce(O),\n    foldMap: _foldMap(O),\n    reduceRight: _reduceRight(O),\n    reduceWithIndex: _reduceWithIndex(O),\n    foldMapWithIndex: _foldMapWithIndex(O),\n    reduceRightWithIndex: _reduceRightWithIndex(O),\n    traverse: _traverse(O),\n    sequence: _sequence(O),\n    traverseWithIndex: _traverseWithIndex(O)\n}); };\n/**\n * @category filtering\n * @since 2.11.0\n */\nexport var getWitherable = function (O) {\n    var T = getTraversable(O);\n    return {\n        URI: URI,\n        map: _map,\n        reduce: _reduce(O),\n        foldMap: _foldMap(O),\n        reduceRight: _reduceRight(O),\n        traverse: T.traverse,\n        sequence: T.sequence,\n        compact: compact,\n        separate: separate,\n        filter: _filter,\n        filterMap: _filterMap,\n        partition: _partition,\n        partitionMap: _partitionMap,\n        wither: witherDefault(T, Compactable),\n        wilt: wiltDefault(T, Compactable)\n    };\n};\n/**\n * Given a `Semigroup` in the base type, it produces a `Semigroup`\n * in the `ReadonlyRecord` of the base type.\n * The resulting `Semigroup` concatenates two `ReadonlyRecord`s by\n * `union`.\n *\n * @example\n * import { getUnionSemigroup, ReadonlyRecord } from \"fp-ts/ReadonlyRecord\"\n * import { Semigroup } from \"fp-ts/Semigroup\"\n *\n * const sNumber: Semigroup<number> = { concat: (x, y) => x - y };\n * const sReadonlyRecord: Semigroup<ReadonlyRecord<string, number>> = getUnionSemigroup(sNumber);\n * assert.deepStrictEqual(sReadonlyRecord.concat({ a: 1, b: 2 }, { b: 3, c: 4 }), { a: 1, b: -1, c: 4 });\n *\n * @category instances\n * @since 2.11.0\n */\nexport var getUnionSemigroup = function (S) {\n    var unionS = union(S);\n    return {\n        concat: function (first, second) { return unionS(second)(first); }\n    };\n};\n/**\n * Same as `getMonoid`.\n * Returns a `Monoid` instance for `ReadonlyRecord`s given a `Semigroup`\n * instance for the base type.\n * The `Monoid` makes the union of two `ReadonlyRecord`s combining the\n * entries that have the same key with the provided `Semigroup`.\n *\n * @example\n * import { SemigroupSum } from 'fp-ts/number'\n * import { getUnionMonoid } from 'fp-ts/ReadonlyRecord'\n *\n * const M = getUnionMonoid(SemigroupSum);\n * assert.deepStrictEqual(M.concat({ foo: 123, bar: 234 }, { foo: 456, baz: 567 }), { foo: 579 , bar: 234, baz: 567 });\n *\n * @category instances\n * @since 2.11.0\n */\nexport var getUnionMonoid = function (S) { return ({\n    concat: getUnionSemigroup(S).concat,\n    empty: empty\n}); };\n/**\n * Given a `Semigroup` in the base type, it produces a `Semigroup`\n * in the `ReadonlyRecord` of the base type.\n * The resulting `Semigroup` concatenates two `ReadonlyRecord`s by\n * `intersection`.\n *\n * @example\n * import { getIntersectionSemigroup, ReadonlyRecord } from \"fp-ts/ReadonlyRecord\"\n * import { Semigroup } from \"fp-ts/Semigroup\"\n *\n * const sNumber: Semigroup<number> = { concat: (x, y) => x - y };\n * const sReadonlyRecord: Semigroup<ReadonlyRecord<string, number>> = getIntersectionSemigroup(sNumber);\n * assert.deepStrictEqual(sReadonlyRecord.concat({ a: 1, b: 2 }, { b: 3, c: 4 }), { b: -1 });\n *\n * @category instances\n * @since 2.11.0\n */\nexport var getIntersectionSemigroup = function (S) {\n    var intersectionS = intersection(S);\n    return {\n        concat: function (first, second) { return intersectionS(second)(first); }\n    };\n};\n/**\n * Produces a `Magma` with a `concat` function that combines\n * two `ReadonlyRecord`s by making the `difference`.\n *\n * @example\n * import { getDifferenceMagma, difference, ReadonlyRecord } from \"fp-ts/ReadonlyRecord\"\n * import { Magma } from \"fp-ts/Magma\"\n *\n * const r1 = { a: 3, c: 3 };\n * const r2 = { a: 1, b: 2 };\n * const m: Magma<ReadonlyRecord<string, number>> = getDifferenceMagma<number>();\n * assert.deepStrictEqual(m.concat(r1, r2), difference(r2)(r1));\n * assert.deepStrictEqual(m.concat(r1, r2), { c: 3, b: 2 });\n *\n * @category instances\n * @since 2.11.0\n */\nexport var getDifferenceMagma = function () { return ({\n    concat: function (first, second) { return difference(second)(first); }\n}); };\n// -------------------------------------------------------------------------------------\n// deprecated\n// -------------------------------------------------------------------------------------\n/**\n * Use `getFoldable` instead.\n *\n * @category zone of death\n * @since 2.7.0\n * @deprecated\n */\nexport var Foldable = {\n    URI: URI,\n    reduce: /*#__PURE__*/ _reduce(S.Ord),\n    foldMap: /*#__PURE__*/ _foldMap(S.Ord),\n    reduceRight: /*#__PURE__*/ _reduceRight(S.Ord)\n};\n/**\n * Use `getFoldableWithIndex` instead.\n *\n * @category zone of death\n * @since 2.7.0\n * @deprecated\n */\nexport var FoldableWithIndex = {\n    URI: URI,\n    reduce: /*#__PURE__*/ _reduce(S.Ord),\n    foldMap: /*#__PURE__*/ _foldMap(S.Ord),\n    reduceRight: /*#__PURE__*/ _reduceRight(S.Ord),\n    reduceWithIndex: /*#__PURE__*/ _reduceWithIndex(S.Ord),\n    foldMapWithIndex: /*#__PURE__*/ _foldMapWithIndex(S.Ord),\n    reduceRightWithIndex: /*#__PURE__*/ _reduceRightWithIndex(S.Ord)\n};\n/**\n * Use `getTraversable` instead.\n *\n * @category zone of death\n * @since 2.7.0\n * @deprecated\n */\nexport var Traversable = {\n    URI: URI,\n    map: _map,\n    reduce: /*#__PURE__*/ _reduce(S.Ord),\n    foldMap: /*#__PURE__*/ _foldMap(S.Ord),\n    reduceRight: /*#__PURE__*/ _reduceRight(S.Ord),\n    traverse: /*#__PURE__*/ _traverse(S.Ord),\n    sequence: sequence\n};\n/**\n * Use `getTraversableWithIndex` instead.\n *\n * @category zone of death\n * @since 2.7.0\n * @deprecated\n */\nexport var TraversableWithIndex = {\n    URI: URI,\n    map: _map,\n    mapWithIndex: _mapWithIndex,\n    reduce: /*#__PURE__*/ _reduce(S.Ord),\n    foldMap: /*#__PURE__*/ _foldMap(S.Ord),\n    reduceRight: /*#__PURE__*/ _reduceRight(S.Ord),\n    reduceWithIndex: /*#__PURE__*/ _reduceWithIndex(S.Ord),\n    foldMapWithIndex: /*#__PURE__*/ _foldMapWithIndex(S.Ord),\n    reduceRightWithIndex: /*#__PURE__*/ _reduceRightWithIndex(S.Ord),\n    traverse: /*#__PURE__*/ _traverse(S.Ord),\n    sequence: sequence,\n    traverseWithIndex: /*#__PURE__*/ _traverseWithIndex(S.Ord)\n};\nvar _wither = /*#__PURE__*/ witherDefault(Traversable, Compactable);\nvar _wilt = /*#__PURE__*/ wiltDefault(Traversable, Compactable);\n/**\n * Use `getWitherable` instead.\n *\n * @category zone of death\n * @since 2.7.0\n * @deprecated\n */\nexport var Witherable = {\n    URI: URI,\n    map: _map,\n    reduce: /*#__PURE__*/ _reduce(S.Ord),\n    foldMap: /*#__PURE__*/ _foldMap(S.Ord),\n    reduceRight: /*#__PURE__*/ _reduceRight(S.Ord),\n    traverse: /*#__PURE__*/ _traverse(S.Ord),\n    sequence: sequence,\n    compact: compact,\n    separate: separate,\n    filter: _filter,\n    filterMap: _filterMap,\n    partition: _partition,\n    partitionMap: _partitionMap,\n    wither: _wither,\n    wilt: _wilt\n};\n/**\n * Use [`upsertAt`](#upsertat) instead.\n *\n * @category zone of death\n * @since 2.5.0\n * @deprecated\n */\nexport var insertAt = upsertAt;\nexport function hasOwnProperty(k, r) {\n    return _.has.call(r === undefined ? this : r, k);\n}\n/**\n * This instance is deprecated, use small, specific instances instead.\n * For example if a function needs a `Functor` instance, pass `RR.Functor` instead of `RR.readonlyRecord`\n * (where `RR` is from `import RR from 'fp-ts/ReadonlyRecord'`)\n *\n * @category zone of death\n * @since 2.5.0\n * @deprecated\n */\nexport var readonlyRecord = {\n    URI: URI,\n    map: _map,\n    reduce: /*#__PURE__*/ _reduce(S.Ord),\n    foldMap: /*#__PURE__*/ _foldMap(S.Ord),\n    reduceRight: /*#__PURE__*/ _reduceRight(S.Ord),\n    traverse: /*#__PURE__*/ _traverse(S.Ord),\n    sequence: sequence,\n    compact: compact,\n    separate: separate,\n    filter: _filter,\n    filterMap: _filterMap,\n    partition: _partition,\n    partitionMap: _partitionMap,\n    mapWithIndex: _mapWithIndex,\n    reduceWithIndex: /*#__PURE__*/ _reduceWithIndex(S.Ord),\n    foldMapWithIndex: /*#__PURE__*/ _foldMapWithIndex(S.Ord),\n    reduceRightWithIndex: /*#__PURE__*/ _reduceRightWithIndex(S.Ord),\n    filterMapWithIndex: _filterMapWithIndex,\n    filterWithIndex: _filterWithIndex,\n    partitionMapWithIndex: _partitionMapWithIndex,\n    partitionWithIndex: _partitionWithIndex,\n    traverseWithIndex: /*#__PURE__*/ _traverseWithIndex(S.Ord),\n    wither: _wither,\n    wilt: _wilt\n};\n","var __assign = (this && this.__assign) || function () {\n    __assign = Object.assign || function(t) {\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\n            s = arguments[i];\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\n                t[p] = s[p];\n        }\n        return t;\n    };\n    return __assign.apply(this, arguments);\n};\nimport * as A from './Array';\nimport { pipe } from './function';\nimport { flap as flap_ } from './Functor';\nimport * as _ from './internal';\nimport * as RR from './ReadonlyRecord';\nimport * as Se from './Semigroup';\nimport * as S from './string';\nimport { wiltDefault, witherDefault } from './Witherable';\n// -------------------------------------------------------------------------------------\n// model\n// -------------------------------------------------------------------------------------\n/**\n * Calculate the number of key/value pairs in a `Record`.\n *\n * @example\n * import { size } from \"fp-ts/Record\";\n *\n * assert.deepStrictEqual(size({ a: true, b: 2, c: \"three\" }), 3);\n *\n * @since 2.0.0\n */\nexport var size = RR.size;\n/**\n * Test whether a `Record` is empty.\n *\n * @example\n * import { isEmpty } from \"fp-ts/Record\";\n *\n * assert.deepStrictEqual(isEmpty({}), true);\n * assert.deepStrictEqual(isEmpty({ a: 3 }), false);\n *\n * @since 2.0.0\n */\nexport var isEmpty = RR.isEmpty;\nvar keys_ = function (O) {\n    return function (r) {\n        return Object.keys(r).sort(O.compare);\n    };\n};\n/**\n * The keys of a `Record`, sorted alphabetically.\n *\n * @example\n * import { keys } from \"fp-ts/Record\";\n *\n * assert.deepStrictEqual(keys({ c: 1, a: 2, b: 3 }), [\"a\", \"b\", \"c\"]);\n *\n * @since 2.0.0\n */\nexport var keys = /*#__PURE__*/ keys_(S.Ord);\nexport function collect(O) {\n    if (typeof O === 'function') {\n        return collect(S.Ord)(O);\n    }\n    var keysO = keys_(O);\n    return function (f) {\n        return function (r) {\n            var out = [];\n            for (var _i = 0, _a = keysO(r); _i < _a.length; _i++) {\n                var key = _a[_i];\n                out.push(f(key, r[key]));\n            }\n            return out;\n        };\n    };\n}\n/**\n * Get a sorted `Array` of the key/value pairs contained in a `Record`.\n * Sorted alphabetically by key.\n *\n * @example\n * import { toArray } from 'fp-ts/Record'\n *\n * const x = { c: 3, a: \"foo\", b: false };\n * assert.deepStrictEqual(toArray(x), [\n *   [\"a\", \"foo\"],\n *   [\"b\", false],\n *   [\"c\", 3],\n * ]);\n *\n * @category conversions\n * @since 2.0.0\n */\nexport var toArray = /*#__PURE__*/ collect(S.Ord)(function (k, a) { return [\n    k,\n    a\n]; });\nexport function toUnfoldable(U) {\n    return function (r) {\n        var sas = toArray(r);\n        var len = sas.length;\n        return U.unfold(0, function (b) { return (b < len ? _.some([sas[b], b + 1]) : _.none); });\n    };\n}\n/**\n * Insert or replace a key/value pair in a `Record`.\n *\n * @example\n * import { upsertAt } from 'fp-ts/Record'\n *\n * assert.deepStrictEqual(upsertAt(\"a\", 5)({ a: 1, b: 2 }), { a: 5, b: 2 });\n * assert.deepStrictEqual(upsertAt(\"c\", 5)({ a: 1, b: 2 }), { a: 1, b: 2, c: 5 });\n *\n * @since 2.10.0\n */\nexport var upsertAt = RR.upsertAt;\n/**\n * Test whether or not a key exists in a `Record`.\n *\n * Note. This function is not pipeable because is a `Refinement`.\n *\n * @example\n * import { has } from 'fp-ts/Record'\n *\n * assert.deepStrictEqual(has(\"a\", { a: 1, b: 2 }), true);\n * assert.deepStrictEqual(has(\"c\", { a: 1, b: 2 }), false);\n *\n * @since 2.10.0\n */\nexport var has = RR.has;\nexport function deleteAt(k) {\n    return function (r) {\n        if (!_.has.call(r, k)) {\n            return r;\n        }\n        var out = Object.assign({}, r);\n        delete out[k];\n        return out;\n    };\n}\n/**\n * Replace a key/value pair in a `Record`.\n *\n * @returns If the specified key exists it returns an `Option` containing a new `Record`\n * with the entry updated, otherwise it returns `None`\n *\n * @example\n * import { updateAt } from 'fp-ts/Record'\n * import { option } from 'fp-ts'\n *\n * assert.deepStrictEqual(updateAt(\"a\", 3)({ a: 1, b: 2 }), option.some({ a: 3, b: 2 }));\n * assert.deepStrictEqual(updateAt(\"c\", 3)({ a: 1, b: 2 }), option.none);\n *\n * @since 2.0.0\n */\nexport var updateAt = function (k, a) {\n    return modifyAt(k, function () { return a; });\n};\n/**\n * Applies a mapping function to one spcific key/value pair in a `Record`.\n *\n * @returns If the specified key exists it returns an `Option` containing a new `Record`\n * with the entry updated, otherwise it returns `None`\n *\n * @example\n * import { modifyAt } from 'fp-ts/Record'\n * import { option } from 'fp-ts'\n *\n * assert.deepStrictEqual(modifyAt(\"a\", (x: number) => x * 3)({ a: 1, b: 2 }), option.some({ a: 3, b: 2 }));\n * assert.deepStrictEqual(modifyAt(\"c\", (x: number) => x * 3)({ a: 1, b: 2 }), option.none);\n *\n * @since 2.0.0\n */\nexport var modifyAt = function (k, f) {\n    return function (r) {\n        if (!has(k, r)) {\n            return _.none;\n        }\n        var out = Object.assign({}, r);\n        out[k] = f(r[k]);\n        return _.some(out);\n    };\n};\nexport function pop(k) {\n    var deleteAtk = deleteAt(k);\n    return function (r) {\n        var oa = lookup(k, r);\n        return _.isNone(oa) ? _.none : _.some([oa.value, deleteAtk(r)]);\n    };\n}\n// TODO: remove non-curried overloading in v3\n/**\n * Test whether one `Record` contains all of the keys and values\n * contained in another `Record`.\n *\n * @example\n * import { isSubrecord } from 'fp-ts/Record'\n * import { string } from 'fp-ts'\n *\n * assert.deepStrictEqual(\n *   isSubrecord(string.Eq)({ a: \"foo\", b: \"bar\", c: \"baz\" })({ a: \"foo\", b: \"bar\", c: \"baz\" }),\n *   true\n * );\n * assert.deepStrictEqual(\n *   isSubrecord(string.Eq)({ a: \"foo\", b: \"bar\", c: \"baz\" })({ a: \"foo\", c: \"baz\" }),\n *   true\n * );\n * assert.deepStrictEqual(\n *   isSubrecord(string.Eq)({ a: \"foo\", b: \"bar\", c: \"baz\" })({ a: \"foo\", b: \"not-bar\", c: \"baz\" }),\n *   false\n * );\n * assert.deepStrictEqual(\n *   isSubrecord(string.Eq)({ a: \"foo\", b: \"bar\" })({ a: \"foo\", b: \"bar\", c: \"baz\" }),\n *   false\n * );\n *\n * @since 2.0.0\n */\nexport var isSubrecord = RR.isSubrecord;\n// TODO: remove non-curried overloading in v3\n/**\n * Lookup the value for a key in a `Record`.\n *\n * @returns If the specified key exists it returns an `Option` containing the value,\n * otherwise it returns `None`\n *\n * @example\n * import { lookup } from 'fp-ts/Record'\n * import { option } from 'fp-ts'\n *\n * assert.deepStrictEqual(lookup(\"b\")({ a: \"foo\", b: \"bar\" }), option.some(\"bar\"));\n * assert.deepStrictEqual(lookup(\"c\")({ a: \"foo\", b: \"bar\" }), option.none);\n *\n * @since 2.0.0\n */\nexport var lookup = RR.lookup;\n/**\n * Map a `Record` passing the key/value pairs to the iterating function.\n *\n * @example\n * import { mapWithIndex } from \"fp-ts/Record\";\n *\n * const f = (k: string, n: number) => `${k.toUpperCase()}-${n}`;\n * assert.deepStrictEqual(mapWithIndex(f)({ a: 3, b: 5 }), { a: \"A-3\", b: \"B-5\" });\n *\n * @since 2.0.0\n */\nexport var mapWithIndex = RR.mapWithIndex;\n/**\n * Map a `Record` passing the values to the iterating function.\n *\n * @example\n * import { map } from \"fp-ts/Record\";\n *\n * const f = (n: number) => `-${n}-`;\n * assert.deepStrictEqual(map(f)({ a: 3, b: 5 }), { a: \"-3-\", b: \"-5-\" });\n *\n * @category mapping\n * @since 2.0.0\n */\nexport var map = RR.map;\nexport function reduceWithIndex() {\n    var args = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        args[_i] = arguments[_i];\n    }\n    return args.length === 1 ? RR.reduceWithIndex(args[0]) : RR.reduceWithIndex(S.Ord).apply(void 0, args);\n}\nexport function foldMapWithIndex(O) {\n    return 'compare' in O ? RR.foldMapWithIndex(O) : RR.foldMapWithIndex(S.Ord)(O);\n}\nexport function reduceRightWithIndex() {\n    var args = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        args[_i] = arguments[_i];\n    }\n    return args.length === 1 ? RR.reduceRightWithIndex(args[0]) : RR.reduceRightWithIndex(S.Ord).apply(void 0, args);\n}\n/**\n * Create a `Record` with one key/value pair.\n *\n * @example\n * import { singleton } from \"fp-ts/Record\";\n *\n * assert.deepStrictEqual(singleton(\"a\", 1), { a: 1 });\n *\n * @since 2.0.0\n */\nexport var singleton = RR.singleton;\nexport function traverseWithIndex(F) {\n    return RR.traverseWithIndex(F);\n}\nexport function traverse(F) {\n    return RR.traverse(F);\n}\nexport function sequence(F) {\n    return RR.sequence(F);\n}\n/**\n * @category filtering\n * @since 2.6.5\n */\nexport var wither = function (F) {\n    var traverseF = traverse(F);\n    return function (f) { return function (fa) { return F.map(pipe(fa, traverseF(f)), compact); }; };\n};\n/**\n * @category filtering\n * @since 2.6.5\n */\nexport var wilt = function (F) {\n    var traverseF = traverse(F);\n    return function (f) { return function (fa) { return F.map(pipe(fa, traverseF(f)), separate); }; };\n};\n/**\n * Maps a `Record` with a function returning an `Either` and\n * partitions the resulting `Record` into `Left`s and `Right`s.\n *\n * @example\n * import { partitionMapWithIndex } from \"fp-ts/Record\"\n * import { either } from \"fp-ts\"\n *\n * const f = (key: string, a: number) =>\n *   a >= 0 ? either.right(`${key} is >= 0 (${a})`) : either.left(`${key} is < 0 (${a})`);\n * assert.deepStrictEqual(partitionMapWithIndex(f)({ a: -1, b: 2, c: 123 }), {\n *   left: {\n *     a: \"a is < 0 (-1)\",\n *   },\n *   right: {\n *     b: \"b is >= 0 (2)\",\n *     c: \"c is >= 0 (123)\",\n *   },\n * });\n *\n * @since 2.0.0\n */\nexport var partitionMapWithIndex = RR.partitionMapWithIndex;\nexport function partitionWithIndex(predicateWithIndex) {\n    return RR.partitionWithIndex(predicateWithIndex);\n}\n/**\n * Maps a `Record` with an iterating function that takes key and value and\n * returns an `Option`, keeping only the `Some` values and discarding `None`s.\n *\n * @example\n * import { filterMapWithIndex } from \"fp-ts/Record\"\n * import { option } from \"fp-ts\"\n *\n * const f = (key: string, a: number) => (a >= 0 ? option.some(`${key}${a}`) : option.none);\n * assert.deepStrictEqual(filterMapWithIndex(f)({ a: -1, b: 2, c: 3 }), {\n *   b: \"b2\",\n *   c: \"c3\",\n * });\n *\n * @since 2.0.0\n */\nexport var filterMapWithIndex = RR.filterMapWithIndex;\nexport function filterWithIndex(predicateWithIndex) {\n    return RR.filterWithIndex(predicateWithIndex);\n}\nexport function fromFoldable(M, F) {\n    return RR.fromFoldable(M, F);\n}\n/**\n * Alias of [`toArray`](#toArray).\n *\n * @example\n * import { toEntries } from 'fp-ts/Record'\n *\n * assert.deepStrictEqual(toEntries({ b: 2, a: 1 }), [['a', 1], ['b', 2]])\n *\n * @since 2.12.0\n * @category conversions\n */\nexport var toEntries = toArray;\n/**\n * Converts an `Array` of `[key, value]` tuples into a `Record`.\n *\n * @example\n * import { fromEntries } from 'fp-ts/Record'\n *\n * assert.deepStrictEqual(fromEntries([['a', 1], ['b', 2], ['a', 3]]), { b: 2, a: 3 })\n *\n * @since 2.12.0\n * @category conversions\n */\nexport var fromEntries = function (fa) { return fromFoldable(Se.last(), A.Foldable)(fa); };\nexport function fromFoldableMap(M, F) {\n    return RR.fromFoldableMap(M, F);\n}\n/**\n * Test if every value in a `Record` satisfies the predicate.\n *\n * @example\n * import { every } from \"fp-ts/Record\"\n *\n * assert.deepStrictEqual(every((n: number) => n >= 0)({ a: 1, b: 2 }), true);\n * assert.deepStrictEqual(every((n: number) => n >= 0)({ a: 1, b: -1 }), false);\n *\n * @since 2.0.0\n */\nexport var every = RR.every;\n/**\n * Test if at least one value in a `Record` satisfies the predicate.\n *\n * @example\n * import { some } from \"fp-ts/Record\"\n *\n * assert.deepStrictEqual(some((n: number) => n >= 0)({ a: 1, b: -2 }), true);\n * assert.deepStrictEqual(some((n: number) => n >= 0)({ a: -1, b: -2 }), false);\n *\n * @since 2.0.0\n */\nexport var some = RR.some;\n// TODO: remove non-curried overloading in v3\n/**\n * Given an `Eq` checks if a `Record` contains an entry with\n * value equal to a provided value.\n *\n * @example\n * import { elem } from \"fp-ts/Record\"\n * import { number } from \"fp-ts\"\n *\n * assert.deepStrictEqual(elem(number.Eq)(123, { foo: 123, bar: 234 }), true);\n * assert.deepStrictEqual(elem(number.Eq)(-7, { foo: 123, bar: 234 }), false);\n *\n * @since 2.0.0\n */\nexport var elem = RR.elem;\n/**\n * Union of two `Record`s.\n * Takes two `Record`s and produces a `Record` combining all the\n * entries of the two inputs.\n * It uses the `concat` function of the provided `Magma` to\n * combine the elements with the same key.\n *\n * @example\n * import { union } from \"fp-ts/Record\";\n * import { Magma } from \"fp-ts/Magma\";\n *\n * const m1: Magma<number> = { concat: (x: number, y: number) => x + y };\n * assert.deepStrictEqual(union(m1)({ a: 3, c: 3 })({ a: 1, b: 2 }), { a: 4, b: 2, c: 3 });\n * const m2: Magma<number> = { concat: (x: number) => x };\n * assert.deepStrictEqual(union(m2)({ a: 3, c: 3 })({ a: 1, b: 2 }), { a: 1, b: 2, c: 3 });\n *\n * @since 2.11.0\n */\nexport var union = function (M) {\n    var unionM = RR.union(M);\n    return function (second) { return function (first) {\n        if (isEmpty(first)) {\n            return __assign({}, second);\n        }\n        if (isEmpty(second)) {\n            return __assign({}, first);\n        }\n        return unionM(second)(first);\n    }; };\n};\n/**\n * Intersection of two `Record`s.\n * Takes two `Record`s and produces a `Record` combining only the\n * entries of the two inputswith the same key.\n * It uses the `concat` function of the provided `Magma` to\n * combine the elements.\n *\n * @example\n * import { intersection } from \"fp-ts/Record\";\n * import { Magma } from \"fp-ts/Magma\";\n *\n * const m1: Magma<number> = { concat: (x: number, y: number) => x + y };\n * assert.deepStrictEqual(intersection(m1)({ a: 3, c: 3 })({ a: 1, b: 2 }), { a: 4});\n * const m2: Magma<number> = { concat: (x: number) => x };\n * assert.deepStrictEqual(intersection(m2)({ a: 3, c: 3 })({ a: 1, b: 2 }), { a: 1});\n *\n * @since 2.11.0\n */\nexport var intersection = function (M) {\n    return function (second) {\n        return function (first) {\n            if (isEmpty(first) || isEmpty(second)) {\n                return {};\n            }\n            return RR.intersection(M)(second)(first);\n        };\n    };\n};\n/**\n * Difference between two `Record`s.\n * Takes two `Record`s and produces a `Record` composed by the\n * entries of the two inputs, removing the entries with the same\n * key in both inputs.\n *\n * @example\n * import { difference } from \"fp-ts/Record\";\n *\n * assert.deepStrictEqual(difference({ a: 1 })({ a: 1, b: 2 }), { b: 2 });\n * assert.deepStrictEqual(difference({ a: 3 })({ a: 1, b: 2 }), { b: 2 });\n * assert.deepStrictEqual(difference({ a: 3, c: 3 })({ a: 1, b: 2 }), { b: 2, c: 3 });\n *\n * @since 2.11.0\n */\nexport var difference = function (second) {\n    return function (first) {\n        if (isEmpty(first)) {\n            return __assign({}, second);\n        }\n        if (isEmpty(second)) {\n            return __assign({}, first);\n        }\n        return RR.difference(second)(first);\n    };\n};\nvar _map = RR._map;\nvar _mapWithIndex = RR._mapWithIndex;\nvar _reduce = RR._reduce;\nvar _foldMap = RR._foldMap;\nvar _reduceRight = RR._reduceRight;\nvar _filter = RR._filter;\nvar _filterMap = RR._filterMap;\nvar _partition = RR._partition;\nvar _partitionMap = RR._partitionMap;\nvar _reduceWithIndex = RR._reduceWithIndex;\nvar _foldMapWithIndex = RR._foldMapWithIndex;\nvar _reduceRightWithIndex = RR._reduceRightWithIndex;\nvar _partitionMapWithIndex = RR._partitionMapWithIndex;\nvar _partitionWithIndex = RR._partitionWithIndex;\nvar _filterMapWithIndex = RR._filterMapWithIndex;\nvar _filterWithIndex = RR._filterWithIndex;\nvar _traverse = RR._traverse;\nvar _sequence = RR._sequence;\nvar _traverseWithIndex = function (O) {\n    return function (F) {\n        var keysO = keys_(O);\n        return function (ta, f) {\n            var ks = keysO(ta);\n            if (ks.length === 0) {\n                return F.of({});\n            }\n            var fr = F.of({});\n            var _loop_1 = function (key) {\n                fr = F.ap(F.map(fr, function (r) { return function (b) {\n                    r[key] = b;\n                    return r;\n                }; }), f(key, ta[key]));\n            };\n            for (var _i = 0, ks_1 = ks; _i < ks_1.length; _i++) {\n                var key = ks_1[_i];\n                _loop_1(key);\n            }\n            return fr;\n        };\n    };\n};\n/**\n * Given a `Predicate`, it produces a new `Record` keeping only the entries with a\n * value that satisfies the provided predicate.\n *\n * @example\n * import { filter } from \"fp-ts/Record\"\n *\n * assert.deepStrictEqual(filter((s: string) => s.length < 4)({ a: \"foo\", b: \"bar\", c: \"verylong\" }), {\n *   a: \"foo\",\n *   b: \"bar\",\n * });\n *\n * @category filtering\n * @since 2.0.0\n */\nexport var filter = RR.filter;\n/**\n * Maps a `Record` with an iterating function that returns an `Option`\n * and it keeps only the `Some` values discarding the `None`s.\n *\n * @example\n * import { filterMap } from \"fp-ts/Record\"\n * import { option } from \"fp-ts\"\n *\n * const f = (s: string) => s.length < 4 ? option.some(`${s} is short`): option.none\n * assert.deepStrictEqual(filterMap(f)({ a: \"foo\", b: \"bar\", c: \"verylong\" }), {\n *   a: \"foo is short\",\n *   b: \"bar is short\",\n * });\n *\n * @category filtering\n * @since 2.0.0\n */\nexport var filterMap = RR.filterMap;\n/**\n * Partition a `Record` into two parts according to a `Predicate`.\n *\n * @example\n * import { partition } from \"fp-ts/Record\"\n *\n * assert.deepStrictEqual(partition((s: string) => s.length < 4)({ a: \"foo\", b: \"bar\", c: \"verylong\" }), {\n *   left:{\n *     c: \"verylong\"\n *   },\n *   right: {\n *     a: \"foo\",\n *     b: \"bar\",\n *   },\n * });\n *\n * @category filtering\n * @since 2.0.0\n */\nexport var partition = RR.partition;\n/**\n * Maps a `Record` with a function returning an `Either` and\n * partitions the resulting `Record` into `Left`s and `Right`s.\n *\n * @example\n * import { partitionMap } from \"fp-ts/Record\"\n * import { either } from \"fp-ts\"\n *\n * const f = (s: string) => (s.length < 4 ? either.right(`${s} is short`) : either.left(`${s} is not short`));\n * assert.deepStrictEqual(partitionMap(f)({ a: \"foo\", b: \"bar\", c: \"verylong\" }), {\n *   left: {\n *     c: \"verylong is not short\",\n *   },\n *   right: {\n *     a: \"foo is short\",\n *     b: \"bar is short\",\n *   },\n * });\n *\n * @category filtering\n * @since 2.0.0\n */\nexport var partitionMap = RR.partitionMap;\nexport function reduce() {\n    var args = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        args[_i] = arguments[_i];\n    }\n    return args.length === 1 ? RR.reduce(args[0]) : RR.reduce(S.Ord).apply(void 0, args);\n}\nexport function foldMap(O) {\n    return 'compare' in O ? RR.foldMap(O) : RR.foldMap(S.Ord)(O);\n}\nexport function reduceRight() {\n    var args = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        args[_i] = arguments[_i];\n    }\n    return args.length === 1 ? RR.reduceRight(args[0]) : RR.reduceRight(S.Ord).apply(void 0, args);\n}\n/**\n * Compact a `Record` of `Option`s discarding the `None` values and\n * keeping the `Some` values.\n *\n * @example\n * import { compact } from 'fp-ts/Record'\n * import { option } from 'fp-ts'\n *\n * assert.deepStrictEqual(compact({ a: option.some(\"foo\"), b: option.none, c: option.some(\"bar\") }), {\n *   a: \"foo\",\n *   c: \"bar\",\n * });\n *\n * @category filtering\n * @since 2.0.0\n */\nexport var compact = RR.compact;\n/**\n * Separate a `Record` of `Either`s into `Left`s and `Right`s.\n *\n * @example\n * import { separate } from 'fp-ts/Record'\n * import { either } from 'fp-ts'\n *\n * assert.deepStrictEqual(\n *   separate({ a: either.right(\"foo\"), b: either.left(\"bar\"), c: either.right(\"baz\") }),\n *   {\n *     right: {\n *       a: \"foo\",\n *       c: \"baz\",\n *     },\n *     left: {\n *       b: \"bar\",\n *     },\n *   }\n * );\n *\n * @category filtering\n * @since 2.0.0\n */\nexport var separate = RR.separate;\n/**\n * @category type lambdas\n * @since 2.0.0\n */\nexport var URI = 'Record';\nexport function getShow(O) {\n    return 'compare' in O ? RR.getShow(O) : RR.getShow(S.Ord)(O);\n}\n/**\n * Given an `Eq` for the base type, it produces an `Eq`\n * for a `Record` of that base type.\n *\n * @example\n * import { getEq } from \"fp-ts/Record\";\n * import { string } from \"fp-ts\";\n * import { Eq } from \"fp-ts/Eq\";\n *\n * const eq: Eq<Record<string, string>> = getEq(string.Eq);\n * assert.deepStrictEqual(eq.equals({ a: \"foo\" }, { b: \"bar\" }), false);\n * assert.deepStrictEqual(eq.equals({ a: \"foo\" }, { a: \"foo\" }), true);\n *\n * @category instances\n * @since 2.0.0\n */\nexport var getEq = RR.getEq;\n/**\n * Returns a `Monoid` instance for `Record`s, given a `Semigroup`\n * instance for the base type.\n * The `Monoid` makes the union of two `Record`s comining the\n * overlapping entries with the provided `Semigroup`.\n *\n * @example\n * import { SemigroupSum } from 'fp-ts/number'\n * import { getMonoid } from 'fp-ts/Record'\n *\n * const M = getMonoid(SemigroupSum);\n * assert.deepStrictEqual(M.concat({ foo: 123, bar: 234 }, { foo: 456, baz: 567 }), { foo: 579 , bar: 234, baz: 567 });\n *\n * @category instances\n * @since 2.0.0\n */\nexport var getMonoid = RR.getMonoid;\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Functor = {\n    URI: URI,\n    map: _map\n};\n/**\n * Takes a value and a `Record` of functions and returns a\n * `Record` by applying each function to the input value.\n *\n * @example\n * import { flap } from \"fp-ts/Record\"\n *\n * const fab = { x: (n: number) => `${n} times 2`, y: (n: number) => `${n * 2}` };\n * assert.deepStrictEqual(flap(3)(fab), {\n *   x: \"3 times 2\",\n *   y: \"6\",\n * });\n *\n * @category mapping\n * @since 2.10.0\n */\nexport var flap = /*#__PURE__*/ flap_(Functor);\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var FunctorWithIndex = {\n    URI: URI,\n    map: _map,\n    mapWithIndex: _mapWithIndex\n};\n/**\n * Produces a `Foldable` instance for a `Record`, using the\n * provided `Ord` to sort the `Record`'s entries by key.\n *\n * @category folding\n * @since 2.11.0\n */\nexport var getFoldable = function (O) { return ({\n    URI: URI,\n    reduce: _reduce(O),\n    foldMap: _foldMap(O),\n    reduceRight: _reduceRight(O)\n}); };\n/**\n * Produces a `FoldableWithIndex1` instance for a `Record`, using the\n * provided `Ord` to sort the `Record`'s entries by key.\n *\n * @category folding\n * @since 2.11.0\n */\nexport var getFoldableWithIndex = function (O) { return ({\n    URI: URI,\n    reduce: _reduce(O),\n    foldMap: _foldMap(O),\n    reduceRight: _reduceRight(O),\n    reduceWithIndex: _reduceWithIndex(O),\n    foldMapWithIndex: _foldMapWithIndex(O),\n    reduceRightWithIndex: _reduceRightWithIndex(O)\n}); };\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Compactable = {\n    URI: URI,\n    compact: compact,\n    separate: separate\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var Filterable = {\n    URI: URI,\n    map: _map,\n    compact: compact,\n    separate: separate,\n    filter: _filter,\n    filterMap: _filterMap,\n    partition: _partition,\n    partitionMap: _partitionMap\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexport var FilterableWithIndex = {\n    URI: URI,\n    map: _map,\n    mapWithIndex: _mapWithIndex,\n    compact: compact,\n    separate: separate,\n    filter: _filter,\n    filterMap: _filterMap,\n    partition: _partition,\n    partitionMap: _partitionMap,\n    filterMapWithIndex: _filterMapWithIndex,\n    filterWithIndex: _filterWithIndex,\n    partitionMapWithIndex: _partitionMapWithIndex,\n    partitionWithIndex: _partitionWithIndex\n};\n/**\n * Produces a `Traversable` instance for a `Record`, using the\n * provided `Ord` to sort the `Record`'s entries by key.\n *\n * @category traversing\n * @since 2.11.0\n */\nexport var getTraversable = function (O) { return ({\n    URI: URI,\n    map: _map,\n    reduce: _reduce(O),\n    foldMap: _foldMap(O),\n    reduceRight: _reduceRight(O),\n    traverse: _traverse(O),\n    sequence: _sequence(O)\n}); };\n/**\n * Produces a `TraversableWithIndex` instance for a `Record`, using the\n * provided `Ord` to sort the `Record`'s entries by key.\n *\n * @category traversing\n * @since 2.11.0\n */\nexport var getTraversableWithIndex = function (O) { return ({\n    URI: URI,\n    map: _map,\n    mapWithIndex: _mapWithIndex,\n    reduce: _reduce(O),\n    foldMap: _foldMap(O),\n    reduceRight: _reduceRight(O),\n    reduceWithIndex: _reduceWithIndex(O),\n    foldMapWithIndex: _foldMapWithIndex(O),\n    reduceRightWithIndex: _reduceRightWithIndex(O),\n    traverse: _traverse(O),\n    sequence: _sequence(O),\n    traverseWithIndex: _traverseWithIndex(O)\n}); };\n/**\n * @category filtering\n * @since 2.11.0\n */\nexport var getWitherable = function (O) {\n    var T = getTraversable(O);\n    return {\n        URI: URI,\n        map: _map,\n        reduce: _reduce(O),\n        foldMap: _foldMap(O),\n        reduceRight: _reduceRight(O),\n        traverse: T.traverse,\n        sequence: T.sequence,\n        compact: compact,\n        separate: separate,\n        filter: _filter,\n        filterMap: _filterMap,\n        partition: _partition,\n        partitionMap: _partitionMap,\n        wither: witherDefault(T, Compactable),\n        wilt: wiltDefault(T, Compactable)\n    };\n};\n/**\n * Given a `Semigroup` in the base type, it produces a `Semigroup`\n * in the `Record` of the base type.\n * The resulting `Semigroup` concatenates two `Record`s by\n * `union`.\n *\n * @example\n * import { getUnionSemigroup } from \"fp-ts/Record\"\n * import { Semigroup } from \"fp-ts/Semigroup\"\n *\n * const sNumber: Semigroup<number> = { concat: (x, y) => x - y };\n * const sRecord: Semigroup<Record<string, number>> = getUnionSemigroup(sNumber);\n * assert.deepStrictEqual(sRecord.concat({ a: 1, b: 2 }, { b: 3, c: 4 }), { a: 1, b: -1, c: 4 });\n *\n * @category instances\n * @since 2.11.0\n */\nexport var getUnionSemigroup = function (S) {\n    var unionS = union(S);\n    return {\n        concat: function (first, second) { return unionS(second)(first); }\n    };\n};\n/**\n * Same as `getMonoid`.\n * Returns a `Monoid` instance for `Record`s given a `Semigroup`\n * instance for the base type.\n * The `Monoid` makes the union of two `Record`s combining the\n * entries that have the same key with the provided `Semigroup`.\n *\n * @example\n * import { SemigroupSum } from 'fp-ts/number'\n * import { getUnionMonoid } from 'fp-ts/Record'\n *\n * const M = getUnionMonoid(SemigroupSum);\n * assert.deepStrictEqual(M.concat({ foo: 123, bar: 234 }, { foo: 456, baz: 567 }), { foo: 579 , bar: 234, baz: 567 });\n *\n * @category instances\n * @since 2.11.0\n */\nexport var getUnionMonoid = function (S) { return ({\n    concat: getUnionSemigroup(S).concat,\n    empty: {}\n}); };\n/**\n * Given a `Semigroup` in the base type, it produces a `Semigroup`\n * in the `Record` of the base type.\n * The resulting `Semigroup` concatenates two `Record`s by\n * `intersection`.\n *\n * @example\n * import { getIntersectionSemigroup } from \"fp-ts/Record\"\n * import { Semigroup } from \"fp-ts/Semigroup\"\n *\n * const sNumber: Semigroup<number> = { concat: (x, y) => x - y };\n * const sRecord: Semigroup<Record<string, number>> = getIntersectionSemigroup(sNumber);\n * assert.deepStrictEqual(sRecord.concat({ a: 1, b: 2 }, { b: 3, c: 4 }), { b: -1 });\n *\n * @category instances\n * @since 2.11.0\n */\nexport var getIntersectionSemigroup = function (S) {\n    var intersectionS = intersection(S);\n    return {\n        concat: function (first, second) { return intersectionS(second)(first); }\n    };\n};\n/**\n * Produces a `Magma` with a `concat` function that combines\n * two `Record`s by making the `difference`.\n *\n * @example\n * import { getDifferenceMagma, difference } from \"fp-ts/Record\"\n * import { Magma } from \"fp-ts/Magma\"\n *\n * const r1 = { a: 3, c: 3 };\n * const r2 = { a: 1, b: 2 };\n * const m: Magma<Record<string, number>> = getDifferenceMagma<number>();\n * assert.deepStrictEqual(m.concat(r1, r2), difference(r2)(r1));\n * assert.deepStrictEqual(m.concat(r1, r2), { c: 3, b: 2 });\n *\n * @category instances\n * @since 2.11.0\n */\nexport var getDifferenceMagma = function () { return ({\n    concat: function (first, second) { return difference(second)(first); }\n}); };\n// -------------------------------------------------------------------------------------\n// deprecated\n// -------------------------------------------------------------------------------------\n/**\n * Use `getFoldable` instead.\n *\n * @category zone of death\n * @since 2.7.0\n * @deprecated\n */\nexport var Foldable = {\n    URI: URI,\n    reduce: /*#__PURE__*/ _reduce(S.Ord),\n    foldMap: /*#__PURE__*/ _foldMap(S.Ord),\n    reduceRight: /*#__PURE__*/ _reduceRight(S.Ord)\n};\n/**\n * Use `getFoldableWithIndex` instead.\n *\n * @category zone of death\n * @since 2.7.0\n * @deprecated\n */\nexport var FoldableWithIndex = {\n    URI: URI,\n    reduce: /*#__PURE__*/ _reduce(S.Ord),\n    foldMap: /*#__PURE__*/ _foldMap(S.Ord),\n    reduceRight: /*#__PURE__*/ _reduceRight(S.Ord),\n    reduceWithIndex: /*#__PURE__*/ _reduceWithIndex(S.Ord),\n    foldMapWithIndex: /*#__PURE__*/ _foldMapWithIndex(S.Ord),\n    reduceRightWithIndex: /*#__PURE__*/ _reduceRightWithIndex(S.Ord)\n};\n/**\n * Use `getTraversable` instead.\n *\n * @category zone of death\n * @since 2.7.0\n * @deprecated\n */\nexport var Traversable = {\n    URI: URI,\n    map: _map,\n    reduce: /*#__PURE__*/ _reduce(S.Ord),\n    foldMap: /*#__PURE__*/ _foldMap(S.Ord),\n    reduceRight: /*#__PURE__*/ _reduceRight(S.Ord),\n    traverse: /*#__PURE__*/ _traverse(S.Ord),\n    sequence: sequence\n};\n/**\n * Use the `getTraversableWithIndex` instead.\n *\n * @category zone of death\n * @since 2.7.0\n * @deprecated\n */\nexport var TraversableWithIndex = {\n    URI: URI,\n    map: _map,\n    mapWithIndex: _mapWithIndex,\n    reduce: /*#__PURE__*/ _reduce(S.Ord),\n    foldMap: /*#__PURE__*/ _foldMap(S.Ord),\n    reduceRight: /*#__PURE__*/ _reduceRight(S.Ord),\n    reduceWithIndex: /*#__PURE__*/ _reduceWithIndex(S.Ord),\n    foldMapWithIndex: /*#__PURE__*/ _foldMapWithIndex(S.Ord),\n    reduceRightWithIndex: /*#__PURE__*/ _reduceRightWithIndex(S.Ord),\n    traverse: /*#__PURE__*/ _traverse(S.Ord),\n    sequence: sequence,\n    traverseWithIndex: /*#__PURE__*/ _traverseWithIndex(S.Ord)\n};\nvar _wither = /*#__PURE__*/ witherDefault(Traversable, Compactable);\nvar _wilt = /*#__PURE__*/ wiltDefault(Traversable, Compactable);\n/**\n * Use `getWitherable` instead.\n *\n * @category zone of death\n * @since 2.7.0\n * @deprecated\n */\nexport var Witherable = {\n    URI: URI,\n    map: _map,\n    reduce: /*#__PURE__*/ _reduce(S.Ord),\n    foldMap: /*#__PURE__*/ _foldMap(S.Ord),\n    reduceRight: /*#__PURE__*/ _reduceRight(S.Ord),\n    traverse: /*#__PURE__*/ _traverse(S.Ord),\n    sequence: sequence,\n    compact: compact,\n    separate: separate,\n    filter: _filter,\n    filterMap: _filterMap,\n    partition: _partition,\n    partitionMap: _partitionMap,\n    wither: _wither,\n    wilt: _wilt\n};\n/**\n * Use a new `{}` instead.\n *\n * @category zone of death\n * @since 2.0.0\n * @deprecated\n */\nexport var empty = {};\n/**\n * Use [`upsertAt`](#upsertat) instead.\n *\n * @category zone of death\n * @since 2.0.0\n * @deprecated\n */\nexport var insertAt = upsertAt;\n/**\n * Use [`has`](#has) instead.\n *\n * @category zone of death\n * @since 2.0.0\n * @deprecated\n */\nexport var hasOwnProperty = RR.hasOwnProperty;\n/**\n * This instance is deprecated, use small, specific instances instead.\n * For example if a function needs a `Functor` instance, pass `R.Functor` instead of `R.record`\n * (where `R` is from `import R from 'fp-ts/Record'`)\n *\n * @category zone of death\n * @since 2.0.0\n * @deprecated\n */\nexport var record = {\n    URI: URI,\n    map: _map,\n    reduce: /*#__PURE__*/ _reduce(S.Ord),\n    foldMap: /*#__PURE__*/ _foldMap(S.Ord),\n    reduceRight: /*#__PURE__*/ _reduceRight(S.Ord),\n    traverse: /*#__PURE__*/ _traverse(S.Ord),\n    sequence: sequence,\n    compact: compact,\n    separate: separate,\n    filter: _filter,\n    filterMap: _filterMap,\n    partition: _partition,\n    partitionMap: _partitionMap,\n    mapWithIndex: _mapWithIndex,\n    reduceWithIndex: /*#__PURE__*/ _reduceWithIndex(S.Ord),\n    foldMapWithIndex: /*#__PURE__*/ _foldMapWithIndex(S.Ord),\n    reduceRightWithIndex: /*#__PURE__*/ _reduceRightWithIndex(S.Ord),\n    filterMapWithIndex: _filterMapWithIndex,\n    filterWithIndex: _filterWithIndex,\n    partitionMapWithIndex: _partitionMapWithIndex,\n    partitionWithIndex: _partitionWithIndex,\n    traverseWithIndex: /*#__PURE__*/ _traverseWithIndex(S.Ord),\n    wither: _wither,\n    wilt: _wilt\n};\n","/**\n * If a type `A` can form a `Semigroup` it has an **associative** binary operation.\n *\n * ```ts\n * interface Semigroup<A> {\n *   readonly concat: (x: A, y: A) => A\n * }\n * ```\n *\n * Associativity means the following equality must hold for any choice of `x`, `y`, and `z`.\n *\n * ```ts\n * concat(x, concat(y, z)) = concat(concat(x, y), z)\n * ```\n *\n * A common example of a semigroup is the type `string` with the operation `+`.\n *\n * ```ts\n * import { Semigroup } from 'fp-ts/Semigroup'\n *\n * const semigroupString: Semigroup<string> = {\n *   concat: (x, y) => x + y\n * }\n *\n * const x = 'x'\n * const y = 'y'\n * const z = 'z'\n *\n * semigroupString.concat(x, y) // 'xy'\n *\n * semigroupString.concat(x, semigroupString.concat(y, z)) // 'xyz'\n *\n * semigroupString.concat(semigroupString.concat(x, y), z) // 'xyz'\n * ```\n *\n * *Adapted from https://typelevel.org/cats*\n *\n * @since 2.0.0\n */\nimport { getSemigroup, identity } from './function';\nimport * as _ from './internal';\nimport * as M from './Magma';\nimport * as Or from './Ord';\n// -------------------------------------------------------------------------------------\n// constructors\n// -------------------------------------------------------------------------------------\n/**\n * Get a semigroup where `concat` will return the minimum, based on the provided order.\n *\n * @example\n * import * as N from 'fp-ts/number'\n * import * as S from 'fp-ts/Semigroup'\n *\n * const S1 = S.min(N.Ord)\n *\n * assert.deepStrictEqual(S1.concat(1, 2), 1)\n *\n * @category constructors\n * @since 2.10.0\n */\nexport var min = function (O) { return ({\n    concat: Or.min(O)\n}); };\n/**\n * Get a semigroup where `concat` will return the maximum, based on the provided order.\n *\n * @example\n * import * as N from 'fp-ts/number'\n * import * as S from 'fp-ts/Semigroup'\n *\n * const S1 = S.max(N.Ord)\n *\n * assert.deepStrictEqual(S1.concat(1, 2), 2)\n *\n * @category constructors\n * @since 2.10.0\n */\nexport var max = function (O) { return ({\n    concat: Or.max(O)\n}); };\n/**\n * @category constructors\n * @since 2.10.0\n */\nexport var constant = function (a) { return ({\n    concat: function () { return a; }\n}); };\n// -------------------------------------------------------------------------------------\n// combinators\n// -------------------------------------------------------------------------------------\n/**\n * The dual of a `Semigroup`, obtained by swapping the arguments of `concat`.\n *\n * @example\n * import { reverse } from 'fp-ts/Semigroup'\n * import * as S from 'fp-ts/string'\n *\n * assert.deepStrictEqual(reverse(S.Semigroup).concat('a', 'b'), 'ba')\n *\n * @since 2.10.0\n */\nexport var reverse = M.reverse;\n/**\n * Given a struct of semigroups returns a semigroup for the struct.\n *\n * @example\n * import { struct } from 'fp-ts/Semigroup'\n * import * as N from 'fp-ts/number'\n *\n * interface Point {\n *   readonly x: number\n *   readonly y: number\n * }\n *\n * const S = struct<Point>({\n *   x: N.SemigroupSum,\n *   y: N.SemigroupSum\n * })\n *\n * assert.deepStrictEqual(S.concat({ x: 1, y: 2 }, { x: 3, y: 4 }), { x: 4, y: 6 })\n *\n * @since 2.10.0\n */\nexport var struct = function (semigroups) { return ({\n    concat: function (first, second) {\n        var r = {};\n        for (var k in semigroups) {\n            if (_.has.call(semigroups, k)) {\n                r[k] = semigroups[k].concat(first[k], second[k]);\n            }\n        }\n        return r;\n    }\n}); };\n/**\n * Given a tuple of semigroups returns a semigroup for the tuple.\n *\n * @example\n * import { tuple } from 'fp-ts/Semigroup'\n * import * as B from 'fp-ts/boolean'\n * import * as N from 'fp-ts/number'\n * import * as S from 'fp-ts/string'\n *\n * const S1 = tuple(S.Semigroup, N.SemigroupSum)\n * assert.deepStrictEqual(S1.concat(['a', 1], ['b', 2]), ['ab', 3])\n *\n * const S2 = tuple(S.Semigroup, N.SemigroupSum, B.SemigroupAll)\n * assert.deepStrictEqual(S2.concat(['a', 1, true], ['b', 2, false]), ['ab', 3, false])\n *\n * @since 2.10.0\n */\nexport var tuple = function () {\n    var semigroups = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        semigroups[_i] = arguments[_i];\n    }\n    return ({\n        concat: function (first, second) { return semigroups.map(function (s, i) { return s.concat(first[i], second[i]); }); }\n    });\n};\n/**\n * Between each pair of elements insert `middle`.\n *\n * @example\n * import { intercalate } from 'fp-ts/Semigroup'\n * import * as S from 'fp-ts/string'\n * import { pipe } from 'fp-ts/function'\n *\n * const S1 = pipe(S.Semigroup, intercalate(' + '))\n *\n * assert.strictEqual(S1.concat('a', 'b'), 'a + b')\n *\n * @since 2.10.0\n */\nexport var intercalate = function (middle) {\n    return function (S) { return ({\n        concat: function (x, y) { return S.concat(x, S.concat(middle, y)); }\n    }); };\n};\n// -------------------------------------------------------------------------------------\n// instances\n// -------------------------------------------------------------------------------------\n/**\n * Always return the first argument.\n *\n * @example\n * import * as S from 'fp-ts/Semigroup'\n *\n * assert.deepStrictEqual(S.first<number>().concat(1, 2), 1)\n *\n * @category instances\n * @since 2.10.0\n */\nexport var first = function () { return ({ concat: identity }); };\n/**\n * Always return the last argument.\n *\n * @example\n * import * as S from 'fp-ts/Semigroup'\n *\n * assert.deepStrictEqual(S.last<number>().concat(1, 2), 2)\n *\n * @category instances\n * @since 2.10.0\n */\nexport var last = function () { return ({ concat: function (_, y) { return y; } }); };\n// -------------------------------------------------------------------------------------\n// utils\n// -------------------------------------------------------------------------------------\n/**\n * Given a sequence of `as`, concat them and return the total.\n *\n * If `as` is empty, return the provided `startWith` value.\n *\n * @example\n * import { concatAll } from 'fp-ts/Semigroup'\n * import * as N from 'fp-ts/number'\n *\n * const sum = concatAll(N.SemigroupSum)(0)\n *\n * assert.deepStrictEqual(sum([1, 2, 3]), 6)\n * assert.deepStrictEqual(sum([]), 0)\n *\n * @since 2.10.0\n */\nexport var concatAll = M.concatAll;\n// -------------------------------------------------------------------------------------\n// deprecated\n// -------------------------------------------------------------------------------------\n/**\n * Use `void` module instead.\n *\n * @category zone of death\n * @since 2.0.0\n * @deprecated\n */\nexport var semigroupVoid = constant(undefined);\n/**\n * Use [`getAssignSemigroup`](./struct.ts.html#getAssignSemigroup) instead.\n *\n * @category zone of death\n * @since 2.0.0\n * @deprecated\n */\nexport var getObjectSemigroup = function () { return ({\n    concat: function (first, second) { return Object.assign({}, first, second); }\n}); };\n/**\n * Use [`last`](#last) instead.\n *\n * @category zone of death\n * @since 2.0.0\n * @deprecated\n */\nexport var getLastSemigroup = last;\n/**\n * Use [`first`](#first) instead.\n *\n * @category zone of death\n * @since 2.0.0\n * @deprecated\n */\nexport var getFirstSemigroup = first;\n/**\n * Use [`tuple`](#tuple) instead.\n *\n * @category zone of death\n * @since 2.0.0\n * @deprecated\n */\nexport var getTupleSemigroup = tuple;\n/**\n * Use [`struct`](#struct) instead.\n *\n * @category zone of death\n * @since 2.0.0\n * @deprecated\n */\nexport var getStructSemigroup = struct;\n/**\n * Use [`reverse`](#reverse) instead.\n *\n * @category zone of death\n * @since 2.0.0\n * @deprecated\n */\nexport var getDualSemigroup = reverse;\n/**\n * Use [`max`](#max) instead.\n *\n * @category zone of death\n * @since 2.0.0\n * @deprecated\n */\nexport var getJoinSemigroup = max;\n/**\n * Use [`min`](#min) instead.\n *\n * @category zone of death\n * @since 2.0.0\n * @deprecated\n */\nexport var getMeetSemigroup = min;\n/**\n * Use [`intercalate`](#intercalate) instead.\n *\n * @category zone of death\n * @since 2.5.0\n * @deprecated\n */\nexport var getIntercalateSemigroup = intercalate;\nexport function fold(S) {\n    var concatAllS = concatAll(S);\n    return function (startWith, as) { return (as === undefined ? concatAllS(startWith) : concatAllS(startWith)(as)); };\n}\n/**\n * Use [`SemigroupAll`](./boolean.ts.html#SemigroupAll) instead.\n *\n * @category zone of death\n * @since 2.0.0\n * @deprecated\n */\nexport var semigroupAll = {\n    concat: function (x, y) { return x && y; }\n};\n/**\n * Use [`SemigroupAny`](./boolean.ts.html#SemigroupAny) instead.\n *\n * @category zone of death\n * @since 2.0.0\n * @deprecated\n */\nexport var semigroupAny = {\n    concat: function (x, y) { return x || y; }\n};\n/**\n * Use [`getSemigroup`](./function.ts.html#getSemigroup) instead.\n *\n * @category zone of death\n * @since 2.0.0\n * @deprecated\n */\nexport var getFunctionSemigroup = getSemigroup;\n/**\n * Use [`Semigroup`](./string.ts.html#Semigroup) instead.\n *\n * @category zone of death\n * @since 2.0.0\n * @deprecated\n */\nexport var semigroupString = {\n    concat: function (x, y) { return x + y; }\n};\n/**\n * Use [`SemigroupSum`](./number.ts.html#SemigroupSum) instead.\n *\n * @category zone of death\n * @since 2.0.0\n * @deprecated\n */\nexport var semigroupSum = {\n    concat: function (x, y) { return x + y; }\n};\n/**\n * Use [`SemigroupProduct`](./number.ts.html#SemigroupProduct) instead.\n *\n * @category zone of death\n * @since 2.0.0\n * @deprecated\n */\nexport var semigroupProduct = {\n    concat: function (x, y) { return x * y; }\n};\n","/**\n * ```ts\n * interface Separated<E, A> {\n *    readonly left: E\n *    readonly right: A\n * }\n * ```\n *\n * Represents a result of separating a whole into two parts.\n *\n * @since 2.10.0\n */\nimport { pipe } from './function';\nimport { flap as flap_ } from './Functor';\n// -------------------------------------------------------------------------------------\n// constructors\n// -------------------------------------------------------------------------------------\n/**\n * @category constructors\n * @since 2.10.0\n */\nexport var separated = function (left, right) { return ({ left: left, right: right }); };\nvar _map = function (fa, f) { return pipe(fa, map(f)); };\nvar _mapLeft = function (fa, f) { return pipe(fa, mapLeft(f)); };\nvar _bimap = function (fa, g, f) { return pipe(fa, bimap(g, f)); };\n/**\n * `map` can be used to turn functions `(a: A) => B` into functions `(fa: F<A>) => F<B>` whose argument and return types\n * use the type constructor `F` to represent some computational context.\n *\n * @category mapping\n * @since 2.10.0\n */\nexport var map = function (f) {\n    return function (fa) {\n        return separated(left(fa), f(right(fa)));\n    };\n};\n/**\n * Map a function over the first type argument of a bifunctor.\n *\n * @category error handling\n * @since 2.10.0\n */\nexport var mapLeft = function (f) {\n    return function (fa) {\n        return separated(f(left(fa)), right(fa));\n    };\n};\n/**\n * Map a pair of functions over the two type arguments of the bifunctor.\n *\n * @category mapping\n * @since 2.10.0\n */\nexport var bimap = function (f, g) {\n    return function (fa) {\n        return separated(f(left(fa)), g(right(fa)));\n    };\n};\n/**\n * @category type lambdas\n * @since 2.10.0\n */\nexport var URI = 'Separated';\n/**\n * @category instances\n * @since 2.10.0\n */\nexport var Bifunctor = {\n    URI: URI,\n    mapLeft: _mapLeft,\n    bimap: _bimap\n};\n/**\n * @category instances\n * @since 2.10.0\n */\nexport var Functor = {\n    URI: URI,\n    map: _map\n};\n/**\n * @category mapping\n * @since 2.10.0\n */\nexport var flap = /*#__PURE__*/ flap_(Functor);\n// -------------------------------------------------------------------------------------\n// utils\n// -------------------------------------------------------------------------------------\n/**\n * @since 2.10.0\n */\nexport var left = function (s) { return s.left; };\n/**\n * @since 2.10.0\n */\nexport var right = function (s) { return s.right; };\n","import * as _ from './internal';\nexport function wiltDefault(T, C) {\n    return function (F) {\n        var traverseF = T.traverse(F);\n        return function (wa, f) { return F.map(traverseF(wa, f), C.separate); };\n    };\n}\nexport function witherDefault(T, C) {\n    return function (F) {\n        var traverseF = T.traverse(F);\n        return function (wa, f) { return F.map(traverseF(wa, f), C.compact); };\n    };\n}\nexport function filterE(W) {\n    return function (F) {\n        var witherF = W.wither(F);\n        return function (predicate) { return function (ga) { return witherF(ga, function (a) { return F.map(predicate(a), function (b) { return (b ? _.some(a) : _.none); }); }); }; };\n    };\n}\n","export function guard(F, P) {\n    return function (b) { return (b ? P.of(undefined) : F.zero()); };\n}\n","var __spreadArray = (this && this.__spreadArray) || function (to, from, pack) {\n    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {\n        if (ar || !(i in from)) {\n            if (!ar) ar = Array.prototype.slice.call(from, 0, i);\n            ar[i] = from[i];\n        }\n    }\n    return to.concat(ar || Array.prototype.slice.call(from));\n};\n// -------------------------------------------------------------------------------------\n// instances\n// -------------------------------------------------------------------------------------\n/**\n * @category instances\n * @since 2.10.0\n */\nexport var getBooleanAlgebra = function (B) {\n    return function () { return ({\n        meet: function (x, y) { return function (a) { return B.meet(x(a), y(a)); }; },\n        join: function (x, y) { return function (a) { return B.join(x(a), y(a)); }; },\n        zero: function () { return B.zero; },\n        one: function () { return B.one; },\n        implies: function (x, y) { return function (a) { return B.implies(x(a), y(a)); }; },\n        not: function (x) { return function (a) { return B.not(x(a)); }; }\n    }); };\n};\n/**\n * Unary functions form a semigroup as long as you can provide a semigroup for the codomain.\n *\n * @example\n * import { Predicate, getSemigroup } from 'fp-ts/function'\n * import * as B from 'fp-ts/boolean'\n *\n * const f: Predicate<number> = (n) => n <= 2\n * const g: Predicate<number> = (n) => n >= 0\n *\n * const S1 = getSemigroup(B.SemigroupAll)<number>()\n *\n * assert.deepStrictEqual(S1.concat(f, g)(1), true)\n * assert.deepStrictEqual(S1.concat(f, g)(3), false)\n *\n * const S2 = getSemigroup(B.SemigroupAny)<number>()\n *\n * assert.deepStrictEqual(S2.concat(f, g)(1), true)\n * assert.deepStrictEqual(S2.concat(f, g)(3), true)\n *\n * @category instances\n * @since 2.10.0\n */\nexport var getSemigroup = function (S) {\n    return function () { return ({\n        concat: function (f, g) { return function (a) { return S.concat(f(a), g(a)); }; }\n    }); };\n};\n/**\n * Unary functions form a monoid as long as you can provide a monoid for the codomain.\n *\n * @example\n * import { Predicate } from 'fp-ts/Predicate'\n * import { getMonoid } from 'fp-ts/function'\n * import * as B from 'fp-ts/boolean'\n *\n * const f: Predicate<number> = (n) => n <= 2\n * const g: Predicate<number> = (n) => n >= 0\n *\n * const M1 = getMonoid(B.MonoidAll)<number>()\n *\n * assert.deepStrictEqual(M1.concat(f, g)(1), true)\n * assert.deepStrictEqual(M1.concat(f, g)(3), false)\n *\n * const M2 = getMonoid(B.MonoidAny)<number>()\n *\n * assert.deepStrictEqual(M2.concat(f, g)(1), true)\n * assert.deepStrictEqual(M2.concat(f, g)(3), true)\n *\n * @category instances\n * @since 2.10.0\n */\nexport var getMonoid = function (M) {\n    var getSemigroupM = getSemigroup(M);\n    return function () { return ({\n        concat: getSemigroupM().concat,\n        empty: function () { return M.empty; }\n    }); };\n};\n/**\n * @category instances\n * @since 2.10.0\n */\nexport var getSemiring = function (S) { return ({\n    add: function (f, g) { return function (x) { return S.add(f(x), g(x)); }; },\n    zero: function () { return S.zero; },\n    mul: function (f, g) { return function (x) { return S.mul(f(x), g(x)); }; },\n    one: function () { return S.one; }\n}); };\n/**\n * @category instances\n * @since 2.10.0\n */\nexport var getRing = function (R) {\n    var S = getSemiring(R);\n    return {\n        add: S.add,\n        mul: S.mul,\n        one: S.one,\n        zero: S.zero,\n        sub: function (f, g) { return function (x) { return R.sub(f(x), g(x)); }; }\n    };\n};\n// -------------------------------------------------------------------------------------\n// utils\n// -------------------------------------------------------------------------------------\n/**\n * @since 2.11.0\n */\nexport var apply = function (a) {\n    return function (f) {\n        return f(a);\n    };\n};\n/**\n * @since 2.0.0\n */\nexport function identity(a) {\n    return a;\n}\n/**\n * @since 2.0.0\n */\nexport var unsafeCoerce = identity;\n/**\n * @since 2.0.0\n */\nexport function constant(a) {\n    return function () { return a; };\n}\n/**\n * A thunk that returns always `true`.\n *\n * @since 2.0.0\n */\nexport var constTrue = /*#__PURE__*/ constant(true);\n/**\n * A thunk that returns always `false`.\n *\n * @since 2.0.0\n */\nexport var constFalse = /*#__PURE__*/ constant(false);\n/**\n * A thunk that returns always `null`.\n *\n * @since 2.0.0\n */\nexport var constNull = /*#__PURE__*/ constant(null);\n/**\n * A thunk that returns always `undefined`.\n *\n * @since 2.0.0\n */\nexport var constUndefined = /*#__PURE__*/ constant(undefined);\n/**\n * A thunk that returns always `void`.\n *\n * @since 2.0.0\n */\nexport var constVoid = constUndefined;\nexport function flip(f) {\n    return function () {\n        var args = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            args[_i] = arguments[_i];\n        }\n        if (args.length > 1) {\n            return f(args[1], args[0]);\n        }\n        return function (a) { return f(a)(args[0]); };\n    };\n}\nexport function flow(ab, bc, cd, de, ef, fg, gh, hi, ij) {\n    switch (arguments.length) {\n        case 1:\n            return ab;\n        case 2:\n            return function () {\n                return bc(ab.apply(this, arguments));\n            };\n        case 3:\n            return function () {\n                return cd(bc(ab.apply(this, arguments)));\n            };\n        case 4:\n            return function () {\n                return de(cd(bc(ab.apply(this, arguments))));\n            };\n        case 5:\n            return function () {\n                return ef(de(cd(bc(ab.apply(this, arguments)))));\n            };\n        case 6:\n            return function () {\n                return fg(ef(de(cd(bc(ab.apply(this, arguments))))));\n            };\n        case 7:\n            return function () {\n                return gh(fg(ef(de(cd(bc(ab.apply(this, arguments)))))));\n            };\n        case 8:\n            return function () {\n                return hi(gh(fg(ef(de(cd(bc(ab.apply(this, arguments))))))));\n            };\n        case 9:\n            return function () {\n                return ij(hi(gh(fg(ef(de(cd(bc(ab.apply(this, arguments)))))))));\n            };\n    }\n    return;\n}\n/**\n * @since 2.0.0\n */\nexport function tuple() {\n    var t = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        t[_i] = arguments[_i];\n    }\n    return t;\n}\n/**\n * @since 2.0.0\n */\nexport function increment(n) {\n    return n + 1;\n}\n/**\n * @since 2.0.0\n */\nexport function decrement(n) {\n    return n - 1;\n}\n/**\n * @since 2.0.0\n */\nexport function absurd(_) {\n    throw new Error('Called `absurd` function which should be uncallable');\n}\n/**\n * Creates a tupled version of this function: instead of `n` arguments, it accepts a single tuple argument.\n *\n * @example\n * import { tupled } from 'fp-ts/function'\n *\n * const add = tupled((x: number, y: number): number => x + y)\n *\n * assert.strictEqual(add([1, 2]), 3)\n *\n * @since 2.4.0\n */\nexport function tupled(f) {\n    return function (a) { return f.apply(void 0, a); };\n}\n/**\n * Inverse function of `tupled`\n *\n * @since 2.4.0\n */\nexport function untupled(f) {\n    return function () {\n        var a = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            a[_i] = arguments[_i];\n        }\n        return f(a);\n    };\n}\nexport function pipe(a, ab, bc, cd, de, ef, fg, gh, hi) {\n    switch (arguments.length) {\n        case 1:\n            return a;\n        case 2:\n            return ab(a);\n        case 3:\n            return bc(ab(a));\n        case 4:\n            return cd(bc(ab(a)));\n        case 5:\n            return de(cd(bc(ab(a))));\n        case 6:\n            return ef(de(cd(bc(ab(a)))));\n        case 7:\n            return fg(ef(de(cd(bc(ab(a))))));\n        case 8:\n            return gh(fg(ef(de(cd(bc(ab(a)))))));\n        case 9:\n            return hi(gh(fg(ef(de(cd(bc(ab(a))))))));\n        default: {\n            var ret = arguments[0];\n            for (var i = 1; i < arguments.length; i++) {\n                ret = arguments[i](ret);\n            }\n            return ret;\n        }\n    }\n}\n/**\n * Type hole simulation\n *\n * @since 2.7.0\n */\nexport var hole = absurd;\n/**\n * @since 2.11.0\n */\nexport var SK = function (_, b) { return b; };\n/**\n * Use `Predicate` module instead.\n *\n * @category zone of death\n * @since 2.0.0\n * @deprecated\n */\nexport function not(predicate) {\n    return function (a) { return !predicate(a); };\n}\n/**\n * Use `Endomorphism` module instead.\n *\n * @category zone of death\n * @since 2.10.0\n * @deprecated\n */\nexport var getEndomorphismMonoid = function () { return ({\n    concat: function (first, second) { return flow(first, second); },\n    empty: identity\n}); };\n/** @internal */\nexport var dual = function (arity, body) {\n    var isDataFirst = typeof arity === 'number' ? function (args) { return args.length >= arity; } : arity;\n    return function () {\n        var args = Array.from(arguments);\n        if (isDataFirst(arguments)) {\n            return body.apply(this, args);\n        }\n        return function (self) { return body.apply(void 0, __spreadArray([self], args, false)); };\n    };\n};\n","var __spreadArray = (this && this.__spreadArray) || function (to, from, pack) {\n    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {\n        if (ar || !(i in from)) {\n            if (!ar) ar = Array.prototype.slice.call(from, 0, i);\n            ar[i] = from[i];\n        }\n    }\n    return to.concat(ar || Array.prototype.slice.call(from));\n};\nimport { dual } from './function';\n// -------------------------------------------------------------------------------------\n// Option\n// -------------------------------------------------------------------------------------\n/** @internal */\nexport var isNone = function (fa) { return fa._tag === 'None'; };\n/** @internal */\nexport var isSome = function (fa) { return fa._tag === 'Some'; };\n/** @internal */\nexport var none = { _tag: 'None' };\n/** @internal */\nexport var some = function (a) { return ({ _tag: 'Some', value: a }); };\n// -------------------------------------------------------------------------------------\n// Either\n// -------------------------------------------------------------------------------------\n/** @internal */\nexport var isLeft = function (ma) { return ma._tag === 'Left'; };\n/** @internal */\nexport var isRight = function (ma) { return ma._tag === 'Right'; };\n/** @internal */\nexport var left = function (e) { return ({ _tag: 'Left', left: e }); };\n/** @internal */\nexport var right = function (a) { return ({ _tag: 'Right', right: a }); };\n// -------------------------------------------------------------------------------------\n// ReadonlyNonEmptyArray\n// -------------------------------------------------------------------------------------\n/** @internal */\nexport var singleton = function (a) { return [a]; };\n/** @internal */\nexport var isNonEmpty = function (as) { return as.length > 0; };\n/** @internal */\nexport var head = function (as) { return as[0]; };\n/** @internal */\nexport var tail = function (as) { return as.slice(1); };\n// -------------------------------------------------------------------------------------\n// empty\n// -------------------------------------------------------------------------------------\n/** @internal */\nexport var emptyReadonlyArray = [];\n/** @internal */\nexport var emptyRecord = {};\n// -------------------------------------------------------------------------------------\n// Record\n// -------------------------------------------------------------------------------------\n/** @internal */\nexport var has = Object.prototype.hasOwnProperty;\n// -------------------------------------------------------------------------------------\n// NonEmptyArray\n// -------------------------------------------------------------------------------------\n/** @internal */\nexport var fromReadonlyNonEmptyArray = function (as) { return __spreadArray([as[0]], as.slice(1), true); };\n/** @internal */\nexport var liftNullable = function (F) {\n    return function (f, onNullable) {\n        return function () {\n            var a = [];\n            for (var _i = 0; _i < arguments.length; _i++) {\n                a[_i] = arguments[_i];\n            }\n            var o = f.apply(void 0, a);\n            return F.fromEither(o == null ? left(onNullable.apply(void 0, a)) : right(o));\n        };\n    };\n};\n/** @internal */\nexport var liftOption = function (F) {\n    return function (f, onNone) {\n        return function () {\n            var a = [];\n            for (var _i = 0; _i < arguments.length; _i++) {\n                a[_i] = arguments[_i];\n            }\n            var o = f.apply(void 0, a);\n            return F.fromEither(isNone(o) ? left(onNone.apply(void 0, a)) : right(o.value));\n        };\n    };\n};\n/** @internal */\nexport var flatMapNullable = function (F, M) {\n    return /*#__PURE__*/ dual(3, function (self, f, onNullable) {\n        return M.flatMap(self, liftNullable(F)(f, onNullable));\n    });\n};\n/** @internal */\nexport var flatMapOption = function (F, M) {\n    return /*#__PURE__*/ dual(3, function (self, f, onNone) { return M.flatMap(self, liftOption(F)(f, onNone)); });\n};\n/** @internal */\nexport var flatMapEither = function (F, M) {\n    return /*#__PURE__*/ dual(2, function (self, f) {\n        return M.flatMap(self, function (a) { return F.fromEither(f(a)); });\n    });\n};\n/** @internal */\nexport var flatMapIO = function (F, M) {\n    return /*#__PURE__*/ dual(2, function (self, f) {\n        return M.flatMap(self, function (a) { return F.fromIO(f(a)); });\n    });\n};\n/** @internal */\nexport var flatMapTask = function (F, M) {\n    return /*#__PURE__*/ dual(2, function (self, f) {\n        return M.flatMap(self, function (a) { return F.fromTask(f(a)); });\n    });\n};\n/** @internal */\nexport var flatMapReader = function (F, M) {\n    return /*#__PURE__*/ dual(2, function (self, f) {\n        return M.flatMap(self, function (a) { return F.fromReader(f(a)); });\n    });\n};\n","// -------------------------------------------------------------------------------------\n// refinements\n// -------------------------------------------------------------------------------------\n/**\n * @category refinements\n * @since 2.11.0\n */\nexport var isNumber = function (u) { return typeof u === 'number'; };\n// -------------------------------------------------------------------------------------\n// instances\n// -------------------------------------------------------------------------------------\n/**\n * @category instances\n * @since 2.10.0\n */\nexport var Eq = {\n    equals: function (first, second) { return first === second; }\n};\n/**\n * @category instances\n * @since 2.10.0\n */\nexport var Ord = {\n    equals: Eq.equals,\n    compare: function (first, second) { return (first < second ? -1 : first > second ? 1 : 0); }\n};\n/**\n * @category instances\n * @since 2.10.0\n */\nexport var Bounded = {\n    equals: Eq.equals,\n    compare: Ord.compare,\n    top: Infinity,\n    bottom: -Infinity\n};\n/**\n * @category instances\n * @since 2.10.0\n */\nexport var Show = {\n    show: function (n) { return JSON.stringify(n); }\n};\n/**\n * @category instances\n * @since 2.11.0\n */\nexport var MagmaSub = {\n    concat: function (first, second) { return first - second; }\n};\n/**\n * `number` semigroup under addition.\n *\n * @example\n * import { SemigroupSum } from 'fp-ts/number'\n *\n * assert.deepStrictEqual(SemigroupSum.concat(2, 3), 5)\n *\n * @category instances\n * @since 2.10.0\n */\nexport var SemigroupSum = {\n    concat: function (first, second) { return first + second; }\n};\n/**\n * `number` semigroup under multiplication.\n *\n * @example\n * import { SemigroupProduct } from 'fp-ts/number'\n *\n * assert.deepStrictEqual(SemigroupProduct.concat(2, 3), 6)\n *\n * @category instances\n * @since 2.10.0\n */\nexport var SemigroupProduct = {\n    concat: function (first, second) { return first * second; }\n};\n/**\n * `number` monoid under addition.\n *\n * The `empty` value is `0`.\n *\n * @example\n * import { MonoidSum } from 'fp-ts/number'\n *\n * assert.deepStrictEqual(MonoidSum.concat(2, MonoidSum.empty), 2)\n *\n * @category instances\n * @since 2.10.0\n */\nexport var MonoidSum = {\n    concat: SemigroupSum.concat,\n    empty: 0\n};\n/**\n * `number` monoid under multiplication.\n *\n * The `empty` value is `1`.\n *\n * @example\n * import { MonoidProduct } from 'fp-ts/number'\n *\n * assert.deepStrictEqual(MonoidProduct.concat(2, MonoidProduct.empty), 2)\n *\n * @category instances\n * @since 2.10.0\n */\nexport var MonoidProduct = {\n    concat: SemigroupProduct.concat,\n    empty: 1\n};\n/**\n * @category instances\n * @since 2.10.0\n */\nexport var Field = {\n    add: SemigroupSum.concat,\n    zero: 0,\n    mul: SemigroupProduct.concat,\n    one: 1,\n    sub: MagmaSub.concat,\n    degree: function (_) { return 1; },\n    div: function (first, second) { return first / second; },\n    mod: function (first, second) { return first % second; }\n};\n","import { apFirst as apFirst_, apSecond as apSecond_ } from './Apply';\nimport { chainFirst as chainFirst_ } from './Chain';\nimport { identity, pipe as pipeFromFunctionModule } from './function';\nexport function map(F) {\n    return function (f) { return function (fa) { return F.map(fa, f); }; };\n}\nexport function contramap(F) {\n    return function (f) { return function (fa) { return F.contramap(fa, f); }; };\n}\nexport function mapWithIndex(F) {\n    return function (f) { return function (fa) { return F.mapWithIndex(fa, f); }; };\n}\nexport function ap(F) {\n    return function (fa) { return function (fab) { return F.ap(fab, fa); }; };\n}\nexport function chain(F) {\n    return function (f) { return function (fa) { return F.chain(fa, f); }; };\n}\nexport function bimap(F) {\n    return function (f, g) { return function (fea) { return F.bimap(fea, f, g); }; };\n}\nexport function mapLeft(F) {\n    return function (f) { return function (fea) { return F.mapLeft(fea, f); }; };\n}\nexport function extend(F) {\n    return function (f) { return function (wa) { return F.extend(wa, f); }; };\n}\nexport function reduce(F) {\n    return function (b, f) { return function (fa) { return F.reduce(fa, b, f); }; };\n}\nexport function foldMap(F) {\n    return function (M) {\n        var foldMapM = F.foldMap(M);\n        return function (f) { return function (fa) { return foldMapM(fa, f); }; };\n    };\n}\nexport function reduceRight(F) {\n    return function (b, f) { return function (fa) { return F.reduceRight(fa, b, f); }; };\n}\nexport function reduceWithIndex(F) {\n    return function (b, f) { return function (fa) { return F.reduceWithIndex(fa, b, f); }; };\n}\nexport function foldMapWithIndex(F) {\n    return function (M) {\n        var foldMapWithIndexM = F.foldMapWithIndex(M);\n        return function (f) { return function (fa) { return foldMapWithIndexM(fa, f); }; };\n    };\n}\nexport function reduceRightWithIndex(F) {\n    return function (b, f) { return function (fa) { return F.reduceRightWithIndex(fa, b, f); }; };\n}\nexport function alt(F) {\n    return function (that) { return function (fa) { return F.alt(fa, that); }; };\n}\nexport function filter(F) {\n    return function (predicate) { return function (fa) { return F.filter(fa, predicate); }; };\n}\nexport function filterMap(F) {\n    return function (f) { return function (fa) { return F.filterMap(fa, f); }; };\n}\nexport function partition(F) {\n    return function (f) { return function (fa) { return F.partition(fa, f); }; };\n}\nexport function partitionMap(F) {\n    return function (f) { return function (fa) { return F.partitionMap(fa, f); }; };\n}\nexport function filterWithIndex(F) {\n    return function (predicate) { return function (fa) { return F.filterWithIndex(fa, predicate); }; };\n}\nexport function filterMapWithIndex(F) {\n    return function (f) { return function (fa) { return F.filterMapWithIndex(fa, f); }; };\n}\nexport function partitionWithIndex(F) {\n    return function (f) { return function (fa) { return F.partitionWithIndex(fa, f); }; };\n}\nexport function partitionMapWithIndex(F) {\n    return function (f) { return function (fa) { return F.partitionMapWithIndex(fa, f); }; };\n}\nexport function promap(F) {\n    return function (f, g) { return function (fbc) { return F.promap(fbc, f, g); }; };\n}\nexport function compose(F) {\n    return function (ea) { return function (ab) { return F.compose(ab, ea); }; };\n}\nvar isFunctor = function (I) { return typeof I.map === 'function'; };\nvar isContravariant = function (I) { return typeof I.contramap === 'function'; };\nvar isFunctorWithIndex = function (I) { return typeof I.mapWithIndex === 'function'; };\nvar isApply = function (I) { return typeof I.ap === 'function'; };\nvar isChain = function (I) { return typeof I.chain === 'function'; };\nvar isBifunctor = function (I) { return typeof I.bimap === 'function'; };\nvar isExtend = function (I) { return typeof I.extend === 'function'; };\nvar isFoldable = function (I) { return typeof I.reduce === 'function'; };\nvar isFoldableWithIndex = function (I) { return typeof I.reduceWithIndex === 'function'; };\nvar isAlt = function (I) { return typeof I.alt === 'function'; };\nvar isCompactable = function (I) { return typeof I.compact === 'function'; };\nvar isFilterable = function (I) { return typeof I.filter === 'function'; };\nvar isFilterableWithIndex = function (I) {\n    return typeof I.filterWithIndex === 'function';\n};\nvar isProfunctor = function (I) { return typeof I.promap === 'function'; };\nvar isSemigroupoid = function (I) { return typeof I.compose === 'function'; };\nvar isMonadThrow = function (I) { return typeof I.throwError === 'function'; };\n/** @deprecated */\nexport function pipeable(I) {\n    var r = {};\n    if (isFunctor(I)) {\n        r.map = map(I);\n    }\n    if (isContravariant(I)) {\n        r.contramap = contramap(I);\n    }\n    if (isFunctorWithIndex(I)) {\n        r.mapWithIndex = mapWithIndex(I);\n    }\n    if (isApply(I)) {\n        r.ap = ap(I);\n        r.apFirst = apFirst_(I);\n        r.apSecond = apSecond_(I);\n    }\n    if (isChain(I)) {\n        r.chain = chain(I);\n        r.chainFirst = chainFirst_(I);\n        r.flatten = r.chain(identity);\n    }\n    if (isBifunctor(I)) {\n        r.bimap = bimap(I);\n        r.mapLeft = mapLeft(I);\n    }\n    if (isExtend(I)) {\n        r.extend = extend(I);\n        r.duplicate = r.extend(identity);\n    }\n    if (isFoldable(I)) {\n        r.reduce = reduce(I);\n        r.foldMap = foldMap(I);\n        r.reduceRight = reduceRight(I);\n    }\n    if (isFoldableWithIndex(I)) {\n        r.reduceWithIndex = reduceWithIndex(I);\n        r.foldMapWithIndex = foldMapWithIndex(I);\n        r.reduceRightWithIndex = reduceRightWithIndex(I);\n    }\n    if (isAlt(I)) {\n        r.alt = alt(I);\n    }\n    if (isCompactable(I)) {\n        r.compact = I.compact;\n        r.separate = I.separate;\n    }\n    if (isFilterable(I)) {\n        r.filter = filter(I);\n        r.filterMap = filterMap(I);\n        r.partition = partition(I);\n        r.partitionMap = partitionMap(I);\n    }\n    if (isFilterableWithIndex(I)) {\n        r.filterWithIndex = filterWithIndex(I);\n        r.filterMapWithIndex = filterMapWithIndex(I);\n        r.partitionWithIndex = partitionWithIndex(I);\n        r.partitionMapWithIndex = partitionMapWithIndex(I);\n    }\n    if (isProfunctor(I)) {\n        r.promap = promap(I);\n    }\n    if (isSemigroupoid(I)) {\n        r.compose = compose(I);\n    }\n    if (isMonadThrow(I)) {\n        var fromOption = function (onNone) { return function (ma) {\n            return ma._tag === 'None' ? I.throwError(onNone()) : I.of(ma.value);\n        }; };\n        var fromEither = function (ma) {\n            return ma._tag === 'Left' ? I.throwError(ma.left) : I.of(ma.right);\n        };\n        var fromPredicate = function (predicate, onFalse) {\n            return function (a) {\n                return predicate(a) ? I.of(a) : I.throwError(onFalse(a));\n            };\n        };\n        var filterOrElse = function (predicate, onFalse) {\n            return function (ma) {\n                return I.chain(ma, function (a) { return (predicate(a) ? I.of(a) : I.throwError(onFalse(a))); });\n            };\n        };\n        r.fromOption = fromOption;\n        r.fromEither = fromEither;\n        r.fromPredicate = fromPredicate;\n        r.filterOrElse = filterOrElse;\n    }\n    return r;\n}\n/**\n * Use [`pipe`](https://gcanti.github.io/fp-ts/modules/function.ts.html#pipe) from `function` module instead.\n *\n * @since 2.0.0\n * @deprecated\n */\nexport var pipe = pipeFromFunctionModule;\n","import { isNonEmpty } from './ReadonlyNonEmptyArray';\n// -------------------------------------------------------------------------------------\n// instances\n// -------------------------------------------------------------------------------------\n/**\n * @example\n * import * as S from 'fp-ts/string'\n *\n * assert.deepStrictEqual(S.Eq.equals('a', 'a'), true)\n * assert.deepStrictEqual(S.Eq.equals('a', 'b'), false)\n *\n * @category instances\n * @since 2.10.0\n */\nexport var Eq = {\n    equals: function (first, second) { return first === second; }\n};\n/**\n * `string` semigroup under concatenation.\n *\n * @example\n * import * as S from 'fp-ts/string'\n *\n * assert.deepStrictEqual(S.Semigroup.concat('a', 'b'), 'ab')\n *\n * @category instances\n * @since 2.10.0\n */\nexport var Semigroup = {\n    concat: function (first, second) { return first + second; }\n};\n/**\n * An empty `string`.\n *\n * @since 2.10.0\n */\nexport var empty = '';\n/**\n * `string` monoid under concatenation.\n *\n * The `empty` value is `''`.\n *\n * @example\n * import * as S from 'fp-ts/string'\n *\n * assert.deepStrictEqual(S.Monoid.concat('a', 'b'), 'ab')\n * assert.deepStrictEqual(S.Monoid.concat('a', S.Monoid.empty), 'a')\n *\n * @category instances\n * @since 2.10.0\n */\nexport var Monoid = {\n    concat: Semigroup.concat,\n    empty: empty\n};\n/**\n * @example\n * import * as S from 'fp-ts/string'\n *\n * assert.deepStrictEqual(S.Ord.compare('a', 'a'), 0)\n * assert.deepStrictEqual(S.Ord.compare('a', 'b'), -1)\n * assert.deepStrictEqual(S.Ord.compare('b', 'a'), 1)\n *\n * @category instances\n * @since 2.10.0\n */\nexport var Ord = {\n    equals: Eq.equals,\n    compare: function (first, second) { return (first < second ? -1 : first > second ? 1 : 0); }\n};\n/**\n * @example\n * import * as S from 'fp-ts/string'\n *\n * assert.deepStrictEqual(S.Show.show('a'), '\"a\"')\n *\n * @category instances\n * @since 2.10.0\n */\nexport var Show = {\n    show: function (s) { return JSON.stringify(s); }\n};\n// -------------------------------------------------------------------------------------\n// refinements\n// -------------------------------------------------------------------------------------\n/**\n * @example\n * import * as S from 'fp-ts/string'\n *\n * assert.deepStrictEqual(S.isString('a'), true)\n * assert.deepStrictEqual(S.isString(1), false)\n *\n * @category refinements\n * @since 2.11.0\n */\nexport var isString = function (u) { return typeof u === 'string'; };\n// -------------------------------------------------------------------------------------\n// combinators\n// -------------------------------------------------------------------------------------\n/**\n * @example\n * import * as S from 'fp-ts/string'\n * import { pipe } from 'fp-ts/function'\n *\n * assert.deepStrictEqual(pipe('a', S.toUpperCase), 'A')\n *\n * @since 2.11.0\n */\nexport var toUpperCase = function (s) { return s.toUpperCase(); };\n/**\n * @example\n * import * as S from 'fp-ts/string'\n * import { pipe } from 'fp-ts/function'\n *\n * assert.deepStrictEqual(pipe('A', S.toLowerCase), 'a')\n *\n * @since 2.11.0\n */\nexport var toLowerCase = function (s) { return s.toLowerCase(); };\n/**\n * @example\n * import * as S from 'fp-ts/string'\n * import { pipe } from 'fp-ts/function'\n *\n * assert.deepStrictEqual(pipe('abc', S.replace('b', 'd')), 'adc')\n *\n * @since 2.11.0\n */\nexport var replace = function (searchValue, replaceValue) {\n    return function (s) {\n        return s.replace(searchValue, replaceValue);\n    };\n};\n/**\n * @example\n * import * as S from 'fp-ts/string'\n * import { pipe } from 'fp-ts/function'\n *\n * assert.deepStrictEqual(pipe(' a ', S.trim), 'a')\n *\n * @since 2.11.0\n */\nexport var trim = function (s) { return s.trim(); };\n/**\n * @example\n * import * as S from 'fp-ts/string'\n * import { pipe } from 'fp-ts/function'\n *\n * assert.deepStrictEqual(pipe(' a ', S.trimLeft), 'a ')\n *\n * @since 2.11.0\n */\nexport var trimLeft = function (s) { return s.trimLeft(); };\n/**\n * @example\n * import * as S from 'fp-ts/string'\n * import { pipe } from 'fp-ts/function'\n *\n * assert.deepStrictEqual(pipe(' a ', S.trimRight), ' a')\n *\n * @since 2.11.0\n */\nexport var trimRight = function (s) { return s.trimRight(); };\n/**\n * @example\n * import * as S from 'fp-ts/string'\n * import { pipe } from 'fp-ts/function'\n *\n * assert.deepStrictEqual(pipe('abcd', S.slice(1, 3)), 'bc')\n *\n * @since 2.11.0\n */\nexport var slice = function (start, end) {\n    return function (s) {\n        return s.slice(start, end);\n    };\n};\n// -------------------------------------------------------------------------------------\n// utils\n// -------------------------------------------------------------------------------------\n/**\n * Test whether a `string` is empty.\n *\n * @example\n * import * as S from 'fp-ts/string'\n * import { pipe } from 'fp-ts/function'\n *\n * assert.deepStrictEqual(pipe('', S.isEmpty), true)\n * assert.deepStrictEqual(pipe('a', S.isEmpty), false)\n *\n * @since 2.10.0\n */\nexport var isEmpty = function (s) { return s.length === 0; };\n/**\n * Calculate the number of characters in a `string`.\n *\n * @example\n * import * as S from 'fp-ts/string'\n * import { pipe } from 'fp-ts/function'\n *\n * assert.deepStrictEqual(pipe('abc', S.size), 3)\n *\n * @since 2.10.0\n */\nexport var size = function (s) { return s.length; };\n/**\n * @example\n * import * as S from 'fp-ts/string'\n * import { pipe } from 'fp-ts/function'\n *\n * assert.deepStrictEqual(pipe('abc', S.split('')), ['a', 'b', 'c'])\n * assert.deepStrictEqual(pipe('', S.split('')), [''])\n *\n * @since 2.11.0\n */\nexport var split = function (separator) {\n    return function (s) {\n        var out = s.split(separator);\n        return isNonEmpty(out) ? out : [s];\n    };\n};\n/**\n * @example\n * import * as S from 'fp-ts/string'\n * import { pipe } from 'fp-ts/function'\n *\n * assert.deepStrictEqual(pipe('abc', S.includes('b')), true)\n * assert.deepStrictEqual(pipe('abc', S.includes('d')), false)\n *\n * @since 2.11.0\n */\nexport var includes = function (searchString, position) {\n    return function (s) {\n        return s.includes(searchString, position);\n    };\n};\n/**\n * @example\n * import * as S from 'fp-ts/string'\n * import { pipe } from 'fp-ts/function'\n *\n * assert.deepStrictEqual(pipe('abc', S.startsWith('a')), true)\n * assert.deepStrictEqual(pipe('bc', S.startsWith('a')), false)\n *\n * @since 2.11.0\n */\nexport var startsWith = function (searchString, position) {\n    return function (s) {\n        return s.startsWith(searchString, position);\n    };\n};\n/**\n * @example\n * import * as S from 'fp-ts/string'\n * import { pipe } from 'fp-ts/function'\n *\n * assert.deepStrictEqual(pipe('abc', S.endsWith('c')), true)\n * assert.deepStrictEqual(pipe('ab', S.endsWith('c')), false)\n *\n * @since 2.11.0\n */\nexport var endsWith = function (searchString, position) {\n    return function (s) {\n        return s.endsWith(searchString, position);\n    };\n};\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.chainFirst = chainFirst;\nexports.tap = tap;\nexports.bind = bind;\nfunction chainFirst(M) {\n    var tapM = tap(M);\n    return function (f) { return function (first) { return tapM(first, f); }; };\n}\n/** @internal */\nfunction tap(M) {\n    return function (first, f) { return M.chain(first, function (a) { return M.map(f(a), function () { return a; }); }); };\n}\nfunction bind(M) {\n    return function (name, f) { return function (ma) { return M.chain(ma, function (a) { return M.map(f(a), function (b) {\n        var _a;\n        return Object.assign({}, a, (_a = {}, _a[name] = b, _a));\n    }); }); }; };\n}\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.eqDate = exports.eqNumber = exports.eqString = exports.eqBoolean = exports.eq = exports.strictEqual = exports.getStructEq = exports.getTupleEq = exports.Contravariant = exports.getMonoid = exports.getSemigroup = exports.eqStrict = exports.URI = exports.contramap = exports.tuple = exports.struct = exports.fromEquals = void 0;\nvar function_1 = require(\"./function\");\n// -------------------------------------------------------------------------------------\n// constructors\n// -------------------------------------------------------------------------------------\n/**\n * @category constructors\n * @since 2.0.0\n */\nvar fromEquals = function (equals) { return ({\n    equals: function (x, y) { return x === y || equals(x, y); }\n}); };\nexports.fromEquals = fromEquals;\n// -------------------------------------------------------------------------------------\n// combinators\n// -------------------------------------------------------------------------------------\n/**\n * @since 2.10.0\n */\nvar struct = function (eqs) {\n    return (0, exports.fromEquals)(function (first, second) {\n        for (var key in eqs) {\n            if (!eqs[key].equals(first[key], second[key])) {\n                return false;\n            }\n        }\n        return true;\n    });\n};\nexports.struct = struct;\n/**\n * Given a tuple of `Eq`s returns a `Eq` for the tuple\n *\n * @example\n * import { tuple } from 'fp-ts/Eq'\n * import * as S from 'fp-ts/string'\n * import * as N from 'fp-ts/number'\n * import * as B from 'fp-ts/boolean'\n *\n * const E = tuple(S.Eq, N.Eq, B.Eq)\n * assert.strictEqual(E.equals(['a', 1, true], ['a', 1, true]), true)\n * assert.strictEqual(E.equals(['a', 1, true], ['b', 1, true]), false)\n * assert.strictEqual(E.equals(['a', 1, true], ['a', 2, true]), false)\n * assert.strictEqual(E.equals(['a', 1, true], ['a', 1, false]), false)\n *\n * @since 2.10.0\n */\nvar tuple = function () {\n    var eqs = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        eqs[_i] = arguments[_i];\n    }\n    return (0, exports.fromEquals)(function (first, second) { return eqs.every(function (E, i) { return E.equals(first[i], second[i]); }); });\n};\nexports.tuple = tuple;\n/* istanbul ignore next */\nvar contramap_ = function (fa, f) { return (0, function_1.pipe)(fa, (0, exports.contramap)(f)); };\n/**\n * A typical use case for `contramap` would be like, given some `User` type, to construct an `Eq<User>`.\n *\n * We can do so with a function from `User -> X` where `X` is some value that we know how to compare\n * for equality (meaning we have an `Eq<X>`)\n *\n * For example, given the following `User` type, we want to construct an `Eq<User>` that just looks at the `key` field\n * for each user (since it's known to be unique).\n *\n * If we have a way of comparing `UUID`s for equality (`eqUUID: Eq<UUID>`) and we know how to go from `User -> UUID`,\n * using `contramap` we can do this\n *\n * @example\n * import { contramap, Eq } from 'fp-ts/Eq'\n * import { pipe } from 'fp-ts/function'\n * import * as S from 'fp-ts/string'\n *\n * type UUID = string\n *\n * interface User {\n *   readonly key: UUID\n *   readonly firstName: string\n *   readonly lastName: string\n * }\n *\n * const eqUUID: Eq<UUID> = S.Eq\n *\n * const eqUserByKey: Eq<User> = pipe(\n *   eqUUID,\n *   contramap((user) => user.key)\n * )\n *\n * assert.deepStrictEqual(\n *   eqUserByKey.equals(\n *     { key: 'k1', firstName: 'a1', lastName: 'b1' },\n *     { key: 'k2', firstName: 'a1', lastName: 'b1' }\n *   ),\n *   false\n * )\n * assert.deepStrictEqual(\n *   eqUserByKey.equals(\n *     { key: 'k1', firstName: 'a1', lastName: 'b1' },\n *     { key: 'k1', firstName: 'a2', lastName: 'b1' }\n *   ),\n *   true\n * )\n *\n * @since 2.0.0\n */\nvar contramap = function (f) { return function (fa) {\n    return (0, exports.fromEquals)(function (x, y) { return fa.equals(f(x), f(y)); });\n}; };\nexports.contramap = contramap;\n/**\n * @category type lambdas\n * @since 2.0.0\n */\nexports.URI = 'Eq';\n/**\n * @category instances\n * @since 2.5.0\n */\nexports.eqStrict = {\n    equals: function (a, b) { return a === b; }\n};\nvar empty = {\n    equals: function () { return true; }\n};\n/**\n * @category instances\n * @since 2.10.0\n */\nvar getSemigroup = function () { return ({\n    concat: function (x, y) { return (0, exports.fromEquals)(function (a, b) { return x.equals(a, b) && y.equals(a, b); }); }\n}); };\nexports.getSemigroup = getSemigroup;\n/**\n * @category instances\n * @since 2.6.0\n */\nvar getMonoid = function () { return ({\n    concat: (0, exports.getSemigroup)().concat,\n    empty: empty\n}); };\nexports.getMonoid = getMonoid;\n/**\n * @category instances\n * @since 2.7.0\n */\nexports.Contravariant = {\n    URI: exports.URI,\n    contramap: contramap_\n};\n// -------------------------------------------------------------------------------------\n// deprecated\n// -------------------------------------------------------------------------------------\n/**\n * Use [`tuple`](#tuple) instead.\n *\n * @category zone of death\n * @since 2.0.0\n * @deprecated\n */\nexports.getTupleEq = exports.tuple;\n/**\n * Use [`struct`](#struct) instead.\n *\n * @category zone of death\n * @since 2.0.0\n * @deprecated\n */\nexports.getStructEq = exports.struct;\n/**\n * Use [`eqStrict`](#eqstrict) instead\n *\n * @category zone of death\n * @since 2.0.0\n * @deprecated\n */\nexports.strictEqual = exports.eqStrict.equals;\n/**\n * This instance is deprecated, use small, specific instances instead.\n * For example if a function needs a `Contravariant` instance, pass `E.Contravariant` instead of `E.eq`\n * (where `E` is from `import E from 'fp-ts/Eq'`)\n *\n * @category zone of death\n * @since 2.0.0\n * @deprecated\n */\nexports.eq = exports.Contravariant;\n/**\n * Use [`Eq`](./boolean.ts.html#eq) instead.\n *\n * @category zone of death\n * @since 2.0.0\n * @deprecated\n */\nexports.eqBoolean = exports.eqStrict;\n/**\n * Use [`Eq`](./string.ts.html#eq) instead.\n *\n * @category zone of death\n * @since 2.0.0\n * @deprecated\n */\nexports.eqString = exports.eqStrict;\n/**\n * Use [`Eq`](./number.ts.html#eq) instead.\n *\n * @category zone of death\n * @since 2.0.0\n * @deprecated\n */\nexports.eqNumber = exports.eqStrict;\n/**\n * Use [`Eq`](./Date.ts.html#eq) instead.\n *\n * @category zone of death\n * @since 2.0.0\n * @deprecated\n */\nexports.eqDate = {\n    equals: function (first, second) { return first.valueOf() === second.valueOf(); }\n};\n","\"use strict\";\n/**\n * The `FromEither` type class represents those data types which support errors.\n *\n * @since 2.10.0\n */\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.fromOption = fromOption;\nexports.fromPredicate = fromPredicate;\nexports.fromOptionK = fromOptionK;\nexports.chainOptionK = chainOptionK;\nexports.fromEitherK = fromEitherK;\nexports.chainEitherK = chainEitherK;\nexports.chainFirstEitherK = chainFirstEitherK;\nexports.filterOrElse = filterOrElse;\nexports.tapEither = tapEither;\nvar Chain_1 = require(\"./Chain\");\nvar function_1 = require(\"./function\");\nvar _ = __importStar(require(\"./internal\"));\nfunction fromOption(F) {\n    return function (onNone) { return function (ma) { return F.fromEither(_.isNone(ma) ? _.left(onNone()) : _.right(ma.value)); }; };\n}\nfunction fromPredicate(F) {\n    return function (predicate, onFalse) {\n        return function (a) {\n            return F.fromEither(predicate(a) ? _.right(a) : _.left(onFalse(a)));\n        };\n    };\n}\nfunction fromOptionK(F) {\n    var fromOptionF = fromOption(F);\n    return function (onNone) {\n        var from = fromOptionF(onNone);\n        return function (f) { return (0, function_1.flow)(f, from); };\n    };\n}\nfunction chainOptionK(F, M) {\n    var fromOptionKF = fromOptionK(F);\n    return function (onNone) {\n        var from = fromOptionKF(onNone);\n        return function (f) { return function (ma) { return M.chain(ma, from(f)); }; };\n    };\n}\nfunction fromEitherK(F) {\n    return function (f) { return (0, function_1.flow)(f, F.fromEither); };\n}\nfunction chainEitherK(F, M) {\n    var fromEitherKF = fromEitherK(F);\n    return function (f) { return function (ma) { return M.chain(ma, fromEitherKF(f)); }; };\n}\nfunction chainFirstEitherK(F, M) {\n    var tapEitherM = tapEither(F, M);\n    return function (f) { return function (ma) { return tapEitherM(ma, f); }; };\n}\nfunction filterOrElse(F, M) {\n    return function (predicate, onFalse) {\n        return function (ma) {\n            return M.chain(ma, function (a) { return F.fromEither(predicate(a) ? _.right(a) : _.left(onFalse(a))); });\n        };\n    };\n}\n/** @internal */\nfunction tapEither(F, M) {\n    var fromEither = fromEitherK(F);\n    var tapM = (0, Chain_1.tap)(M);\n    return function (self, f) { return tapM(self, fromEither(f)); };\n}\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.map = map;\nexports.flap = flap;\nexports.bindTo = bindTo;\nexports.let = let_;\nexports.getFunctorComposition = getFunctorComposition;\nexports.as = as;\nexports.asUnit = asUnit;\n/**\n * A `Functor` is a type constructor which supports a mapping operation `map`.\n *\n * `map` can be used to turn functions `a -> b` into functions `f a -> f b` whose argument and return types use the type\n * constructor `f` to represent some computational context.\n *\n * Instances must satisfy the following laws:\n *\n * 1. Identity: `F.map(fa, a => a) <-> fa`\n * 2. Composition: `F.map(fa, a => bc(ab(a))) <-> F.map(F.map(fa, ab), bc)`\n *\n * @since 2.0.0\n */\nvar function_1 = require(\"./function\");\nfunction map(F, G) {\n    return function (f) { return function (fa) { return F.map(fa, function (ga) { return G.map(ga, f); }); }; };\n}\nfunction flap(F) {\n    return function (a) { return function (fab) { return F.map(fab, function (f) { return f(a); }); }; };\n}\nfunction bindTo(F) {\n    return function (name) { return function (fa) { return F.map(fa, function (a) {\n        var _a;\n        return (_a = {}, _a[name] = a, _a);\n    }); }; };\n}\nfunction let_(F) {\n    return function (name, f) { return function (fa) { return F.map(fa, function (a) {\n        var _a;\n        return Object.assign({}, a, (_a = {}, _a[name] = f(a), _a));\n    }); }; };\n}\n/** @deprecated */\nfunction getFunctorComposition(F, G) {\n    var _map = map(F, G);\n    return {\n        map: function (fga, f) { return (0, function_1.pipe)(fga, _map(f)); }\n    };\n}\n/** @internal */\nfunction as(F) {\n    return function (self, b) { return F.map(self, function () { return b; }); };\n}\n/** @internal */\nfunction asUnit(F) {\n    var asM = as(F);\n    return function (self) { return asM(self, undefined); };\n}\n","\"use strict\";\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.these = exports.traverseReadonlyArrayWithIndex = exports.traverseReadonlyNonEmptyArrayWithIndex = exports.ApT = exports.toTuple = exports.toTuple2 = exports.exists = exports.elem = exports.fromOptionK = exports.fromOption = exports.fromPredicate = exports.FromEither = exports.Traversable = exports.Foldable = exports.FromThese = exports.Bifunctor = exports.Pointed = exports.flap = exports.Functor = exports.URI = exports.of = exports.sequence = exports.traverse = exports.reduceRight = exports.foldMap = exports.reduce = exports.map = exports.mapLeft = exports.bimap = exports.fromOptions = exports.getApply = exports.swap = exports.fold = exports.match = exports.foldW = exports.matchW = exports.isRight = exports.isLeft = void 0;\nexports.isBoth = isBoth;\nexports.left = left;\nexports.right = right;\nexports.both = both;\nexports.getShow = getShow;\nexports.getEq = getEq;\nexports.getSemigroup = getSemigroup;\nexports.getApplicative = getApplicative;\nexports.getChain = getChain;\nexports.getMonad = getMonad;\nexports.getLeft = getLeft;\nexports.getRight = getRight;\nexports.leftOrBoth = leftOrBoth;\nexports.rightOrBoth = rightOrBoth;\nexports.getLeftOnly = getLeftOnly;\nexports.getRightOnly = getRightOnly;\nvar Eq_1 = require(\"./Eq\");\nvar FromEither_1 = require(\"./FromEither\");\nvar function_1 = require(\"./function\");\nvar Functor_1 = require(\"./Functor\");\nvar _ = __importStar(require(\"./internal\"));\n// -------------------------------------------------------------------------------------\n// refinements\n// -------------------------------------------------------------------------------------\n/**\n * Returns `true` if the these is an instance of `Left`, `false` otherwise\n *\n * @category refinements\n * @since 2.0.0\n */\nvar isLeft = function (fa) { return fa._tag === 'Left'; };\nexports.isLeft = isLeft;\n/**\n * Returns `true` if the these is an instance of `Right`, `false` otherwise\n *\n * @category refinements\n * @since 2.0.0\n */\nvar isRight = function (fa) { return fa._tag === 'Right'; };\nexports.isRight = isRight;\n/**\n * Returns `true` if the these is an instance of `Both`, `false` otherwise\n *\n * @category refinements\n * @since 2.0.0\n */\nfunction isBoth(fa) {\n    return fa._tag === 'Both';\n}\n// -------------------------------------------------------------------------------------\n// constructors\n// -------------------------------------------------------------------------------------\n/**\n * @category constructors\n * @since 2.0.0\n */\nfunction left(left) {\n    return { _tag: 'Left', left: left };\n}\n/**\n * @category constructors\n * @since 2.0.0\n */\nfunction right(right) {\n    return { _tag: 'Right', right: right };\n}\n/**\n * @category constructors\n * @since 2.0.0\n */\nfunction both(left, right) {\n    return { _tag: 'Both', left: left, right: right };\n}\n/**\n * Less strict version of [`match`](#match).\n *\n * The `W` suffix (short for **W**idening) means that the handler return types will be merged.\n *\n * @category pattern matching\n * @since 2.10.0\n */\nvar matchW = function (onLeft, onRight, onBoth) {\n    return function (fa) {\n        switch (fa._tag) {\n            case 'Left':\n                return onLeft(fa.left);\n            case 'Right':\n                return onRight(fa.right);\n            case 'Both':\n                return onBoth(fa.left, fa.right);\n        }\n    };\n};\nexports.matchW = matchW;\n/**\n * Alias of [`matchW`](#matchw).\n *\n * @category pattern matching\n * @since 2.10.0\n */\nexports.foldW = exports.matchW;\n/**\n * @category pattern matching\n * @since 2.10.0\n */\nexports.match = exports.matchW;\n/**\n * Alias of [`match`](#match).\n *\n * @category pattern matching\n * @since 2.0.0\n */\nexports.fold = exports.match;\n/**\n * @since 2.4.0\n */\nexports.swap = (0, exports.match)(right, left, function (e, a) { return both(a, e); });\n/**\n * @category instances\n * @since 2.0.0\n */\nfunction getShow(SE, SA) {\n    return {\n        show: (0, exports.match)(function (l) { return \"left(\".concat(SE.show(l), \")\"); }, function (a) { return \"right(\".concat(SA.show(a), \")\"); }, function (l, a) { return \"both(\".concat(SE.show(l), \", \").concat(SA.show(a), \")\"); })\n    };\n}\n/**\n * @category instances\n * @since 2.0.0\n */\nfunction getEq(EE, EA) {\n    return (0, Eq_1.fromEquals)(function (x, y) {\n        return (0, exports.isLeft)(x)\n            ? (0, exports.isLeft)(y) && EE.equals(x.left, y.left)\n            : (0, exports.isRight)(x)\n                ? (0, exports.isRight)(y) && EA.equals(x.right, y.right)\n                : isBoth(y) && EE.equals(x.left, y.left) && EA.equals(x.right, y.right);\n    });\n}\n/**\n * @category instances\n * @since 2.0.0\n */\nfunction getSemigroup(SE, SA) {\n    return {\n        concat: function (x, y) {\n            return (0, exports.isLeft)(x)\n                ? (0, exports.isLeft)(y)\n                    ? left(SE.concat(x.left, y.left))\n                    : (0, exports.isRight)(y)\n                        ? both(x.left, y.right)\n                        : both(SE.concat(x.left, y.left), y.right)\n                : (0, exports.isRight)(x)\n                    ? (0, exports.isLeft)(y)\n                        ? both(y.left, x.right)\n                        : (0, exports.isRight)(y)\n                            ? right(SA.concat(x.right, y.right))\n                            : both(y.left, SA.concat(x.right, y.right))\n                    : (0, exports.isLeft)(y)\n                        ? both(SE.concat(x.left, y.left), x.right)\n                        : (0, exports.isRight)(y)\n                            ? both(x.left, SA.concat(x.right, y.right))\n                            : both(SE.concat(x.left, y.left), SA.concat(x.right, y.right));\n        }\n    };\n}\n/**\n * @category instances\n * @since 2.10.0\n */\nvar getApply = function (S) { return ({\n    URI: exports.URI,\n    _E: undefined,\n    map: _map,\n    ap: function (fab, fa) {\n        return (0, exports.isLeft)(fab)\n            ? (0, exports.isLeft)(fa)\n                ? left(S.concat(fab.left, fa.left))\n                : (0, exports.isRight)(fa)\n                    ? left(fab.left)\n                    : left(S.concat(fab.left, fa.left))\n            : (0, exports.isRight)(fab)\n                ? (0, exports.isLeft)(fa)\n                    ? left(fa.left)\n                    : (0, exports.isRight)(fa)\n                        ? right(fab.right(fa.right))\n                        : both(fa.left, fab.right(fa.right))\n                : (0, exports.isLeft)(fa)\n                    ? left(S.concat(fab.left, fa.left))\n                    : (0, exports.isRight)(fa)\n                        ? both(fab.left, fab.right(fa.right))\n                        : both(S.concat(fab.left, fa.left), fab.right(fa.right));\n    }\n}); };\nexports.getApply = getApply;\n/**\n * @category instances\n * @since 2.7.0\n */\nfunction getApplicative(S) {\n    var A = (0, exports.getApply)(S);\n    return {\n        URI: exports.URI,\n        _E: undefined,\n        map: _map,\n        ap: A.ap,\n        of: exports.of\n    };\n}\n/**\n * @category instances\n * @since 2.10.0\n */\nfunction getChain(S) {\n    var A = (0, exports.getApply)(S);\n    var chain = function (ma, f) {\n        if ((0, exports.isLeft)(ma)) {\n            return ma;\n        }\n        if ((0, exports.isRight)(ma)) {\n            return f(ma.right);\n        }\n        var fb = f(ma.right);\n        return (0, exports.isLeft)(fb)\n            ? left(S.concat(ma.left, fb.left))\n            : (0, exports.isRight)(fb)\n                ? both(ma.left, fb.right)\n                : both(S.concat(ma.left, fb.left), fb.right);\n    };\n    return {\n        URI: exports.URI,\n        _E: undefined,\n        map: _map,\n        ap: A.ap,\n        chain: chain\n    };\n}\n/**\n * @category instances\n * @since 2.0.0\n */\nfunction getMonad(S) {\n    var C = getChain(S);\n    return {\n        URI: exports.URI,\n        _E: undefined,\n        map: _map,\n        of: exports.of,\n        ap: C.ap,\n        chain: C.chain,\n        throwError: left\n    };\n}\n/**\n * Returns an `E` value if possible\n *\n * @example\n * import { getLeft, left, right, both } from 'fp-ts/These'\n * import { none, some } from 'fp-ts/Option'\n *\n * assert.deepStrictEqual(getLeft(left('a')), some('a'))\n * assert.deepStrictEqual(getLeft(right(1)), none)\n * assert.deepStrictEqual(getLeft(both('a', 1)), some('a'))\n *\n * @category conversions\n * @since 2.0.0\n */\nfunction getLeft(fa) {\n    return (0, exports.isLeft)(fa) ? _.some(fa.left) : (0, exports.isRight)(fa) ? _.none : _.some(fa.left);\n}\n/**\n * Returns an `A` value if possible\n *\n * @example\n * import { getRight, left, right, both } from 'fp-ts/These'\n * import { none, some } from 'fp-ts/Option'\n *\n * assert.deepStrictEqual(getRight(left('a')), none)\n * assert.deepStrictEqual(getRight(right(1)), some(1))\n * assert.deepStrictEqual(getRight(both('a', 1)), some(1))\n *\n * @category conversions\n * @since 2.0.0\n */\nfunction getRight(fa) {\n    return (0, exports.isLeft)(fa) ? _.none : (0, exports.isRight)(fa) ? _.some(fa.right) : _.some(fa.right);\n}\n// TODO: make lazy in v3\n/**\n * @example\n * import { leftOrBoth, left, both } from 'fp-ts/These'\n * import { none, some } from 'fp-ts/Option'\n *\n * assert.deepStrictEqual(leftOrBoth('a')(none), left('a'))\n * assert.deepStrictEqual(leftOrBoth('a')(some(1)), both('a', 1))\n *\n * @category constructors\n * @since 2.0.0\n */\nfunction leftOrBoth(e) {\n    return function (ma) { return (_.isNone(ma) ? left(e) : both(e, ma.value)); };\n}\n// TODO: make lazy in v3\n/**\n * @example\n * import { rightOrBoth, right, both } from 'fp-ts/These'\n * import { none, some } from 'fp-ts/Option'\n *\n * assert.deepStrictEqual(rightOrBoth(1)(none), right(1))\n * assert.deepStrictEqual(rightOrBoth(1)(some('a')), both('a', 1))\n *\n * @category constructors\n * @since 2.0.0\n */\nfunction rightOrBoth(a) {\n    return function (me) { return (_.isNone(me) ? right(a) : both(me.value, a)); };\n}\n/**\n * Returns the `E` value if and only if the value is constructed with `Left`\n *\n * @example\n * import { getLeftOnly, left, right, both } from 'fp-ts/These'\n * import { none, some } from 'fp-ts/Option'\n *\n * assert.deepStrictEqual(getLeftOnly(left('a')), some('a'))\n * assert.deepStrictEqual(getLeftOnly(right(1)), none)\n * assert.deepStrictEqual(getLeftOnly(both('a', 1)), none)\n *\n * @category conversions\n * @since 2.0.0\n */\nfunction getLeftOnly(fa) {\n    return (0, exports.isLeft)(fa) ? _.some(fa.left) : _.none;\n}\n/**\n * Returns the `A` value if and only if the value is constructed with `Right`\n *\n * @example\n * import { getRightOnly, left, right, both } from 'fp-ts/These'\n * import { none, some } from 'fp-ts/Option'\n *\n * assert.deepStrictEqual(getRightOnly(left('a')), none)\n * assert.deepStrictEqual(getRightOnly(right(1)), some(1))\n * assert.deepStrictEqual(getRightOnly(both('a', 1)), none)\n *\n * @category conversions\n * @since 2.0.0\n */\nfunction getRightOnly(fa) {\n    return (0, exports.isRight)(fa) ? _.some(fa.right) : _.none;\n}\n/**\n * Takes a pair of `Option`s and attempts to create a `These` from them\n *\n * @example\n * import { fromOptions, left, right, both } from 'fp-ts/These'\n * import { none, some } from 'fp-ts/Option'\n *\n * assert.deepStrictEqual(fromOptions(none, none), none)\n * assert.deepStrictEqual(fromOptions(some('a'), none), some(left('a')))\n * assert.deepStrictEqual(fromOptions(none, some(1)), some(right(1)))\n * assert.deepStrictEqual(fromOptions(some('a'), some(1)), some(both('a', 1)))\n *\n * @category conversions\n * @since 2.0.0\n */\nvar fromOptions = function (fe, fa) {\n    return _.isNone(fe)\n        ? _.isNone(fa)\n            ? _.none\n            : _.some(right(fa.value))\n        : _.isNone(fa)\n            ? _.some(left(fe.value))\n            : _.some(both(fe.value, fa.value));\n};\nexports.fromOptions = fromOptions;\nvar _map = function (fa, f) { return (0, function_1.pipe)(fa, (0, exports.map)(f)); };\n/* istanbul ignore next */\nvar _bimap = function (fa, f, g) { return (0, function_1.pipe)(fa, (0, exports.bimap)(f, g)); };\n/* istanbul ignore next */\nvar _mapLeft = function (fa, f) { return (0, function_1.pipe)(fa, (0, exports.mapLeft)(f)); };\n/* istanbul ignore next */\nvar _reduce = function (fa, b, f) { return (0, function_1.pipe)(fa, (0, exports.reduce)(b, f)); };\n/* istanbul ignore next */\nvar _foldMap = function (M) {\n    var foldMapM = (0, exports.foldMap)(M);\n    return function (fa, f) { return (0, function_1.pipe)(fa, foldMapM(f)); };\n};\n/* istanbul ignore next */\nvar _reduceRight = function (fa, b, f) { return (0, function_1.pipe)(fa, (0, exports.reduceRight)(b, f)); };\n/* istanbul ignore next */\nvar _traverse = function (F) {\n    var traverseF = (0, exports.traverse)(F);\n    return function (ta, f) { return (0, function_1.pipe)(ta, traverseF(f)); };\n};\n/**\n * Map a pair of functions over the two type arguments of the bifunctor.\n *\n * @category mapping\n * @since 2.0.0\n */\nvar bimap = function (f, g) { return function (fa) {\n    return (0, exports.isLeft)(fa) ? left(f(fa.left)) : (0, exports.isRight)(fa) ? right(g(fa.right)) : both(f(fa.left), g(fa.right));\n}; };\nexports.bimap = bimap;\n/**\n * Map a function over the first type argument of a bifunctor.\n *\n * @category error handling\n * @since 2.0.0\n */\nvar mapLeft = function (f) { return function (fa) {\n    return (0, exports.isLeft)(fa) ? left(f(fa.left)) : isBoth(fa) ? both(f(fa.left), fa.right) : fa;\n}; };\nexports.mapLeft = mapLeft;\n/**\n * `map` can be used to turn functions `(a: A) => B` into functions `(fa: F<A>) => F<B>` whose argument and return types\n * use the type constructor `F` to represent some computational context.\n *\n * @category mapping\n * @since 2.0.0\n */\nvar map = function (f) { return function (fa) {\n    return (0, exports.isLeft)(fa) ? fa : (0, exports.isRight)(fa) ? right(f(fa.right)) : both(fa.left, f(fa.right));\n}; };\nexports.map = map;\n/**\n * @category folding\n * @since 2.0.0\n */\nvar reduce = function (b, f) { return function (fa) {\n    return (0, exports.isLeft)(fa) ? b : f(b, fa.right);\n}; };\nexports.reduce = reduce;\n/**\n * @category folding\n * @since 2.0.0\n */\nvar foldMap = function (M) { return function (f) { return function (fa) {\n    return (0, exports.isLeft)(fa) ? M.empty : f(fa.right);\n}; }; };\nexports.foldMap = foldMap;\n/**\n * @category folding\n * @since 2.0.0\n */\nvar reduceRight = function (b, f) { return function (fa) {\n    return (0, exports.isLeft)(fa) ? b : f(fa.right, b);\n}; };\nexports.reduceRight = reduceRight;\n/**\n * @category traversing\n * @since 2.6.3\n */\nvar traverse = function (F) {\n    return function (f) {\n        return function (ta) {\n            return (0, exports.isLeft)(ta) ? F.of(ta) : (0, exports.isRight)(ta) ? F.map(f(ta.right), right) : F.map(f(ta.right), function (b) { return both(ta.left, b); });\n        };\n    };\n};\nexports.traverse = traverse;\n/**\n * @category traversing\n * @since 2.6.3\n */\nvar sequence = function (F) {\n    return function (ta) {\n        return (0, exports.isLeft)(ta) ? F.of(ta) : (0, exports.isRight)(ta) ? F.map(ta.right, right) : F.map(ta.right, function (b) { return both(ta.left, b); });\n    };\n};\nexports.sequence = sequence;\n/**\n * @category constructors\n * @since 2.0.0\n */\nexports.of = right;\n/**\n * @category type lambdas\n * @since 2.0.0\n */\nexports.URI = 'These';\n/**\n * @category instances\n * @since 2.7.0\n */\nexports.Functor = {\n    URI: exports.URI,\n    map: _map\n};\n/**\n * @category mapping\n * @since 2.10.0\n */\nexports.flap = (0, Functor_1.flap)(exports.Functor);\n/**\n * @category instances\n * @since 2.10.0\n */\nexports.Pointed = {\n    URI: exports.URI,\n    of: exports.of\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexports.Bifunctor = {\n    URI: exports.URI,\n    bimap: _bimap,\n    mapLeft: _mapLeft\n};\n/**\n * @category instances\n * @since 2.11.0\n */\nexports.FromThese = {\n    URI: exports.URI,\n    fromThese: function_1.identity\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexports.Foldable = {\n    URI: exports.URI,\n    reduce: _reduce,\n    foldMap: _foldMap,\n    reduceRight: _reduceRight\n};\n/**\n * @category instances\n * @since 2.7.0\n */\nexports.Traversable = {\n    URI: exports.URI,\n    map: _map,\n    reduce: _reduce,\n    foldMap: _foldMap,\n    reduceRight: _reduceRight,\n    traverse: _traverse,\n    sequence: exports.sequence\n};\n/**\n * @category instances\n * @since 2.10.0\n */\nexports.FromEither = {\n    URI: exports.URI,\n    fromEither: function_1.identity\n};\n/**\n * @category lifting\n * @since 2.13.0\n */\nexports.fromPredicate = (0, FromEither_1.fromPredicate)(exports.FromEither);\n/**\n * @category conversions\n * @since 2.10.0\n */\nexports.fromOption = \n/*#__PURE__*/ (0, FromEither_1.fromOption)(exports.FromEither);\n/**\n * @category lifting\n * @since 2.10.0\n */\nexports.fromOptionK = \n/*#__PURE__*/ (0, FromEither_1.fromOptionK)(exports.FromEither);\n// -------------------------------------------------------------------------------------\n// utils\n// -------------------------------------------------------------------------------------\n/**\n * @since 2.11.0\n */\nvar elem = function (E) {\n    return function (a) {\n        return function (ma) {\n            return (0, exports.isLeft)(ma) ? false : E.equals(a, ma.right);\n        };\n    };\n};\nexports.elem = elem;\n/**\n * @since 2.11.0\n */\nvar exists = function (predicate) {\n    return function (ma) {\n        return (0, exports.isLeft)(ma) ? false : predicate(ma.right);\n    };\n};\nexports.exists = exists;\n/**\n * @example\n * import { toTuple2, left, right, both } from 'fp-ts/These'\n *\n * assert.deepStrictEqual(toTuple2(() => 'a', () => 1)(left('b')), ['b', 1])\n * assert.deepStrictEqual(toTuple2(() => 'a', () => 1)(right(2)), ['a', 2])\n * assert.deepStrictEqual(toTuple2(() => 'a', () => 1)(both('b', 2)), ['b', 2])\n *\n * @category conversions\n * @since 2.10.0\n */\nvar toTuple2 = function (e, a) {\n    return function (fa) {\n        return (0, exports.isLeft)(fa) ? [fa.left, a()] : (0, exports.isRight)(fa) ? [e(), fa.right] : [fa.left, fa.right];\n    };\n};\nexports.toTuple2 = toTuple2;\n// -------------------------------------------------------------------------------------\n// deprecated\n// -------------------------------------------------------------------------------------\n/**\n * Use [`toTuple2`](#totuple2) instead.\n *\n * @category zone of death\n * @since 2.0.0\n * @deprecated\n */\nvar toTuple = function (e, a) {\n    return (0, exports.toTuple2)(function () { return e; }, function () { return a; });\n};\nexports.toTuple = toTuple;\n/**\n * @since 2.11.0\n */\nexports.ApT = (0, exports.of)(_.emptyReadonlyArray);\n// -------------------------------------------------------------------------------------\n// array utils\n// -------------------------------------------------------------------------------------\n/**\n * Equivalent to `ReadonlyNonEmptyArray#traverseWithIndex(getApplicative(S))`.\n *\n * @category traversing\n * @since 2.11.0\n */\nvar traverseReadonlyNonEmptyArrayWithIndex = function (S) {\n    return function (f) {\n        return function (as) {\n            var e = _.none;\n            var t = f(0, _.head(as));\n            if ((0, exports.isLeft)(t)) {\n                return t;\n            }\n            if (isBoth(t)) {\n                e = _.some(t.left);\n            }\n            var out = [t.right];\n            for (var i = 1; i < as.length; i++) {\n                var t_1 = f(i, as[i]);\n                if ((0, exports.isLeft)(t_1)) {\n                    return t_1;\n                }\n                if (isBoth(t_1)) {\n                    e = _.isNone(e) ? _.some(t_1.left) : _.some(S.concat(e.value, t_1.left));\n                }\n                out.push(t_1.right);\n            }\n            return _.isNone(e) ? right(out) : both(e.value, out);\n        };\n    };\n};\nexports.traverseReadonlyNonEmptyArrayWithIndex = traverseReadonlyNonEmptyArrayWithIndex;\n/**\n * Equivalent to `ReadonlyArray#traverseWithIndex(getApplicative(S))`.\n *\n * @category traversing\n * @since 2.11.0\n */\nvar traverseReadonlyArrayWithIndex = function (S) {\n    return function (f) {\n        var g = (0, exports.traverseReadonlyNonEmptyArrayWithIndex)(S)(f);\n        return function (as) { return (_.isNonEmpty(as) ? g(as) : exports.ApT); };\n    };\n};\nexports.traverseReadonlyArrayWithIndex = traverseReadonlyArrayWithIndex;\n// -------------------------------------------------------------------------------------\n// deprecated\n// -------------------------------------------------------------------------------------\n/**\n * This instance is deprecated, use small, specific instances instead.\n * For example if a function needs a `Functor` instance, pass `T.Functor` instead of `T.these`\n * (where `T` is from `import T from 'fp-ts/These'`)\n *\n * @category zone of death\n * @since 2.0.0\n * @deprecated\n */\nexports.these = {\n    URI: exports.URI,\n    map: _map,\n    bimap: _bimap,\n    mapLeft: _mapLeft,\n    reduce: _reduce,\n    foldMap: _foldMap,\n    reduceRight: _reduceRight,\n    traverse: _traverse,\n    sequence: exports.sequence\n};\n","\"use strict\";\nvar __spreadArray = (this && this.__spreadArray) || function (to, from, pack) {\n    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {\n        if (ar || !(i in from)) {\n            if (!ar) ar = Array.prototype.slice.call(from, 0, i);\n            ar[i] = from[i];\n        }\n    }\n    return to.concat(ar || Array.prototype.slice.call(from));\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.dual = exports.getEndomorphismMonoid = exports.SK = exports.hole = exports.constVoid = exports.constUndefined = exports.constNull = exports.constFalse = exports.constTrue = exports.unsafeCoerce = exports.apply = exports.getRing = exports.getSemiring = exports.getMonoid = exports.getSemigroup = exports.getBooleanAlgebra = void 0;\nexports.identity = identity;\nexports.constant = constant;\nexports.flip = flip;\nexports.flow = flow;\nexports.tuple = tuple;\nexports.increment = increment;\nexports.decrement = decrement;\nexports.absurd = absurd;\nexports.tupled = tupled;\nexports.untupled = untupled;\nexports.pipe = pipe;\nexports.not = not;\n// -------------------------------------------------------------------------------------\n// instances\n// -------------------------------------------------------------------------------------\n/**\n * @category instances\n * @since 2.10.0\n */\nvar getBooleanAlgebra = function (B) {\n    return function () { return ({\n        meet: function (x, y) { return function (a) { return B.meet(x(a), y(a)); }; },\n        join: function (x, y) { return function (a) { return B.join(x(a), y(a)); }; },\n        zero: function () { return B.zero; },\n        one: function () { return B.one; },\n        implies: function (x, y) { return function (a) { return B.implies(x(a), y(a)); }; },\n        not: function (x) { return function (a) { return B.not(x(a)); }; }\n    }); };\n};\nexports.getBooleanAlgebra = getBooleanAlgebra;\n/**\n * Unary functions form a semigroup as long as you can provide a semigroup for the codomain.\n *\n * @example\n * import { Predicate, getSemigroup } from 'fp-ts/function'\n * import * as B from 'fp-ts/boolean'\n *\n * const f: Predicate<number> = (n) => n <= 2\n * const g: Predicate<number> = (n) => n >= 0\n *\n * const S1 = getSemigroup(B.SemigroupAll)<number>()\n *\n * assert.deepStrictEqual(S1.concat(f, g)(1), true)\n * assert.deepStrictEqual(S1.concat(f, g)(3), false)\n *\n * const S2 = getSemigroup(B.SemigroupAny)<number>()\n *\n * assert.deepStrictEqual(S2.concat(f, g)(1), true)\n * assert.deepStrictEqual(S2.concat(f, g)(3), true)\n *\n * @category instances\n * @since 2.10.0\n */\nvar getSemigroup = function (S) {\n    return function () { return ({\n        concat: function (f, g) { return function (a) { return S.concat(f(a), g(a)); }; }\n    }); };\n};\nexports.getSemigroup = getSemigroup;\n/**\n * Unary functions form a monoid as long as you can provide a monoid for the codomain.\n *\n * @example\n * import { Predicate } from 'fp-ts/Predicate'\n * import { getMonoid } from 'fp-ts/function'\n * import * as B from 'fp-ts/boolean'\n *\n * const f: Predicate<number> = (n) => n <= 2\n * const g: Predicate<number> = (n) => n >= 0\n *\n * const M1 = getMonoid(B.MonoidAll)<number>()\n *\n * assert.deepStrictEqual(M1.concat(f, g)(1), true)\n * assert.deepStrictEqual(M1.concat(f, g)(3), false)\n *\n * const M2 = getMonoid(B.MonoidAny)<number>()\n *\n * assert.deepStrictEqual(M2.concat(f, g)(1), true)\n * assert.deepStrictEqual(M2.concat(f, g)(3), true)\n *\n * @category instances\n * @since 2.10.0\n */\nvar getMonoid = function (M) {\n    var getSemigroupM = (0, exports.getSemigroup)(M);\n    return function () { return ({\n        concat: getSemigroupM().concat,\n        empty: function () { return M.empty; }\n    }); };\n};\nexports.getMonoid = getMonoid;\n/**\n * @category instances\n * @since 2.10.0\n */\nvar getSemiring = function (S) { return ({\n    add: function (f, g) { return function (x) { return S.add(f(x), g(x)); }; },\n    zero: function () { return S.zero; },\n    mul: function (f, g) { return function (x) { return S.mul(f(x), g(x)); }; },\n    one: function () { return S.one; }\n}); };\nexports.getSemiring = getSemiring;\n/**\n * @category instances\n * @since 2.10.0\n */\nvar getRing = function (R) {\n    var S = (0, exports.getSemiring)(R);\n    return {\n        add: S.add,\n        mul: S.mul,\n        one: S.one,\n        zero: S.zero,\n        sub: function (f, g) { return function (x) { return R.sub(f(x), g(x)); }; }\n    };\n};\nexports.getRing = getRing;\n// -------------------------------------------------------------------------------------\n// utils\n// -------------------------------------------------------------------------------------\n/**\n * @since 2.11.0\n */\nvar apply = function (a) {\n    return function (f) {\n        return f(a);\n    };\n};\nexports.apply = apply;\n/**\n * @since 2.0.0\n */\nfunction identity(a) {\n    return a;\n}\n/**\n * @since 2.0.0\n */\nexports.unsafeCoerce = identity;\n/**\n * @since 2.0.0\n */\nfunction constant(a) {\n    return function () { return a; };\n}\n/**\n * A thunk that returns always `true`.\n *\n * @since 2.0.0\n */\nexports.constTrue = constant(true);\n/**\n * A thunk that returns always `false`.\n *\n * @since 2.0.0\n */\nexports.constFalse = constant(false);\n/**\n * A thunk that returns always `null`.\n *\n * @since 2.0.0\n */\nexports.constNull = constant(null);\n/**\n * A thunk that returns always `undefined`.\n *\n * @since 2.0.0\n */\nexports.constUndefined = constant(undefined);\n/**\n * A thunk that returns always `void`.\n *\n * @since 2.0.0\n */\nexports.constVoid = exports.constUndefined;\nfunction flip(f) {\n    return function () {\n        var args = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            args[_i] = arguments[_i];\n        }\n        if (args.length > 1) {\n            return f(args[1], args[0]);\n        }\n        return function (a) { return f(a)(args[0]); };\n    };\n}\nfunction flow(ab, bc, cd, de, ef, fg, gh, hi, ij) {\n    switch (arguments.length) {\n        case 1:\n            return ab;\n        case 2:\n            return function () {\n                return bc(ab.apply(this, arguments));\n            };\n        case 3:\n            return function () {\n                return cd(bc(ab.apply(this, arguments)));\n            };\n        case 4:\n            return function () {\n                return de(cd(bc(ab.apply(this, arguments))));\n            };\n        case 5:\n            return function () {\n                return ef(de(cd(bc(ab.apply(this, arguments)))));\n            };\n        case 6:\n            return function () {\n                return fg(ef(de(cd(bc(ab.apply(this, arguments))))));\n            };\n        case 7:\n            return function () {\n                return gh(fg(ef(de(cd(bc(ab.apply(this, arguments)))))));\n            };\n        case 8:\n            return function () {\n                return hi(gh(fg(ef(de(cd(bc(ab.apply(this, arguments))))))));\n            };\n        case 9:\n            return function () {\n                return ij(hi(gh(fg(ef(de(cd(bc(ab.apply(this, arguments)))))))));\n            };\n    }\n    return;\n}\n/**\n * @since 2.0.0\n */\nfunction tuple() {\n    var t = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        t[_i] = arguments[_i];\n    }\n    return t;\n}\n/**\n * @since 2.0.0\n */\nfunction increment(n) {\n    return n + 1;\n}\n/**\n * @since 2.0.0\n */\nfunction decrement(n) {\n    return n - 1;\n}\n/**\n * @since 2.0.0\n */\nfunction absurd(_) {\n    throw new Error('Called `absurd` function which should be uncallable');\n}\n/**\n * Creates a tupled version of this function: instead of `n` arguments, it accepts a single tuple argument.\n *\n * @example\n * import { tupled } from 'fp-ts/function'\n *\n * const add = tupled((x: number, y: number): number => x + y)\n *\n * assert.strictEqual(add([1, 2]), 3)\n *\n * @since 2.4.0\n */\nfunction tupled(f) {\n    return function (a) { return f.apply(void 0, a); };\n}\n/**\n * Inverse function of `tupled`\n *\n * @since 2.4.0\n */\nfunction untupled(f) {\n    return function () {\n        var a = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            a[_i] = arguments[_i];\n        }\n        return f(a);\n    };\n}\nfunction pipe(a, ab, bc, cd, de, ef, fg, gh, hi) {\n    switch (arguments.length) {\n        case 1:\n            return a;\n        case 2:\n            return ab(a);\n        case 3:\n            return bc(ab(a));\n        case 4:\n            return cd(bc(ab(a)));\n        case 5:\n            return de(cd(bc(ab(a))));\n        case 6:\n            return ef(de(cd(bc(ab(a)))));\n        case 7:\n            return fg(ef(de(cd(bc(ab(a))))));\n        case 8:\n            return gh(fg(ef(de(cd(bc(ab(a)))))));\n        case 9:\n            return hi(gh(fg(ef(de(cd(bc(ab(a))))))));\n        default: {\n            var ret = arguments[0];\n            for (var i = 1; i < arguments.length; i++) {\n                ret = arguments[i](ret);\n            }\n            return ret;\n        }\n    }\n}\n/**\n * Type hole simulation\n *\n * @since 2.7.0\n */\nexports.hole = absurd;\n/**\n * @since 2.11.0\n */\nvar SK = function (_, b) { return b; };\nexports.SK = SK;\n/**\n * Use `Predicate` module instead.\n *\n * @category zone of death\n * @since 2.0.0\n * @deprecated\n */\nfunction not(predicate) {\n    return function (a) { return !predicate(a); };\n}\n/**\n * Use `Endomorphism` module instead.\n *\n * @category zone of death\n * @since 2.10.0\n * @deprecated\n */\nvar getEndomorphismMonoid = function () { return ({\n    concat: function (first, second) { return flow(first, second); },\n    empty: identity\n}); };\nexports.getEndomorphismMonoid = getEndomorphismMonoid;\n/** @internal */\nvar dual = function (arity, body) {\n    var isDataFirst = typeof arity === 'number' ? function (args) { return args.length >= arity; } : arity;\n    return function () {\n        var args = Array.from(arguments);\n        if (isDataFirst(arguments)) {\n            return body.apply(this, args);\n        }\n        return function (self) { return body.apply(void 0, __spreadArray([self], args, false)); };\n    };\n};\nexports.dual = dual;\n","\"use strict\";\nvar __spreadArray = (this && this.__spreadArray) || function (to, from, pack) {\n    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {\n        if (ar || !(i in from)) {\n            if (!ar) ar = Array.prototype.slice.call(from, 0, i);\n            ar[i] = from[i];\n        }\n    }\n    return to.concat(ar || Array.prototype.slice.call(from));\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.flatMapReader = exports.flatMapTask = exports.flatMapIO = exports.flatMapEither = exports.flatMapOption = exports.flatMapNullable = exports.liftOption = exports.liftNullable = exports.fromReadonlyNonEmptyArray = exports.has = exports.emptyRecord = exports.emptyReadonlyArray = exports.tail = exports.head = exports.isNonEmpty = exports.singleton = exports.right = exports.left = exports.isRight = exports.isLeft = exports.some = exports.none = exports.isSome = exports.isNone = void 0;\nvar function_1 = require(\"./function\");\n// -------------------------------------------------------------------------------------\n// Option\n// -------------------------------------------------------------------------------------\n/** @internal */\nvar isNone = function (fa) { return fa._tag === 'None'; };\nexports.isNone = isNone;\n/** @internal */\nvar isSome = function (fa) { return fa._tag === 'Some'; };\nexports.isSome = isSome;\n/** @internal */\nexports.none = { _tag: 'None' };\n/** @internal */\nvar some = function (a) { return ({ _tag: 'Some', value: a }); };\nexports.some = some;\n// -------------------------------------------------------------------------------------\n// Either\n// -------------------------------------------------------------------------------------\n/** @internal */\nvar isLeft = function (ma) { return ma._tag === 'Left'; };\nexports.isLeft = isLeft;\n/** @internal */\nvar isRight = function (ma) { return ma._tag === 'Right'; };\nexports.isRight = isRight;\n/** @internal */\nvar left = function (e) { return ({ _tag: 'Left', left: e }); };\nexports.left = left;\n/** @internal */\nvar right = function (a) { return ({ _tag: 'Right', right: a }); };\nexports.right = right;\n// -------------------------------------------------------------------------------------\n// ReadonlyNonEmptyArray\n// -------------------------------------------------------------------------------------\n/** @internal */\nvar singleton = function (a) { return [a]; };\nexports.singleton = singleton;\n/** @internal */\nvar isNonEmpty = function (as) { return as.length > 0; };\nexports.isNonEmpty = isNonEmpty;\n/** @internal */\nvar head = function (as) { return as[0]; };\nexports.head = head;\n/** @internal */\nvar tail = function (as) { return as.slice(1); };\nexports.tail = tail;\n// -------------------------------------------------------------------------------------\n// empty\n// -------------------------------------------------------------------------------------\n/** @internal */\nexports.emptyReadonlyArray = [];\n/** @internal */\nexports.emptyRecord = {};\n// -------------------------------------------------------------------------------------\n// Record\n// -------------------------------------------------------------------------------------\n/** @internal */\nexports.has = Object.prototype.hasOwnProperty;\n// -------------------------------------------------------------------------------------\n// NonEmptyArray\n// -------------------------------------------------------------------------------------\n/** @internal */\nvar fromReadonlyNonEmptyArray = function (as) { return __spreadArray([as[0]], as.slice(1), true); };\nexports.fromReadonlyNonEmptyArray = fromReadonlyNonEmptyArray;\n/** @internal */\nvar liftNullable = function (F) {\n    return function (f, onNullable) {\n        return function () {\n            var a = [];\n            for (var _i = 0; _i < arguments.length; _i++) {\n                a[_i] = arguments[_i];\n            }\n            var o = f.apply(void 0, a);\n            return F.fromEither(o == null ? (0, exports.left)(onNullable.apply(void 0, a)) : (0, exports.right)(o));\n        };\n    };\n};\nexports.liftNullable = liftNullable;\n/** @internal */\nvar liftOption = function (F) {\n    return function (f, onNone) {\n        return function () {\n            var a = [];\n            for (var _i = 0; _i < arguments.length; _i++) {\n                a[_i] = arguments[_i];\n            }\n            var o = f.apply(void 0, a);\n            return F.fromEither((0, exports.isNone)(o) ? (0, exports.left)(onNone.apply(void 0, a)) : (0, exports.right)(o.value));\n        };\n    };\n};\nexports.liftOption = liftOption;\n/** @internal */\nvar flatMapNullable = function (F, M) {\n    return /*#__PURE__*/ (0, function_1.dual)(3, function (self, f, onNullable) {\n        return M.flatMap(self, (0, exports.liftNullable)(F)(f, onNullable));\n    });\n};\nexports.flatMapNullable = flatMapNullable;\n/** @internal */\nvar flatMapOption = function (F, M) {\n    return /*#__PURE__*/ (0, function_1.dual)(3, function (self, f, onNone) { return M.flatMap(self, (0, exports.liftOption)(F)(f, onNone)); });\n};\nexports.flatMapOption = flatMapOption;\n/** @internal */\nvar flatMapEither = function (F, M) {\n    return /*#__PURE__*/ (0, function_1.dual)(2, function (self, f) {\n        return M.flatMap(self, function (a) { return F.fromEither(f(a)); });\n    });\n};\nexports.flatMapEither = flatMapEither;\n/** @internal */\nvar flatMapIO = function (F, M) {\n    return /*#__PURE__*/ (0, function_1.dual)(2, function (self, f) {\n        return M.flatMap(self, function (a) { return F.fromIO(f(a)); });\n    });\n};\nexports.flatMapIO = flatMapIO;\n/** @internal */\nvar flatMapTask = function (F, M) {\n    return /*#__PURE__*/ (0, function_1.dual)(2, function (self, f) {\n        return M.flatMap(self, function (a) { return F.fromTask(f(a)); });\n    });\n};\nexports.flatMapTask = flatMapTask;\n/** @internal */\nvar flatMapReader = function (F, M) {\n    return /*#__PURE__*/ (0, function_1.dual)(2, function (self, f) {\n        return M.flatMap(self, function (a) { return F.fromReader(f(a)); });\n    });\n};\nexports.flatMapReader = flatMapReader;\n","\"use strict\";\nvar __assign = (this && this.__assign) || function () {\n    __assign = Object.assign || function(t) {\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\n            s = arguments[i];\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\n                t[p] = s[p];\n        }\n        return t;\n    };\n    return __assign.apply(this, arguments);\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.encode = encode;\nexports.decodeEntity = decodeEntity;\nexports.decode = decode;\nvar named_references_js_1 = require(\"./named-references.js\");\nvar numeric_unicode_map_js_1 = require(\"./numeric-unicode-map.js\");\nvar surrogate_pairs_js_1 = require(\"./surrogate-pairs.js\");\nvar allNamedReferences = __assign(__assign({}, named_references_js_1.namedReferences), { all: named_references_js_1.namedReferences.html5 });\nvar encodeRegExps = {\n    specialChars: /[<>'\"&]/g,\n    nonAscii: /[<>'\"&\\u0080-\\uD7FF\\uE000-\\uFFFF\\uDC00-\\uDFFF]|[\\uD800-\\uDBFF][\\uDC00-\\uDFFF]?/g,\n    nonAsciiPrintable: /[<>'\"&\\x01-\\x08\\x11-\\x15\\x17-\\x1F\\x7f-\\uD7FF\\uE000-\\uFFFF\\uDC00-\\uDFFF]|[\\uD800-\\uDBFF][\\uDC00-\\uDFFF]?/g,\n    nonAsciiPrintableOnly: /[\\x01-\\x08\\x11-\\x15\\x17-\\x1F\\x7f-\\uD7FF\\uE000-\\uFFFF\\uDC00-\\uDFFF]|[\\uD800-\\uDBFF][\\uDC00-\\uDFFF]?/g,\n    extensive: /[\\x01-\\x0c\\x0e-\\x1f\\x21-\\x2c\\x2e-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\x7d\\x7f-\\uD7FF\\uE000-\\uFFFF\\uDC00-\\uDFFF]|[\\uD800-\\uDBFF][\\uDC00-\\uDFFF]?/g\n};\nvar defaultEncodeOptions = {\n    mode: 'specialChars',\n    level: 'all',\n    numeric: 'decimal'\n};\n/** Encodes all the necessary (specified by `level`) characters in the text */\nfunction encode(text, _a) {\n    var _b = _a === void 0 ? defaultEncodeOptions : _a, _c = _b.mode, mode = _c === void 0 ? 'specialChars' : _c, _d = _b.numeric, numeric = _d === void 0 ? 'decimal' : _d, _e = _b.level, level = _e === void 0 ? 'all' : _e;\n    if (!text) {\n        return '';\n    }\n    var encodeRegExp = encodeRegExps[mode];\n    var references = allNamedReferences[level].characters;\n    var isHex = numeric === 'hexadecimal';\n    return String.prototype.replace.call(text, encodeRegExp, function (input) {\n        var result = references[input];\n        if (!result) {\n            var code = input.length > 1 ? (0, surrogate_pairs_js_1.getCodePoint)(input, 0) : input.charCodeAt(0);\n            result = (isHex ? '&#x' + code.toString(16) : '&#' + code) + ';';\n        }\n        return result;\n    });\n}\nvar defaultDecodeOptions = {\n    scope: 'body',\n    level: 'all'\n};\nvar strict = /&(?:#\\d+|#[xX][\\da-fA-F]+|[0-9a-zA-Z]+);/g;\nvar attribute = /&(?:#\\d+|#[xX][\\da-fA-F]+|[0-9a-zA-Z]+)[;=]?/g;\nvar baseDecodeRegExps = {\n    xml: {\n        strict: strict,\n        attribute: attribute,\n        body: named_references_js_1.bodyRegExps.xml\n    },\n    html4: {\n        strict: strict,\n        attribute: attribute,\n        body: named_references_js_1.bodyRegExps.html4\n    },\n    html5: {\n        strict: strict,\n        attribute: attribute,\n        body: named_references_js_1.bodyRegExps.html5\n    }\n};\nvar decodeRegExps = __assign(__assign({}, baseDecodeRegExps), { all: baseDecodeRegExps.html5 });\nvar fromCharCode = String.fromCharCode;\nvar outOfBoundsChar = fromCharCode(65533);\nvar defaultDecodeEntityOptions = {\n    level: 'all'\n};\nfunction getDecodedEntity(entity, references, isAttribute, isStrict) {\n    var decodeResult = entity;\n    var decodeEntityLastChar = entity[entity.length - 1];\n    if (isAttribute && decodeEntityLastChar === '=') {\n        decodeResult = entity;\n    }\n    else if (isStrict && decodeEntityLastChar !== ';') {\n        decodeResult = entity;\n    }\n    else {\n        var decodeResultByReference = references[entity];\n        if (decodeResultByReference) {\n            decodeResult = decodeResultByReference;\n        }\n        else if (entity[0] === '&' && entity[1] === '#') {\n            var decodeSecondChar = entity[2];\n            var decodeCode = decodeSecondChar == 'x' || decodeSecondChar == 'X'\n                ? parseInt(entity.substr(3), 16)\n                : parseInt(entity.substr(2));\n            decodeResult =\n                decodeCode >= 0x10ffff\n                    ? outOfBoundsChar\n                    : decodeCode > 65535\n                        ? (0, surrogate_pairs_js_1.fromCodePoint)(decodeCode)\n                        : fromCharCode(numeric_unicode_map_js_1.numericUnicodeMap[decodeCode] || decodeCode);\n        }\n    }\n    return decodeResult;\n}\n/** Decodes a single entity */\nfunction decodeEntity(entity, _a) {\n    var _b = _a === void 0 ? defaultDecodeEntityOptions : _a, _c = _b.level, level = _c === void 0 ? 'all' : _c;\n    if (!entity) {\n        return '';\n    }\n    return getDecodedEntity(entity, allNamedReferences[level].entities, false, false);\n}\n/** Decodes all entities in the text */\nfunction decode(text, _a) {\n    var _b = _a === void 0 ? defaultDecodeOptions : _a, _c = _b.level, level = _c === void 0 ? 'all' : _c, _d = _b.scope, scope = _d === void 0 ? level === 'xml' ? 'strict' : 'body' : _d;\n    if (!text) {\n        return '';\n    }\n    var decodeRegExp = decodeRegExps[level][scope];\n    var references = allNamedReferences[level].entities;\n    var isAttribute = scope === 'attribute';\n    var isStrict = scope === 'strict';\n    return text.replace(decodeRegExp, function (entity) { return getDecodedEntity(entity, references, isAttribute, isStrict); });\n}\n//# sourceMappingURL=index.js.map","\"use strict\";\nvar __assign = (this && this.__assign) || function () {\n    __assign = Object.assign || function(t) {\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\n            s = arguments[i];\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\n                t[p] = s[p];\n        }\n        return t;\n    };\n    return __assign.apply(this, arguments);\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.namedReferences = exports.bodyRegExps = void 0;\n// This file is autogenerated by tools/process-named-references.ts\nvar pairDivider = \"~\";\nvar blockDivider = \"~~\";\nfunction generateNamedReferences(input, prev) {\n    var entities = {};\n    var characters = {};\n    var blocks = input.split(blockDivider);\n    var isOptionalBlock = false;\n    for (var i = 0; blocks.length > i; i++) {\n        var entries = blocks[i].split(pairDivider);\n        for (var j = 0; j < entries.length; j += 2) {\n            var entity = entries[j];\n            var character = entries[j + 1];\n            var fullEntity = '&' + entity + ';';\n            entities[fullEntity] = character;\n            if (isOptionalBlock) {\n                entities['&' + entity] = character;\n            }\n            characters[character] = fullEntity;\n        }\n        isOptionalBlock = true;\n    }\n    return prev ?\n        { entities: __assign(__assign({}, entities), prev.entities), characters: __assign(__assign({}, characters), prev.characters) } :\n        { entities: entities, characters: characters };\n}\nexports.bodyRegExps = {\n    xml: /&(?:#\\d+|#[xX][\\da-fA-F]+|[0-9a-zA-Z]+);?/g,\n    html4: /&notin;|&(?:nbsp|iexcl|cent|pound|curren|yen|brvbar|sect|uml|copy|ordf|laquo|not|shy|reg|macr|deg|plusmn|sup2|sup3|acute|micro|para|middot|cedil|sup1|ordm|raquo|frac14|frac12|frac34|iquest|Agrave|Aacute|Acirc|Atilde|Auml|Aring|AElig|Ccedil|Egrave|Eacute|Ecirc|Euml|Igrave|Iacute|Icirc|Iuml|ETH|Ntilde|Ograve|Oacute|Ocirc|Otilde|Ouml|times|Oslash|Ugrave|Uacute|Ucirc|Uuml|Yacute|THORN|szlig|agrave|aacute|acirc|atilde|auml|aring|aelig|ccedil|egrave|eacute|ecirc|euml|igrave|iacute|icirc|iuml|eth|ntilde|ograve|oacute|ocirc|otilde|ouml|divide|oslash|ugrave|uacute|ucirc|uuml|yacute|thorn|yuml|quot|amp|lt|gt|#\\d+|#[xX][\\da-fA-F]+|[0-9a-zA-Z]+);?/g,\n    html5: /&centerdot;|&copysr;|&divideontimes;|&gtcc;|&gtcir;|&gtdot;|&gtlPar;|&gtquest;|&gtrapprox;|&gtrarr;|&gtrdot;|&gtreqless;|&gtreqqless;|&gtrless;|&gtrsim;|&ltcc;|&ltcir;|&ltdot;|&lthree;|&ltimes;|&ltlarr;|&ltquest;|&ltrPar;|&ltri;|&ltrie;|&ltrif;|&notin;|&notinE;|&notindot;|&notinva;|&notinvb;|&notinvc;|&notni;|&notniva;|&notnivb;|&notnivc;|&parallel;|&timesb;|&timesbar;|&timesd;|&(?:AElig|AMP|Aacute|Acirc|Agrave|Aring|Atilde|Auml|COPY|Ccedil|ETH|Eacute|Ecirc|Egrave|Euml|GT|Iacute|Icirc|Igrave|Iuml|LT|Ntilde|Oacute|Ocirc|Ograve|Oslash|Otilde|Ouml|QUOT|REG|THORN|Uacute|Ucirc|Ugrave|Uuml|Yacute|aacute|acirc|acute|aelig|agrave|amp|aring|atilde|auml|brvbar|ccedil|cedil|cent|copy|curren|deg|divide|eacute|ecirc|egrave|eth|euml|frac12|frac14|frac34|gt|iacute|icirc|iexcl|igrave|iquest|iuml|laquo|lt|macr|micro|middot|nbsp|not|ntilde|oacute|ocirc|ograve|ordf|ordm|oslash|otilde|ouml|para|plusmn|pound|quot|raquo|reg|sect|shy|sup1|sup2|sup3|szlig|thorn|times|uacute|ucirc|ugrave|uml|uuml|yacute|yen|yuml|#\\d+|#[xX][\\da-fA-F]+|[0-9a-zA-Z]+);?/g\n};\nexports.namedReferences = {};\nexports.namedReferences['xml'] = generateNamedReferences(\"lt~<~gt~>~quot~\\\"~apos~'~amp~&\");\nexports.namedReferences['html4'] = generateNamedReferences(\"apos~'~OElig~~oelig~~Scaron~~scaron~~Yuml~~circ~~tilde~~ensp~~emsp~~thinsp~~zwnj~~zwj~~lrm~~rlm~~ndash~~mdash~~lsquo~~rsquo~~sbquo~~ldquo~~rdquo~~bdquo~~dagger~~Dagger~~permil~~lsaquo~~rsaquo~~euro~~fnof~~Alpha~~Beta~~Gamma~~Delta~~Epsilon~~Zeta~~Eta~~Theta~~Iota~~Kappa~~Lambda~~Mu~~Nu~~Xi~~Omicron~~Pi~~Rho~~Sigma~~Tau~~Upsilon~~Phi~~Chi~~Psi~~Omega~~alpha~~beta~~gamma~~delta~~epsilon~~zeta~~eta~~theta~~iota~~kappa~~lambda~~mu~~nu~~xi~~omicron~~pi~~rho~~sigmaf~~sigma~~tau~~upsilon~~phi~~chi~~psi~~omega~~thetasym~~upsih~~piv~~bull~~hellip~~prime~~Prime~~oline~~frasl~~weierp~~image~~real~~trade~~alefsym~~larr~~uarr~~rarr~~darr~~harr~~crarr~~lArr~~uArr~~rArr~~dArr~~hArr~~forall~~part~~exist~~empty~~nabla~~isin~~notin~~ni~~prod~~sum~~minus~~lowast~~radic~~prop~~infin~~ang~~and~~or~~cap~~cup~~int~~there4~~sim~~cong~~asymp~~ne~~equiv~~le~~ge~~sub~~sup~~nsub~~sube~~supe~~oplus~~otimes~~perp~~sdot~~lceil~~rceil~~lfloor~~rfloor~~lang~~rang~~loz~~spades~~clubs~~hearts~~diams~~~nbsp~~iexcl~~cent~~pound~~curren~~yen~~brvbar~~sect~~uml~~copy~~ordf~~laquo~~not~~shy~~reg~~macr~~deg~~plusmn~~sup2~~sup3~~acute~~micro~~para~~middot~~cedil~~sup1~~ordm~~raquo~~frac14~~frac12~~frac34~~iquest~~Agrave~~Aacute~~Acirc~~Atilde~~Auml~~Aring~~AElig~~Ccedil~~Egrave~~Eacute~~Ecirc~~Euml~~Igrave~~Iacute~~Icirc~~Iuml~~ETH~~Ntilde~~Ograve~~Oacute~~Ocirc~~Otilde~~Ouml~~times~~Oslash~~Ugrave~~Uacute~~Ucirc~~Uuml~~Yacute~~THORN~~szlig~~agrave~~aacute~~acirc~~atilde~~auml~~aring~~aelig~~ccedil~~egrave~~eacute~~ecirc~~euml~~igrave~~iacute~~icirc~~iuml~~eth~~ntilde~~ograve~~oacute~~ocirc~~otilde~~ouml~~divide~~oslash~~ugrave~~uacute~~ucirc~~uuml~~yacute~~thorn~~yuml~~quot~\\\"~amp~&~lt~<~gt~>\");\nexports.namedReferences['html5'] = generateNamedReferences(\"Abreve~~Acy~~Afr~~Amacr~~And~~Aogon~~Aopf~~ApplyFunction~~Ascr~~Assign~~Backslash~~Barv~~Barwed~~Bcy~~Because~~Bernoullis~~Bfr~~Bopf~~Breve~~Bscr~~Bumpeq~~CHcy~~Cacute~~Cap~~CapitalDifferentialD~~Cayleys~~Ccaron~~Ccirc~~Cconint~~Cdot~~Cedilla~~CenterDot~~Cfr~~CircleDot~~CircleMinus~~CirclePlus~~CircleTimes~~ClockwiseContourIntegral~~CloseCurlyDoubleQuote~~CloseCurlyQuote~~Colon~~Colone~~Congruent~~Conint~~ContourIntegral~~Copf~~Coproduct~~CounterClockwiseContourIntegral~~Cross~~Cscr~~Cup~~CupCap~~DD~~DDotrahd~~DJcy~~DScy~~DZcy~~Darr~~Dashv~~Dcaron~~Dcy~~Del~~Dfr~~DiacriticalAcute~~DiacriticalDot~~DiacriticalDoubleAcute~~DiacriticalGrave~`~DiacriticalTilde~~Diamond~~DifferentialD~~Dopf~~Dot~~DotDot~~DotEqual~~DoubleContourIntegral~~DoubleDot~~DoubleDownArrow~~DoubleLeftArrow~~DoubleLeftRightArrow~~DoubleLeftTee~~DoubleLongLeftArrow~~DoubleLongLeftRightArrow~~DoubleLongRightArrow~~DoubleRightArrow~~DoubleRightTee~~DoubleUpArrow~~DoubleUpDownArrow~~DoubleVerticalBar~~DownArrow~~DownArrowBar~~DownArrowUpArrow~~DownBreve~~DownLeftRightVector~~DownLeftTeeVector~~DownLeftVector~~DownLeftVectorBar~~DownRightTeeVector~~DownRightVector~~DownRightVectorBar~~DownTee~~DownTeeArrow~~Downarrow~~Dscr~~Dstrok~~ENG~~Ecaron~~Ecy~~Edot~~Efr~~Element~~Emacr~~EmptySmallSquare~~EmptyVerySmallSquare~~Eogon~~Eopf~~Equal~~EqualTilde~~Equilibrium~~Escr~~Esim~~Exists~~ExponentialE~~Fcy~~Ffr~~FilledSmallSquare~~FilledVerySmallSquare~~Fopf~~ForAll~~Fouriertrf~~Fscr~~GJcy~~Gammad~~Gbreve~~Gcedil~~Gcirc~~Gcy~~Gdot~~Gfr~~Gg~~Gopf~~GreaterEqual~~GreaterEqualLess~~GreaterFullEqual~~GreaterGreater~~GreaterLess~~GreaterSlantEqual~~GreaterTilde~~Gscr~~Gt~~HARDcy~~Hacek~~Hat~^~Hcirc~~Hfr~~HilbertSpace~~Hopf~~HorizontalLine~~Hscr~~Hstrok~~HumpDownHump~~HumpEqual~~IEcy~~IJlig~~IOcy~~Icy~~Idot~~Ifr~~Im~~Imacr~~ImaginaryI~~Implies~~Int~~Integral~~Intersection~~InvisibleComma~~InvisibleTimes~~Iogon~~Iopf~~Iscr~~Itilde~~Iukcy~~Jcirc~~Jcy~~Jfr~~Jopf~~Jscr~~Jsercy~~Jukcy~~KHcy~~KJcy~~Kcedil~~Kcy~~Kfr~~Kopf~~Kscr~~LJcy~~Lacute~~Lang~~Laplacetrf~~Larr~~Lcaron~~Lcedil~~Lcy~~LeftAngleBracket~~LeftArrow~~LeftArrowBar~~LeftArrowRightArrow~~LeftCeiling~~LeftDoubleBracket~~LeftDownTeeVector~~LeftDownVector~~LeftDownVectorBar~~LeftFloor~~LeftRightArrow~~LeftRightVector~~LeftTee~~LeftTeeArrow~~LeftTeeVector~~LeftTriangle~~LeftTriangleBar~~LeftTriangleEqual~~LeftUpDownVector~~LeftUpTeeVector~~LeftUpVector~~LeftUpVectorBar~~LeftVector~~LeftVectorBar~~Leftarrow~~Leftrightarrow~~LessEqualGreater~~LessFullEqual~~LessGreater~~LessLess~~LessSlantEqual~~LessTilde~~Lfr~~Ll~~Lleftarrow~~Lmidot~~LongLeftArrow~~LongLeftRightArrow~~LongRightArrow~~Longleftarrow~~Longleftrightarrow~~Longrightarrow~~Lopf~~LowerLeftArrow~~LowerRightArrow~~Lscr~~Lsh~~Lstrok~~Lt~~Map~~Mcy~~MediumSpace~~Mellintrf~~Mfr~~MinusPlus~~Mopf~~Mscr~~NJcy~~Nacute~~Ncaron~~Ncedil~~Ncy~~NegativeMediumSpace~~NegativeThickSpace~~NegativeThinSpace~~NegativeVeryThinSpace~~NestedGreaterGreater~~NestedLessLess~~NewLine~\\n~Nfr~~NoBreak~~NonBreakingSpace~~Nopf~~Not~~NotCongruent~~NotCupCap~~NotDoubleVerticalBar~~NotElement~~NotEqual~~NotEqualTilde~~NotExists~~NotGreater~~NotGreaterEqual~~NotGreaterFullEqual~~NotGreaterGreater~~NotGreaterLess~~NotGreaterSlantEqual~~NotGreaterTilde~~NotHumpDownHump~~NotHumpEqual~~NotLeftTriangle~~NotLeftTriangleBar~~NotLeftTriangleEqual~~NotLess~~NotLessEqual~~NotLessGreater~~NotLessLess~~NotLessSlantEqual~~NotLessTilde~~NotNestedGreaterGreater~~NotNestedLessLess~~NotPrecedes~~NotPrecedesEqual~~NotPrecedesSlantEqual~~NotReverseElement~~NotRightTriangle~~NotRightTriangleBar~~NotRightTriangleEqual~~NotSquareSubset~~NotSquareSubsetEqual~~NotSquareSuperset~~NotSquareSupersetEqual~~NotSubset~~NotSubsetEqual~~NotSucceeds~~NotSucceedsEqual~~NotSucceedsSlantEqual~~NotSucceedsTilde~~NotSuperset~~NotSupersetEqual~~NotTilde~~NotTildeEqual~~NotTildeFullEqual~~NotTildeTilde~~NotVerticalBar~~Nscr~~Ocy~~Odblac~~Ofr~~Omacr~~Oopf~~OpenCurlyDoubleQuote~~OpenCurlyQuote~~Or~~Oscr~~Otimes~~OverBar~~OverBrace~~OverBracket~~OverParenthesis~~PartialD~~Pcy~~Pfr~~PlusMinus~~Poincareplane~~Popf~~Pr~~Precedes~~PrecedesEqual~~PrecedesSlantEqual~~PrecedesTilde~~Product~~Proportion~~Proportional~~Pscr~~Qfr~~Qopf~~Qscr~~RBarr~~Racute~~Rang~~Rarr~~Rarrtl~~Rcaron~~Rcedil~~Rcy~~Re~~ReverseElement~~ReverseEquilibrium~~ReverseUpEquilibrium~~Rfr~~RightAngleBracket~~RightArrow~~RightArrowBar~~RightArrowLeftArrow~~RightCeiling~~RightDoubleBracket~~RightDownTeeVector~~RightDownVector~~RightDownVectorBar~~RightFloor~~RightTee~~RightTeeArrow~~RightTeeVector~~RightTriangle~~RightTriangleBar~~RightTriangleEqual~~RightUpDownVector~~RightUpTeeVector~~RightUpVector~~RightUpVectorBar~~RightVector~~RightVectorBar~~Rightarrow~~Ropf~~RoundImplies~~Rrightarrow~~Rscr~~Rsh~~RuleDelayed~~SHCHcy~~SHcy~~SOFTcy~~Sacute~~Sc~~Scedil~~Scirc~~Scy~~Sfr~~ShortDownArrow~~ShortLeftArrow~~ShortRightArrow~~ShortUpArrow~~SmallCircle~~Sopf~~Sqrt~~Square~~SquareIntersection~~SquareSubset~~SquareSubsetEqual~~SquareSuperset~~SquareSupersetEqual~~SquareUnion~~Sscr~~Star~~Sub~~Subset~~SubsetEqual~~Succeeds~~SucceedsEqual~~SucceedsSlantEqual~~SucceedsTilde~~SuchThat~~Sum~~Sup~~Superset~~SupersetEqual~~Supset~~TRADE~~TSHcy~~TScy~~Tab~\\t~Tcaron~~Tcedil~~Tcy~~Tfr~~Therefore~~ThickSpace~~ThinSpace~~Tilde~~TildeEqual~~TildeFullEqual~~TildeTilde~~Topf~~TripleDot~~Tscr~~Tstrok~~Uarr~~Uarrocir~~Ubrcy~~Ubreve~~Ucy~~Udblac~~Ufr~~Umacr~~UnderBar~_~UnderBrace~~UnderBracket~~UnderParenthesis~~Union~~UnionPlus~~Uogon~~Uopf~~UpArrow~~UpArrowBar~~UpArrowDownArrow~~UpDownArrow~~UpEquilibrium~~UpTee~~UpTeeArrow~~Uparrow~~Updownarrow~~UpperLeftArrow~~UpperRightArrow~~Upsi~~Uring~~Uscr~~Utilde~~VDash~~Vbar~~Vcy~~Vdash~~Vdashl~~Vee~~Verbar~~Vert~~VerticalBar~~VerticalLine~|~VerticalSeparator~~VerticalTilde~~VeryThinSpace~~Vfr~~Vopf~~Vscr~~Vvdash~~Wcirc~~Wedge~~Wfr~~Wopf~~Wscr~~Xfr~~Xopf~~Xscr~~YAcy~~YIcy~~YUcy~~Ycirc~~Ycy~~Yfr~~Yopf~~Yscr~~ZHcy~~Zacute~~Zcaron~~Zcy~~Zdot~~ZeroWidthSpace~~Zfr~~Zopf~~Zscr~~abreve~~ac~~acE~~acd~~acy~~af~~afr~~aleph~~amacr~~amalg~~andand~~andd~~andslope~~andv~~ange~~angle~~angmsd~~angmsdaa~~angmsdab~~angmsdac~~angmsdad~~angmsdae~~angmsdaf~~angmsdag~~angmsdah~~angrt~~angrtvb~~angrtvbd~~angsph~~angst~~angzarr~~aogon~~aopf~~ap~~apE~~apacir~~ape~~apid~~approx~~approxeq~~ascr~~ast~*~asympeq~~awconint~~awint~~bNot~~backcong~~backepsilon~~backprime~~backsim~~backsimeq~~barvee~~barwed~~barwedge~~bbrk~~bbrktbrk~~bcong~~bcy~~becaus~~because~~bemptyv~~bepsi~~bernou~~beth~~between~~bfr~~bigcap~~bigcirc~~bigcup~~bigodot~~bigoplus~~bigotimes~~bigsqcup~~bigstar~~bigtriangledown~~bigtriangleup~~biguplus~~bigvee~~bigwedge~~bkarow~~blacklozenge~~blacksquare~~blacktriangle~~blacktriangledown~~blacktriangleleft~~blacktriangleright~~blank~~blk12~~blk14~~blk34~~block~~bne~=~bnequiv~~bnot~~bopf~~bot~~bottom~~bowtie~~boxDL~~boxDR~~boxDl~~boxDr~~boxH~~boxHD~~boxHU~~boxHd~~boxHu~~boxUL~~boxUR~~boxUl~~boxUr~~boxV~~boxVH~~boxVL~~boxVR~~boxVh~~boxVl~~boxVr~~boxbox~~boxdL~~boxdR~~boxdl~~boxdr~~boxh~~boxhD~~boxhU~~boxhd~~boxhu~~boxminus~~boxplus~~boxtimes~~boxuL~~boxuR~~boxul~~boxur~~boxv~~boxvH~~boxvL~~boxvR~~boxvh~~boxvl~~boxvr~~bprime~~breve~~bscr~~bsemi~~bsim~~bsime~~bsol~\\\\~bsolb~~bsolhsub~~bullet~~bump~~bumpE~~bumpe~~bumpeq~~cacute~~capand~~capbrcup~~capcap~~capcup~~capdot~~caps~~caret~~caron~~ccaps~~ccaron~~ccirc~~ccups~~ccupssm~~cdot~~cemptyv~~centerdot~~cfr~~chcy~~check~~checkmark~~cir~~cirE~~circeq~~circlearrowleft~~circlearrowright~~circledR~~circledS~~circledast~~circledcirc~~circleddash~~cire~~cirfnint~~cirmid~~cirscir~~clubsuit~~colon~:~colone~~coloneq~~comma~,~commat~@~comp~~compfn~~complement~~complexes~~congdot~~conint~~copf~~coprod~~copysr~~cross~~cscr~~csub~~csube~~csup~~csupe~~ctdot~~cudarrl~~cudarrr~~cuepr~~cuesc~~cularr~~cularrp~~cupbrcap~~cupcap~~cupcup~~cupdot~~cupor~~cups~~curarr~~curarrm~~curlyeqprec~~curlyeqsucc~~curlyvee~~curlywedge~~curvearrowleft~~curvearrowright~~cuvee~~cuwed~~cwconint~~cwint~~cylcty~~dHar~~daleth~~dash~~dashv~~dbkarow~~dblac~~dcaron~~dcy~~dd~~ddagger~~ddarr~~ddotseq~~demptyv~~dfisht~~dfr~~dharl~~dharr~~diam~~diamond~~diamondsuit~~die~~digamma~~disin~~div~~divideontimes~~divonx~~djcy~~dlcorn~~dlcrop~~dollar~$~dopf~~dot~~doteq~~doteqdot~~dotminus~~dotplus~~dotsquare~~doublebarwedge~~downarrow~~downdownarrows~~downharpoonleft~~downharpoonright~~drbkarow~~drcorn~~drcrop~~dscr~~dscy~~dsol~~dstrok~~dtdot~~dtri~~dtrif~~duarr~~duhar~~dwangle~~dzcy~~dzigrarr~~eDDot~~eDot~~easter~~ecaron~~ecir~~ecolon~~ecy~~edot~~ee~~efDot~~efr~~eg~~egs~~egsdot~~el~~elinters~~ell~~els~~elsdot~~emacr~~emptyset~~emptyv~~emsp13~~emsp14~~eng~~eogon~~eopf~~epar~~eparsl~~eplus~~epsi~~epsiv~~eqcirc~~eqcolon~~eqsim~~eqslantgtr~~eqslantless~~equals~=~equest~~equivDD~~eqvparsl~~erDot~~erarr~~escr~~esdot~~esim~~excl~!~expectation~~exponentiale~~fallingdotseq~~fcy~~female~~ffilig~~fflig~~ffllig~~ffr~~filig~~fjlig~fj~flat~~fllig~~fltns~~fopf~~fork~~forkv~~fpartint~~frac13~~frac15~~frac16~~frac18~~frac23~~frac25~~frac35~~frac38~~frac45~~frac56~~frac58~~frac78~~frown~~fscr~~gE~~gEl~~gacute~~gammad~~gap~~gbreve~~gcirc~~gcy~~gdot~~gel~~geq~~geqq~~geqslant~~ges~~gescc~~gesdot~~gesdoto~~gesdotol~~gesl~~gesles~~gfr~~gg~~ggg~~gimel~~gjcy~~gl~~glE~~gla~~glj~~gnE~~gnap~~gnapprox~~gne~~gneq~~gneqq~~gnsim~~gopf~~grave~`~gscr~~gsim~~gsime~~gsiml~~gtcc~~gtcir~~gtdot~~gtlPar~~gtquest~~gtrapprox~~gtrarr~~gtrdot~~gtreqless~~gtreqqless~~gtrless~~gtrsim~~gvertneqq~~gvnE~~hairsp~~half~~hamilt~~hardcy~~harrcir~~harrw~~hbar~~hcirc~~heartsuit~~hercon~~hfr~~hksearow~~hkswarow~~hoarr~~homtht~~hookleftarrow~~hookrightarrow~~hopf~~horbar~~hscr~~hslash~~hstrok~~hybull~~hyphen~~ic~~icy~~iecy~~iff~~ifr~~ii~~iiiint~~iiint~~iinfin~~iiota~~ijlig~~imacr~~imagline~~imagpart~~imath~~imof~~imped~~in~~incare~~infintie~~inodot~~intcal~~integers~~intercal~~intlarhk~~intprod~~iocy~~iogon~~iopf~~iprod~~iscr~~isinE~~isindot~~isins~~isinsv~~isinv~~it~~itilde~~iukcy~~jcirc~~jcy~~jfr~~jmath~~jopf~~jscr~~jsercy~~jukcy~~kappav~~kcedil~~kcy~~kfr~~kgreen~~khcy~~kjcy~~kopf~~kscr~~lAarr~~lAtail~~lBarr~~lE~~lEg~~lHar~~lacute~~laemptyv~~lagran~~langd~~langle~~lap~~larrb~~larrbfs~~larrfs~~larrhk~~larrlp~~larrpl~~larrsim~~larrtl~~lat~~latail~~late~~lates~~lbarr~~lbbrk~~lbrace~{~lbrack~[~lbrke~~lbrksld~~lbrkslu~~lcaron~~lcedil~~lcub~{~lcy~~ldca~~ldquor~~ldrdhar~~ldrushar~~ldsh~~leftarrow~~leftarrowtail~~leftharpoondown~~leftharpoonup~~leftleftarrows~~leftrightarrow~~leftrightarrows~~leftrightharpoons~~leftrightsquigarrow~~leftthreetimes~~leg~~leq~~leqq~~leqslant~~les~~lescc~~lesdot~~lesdoto~~lesdotor~~lesg~~lesges~~lessapprox~~lessdot~~lesseqgtr~~lesseqqgtr~~lessgtr~~lesssim~~lfisht~~lfr~~lg~~lgE~~lhard~~lharu~~lharul~~lhblk~~ljcy~~ll~~llarr~~llcorner~~llhard~~lltri~~lmidot~~lmoust~~lmoustache~~lnE~~lnap~~lnapprox~~lne~~lneq~~lneqq~~lnsim~~loang~~loarr~~lobrk~~longleftarrow~~longleftrightarrow~~longmapsto~~longrightarrow~~looparrowleft~~looparrowright~~lopar~~lopf~~loplus~~lotimes~~lowbar~_~lozenge~~lozf~~lpar~(~lparlt~~lrarr~~lrcorner~~lrhar~~lrhard~~lrtri~~lscr~~lsh~~lsim~~lsime~~lsimg~~lsqb~[~lsquor~~lstrok~~ltcc~~ltcir~~ltdot~~lthree~~ltimes~~ltlarr~~ltquest~~ltrPar~~ltri~~ltrie~~ltrif~~lurdshar~~luruhar~~lvertneqq~~lvnE~~mDDot~~male~~malt~~maltese~~map~~mapsto~~mapstodown~~mapstoleft~~mapstoup~~marker~~mcomma~~mcy~~measuredangle~~mfr~~mho~~mid~~midast~*~midcir~~minusb~~minusd~~minusdu~~mlcp~~mldr~~mnplus~~models~~mopf~~mp~~mscr~~mstpos~~multimap~~mumap~~nGg~~nGt~~nGtv~~nLeftarrow~~nLeftrightarrow~~nLl~~nLt~~nLtv~~nRightarrow~~nVDash~~nVdash~~nacute~~nang~~nap~~napE~~napid~~napos~~napprox~~natur~~natural~~naturals~~nbump~~nbumpe~~ncap~~ncaron~~ncedil~~ncong~~ncongdot~~ncup~~ncy~~neArr~~nearhk~~nearr~~nearrow~~nedot~~nequiv~~nesear~~nesim~~nexist~~nexists~~nfr~~ngE~~nge~~ngeq~~ngeqq~~ngeqslant~~nges~~ngsim~~ngt~~ngtr~~nhArr~~nharr~~nhpar~~nis~~nisd~~niv~~njcy~~nlArr~~nlE~~nlarr~~nldr~~nle~~nleftarrow~~nleftrightarrow~~nleq~~nleqq~~nleqslant~~nles~~nless~~nlsim~~nlt~~nltri~~nltrie~~nmid~~nopf~~notinE~~notindot~~notinva~~notinvb~~notinvc~~notni~~notniva~~notnivb~~notnivc~~npar~~nparallel~~nparsl~~npart~~npolint~~npr~~nprcue~~npre~~nprec~~npreceq~~nrArr~~nrarr~~nrarrc~~nrarrw~~nrightarrow~~nrtri~~nrtrie~~nsc~~nsccue~~nsce~~nscr~~nshortmid~~nshortparallel~~nsim~~nsime~~nsimeq~~nsmid~~nspar~~nsqsube~~nsqsupe~~nsubE~~nsube~~nsubset~~nsubseteq~~nsubseteqq~~nsucc~~nsucceq~~nsup~~nsupE~~nsupe~~nsupset~~nsupseteq~~nsupseteqq~~ntgl~~ntlg~~ntriangleleft~~ntrianglelefteq~~ntriangleright~~ntrianglerighteq~~num~#~numero~~numsp~~nvDash~~nvHarr~~nvap~~nvdash~~nvge~~nvgt~>~nvinfin~~nvlArr~~nvle~~nvlt~<~nvltrie~~nvrArr~~nvrtrie~~nvsim~~nwArr~~nwarhk~~nwarr~~nwarrow~~nwnear~~oS~~oast~~ocir~~ocy~~odash~~odblac~~odiv~~odot~~odsold~~ofcir~~ofr~~ogon~~ogt~~ohbar~~ohm~~oint~~olarr~~olcir~~olcross~~olt~~omacr~~omid~~ominus~~oopf~~opar~~operp~~orarr~~ord~~order~~orderof~~origof~~oror~~orslope~~orv~~oscr~~osol~~otimesas~~ovbar~~par~~parallel~~parsim~~parsl~~pcy~~percnt~%~period~.~pertenk~~pfr~~phiv~~phmmat~~phone~~pitchfork~~planck~~planckh~~plankv~~plus~+~plusacir~~plusb~~pluscir~~plusdo~~plusdu~~pluse~~plussim~~plustwo~~pm~~pointint~~popf~~pr~~prE~~prap~~prcue~~pre~~prec~~precapprox~~preccurlyeq~~preceq~~precnapprox~~precneqq~~precnsim~~precsim~~primes~~prnE~~prnap~~prnsim~~profalar~~profline~~profsurf~~propto~~prsim~~prurel~~pscr~~puncsp~~qfr~~qint~~qopf~~qprime~~qscr~~quaternions~~quatint~~quest~?~questeq~~rAarr~~rAtail~~rBarr~~rHar~~race~~racute~~raemptyv~~rangd~~range~~rangle~~rarrap~~rarrb~~rarrbfs~~rarrc~~rarrfs~~rarrhk~~rarrlp~~rarrpl~~rarrsim~~rarrtl~~rarrw~~ratail~~ratio~~rationals~~rbarr~~rbbrk~~rbrace~}~rbrack~]~rbrke~~rbrksld~~rbrkslu~~rcaron~~rcedil~~rcub~}~rcy~~rdca~~rdldhar~~rdquor~~rdsh~~realine~~realpart~~reals~~rect~~rfisht~~rfr~~rhard~~rharu~~rharul~~rhov~~rightarrow~~rightarrowtail~~rightharpoondown~~rightharpoonup~~rightleftarrows~~rightleftharpoons~~rightrightarrows~~rightsquigarrow~~rightthreetimes~~ring~~risingdotseq~~rlarr~~rlhar~~rmoust~~rmoustache~~rnmid~~roang~~roarr~~robrk~~ropar~~ropf~~roplus~~rotimes~~rpar~)~rpargt~~rppolint~~rrarr~~rscr~~rsh~~rsqb~]~rsquor~~rthree~~rtimes~~rtri~~rtrie~~rtrif~~rtriltri~~ruluhar~~rx~~sacute~~sc~~scE~~scap~~sccue~~sce~~scedil~~scirc~~scnE~~scnap~~scnsim~~scpolint~~scsim~~scy~~sdotb~~sdote~~seArr~~searhk~~searr~~searrow~~semi~;~seswar~~setminus~~setmn~~sext~~sfr~~sfrown~~sharp~~shchcy~~shcy~~shortmid~~shortparallel~~sigmav~~simdot~~sime~~simeq~~simg~~simgE~~siml~~simlE~~simne~~simplus~~simrarr~~slarr~~smallsetminus~~smashp~~smeparsl~~smid~~smile~~smt~~smte~~smtes~~softcy~~sol~/~solb~~solbar~~sopf~~spadesuit~~spar~~sqcap~~sqcaps~~sqcup~~sqcups~~sqsub~~sqsube~~sqsubset~~sqsubseteq~~sqsup~~sqsupe~~sqsupset~~sqsupseteq~~squ~~square~~squarf~~squf~~srarr~~sscr~~ssetmn~~ssmile~~sstarf~~star~~starf~~straightepsilon~~straightphi~~strns~~subE~~subdot~~subedot~~submult~~subnE~~subne~~subplus~~subrarr~~subset~~subseteq~~subseteqq~~subsetneq~~subsetneqq~~subsim~~subsub~~subsup~~succ~~succapprox~~succcurlyeq~~succeq~~succnapprox~~succneqq~~succnsim~~succsim~~sung~~supE~~supdot~~supdsub~~supedot~~suphsol~~suphsub~~suplarr~~supmult~~supnE~~supne~~supplus~~supset~~supseteq~~supseteqq~~supsetneq~~supsetneqq~~supsim~~supsub~~supsup~~swArr~~swarhk~~swarr~~swarrow~~swnwar~~target~~tbrk~~tcaron~~tcedil~~tcy~~tdot~~telrec~~tfr~~therefore~~thetav~~thickapprox~~thicksim~~thkap~~thksim~~timesb~~timesbar~~timesd~~tint~~toea~~top~~topbot~~topcir~~topf~~topfork~~tosa~~tprime~~triangle~~triangledown~~triangleleft~~trianglelefteq~~triangleq~~triangleright~~trianglerighteq~~tridot~~trie~~triminus~~triplus~~trisb~~tritime~~trpezium~~tscr~~tscy~~tshcy~~tstrok~~twixt~~twoheadleftarrow~~twoheadrightarrow~~uHar~~ubrcy~~ubreve~~ucy~~udarr~~udblac~~udhar~~ufisht~~ufr~~uharl~~uharr~~uhblk~~ulcorn~~ulcorner~~ulcrop~~ultri~~umacr~~uogon~~uopf~~uparrow~~updownarrow~~upharpoonleft~~upharpoonright~~uplus~~upsi~~upuparrows~~urcorn~~urcorner~~urcrop~~uring~~urtri~~uscr~~utdot~~utilde~~utri~~utrif~~uuarr~~uwangle~~vArr~~vBar~~vBarv~~vDash~~vangrt~~varepsilon~~varkappa~~varnothing~~varphi~~varpi~~varpropto~~varr~~varrho~~varsigma~~varsubsetneq~~varsubsetneqq~~varsupsetneq~~varsupsetneqq~~vartheta~~vartriangleleft~~vartriangleright~~vcy~~vdash~~vee~~veebar~~veeeq~~vellip~~verbar~|~vert~|~vfr~~vltri~~vnsub~~vnsup~~vopf~~vprop~~vrtri~~vscr~~vsubnE~~vsubne~~vsupnE~~vsupne~~vzigzag~~wcirc~~wedbar~~wedge~~wedgeq~~wfr~~wopf~~wp~~wr~~wreath~~wscr~~xcap~~xcirc~~xcup~~xdtri~~xfr~~xhArr~~xharr~~xlArr~~xlarr~~xmap~~xnis~~xodot~~xopf~~xoplus~~xotime~~xrArr~~xrarr~~xscr~~xsqcup~~xuplus~~xutri~~xvee~~xwedge~~yacy~~ycirc~~ycy~~yfr~~yicy~~yopf~~yscr~~yucy~~zacute~~zcaron~~zcy~~zdot~~zeetrf~~zfr~~zhcy~~zigrarr~~zopf~~zscr~~~AMP~&~COPY~~GT~>~LT~<~QUOT~\\\"~REG~\", exports.namedReferences['html4']);\n//# sourceMappingURL=named-references.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.numericUnicodeMap = void 0;\nexports.numericUnicodeMap = {\n    0: 65533,\n    128: 8364,\n    130: 8218,\n    131: 402,\n    132: 8222,\n    133: 8230,\n    134: 8224,\n    135: 8225,\n    136: 710,\n    137: 8240,\n    138: 352,\n    139: 8249,\n    140: 338,\n    142: 381,\n    145: 8216,\n    146: 8217,\n    147: 8220,\n    148: 8221,\n    149: 8226,\n    150: 8211,\n    151: 8212,\n    152: 732,\n    153: 8482,\n    154: 353,\n    155: 8250,\n    156: 339,\n    158: 382,\n    159: 376\n};\n//# sourceMappingURL=numeric-unicode-map.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.highSurrogateTo = exports.highSurrogateFrom = exports.getCodePoint = exports.fromCodePoint = void 0;\nexports.fromCodePoint = String.fromCodePoint ||\n    function (astralCodePoint) {\n        return String.fromCharCode(Math.floor((astralCodePoint - 0x10000) / 0x400) + 0xd800, ((astralCodePoint - 0x10000) % 0x400) + 0xdc00);\n    };\n// @ts-expect-error - String.prototype.codePointAt might not exist in older node versions\nexports.getCodePoint = String.prototype.codePointAt\n    ? function (input, position) {\n        return input.codePointAt(position);\n    }\n    : function (input, position) {\n        return (input.charCodeAt(position) - 0xd800) * 0x400 + input.charCodeAt(position + 1) - 0xdc00 + 0x10000;\n    };\nexports.highSurrogateFrom = 0xd800;\nexports.highSurrogateTo = 0xdbff;\n//# sourceMappingURL=surrogate-pairs.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.reporter = exports.formatValidationErrors = exports.formatValidationError = exports.TYPE_MAX_LEN = void 0;\n/**\n * An [io-ts Reporter](https://gcanti.github.io/io-ts/modules/Reporter.ts.html#reporter-interface).\n *\n * @example\n *\n * import * as t from 'io-ts';\n * import Reporter from 'io-ts-reporters';\n *\n * const User = t.interface({ name: t.string });\n *\n * assert.deepEqual(\n *   Reporter.report(User.decode({ nam: 'Jane' })),\n *   ['Expecting string at name but instead got: undefined'],\n * )\n * assert.deepEqual( Reporter.report(User.decode({ name: 'Jane' })), [])\n *\n * @since 1.2.0\n */\nvar A = require(\"fp-ts/Array\");\nvar E = require(\"fp-ts/Either\");\nvar NEA = require(\"fp-ts/NonEmptyArray\");\nvar O = require(\"fp-ts/Option\");\nvar R = require(\"fp-ts/Record\");\nvar pipeable_1 = require(\"fp-ts/pipeable\");\nvar t = require(\"io-ts\");\nvar utils_1 = require(\"./utils\");\nvar isUnionType = function (_a) {\n    var type = _a.type;\n    return type instanceof t.UnionType;\n};\nvar jsToString = function (value) {\n    return value === undefined ? 'undefined' : JSON.stringify(value);\n};\nvar keyPath = function (ctx) {\n    // The context entry with an empty key is the original\n    // type (\"default context\"), not a type error.\n    return ctx\n        .map(function (c) { return c.key; })\n        .filter(Boolean)\n        .join('.');\n};\n// The actual error is last in context\nvar getErrorFromCtx = function (validation) {\n    // https://github.com/gcanti/fp-ts/pull/544/files\n    return A.last(validation.context);\n};\nvar getValidationContext = function (validation) {\n    // https://github.com/gcanti/fp-ts/pull/544/files\n    return validation.context;\n};\n/**\n * @category internals\n * @since 1.2.1\n */\nexports.TYPE_MAX_LEN = 160; // Two lines of 80-col text\nvar truncateType = function (type, options) {\n    if (options === void 0) { options = {}; }\n    var _a = options.truncateLongTypes, truncateLongTypes = _a === void 0 ? true : _a;\n    if (truncateLongTypes && type.length > exports.TYPE_MAX_LEN) {\n        return type.slice(0, exports.TYPE_MAX_LEN - 3) + \"...\";\n    }\n    return type;\n};\nvar errorMessageSimple = function (expectedType, path, error, options) {\n    // https://github.com/elm-lang/core/blob/18c9e84e975ed22649888bfad15d1efdb0128ab2/src/Native/Json.js#L199\n    return [\n        \"Expecting \" + truncateType(expectedType, options),\n        path === '' ? '' : \"at \" + path,\n        \"but instead got: \" + jsToString(error.value),\n        error.message ? \"(\" + error.message + \")\" : '',\n    ]\n        .filter(Boolean)\n        .join(' ');\n};\nvar errorMessageUnion = function (expectedTypes, path, value, options) {\n    // https://github.com/elm-lang/core/blob/18c9e84e975ed22649888bfad15d1efdb0128ab2/src/Native/Json.js#L199\n    return [\n        'Expecting one of:\\n',\n        expectedTypes\n            .map(function (type) { return \"    \" + truncateType(type, options); })\n            .join('\\n'),\n        path === '' ? '\\n' : \"\\nat \" + path + \" \",\n        \"but instead got: \" + jsToString(value),\n    ]\n        .filter(Boolean)\n        .join('');\n};\n// Find the union type in the list of ContextEntry\n// The next ContextEntry should be the type of this branch of the union\nvar findExpectedType = function (ctx) {\n    return pipeable_1.pipe(ctx, A.findIndex(isUnionType), O.chain(function (n) { return A.lookup(n + 1, ctx); }));\n};\nvar formatValidationErrorOfUnion = function (path, errors, options) {\n    var expectedTypes = pipeable_1.pipe(errors, A.map(getValidationContext), A.map(findExpectedType), A.compact);\n    var value = pipeable_1.pipe(expectedTypes, A.head, O.map(function (v) { return v.actual; }), O.getOrElse(function () { return undefined; }));\n    var expected = expectedTypes.map(function (_a) {\n        var type = _a.type;\n        return type.name;\n    });\n    return expected.length > 0\n        ? O.some(errorMessageUnion(expected, path, value, options))\n        : O.none;\n};\nvar formatValidationCommonError = function (path, error, options) {\n    return pipeable_1.pipe(error, getErrorFromCtx, O.map(function (errorContext) {\n        return errorMessageSimple(errorContext.type.name, path, error, options);\n    }));\n};\nvar groupByKey = NEA.groupBy(function (error) {\n    return pipeable_1.pipe(error.context, utils_1.takeUntil(isUnionType), keyPath);\n});\nvar format = function (path, errors, options) {\n    return NEA.tail(errors).length > 0\n        ? formatValidationErrorOfUnion(path, errors, options)\n        : formatValidationCommonError(path, NEA.head(errors), options);\n};\n/**\n * Format a single validation error.\n *\n * @category formatters\n * @since 1.0.0\n */\nvar formatValidationError = function (error, options) { return formatValidationCommonError(keyPath(error.context), error, options); };\nexports.formatValidationError = formatValidationError;\n/**\n * Format validation errors (`t.Errors`).\n *\n * @example\n * import * as E from 'fp-ts/Either'\n * import * as t from 'io-ts'\n * import { formatValidationErrors } from 'io-ts-reporters'\n *\n * const result = t.string.decode(123)\n *\n * assert.deepEqual(\n *   E.mapLeft(formatValidationErrors)(result),\n *   E.left(['Expecting string but instead got: 123'])\n * )\n *\n * @category formatters\n * @since 1.2.0\n */\nvar formatValidationErrors = function (errors, options) {\n    return pipeable_1.pipe(errors, groupByKey, R.mapWithIndex(function (path, errors) { return format(path, errors, options); }), R.compact, R.toArray, A.map(function (_a) {\n        var _key = _a[0], error = _a[1];\n        return error;\n    }));\n};\nexports.formatValidationErrors = formatValidationErrors;\n/**\n * Deprecated, use the default export instead.\n *\n * @category deprecated\n * @deprecated\n * @since 1.0.0\n */\nvar reporter = function (validation, options) {\n    return pipeable_1.pipe(validation, E.mapLeft(function (errors) { return exports.formatValidationErrors(errors, options); }), E.fold(function (errors) { return errors; }, function () { return []; }));\n};\nexports.reporter = reporter;\nvar prettyReporter = { report: exports.reporter };\nexports.default = prettyReporter;\n//# sourceMappingURL=index.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.takeUntil = void 0;\n/**\n * @since 1.1.0\n */\n/* eslint-disable @typescript-eslint/array-type */\nvar takeUntil = function (predicate) {\n    return function (as) {\n        var init = [];\n        // eslint-disable-next-line unicorn/no-for-loop\n        for (var i = 0; i < as.length; i++) {\n            init[i] = as[i];\n            if (predicate(as[i])) {\n                return init;\n            }\n        }\n        return init;\n    };\n};\nexports.takeUntil = takeUntil;\n/* eslint-enable @typescript-eslint/array-type */\n//# sourceMappingURL=utils.js.map","var __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        if (typeof b !== \"function\" && b !== null)\n            throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar __assign = (this && this.__assign) || function () {\n    __assign = Object.assign || function(t) {\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\n            s = arguments[i];\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\n                t[p] = s[p];\n        }\n        return t;\n    };\n    return __assign.apply(this, arguments);\n};\nvar __spreadArray = (this && this.__spreadArray) || function (to, from, pack) {\n    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {\n        if (ar || !(i in from)) {\n            if (!ar) ar = Array.prototype.slice.call(from, 0, i);\n            ar[i] = from[i];\n        }\n    }\n    return to.concat(ar || Array.prototype.slice.call(from));\n};\n/**\n * @since 1.0.0\n */\nimport { isLeft, left, right } from 'fp-ts/es6/Either';\n/**\n * @category Decode error\n * @since 1.0.0\n */\nexport var failures = left;\n/**\n * @category Decode error\n * @since 1.0.0\n */\nexport var failure = function (value, context, message) {\n    return failures([{ value: value, context: context, message: message }]);\n};\n/**\n * @category Decode error\n * @since 1.0.0\n */\nexport var success = right;\n/**\n * @category Codec\n * @since 1.0.0\n */\nvar Type = /** @class */ (function () {\n    function Type(\n    /** a unique name for this codec */\n    name, \n    /** a custom type guard */\n    is, \n    /** succeeds if a value of type I can be decoded to a value of type A */\n    validate, \n    /** converts a value of type A to a value of type O */\n    encode) {\n        this.name = name;\n        this.is = is;\n        this.validate = validate;\n        this.encode = encode;\n        this.decode = this.decode.bind(this);\n    }\n    /**\n     * @since 1.0.0\n     */\n    Type.prototype.pipe = function (ab, name) {\n        var _this = this;\n        if (name === void 0) { name = \"pipe(\".concat(this.name, \", \").concat(ab.name, \")\"); }\n        return new Type(name, ab.is, function (i, c) {\n            var e = _this.validate(i, c);\n            if (isLeft(e)) {\n                return e;\n            }\n            return ab.validate(e.right, c);\n        }, this.encode === identity && ab.encode === identity ? identity : function (b) { return _this.encode(ab.encode(b)); });\n    };\n    /**\n     * @since 1.0.0\n     */\n    Type.prototype.asDecoder = function () {\n        return this;\n    };\n    /**\n     * @since 1.0.0\n     */\n    Type.prototype.asEncoder = function () {\n        return this;\n    };\n    /**\n     * a version of `validate` with a default context\n     * @since 1.0.0\n     */\n    Type.prototype.decode = function (i) {\n        return this.validate(i, [{ key: '', type: this, actual: i }]);\n    };\n    return Type;\n}());\nexport { Type };\n// -------------------------------------------------------------------------------------\n// utils\n// -------------------------------------------------------------------------------------\n/**\n * @since 1.0.0\n */\nexport var identity = function (a) { return a; };\n/**\n * @since 1.0.0\n */\nexport function getFunctionName(f) {\n    return f.displayName || f.name || \"<function\".concat(f.length, \">\");\n}\n/**\n * @since 1.0.0\n */\nexport function getContextEntry(key, decoder) {\n    return { key: key, type: decoder };\n}\n/**\n * @since 1.0.0\n */\nexport function appendContext(c, key, decoder, actual) {\n    var len = c.length;\n    var r = Array(len + 1);\n    for (var i = 0; i < len; i++) {\n        r[i] = c[i];\n    }\n    r[len] = { key: key, type: decoder, actual: actual };\n    return r;\n}\nfunction pushAll(xs, ys) {\n    var l = ys.length;\n    for (var i = 0; i < l; i++) {\n        xs.push(ys[i]);\n    }\n}\nvar hasOwnProperty = Object.prototype.hasOwnProperty;\nfunction getNameFromProps(props) {\n    return Object.keys(props)\n        .map(function (k) { return \"\".concat(k, \": \").concat(props[k].name); })\n        .join(', ');\n}\nfunction useIdentity(codecs) {\n    for (var i = 0; i < codecs.length; i++) {\n        if (codecs[i].encode !== identity) {\n            return false;\n        }\n    }\n    return true;\n}\nfunction getInterfaceTypeName(props) {\n    return \"{ \".concat(getNameFromProps(props), \" }\");\n}\nfunction getPartialTypeName(inner) {\n    return \"Partial<\".concat(inner, \">\");\n}\nfunction enumerableRecord(keys, domain, codomain, name) {\n    if (name === void 0) { name = \"{ [K in \".concat(domain.name, \"]: \").concat(codomain.name, \" }\"); }\n    var len = keys.length;\n    var props = {};\n    for (var i = 0; i < len; i++) {\n        props[keys[i]] = codomain;\n    }\n    var exactCodec = strict(props, name);\n    return new DictionaryType(name, function (u) { return exactCodec.is(u); }, exactCodec.validate, exactCodec.encode, domain, codomain);\n}\n/**\n * @internal\n */\nexport function getDomainKeys(domain) {\n    var _a;\n    if (isLiteralC(domain)) {\n        var literal_1 = domain.value;\n        if (string.is(literal_1)) {\n            return _a = {}, _a[literal_1] = null, _a;\n        }\n    }\n    else if (isKeyofC(domain)) {\n        return domain.keys;\n    }\n    else if (isUnionC(domain)) {\n        var keys = domain.types.map(function (type) { return getDomainKeys(type); });\n        return keys.some(undefinedType.is) ? undefined : Object.assign.apply(Object, __spreadArray([{}], keys, false));\n    }\n    return undefined;\n}\nfunction stripNonDomainKeys(o, domain) {\n    var keys = Object.keys(o);\n    var len = keys.length;\n    var shouldStrip = false;\n    var r = {};\n    for (var i = 0; i < len; i++) {\n        var k = keys[i];\n        if (domain.is(k)) {\n            r[k] = o[k];\n        }\n        else {\n            shouldStrip = true;\n        }\n    }\n    return shouldStrip ? r : o;\n}\nfunction nonEnumerableRecord(domain, codomain, name) {\n    if (name === void 0) { name = \"{ [K in \".concat(domain.name, \"]: \").concat(codomain.name, \" }\"); }\n    return new DictionaryType(name, function (u) {\n        if (UnknownRecord.is(u)) {\n            return Object.keys(u).every(function (k) { return !domain.is(k) || codomain.is(u[k]); });\n        }\n        return isAnyC(codomain) && Array.isArray(u);\n    }, function (u, c) {\n        if (UnknownRecord.is(u)) {\n            var a = {};\n            var errors = [];\n            var keys = Object.keys(u);\n            var len = keys.length;\n            var changed = false;\n            for (var i = 0; i < len; i++) {\n                var k = keys[i];\n                var ok = u[k];\n                var domainResult = domain.validate(k, appendContext(c, k, domain, k));\n                if (isLeft(domainResult)) {\n                    changed = true;\n                }\n                else {\n                    var vk = domainResult.right;\n                    changed = changed || vk !== k;\n                    k = vk;\n                    var codomainResult = codomain.validate(ok, appendContext(c, k, codomain, ok));\n                    if (isLeft(codomainResult)) {\n                        pushAll(errors, codomainResult.left);\n                    }\n                    else {\n                        var vok = codomainResult.right;\n                        changed = changed || vok !== ok;\n                        a[k] = vok;\n                    }\n                }\n            }\n            return errors.length > 0 ? failures(errors) : success((changed ? a : u));\n        }\n        if (isAnyC(codomain) && Array.isArray(u)) {\n            return success(u);\n        }\n        return failure(u, c);\n    }, domain.encode === identity && codomain.encode === identity\n        ? function (a) { return stripNonDomainKeys(a, domain); }\n        : function (a) {\n            var s = {};\n            var keys = Object.keys(stripNonDomainKeys(a, domain));\n            var len = keys.length;\n            for (var i = 0; i < len; i++) {\n                var k = keys[i];\n                s[String(domain.encode(k))] = codomain.encode(a[k]);\n            }\n            return s;\n        }, domain, codomain);\n}\nfunction getUnionName(codecs) {\n    return '(' + codecs.map(function (type) { return type.name; }).join(' | ') + ')';\n}\n/**\n * @internal\n */\n// eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types\nexport function mergeAll(base, us) {\n    var equal = true;\n    var primitive = true;\n    var baseIsNotADictionary = !UnknownRecord.is(base);\n    for (var _i = 0, us_1 = us; _i < us_1.length; _i++) {\n        var u = us_1[_i];\n        if (u !== base) {\n            equal = false;\n        }\n        if (UnknownRecord.is(u)) {\n            primitive = false;\n        }\n    }\n    if (equal) {\n        return base;\n    }\n    else if (primitive) {\n        return us[us.length - 1];\n    }\n    var r = {};\n    for (var _a = 0, us_2 = us; _a < us_2.length; _a++) {\n        var u = us_2[_a];\n        for (var k in u) {\n            if (!hasOwnProperty.call(r, k) || baseIsNotADictionary || u[k] !== base[k]) {\n                r[k] = u[k];\n            }\n        }\n    }\n    return r;\n}\nfunction getProps(codec) {\n    switch (codec._tag) {\n        case 'RefinementType':\n        case 'ReadonlyType':\n            return getProps(codec.type);\n        case 'InterfaceType':\n        case 'StrictType':\n        case 'PartialType':\n            return codec.props;\n        case 'IntersectionType':\n            return codec.types.reduce(function (props, type) { return Object.assign(props, getProps(type)); }, {});\n    }\n}\nfunction stripKeys(o, props) {\n    var keys = Object.getOwnPropertyNames(o);\n    var shouldStrip = false;\n    var r = {};\n    for (var i = 0; i < keys.length; i++) {\n        var key = keys[i];\n        if (!hasOwnProperty.call(props, key)) {\n            shouldStrip = true;\n        }\n        else {\n            r[key] = o[key];\n        }\n    }\n    return shouldStrip ? r : o;\n}\nfunction getExactTypeName(codec) {\n    if (isTypeC(codec)) {\n        return \"{| \".concat(getNameFromProps(codec.props), \" |}\");\n    }\n    else if (isPartialC(codec)) {\n        return getPartialTypeName(\"{| \".concat(getNameFromProps(codec.props), \" |}\"));\n    }\n    return \"Exact<\".concat(codec.name, \">\");\n}\nfunction isNonEmpty(as) {\n    return as.length > 0;\n}\n/**\n * @internal\n */\nexport var emptyTags = {};\nfunction intersect(a, b) {\n    var r = [];\n    for (var _i = 0, a_1 = a; _i < a_1.length; _i++) {\n        var v = a_1[_i];\n        if (b.indexOf(v) !== -1) {\n            r.push(v);\n        }\n    }\n    return r;\n}\nfunction mergeTags(a, b) {\n    if (a === emptyTags) {\n        return b;\n    }\n    if (b === emptyTags) {\n        return a;\n    }\n    var r = Object.assign({}, a);\n    for (var k in b) {\n        if (hasOwnProperty.call(a, k)) {\n            var intersection_1 = intersect(a[k], b[k]);\n            if (isNonEmpty(intersection_1)) {\n                r[k] = intersection_1;\n            }\n            else {\n                r = emptyTags;\n                break;\n            }\n        }\n        else {\n            r[k] = b[k];\n        }\n    }\n    return r;\n}\nfunction intersectTags(a, b) {\n    if (a === emptyTags || b === emptyTags) {\n        return emptyTags;\n    }\n    var r = emptyTags;\n    for (var k in a) {\n        if (hasOwnProperty.call(b, k)) {\n            var intersection_2 = intersect(a[k], b[k]);\n            if (intersection_2.length === 0) {\n                if (r === emptyTags) {\n                    r = {};\n                }\n                r[k] = a[k].concat(b[k]);\n            }\n        }\n    }\n    return r;\n}\n// tslint:disable-next-line: deprecation\nfunction isAnyC(codec) {\n    return codec._tag === 'AnyType';\n}\nfunction isLiteralC(codec) {\n    return codec._tag === 'LiteralType';\n}\nfunction isKeyofC(codec) {\n    return codec._tag === 'KeyofType';\n}\nfunction isTypeC(codec) {\n    return codec._tag === 'InterfaceType';\n}\nfunction isPartialC(codec) {\n    return codec._tag === 'PartialType';\n}\n// tslint:disable-next-line: deprecation\nfunction isStrictC(codec) {\n    return codec._tag === 'StrictType';\n}\nfunction isExactC(codec) {\n    return codec._tag === 'ExactType';\n}\n// tslint:disable-next-line: deprecation\nfunction isRefinementC(codec) {\n    return codec._tag === 'RefinementType';\n}\nfunction isIntersectionC(codec) {\n    return codec._tag === 'IntersectionType';\n}\nfunction isUnionC(codec) {\n    return codec._tag === 'UnionType';\n}\nfunction isRecursiveC(codec) {\n    return codec._tag === 'RecursiveType';\n}\nfunction isReadonlyC(codec) {\n    return codec._tag === 'ReadonlyType';\n}\nvar lazyCodecs = [];\n/**\n * @internal\n */\nexport function getTags(codec) {\n    if (lazyCodecs.indexOf(codec) !== -1) {\n        return emptyTags;\n    }\n    if (isTypeC(codec) || isStrictC(codec)) {\n        var index = emptyTags;\n        // tslint:disable-next-line: forin\n        for (var k in codec.props) {\n            var prop = codec.props[k];\n            if (isLiteralC(prop)) {\n                if (index === emptyTags) {\n                    index = {};\n                }\n                index[k] = [prop.value];\n            }\n        }\n        return index;\n    }\n    else if (isExactC(codec) || isRefinementC(codec) || isReadonlyC(codec)) {\n        return getTags(codec.type);\n    }\n    else if (isIntersectionC(codec)) {\n        return codec.types.reduce(function (tags, codec) { return mergeTags(tags, getTags(codec)); }, emptyTags);\n    }\n    else if (isUnionC(codec)) {\n        return codec.types.slice(1).reduce(function (tags, codec) { return intersectTags(tags, getTags(codec)); }, getTags(codec.types[0]));\n    }\n    else if (isRecursiveC(codec)) {\n        lazyCodecs.push(codec);\n        var tags = getTags(codec.type);\n        lazyCodecs.pop();\n        return tags;\n    }\n    return emptyTags;\n}\n/**\n * @internal\n */\nexport function getIndex(codecs) {\n    var tags = getTags(codecs[0]);\n    var keys = Object.keys(tags);\n    var len = codecs.length;\n    var _loop_1 = function (k) {\n        var all = tags[k].slice();\n        var index = [tags[k]];\n        for (var i = 1; i < len; i++) {\n            var codec = codecs[i];\n            var ctags = getTags(codec);\n            var values = ctags[k];\n            // tslint:disable-next-line: strict-type-predicates\n            if (values === undefined) {\n                return \"continue-keys\";\n            }\n            else {\n                if (values.some(function (v) { return all.indexOf(v) !== -1; })) {\n                    return \"continue-keys\";\n                }\n                else {\n                    all.push.apply(all, values);\n                    index.push(values);\n                }\n            }\n        }\n        return { value: [k, index] };\n    };\n    keys: for (var _i = 0, keys_1 = keys; _i < keys_1.length; _i++) {\n        var k = keys_1[_i];\n        var state_1 = _loop_1(k);\n        if (typeof state_1 === \"object\")\n            return state_1.value;\n        switch (state_1) {\n            case \"continue-keys\": continue keys;\n        }\n    }\n    return undefined;\n}\n// -------------------------------------------------------------------------------------\n// primitives\n// -------------------------------------------------------------------------------------\n/**\n * @since 1.0.0\n */\nvar NullType = /** @class */ (function (_super) {\n    __extends(NullType, _super);\n    function NullType() {\n        var _this = _super.call(this, 'null', function (u) { return u === null; }, function (u, c) { return (_this.is(u) ? success(u) : failure(u, c)); }, identity) || this;\n        /**\n         * @since 1.0.0\n         */\n        _this._tag = 'NullType';\n        return _this;\n    }\n    return NullType;\n}(Type));\nexport { NullType };\n/**\n * @category primitives\n * @since 1.0.0\n */\nexport var nullType = new NullType();\n/**\n * @since 1.0.0\n */\nvar UndefinedType = /** @class */ (function (_super) {\n    __extends(UndefinedType, _super);\n    function UndefinedType() {\n        var _this = _super.call(this, 'undefined', function (u) { return u === void 0; }, function (u, c) { return (_this.is(u) ? success(u) : failure(u, c)); }, identity) || this;\n        /**\n         * @since 1.0.0\n         */\n        _this._tag = 'UndefinedType';\n        return _this;\n    }\n    return UndefinedType;\n}(Type));\nexport { UndefinedType };\nvar undefinedType = new UndefinedType();\n/**\n * @since 1.2.0\n */\nvar VoidType = /** @class */ (function (_super) {\n    __extends(VoidType, _super);\n    function VoidType() {\n        var _this = _super.call(this, 'void', undefinedType.is, undefinedType.validate, identity) || this;\n        /**\n         * @since 1.0.0\n         */\n        _this._tag = 'VoidType';\n        return _this;\n    }\n    return VoidType;\n}(Type));\nexport { VoidType };\n/**\n * @category primitives\n * @since 1.2.0\n */\nexport var voidType = new VoidType();\n/**\n * @since 1.5.0\n */\nvar UnknownType = /** @class */ (function (_super) {\n    __extends(UnknownType, _super);\n    function UnknownType() {\n        var _this = _super.call(this, 'unknown', function (_) { return true; }, success, identity) || this;\n        /**\n         * @since 1.0.0\n         */\n        _this._tag = 'UnknownType';\n        return _this;\n    }\n    return UnknownType;\n}(Type));\nexport { UnknownType };\n/**\n * @category primitives\n * @since 1.5.0\n */\nexport var unknown = new UnknownType();\n/**\n * @since 1.0.0\n */\nvar StringType = /** @class */ (function (_super) {\n    __extends(StringType, _super);\n    function StringType() {\n        var _this = _super.call(this, 'string', function (u) { return typeof u === 'string'; }, function (u, c) { return (_this.is(u) ? success(u) : failure(u, c)); }, identity) || this;\n        /**\n         * @since 1.0.0\n         */\n        _this._tag = 'StringType';\n        return _this;\n    }\n    return StringType;\n}(Type));\nexport { StringType };\n/**\n * @category primitives\n * @since 1.0.0\n */\nexport var string = new StringType();\n/**\n * @since 1.0.0\n */\nvar NumberType = /** @class */ (function (_super) {\n    __extends(NumberType, _super);\n    function NumberType() {\n        var _this = _super.call(this, 'number', function (u) { return typeof u === 'number'; }, function (u, c) { return (_this.is(u) ? success(u) : failure(u, c)); }, identity) || this;\n        /**\n         * @since 1.0.0\n         */\n        _this._tag = 'NumberType';\n        return _this;\n    }\n    return NumberType;\n}(Type));\nexport { NumberType };\n/**\n * @category primitives\n * @since 1.0.0\n */\nexport var number = new NumberType();\n/**\n * @since 2.1.0\n */\nvar BigIntType = /** @class */ (function (_super) {\n    __extends(BigIntType, _super);\n    function BigIntType() {\n        var _this = _super.call(this, 'bigint', \n        // tslint:disable-next-line: valid-typeof\n        function (u) { return typeof u === 'bigint'; }, function (u, c) { return (_this.is(u) ? success(u) : failure(u, c)); }, identity) || this;\n        /**\n         * @since 1.0.0\n         */\n        _this._tag = 'BigIntType';\n        return _this;\n    }\n    return BigIntType;\n}(Type));\nexport { BigIntType };\n/**\n * @category primitives\n * @since 2.1.0\n */\nexport var bigint = new BigIntType();\n/**\n * @since 1.0.0\n */\nvar BooleanType = /** @class */ (function (_super) {\n    __extends(BooleanType, _super);\n    function BooleanType() {\n        var _this = _super.call(this, 'boolean', function (u) { return typeof u === 'boolean'; }, function (u, c) { return (_this.is(u) ? success(u) : failure(u, c)); }, identity) || this;\n        /**\n         * @since 1.0.0\n         */\n        _this._tag = 'BooleanType';\n        return _this;\n    }\n    return BooleanType;\n}(Type));\nexport { BooleanType };\n/**\n * @category primitives\n * @since 1.0.0\n */\nexport var boolean = new BooleanType();\n/**\n * @since 1.0.0\n */\nvar AnyArrayType = /** @class */ (function (_super) {\n    __extends(AnyArrayType, _super);\n    function AnyArrayType() {\n        var _this = _super.call(this, 'UnknownArray', Array.isArray, function (u, c) { return (_this.is(u) ? success(u) : failure(u, c)); }, identity) || this;\n        /**\n         * @since 1.0.0\n         */\n        _this._tag = 'AnyArrayType';\n        return _this;\n    }\n    return AnyArrayType;\n}(Type));\nexport { AnyArrayType };\n/**\n * @category primitives\n * @since 1.7.1\n */\nexport var UnknownArray = new AnyArrayType();\n/**\n * @since 1.0.0\n */\nvar AnyDictionaryType = /** @class */ (function (_super) {\n    __extends(AnyDictionaryType, _super);\n    function AnyDictionaryType() {\n        var _this = _super.call(this, 'UnknownRecord', function (u) { return u !== null && typeof u === 'object' && !Array.isArray(u); }, function (u, c) { return (_this.is(u) ? success(u) : failure(u, c)); }, identity) || this;\n        /**\n         * @since 1.0.0\n         */\n        _this._tag = 'AnyDictionaryType';\n        return _this;\n    }\n    return AnyDictionaryType;\n}(Type));\nexport { AnyDictionaryType };\n/**\n * @category primitives\n * @since 1.7.1\n */\nexport var UnknownRecord = new AnyDictionaryType();\nexport { \n/**\n * @category primitives\n * @since 1.0.0\n */\nnullType as null, \n/**\n * @category primitives\n * @since 1.0.0\n */\nundefinedType as undefined, \n/**\n * @category primitives\n * @since 1.0.0\n */\nvoidType as void };\n/**\n * @since 1.0.0\n */\nvar LiteralType = /** @class */ (function (_super) {\n    __extends(LiteralType, _super);\n    function LiteralType(name, is, validate, encode, value) {\n        var _this = _super.call(this, name, is, validate, encode) || this;\n        _this.value = value;\n        /**\n         * @since 1.0.0\n         */\n        _this._tag = 'LiteralType';\n        return _this;\n    }\n    return LiteralType;\n}(Type));\nexport { LiteralType };\n/**\n * @category constructors\n * @since 1.0.0\n */\nexport function literal(value, name) {\n    if (name === void 0) { name = JSON.stringify(value); }\n    var is = function (u) { return u === value; };\n    return new LiteralType(name, is, function (u, c) { return (is(u) ? success(value) : failure(u, c)); }, identity, value);\n}\n/**\n * @since 1.0.0\n */\nvar KeyofType = /** @class */ (function (_super) {\n    __extends(KeyofType, _super);\n    function KeyofType(name, is, validate, encode, keys) {\n        var _this = _super.call(this, name, is, validate, encode) || this;\n        _this.keys = keys;\n        /**\n         * @since 1.0.0\n         */\n        _this._tag = 'KeyofType';\n        return _this;\n    }\n    return KeyofType;\n}(Type));\nexport { KeyofType };\n/**\n * @category constructors\n * @since 1.0.0\n */\nexport function keyof(keys, name) {\n    if (name === void 0) { name = Object.keys(keys)\n        .map(function (k) { return JSON.stringify(k); })\n        .join(' | '); }\n    var is = function (u) { return string.is(u) && hasOwnProperty.call(keys, u); };\n    return new KeyofType(name, is, function (u, c) { return (is(u) ? success(u) : failure(u, c)); }, identity, keys);\n}\n// -------------------------------------------------------------------------------------\n// combinators\n// -------------------------------------------------------------------------------------\n/**\n * @since 1.0.0\n */\nvar RefinementType = /** @class */ (function (_super) {\n    __extends(RefinementType, _super);\n    function RefinementType(name, is, validate, encode, type, predicate) {\n        var _this = _super.call(this, name, is, validate, encode) || this;\n        _this.type = type;\n        _this.predicate = predicate;\n        /**\n         * @since 1.0.0\n         */\n        _this._tag = 'RefinementType';\n        return _this;\n    }\n    return RefinementType;\n}(Type));\nexport { RefinementType };\n/**\n * @category combinators\n * @since 1.8.1\n */\nexport function brand(codec, predicate, name) {\n    return refinement(codec, predicate, name);\n}\n/**\n * A branded codec representing an integer\n *\n * @category primitives\n * @since 1.8.1\n */\nexport var Int = brand(number, function (n) { return Number.isInteger(n); }, 'Int');\n/**\n * @since 1.0.0\n */\nvar RecursiveType = /** @class */ (function (_super) {\n    __extends(RecursiveType, _super);\n    function RecursiveType(name, is, validate, encode, runDefinition) {\n        var _this = _super.call(this, name, is, validate, encode) || this;\n        _this.runDefinition = runDefinition;\n        /**\n         * @since 1.0.0\n         */\n        _this._tag = 'RecursiveType';\n        return _this;\n    }\n    return RecursiveType;\n}(Type));\nexport { RecursiveType };\nObject.defineProperty(RecursiveType.prototype, 'type', {\n    get: function () {\n        return this.runDefinition();\n    },\n    enumerable: true,\n    configurable: true\n});\n/**\n * @category combinators\n * @since 1.0.0\n */\nexport function recursion(name, definition) {\n    var cache;\n    var runDefinition = function () {\n        if (!cache) {\n            cache = definition(Self);\n            cache.name = name;\n        }\n        return cache;\n    };\n    var Self = new RecursiveType(name, function (u) { return runDefinition().is(u); }, function (u, c) { return runDefinition().validate(u, c); }, function (a) { return runDefinition().encode(a); }, runDefinition);\n    return Self;\n}\n/**\n * @since 1.0.0\n */\nvar ArrayType = /** @class */ (function (_super) {\n    __extends(ArrayType, _super);\n    function ArrayType(name, is, validate, encode, type) {\n        var _this = _super.call(this, name, is, validate, encode) || this;\n        _this.type = type;\n        /**\n         * @since 1.0.0\n         */\n        _this._tag = 'ArrayType';\n        return _this;\n    }\n    return ArrayType;\n}(Type));\nexport { ArrayType };\n/**\n * @category combinators\n * @since 1.0.0\n */\nexport function array(item, name) {\n    if (name === void 0) { name = \"Array<\".concat(item.name, \">\"); }\n    return new ArrayType(name, function (u) { return UnknownArray.is(u) && u.every(item.is); }, function (u, c) {\n        var e = UnknownArray.validate(u, c);\n        if (isLeft(e)) {\n            return e;\n        }\n        var us = e.right;\n        var len = us.length;\n        var as = us;\n        var errors = [];\n        for (var i = 0; i < len; i++) {\n            var ui = us[i];\n            var result = item.validate(ui, appendContext(c, String(i), item, ui));\n            if (isLeft(result)) {\n                pushAll(errors, result.left);\n            }\n            else {\n                var ai = result.right;\n                if (ai !== ui) {\n                    if (as === us) {\n                        as = us.slice();\n                    }\n                    as[i] = ai;\n                }\n            }\n        }\n        return errors.length > 0 ? failures(errors) : success(as);\n    }, item.encode === identity ? identity : function (a) { return a.map(item.encode); }, item);\n}\n/**\n * @since 1.0.0\n */\nvar InterfaceType = /** @class */ (function (_super) {\n    __extends(InterfaceType, _super);\n    function InterfaceType(name, is, validate, encode, props) {\n        var _this = _super.call(this, name, is, validate, encode) || this;\n        _this.props = props;\n        /**\n         * @since 1.0.0\n         */\n        _this._tag = 'InterfaceType';\n        return _this;\n    }\n    return InterfaceType;\n}(Type));\nexport { InterfaceType };\n/**\n * @category combinators\n * @since 1.0.0\n */\nexport function type(props, name) {\n    if (name === void 0) { name = getInterfaceTypeName(props); }\n    var keys = Object.keys(props);\n    var types = keys.map(function (key) { return props[key]; });\n    var len = keys.length;\n    return new InterfaceType(name, function (u) {\n        if (UnknownRecord.is(u)) {\n            for (var i = 0; i < len; i++) {\n                var k = keys[i];\n                var uk = u[k];\n                if ((uk === undefined && !hasOwnProperty.call(u, k)) || !types[i].is(uk)) {\n                    return false;\n                }\n            }\n            return true;\n        }\n        return false;\n    }, function (u, c) {\n        var e = UnknownRecord.validate(u, c);\n        if (isLeft(e)) {\n            return e;\n        }\n        var o = e.right;\n        var a = o;\n        var errors = [];\n        for (var i = 0; i < len; i++) {\n            var k = keys[i];\n            var ak = a[k];\n            var type_1 = types[i];\n            var result = type_1.validate(ak, appendContext(c, k, type_1, ak));\n            if (isLeft(result)) {\n                pushAll(errors, result.left);\n            }\n            else {\n                var vak = result.right;\n                if (vak !== ak || (vak === undefined && !hasOwnProperty.call(a, k))) {\n                    /* istanbul ignore next */\n                    if (a === o) {\n                        a = __assign({}, o);\n                    }\n                    a[k] = vak;\n                }\n            }\n        }\n        return errors.length > 0 ? failures(errors) : success(a);\n    }, useIdentity(types)\n        ? identity\n        : function (a) {\n            var s = __assign({}, a);\n            for (var i = 0; i < len; i++) {\n                var k = keys[i];\n                var encode = types[i].encode;\n                if (encode !== identity) {\n                    s[k] = encode(a[k]);\n                }\n            }\n            return s;\n        }, props);\n}\n/**\n * @since 1.0.0\n */\nvar PartialType = /** @class */ (function (_super) {\n    __extends(PartialType, _super);\n    function PartialType(name, is, validate, encode, props) {\n        var _this = _super.call(this, name, is, validate, encode) || this;\n        _this.props = props;\n        /**\n         * @since 1.0.0\n         */\n        _this._tag = 'PartialType';\n        return _this;\n    }\n    return PartialType;\n}(Type));\nexport { PartialType };\n/**\n * @category combinators\n * @since 1.0.0\n */\nexport function partial(props, name) {\n    if (name === void 0) { name = getPartialTypeName(getInterfaceTypeName(props)); }\n    var keys = Object.keys(props);\n    var types = keys.map(function (key) { return props[key]; });\n    var len = keys.length;\n    return new PartialType(name, function (u) {\n        if (UnknownRecord.is(u)) {\n            for (var i = 0; i < len; i++) {\n                var k = keys[i];\n                var uk = u[k];\n                if (uk !== undefined && !props[k].is(uk)) {\n                    return false;\n                }\n            }\n            return true;\n        }\n        return false;\n    }, function (u, c) {\n        var e = UnknownRecord.validate(u, c);\n        if (isLeft(e)) {\n            return e;\n        }\n        var o = e.right;\n        var a = o;\n        var errors = [];\n        for (var i = 0; i < len; i++) {\n            var k = keys[i];\n            var ak = a[k];\n            var type_2 = props[k];\n            var result = type_2.validate(ak, appendContext(c, k, type_2, ak));\n            if (isLeft(result)) {\n                if (ak !== undefined) {\n                    pushAll(errors, result.left);\n                }\n            }\n            else {\n                var vak = result.right;\n                if (vak !== ak) {\n                    /* istanbul ignore next */\n                    if (a === o) {\n                        a = __assign({}, o);\n                    }\n                    a[k] = vak;\n                }\n            }\n        }\n        return errors.length > 0 ? failures(errors) : success(a);\n    }, useIdentity(types)\n        ? identity\n        : function (a) {\n            var s = __assign({}, a);\n            for (var i = 0; i < len; i++) {\n                var k = keys[i];\n                var ak = a[k];\n                if (ak !== undefined) {\n                    s[k] = types[i].encode(ak);\n                }\n            }\n            return s;\n        }, props);\n}\n/**\n * @since 1.0.0\n */\nvar DictionaryType = /** @class */ (function (_super) {\n    __extends(DictionaryType, _super);\n    function DictionaryType(name, is, validate, encode, domain, codomain) {\n        var _this = _super.call(this, name, is, validate, encode) || this;\n        _this.domain = domain;\n        _this.codomain = codomain;\n        /**\n         * @since 1.0.0\n         */\n        _this._tag = 'DictionaryType';\n        return _this;\n    }\n    return DictionaryType;\n}(Type));\nexport { DictionaryType };\n/**\n * @category combinators\n * @since 1.7.1\n */\nexport function record(domain, codomain, name) {\n    var keys = getDomainKeys(domain);\n    return keys\n        ? enumerableRecord(Object.keys(keys), domain, codomain, name)\n        : nonEnumerableRecord(domain, codomain, name);\n}\n/**\n * @since 1.0.0\n */\nvar UnionType = /** @class */ (function (_super) {\n    __extends(UnionType, _super);\n    function UnionType(name, is, validate, encode, types) {\n        var _this = _super.call(this, name, is, validate, encode) || this;\n        _this.types = types;\n        /**\n         * @since 1.0.0\n         */\n        _this._tag = 'UnionType';\n        return _this;\n    }\n    return UnionType;\n}(Type));\nexport { UnionType };\n/**\n * @category combinators\n * @since 1.0.0\n */\nexport function union(codecs, name) {\n    if (name === void 0) { name = getUnionName(codecs); }\n    var index = getIndex(codecs);\n    if (index !== undefined && codecs.length > 0) {\n        var tag_1 = index[0], groups_1 = index[1];\n        var len_1 = groups_1.length;\n        var find_1 = function (value) {\n            for (var i = 0; i < len_1; i++) {\n                if (groups_1[i].indexOf(value) !== -1) {\n                    return i;\n                }\n            }\n            return undefined;\n        };\n        // tslint:disable-next-line: deprecation\n        return new TaggedUnionType(name, function (u) {\n            if (UnknownRecord.is(u)) {\n                var i = find_1(u[tag_1]);\n                return i !== undefined ? codecs[i].is(u) : false;\n            }\n            return false;\n        }, function (u, c) {\n            var e = UnknownRecord.validate(u, c);\n            if (isLeft(e)) {\n                return e;\n            }\n            var r = e.right;\n            var i = find_1(r[tag_1]);\n            if (i === undefined) {\n                return failure(u, c);\n            }\n            var codec = codecs[i];\n            return codec.validate(r, appendContext(c, String(i), codec, r));\n        }, useIdentity(codecs)\n            ? identity\n            : function (a) {\n                var i = find_1(a[tag_1]);\n                if (i === undefined) {\n                    // https://github.com/gcanti/io-ts/pull/305\n                    throw new Error(\"no codec found to encode value in union codec \".concat(name));\n                }\n                else {\n                    return codecs[i].encode(a);\n                }\n            }, codecs, tag_1);\n    }\n    else {\n        return new UnionType(name, function (u) { return codecs.some(function (type) { return type.is(u); }); }, function (u, c) {\n            var errors = [];\n            for (var i = 0; i < codecs.length; i++) {\n                var codec = codecs[i];\n                var result = codec.validate(u, appendContext(c, String(i), codec, u));\n                if (isLeft(result)) {\n                    pushAll(errors, result.left);\n                }\n                else {\n                    return success(result.right);\n                }\n            }\n            return failures(errors);\n        }, useIdentity(codecs)\n            ? identity\n            : function (a) {\n                for (var _i = 0, codecs_1 = codecs; _i < codecs_1.length; _i++) {\n                    var codec = codecs_1[_i];\n                    if (codec.is(a)) {\n                        return codec.encode(a);\n                    }\n                }\n                // https://github.com/gcanti/io-ts/pull/305\n                throw new Error(\"no codec found to encode value in union type \".concat(name));\n            }, codecs);\n    }\n}\n/**\n * @since 1.0.0\n */\nvar IntersectionType = /** @class */ (function (_super) {\n    __extends(IntersectionType, _super);\n    function IntersectionType(name, is, validate, encode, types) {\n        var _this = _super.call(this, name, is, validate, encode) || this;\n        _this.types = types;\n        /**\n         * @since 1.0.0\n         */\n        _this._tag = 'IntersectionType';\n        return _this;\n    }\n    return IntersectionType;\n}(Type));\nexport { IntersectionType };\nexport function intersection(codecs, name) {\n    if (name === void 0) { name = \"(\".concat(codecs.map(function (type) { return type.name; }).join(' & '), \")\"); }\n    var len = codecs.length;\n    return new IntersectionType(name, function (u) { return codecs.every(function (type) { return type.is(u); }); }, codecs.length === 0\n        ? success\n        : function (u, c) {\n            var us = [];\n            var errors = [];\n            for (var i = 0; i < len; i++) {\n                var codec = codecs[i];\n                var result = codec.validate(u, appendContext(c, String(i), codec, u));\n                if (isLeft(result)) {\n                    pushAll(errors, result.left);\n                }\n                else {\n                    us.push(result.right);\n                }\n            }\n            return errors.length > 0 ? failures(errors) : success(mergeAll(u, us));\n        }, codecs.length === 0\n        ? identity\n        : function (a) {\n            return mergeAll(a, codecs.map(function (codec) { return codec.encode(a); }));\n        }, codecs);\n}\n/**\n * @since 1.0.0\n */\nvar TupleType = /** @class */ (function (_super) {\n    __extends(TupleType, _super);\n    function TupleType(name, is, validate, encode, types) {\n        var _this = _super.call(this, name, is, validate, encode) || this;\n        _this.types = types;\n        /**\n         * @since 1.0.0\n         */\n        _this._tag = 'TupleType';\n        return _this;\n    }\n    return TupleType;\n}(Type));\nexport { TupleType };\nexport function tuple(codecs, name) {\n    if (name === void 0) { name = \"[\".concat(codecs.map(function (type) { return type.name; }).join(', '), \"]\"); }\n    var len = codecs.length;\n    return new TupleType(name, function (u) { return UnknownArray.is(u) && u.length === len && codecs.every(function (type, i) { return type.is(u[i]); }); }, function (u, c) {\n        var e = UnknownArray.validate(u, c);\n        if (isLeft(e)) {\n            return e;\n        }\n        var us = e.right;\n        var as = us.length > len ? us.slice(0, len) : us; // strip additional components\n        var errors = [];\n        for (var i = 0; i < len; i++) {\n            var a = us[i];\n            var type_3 = codecs[i];\n            var result = type_3.validate(a, appendContext(c, String(i), type_3, a));\n            if (isLeft(result)) {\n                pushAll(errors, result.left);\n            }\n            else {\n                var va = result.right;\n                if (va !== a) {\n                    /* istanbul ignore next */\n                    if (as === us) {\n                        as = us.slice();\n                    }\n                    as[i] = va;\n                }\n            }\n        }\n        return errors.length > 0 ? failures(errors) : success(as);\n    }, useIdentity(codecs) ? identity : function (a) { return codecs.map(function (type, i) { return type.encode(a[i]); }); }, codecs);\n}\n/**\n * @since 1.0.0\n */\nvar ReadonlyType = /** @class */ (function (_super) {\n    __extends(ReadonlyType, _super);\n    function ReadonlyType(name, is, validate, encode, type) {\n        var _this = _super.call(this, name, is, validate, encode) || this;\n        _this.type = type;\n        /**\n         * @since 1.0.0\n         */\n        _this._tag = 'ReadonlyType';\n        return _this;\n    }\n    return ReadonlyType;\n}(Type));\nexport { ReadonlyType };\n/**\n * @category combinators\n * @since 1.0.0\n */\nexport function readonly(codec, name) {\n    if (name === void 0) { name = \"Readonly<\".concat(codec.name, \">\"); }\n    return new ReadonlyType(name, codec.is, codec.validate, codec.encode, codec);\n}\n/**\n * @since 1.0.0\n */\nvar ReadonlyArrayType = /** @class */ (function (_super) {\n    __extends(ReadonlyArrayType, _super);\n    function ReadonlyArrayType(name, is, validate, encode, type) {\n        var _this = _super.call(this, name, is, validate, encode) || this;\n        _this.type = type;\n        /**\n         * @since 1.0.0\n         */\n        _this._tag = 'ReadonlyArrayType';\n        return _this;\n    }\n    return ReadonlyArrayType;\n}(Type));\nexport { ReadonlyArrayType };\n/**\n * @category combinators\n * @since 1.0.0\n */\nexport function readonlyArray(item, name) {\n    if (name === void 0) { name = \"ReadonlyArray<\".concat(item.name, \">\"); }\n    var codec = array(item);\n    return new ReadonlyArrayType(name, codec.is, codec.validate, codec.encode, item);\n}\n/**\n * Strips additional properties, equivalent to `exact(type(props))`.\n *\n * @category combinators\n * @since 1.0.0\n */\nexport var strict = function (props, name) { return exact(type(props), name); };\n/**\n * @since 1.1.0\n */\nvar ExactType = /** @class */ (function (_super) {\n    __extends(ExactType, _super);\n    function ExactType(name, is, validate, encode, type) {\n        var _this = _super.call(this, name, is, validate, encode) || this;\n        _this.type = type;\n        /**\n         * @since 1.0.0\n         */\n        _this._tag = 'ExactType';\n        return _this;\n    }\n    return ExactType;\n}(Type));\nexport { ExactType };\n/**\n * Strips additional properties.\n *\n * @category combinators\n * @since 1.1.0\n */\nexport function exact(codec, name) {\n    if (name === void 0) { name = getExactTypeName(codec); }\n    var props = getProps(codec);\n    return new ExactType(name, codec.is, function (u, c) {\n        var e = UnknownRecord.validate(u, c);\n        if (isLeft(e)) {\n            return e;\n        }\n        var ce = codec.validate(u, c);\n        if (isLeft(ce)) {\n            return ce;\n        }\n        return right(stripKeys(ce.right, props));\n    }, function (a) { return codec.encode(stripKeys(a, props)); }, codec);\n}\n/**\n * @since 1.0.0\n */\nvar FunctionType = /** @class */ (function (_super) {\n    __extends(FunctionType, _super);\n    function FunctionType() {\n        var _this = _super.call(this, 'Function', \n        // tslint:disable-next-line:strict-type-predicates\n        function (u) { return typeof u === 'function'; }, function (u, c) { return (_this.is(u) ? success(u) : failure(u, c)); }, identity) || this;\n        /**\n         * @since 1.0.0\n         */\n        _this._tag = 'FunctionType';\n        return _this;\n    }\n    return FunctionType;\n}(Type));\nexport { FunctionType };\n/**\n * @category primitives\n * @since 1.0.0\n */\nexport var Function = new FunctionType();\n/**\n * @since 1.0.0\n */\nvar NeverType = /** @class */ (function (_super) {\n    __extends(NeverType, _super);\n    function NeverType() {\n        var _this = _super.call(this, 'never', function (_) { return false; }, function (u, c) { return failure(u, c); }, \n        /* istanbul ignore next */\n        function () {\n            throw new Error('cannot encode never');\n        }) || this;\n        /**\n         * @since 1.0.0\n         */\n        _this._tag = 'NeverType';\n        return _this;\n    }\n    return NeverType;\n}(Type));\nexport { NeverType };\n/**\n * @category primitives\n * @since 1.0.0\n */\nexport var never = new NeverType();\n/**\n * @since 1.0.0\n */\nvar AnyType = /** @class */ (function (_super) {\n    __extends(AnyType, _super);\n    function AnyType() {\n        var _this = _super.call(this, 'any', function (_) { return true; }, success, identity) || this;\n        /**\n         * @since 1.0.0\n         */\n        _this._tag = 'AnyType';\n        return _this;\n    }\n    return AnyType;\n}(Type));\nexport { AnyType };\n/**\n * @category primitives\n * @since 1.0.0\n */\nexport var any = new AnyType();\nexport function refinement(codec, predicate, name) {\n    if (name === void 0) { name = \"(\".concat(codec.name, \" | \").concat(getFunctionName(predicate), \")\"); }\n    return new RefinementType(name, function (u) { return codec.is(u) && predicate(u); }, function (i, c) {\n        var e = codec.validate(i, c);\n        if (isLeft(e)) {\n            return e;\n        }\n        var a = e.right;\n        return predicate(a) ? success(a) : failure(a, c);\n    }, codec.encode, codec, predicate);\n}\n/**\n * @category primitives\n * @since 1.0.0\n */\nexport var Integer = refinement(number, Number.isInteger, 'Integer');\n// -------------------------------------------------------------------------------------\n// deprecated\n// -------------------------------------------------------------------------------------\n/**\n * @since 1.3.0\n * @deprecated\n */\nvar TaggedUnionType = /** @class */ (function (_super) {\n    __extends(TaggedUnionType, _super);\n    function TaggedUnionType(name, \n    // tslint:disable-next-line: deprecation\n    is, \n    // tslint:disable-next-line: deprecation\n    validate, \n    // tslint:disable-next-line: deprecation\n    encode, codecs, tag) {\n        var _this = _super.call(this, name, is, validate, encode, codecs) /* istanbul ignore next */ // <= workaround for https://github.com/Microsoft/TypeScript/issues/13455\n         || this;\n        _this.tag = tag;\n        return _this;\n    }\n    return TaggedUnionType;\n}(UnionType));\nexport { TaggedUnionType };\n/**\n * Use `union` instead.\n *\n * @category combinators\n * @since 1.3.0\n * @deprecated\n */\nexport var taggedUnion = function (tag, codecs, name\n// tslint:disable-next-line: deprecation\n) {\n    if (name === void 0) { name = getUnionName(codecs); }\n    var U = union(codecs, name);\n    // tslint:disable-next-line: deprecation\n    if (U instanceof TaggedUnionType) {\n        return U;\n    }\n    else {\n        console.warn(\"[io-ts] Cannot build a tagged union for \".concat(name, \", returning a de-optimized union\"));\n        // tslint:disable-next-line: deprecation\n        return new TaggedUnionType(name, U.is, U.validate, U.encode, codecs, tag);\n    }\n};\nexport { \n/**\n * Use `UnknownArray` instead.\n *\n * @category primitives\n * @deprecated\n * @since 1.0.0\n */\nUnknownArray as Array };\nexport { \n/**\n * Use `type` instead.\n *\n * @category combinators\n * @deprecated\n * @since 1.0.0\n */\ntype as interface };\n/**\n * @since 1.0.0\n * @deprecated\n */\nexport var getValidationError /* istanbul ignore next */ = function (value, context) { return ({\n    value: value,\n    context: context\n}); };\n/**\n * @since 1.0.0\n * @deprecated\n */\nexport var getDefaultContext /* istanbul ignore next */ = function (decoder) { return [\n    { key: '', type: decoder }\n]; };\n/**\n * Use `UnknownRecord` instead.\n *\n * @category primitives\n * @since 1.0.0\n * @deprecated\n */\nexport var Dictionary = UnknownRecord;\n/**\n * @since 1.0.0\n * @deprecated\n */\nvar ObjectType = /** @class */ (function (_super) {\n    __extends(ObjectType, _super);\n    function ObjectType() {\n        var _this = _super.call(this, 'object', function (u) { return u !== null && typeof u === 'object'; }, function (u, c) { return (_this.is(u) ? success(u) : failure(u, c)); }, identity) || this;\n        /**\n         * @since 1.0.0\n         */\n        _this._tag = 'ObjectType';\n        return _this;\n    }\n    return ObjectType;\n}(Type));\nexport { ObjectType };\n/**\n * Use `UnknownRecord` instead.\n *\n * @category primitives\n * @since 1.0.0\n * @deprecated\n */\n// tslint:disable-next-line: deprecation\nexport var object = new ObjectType();\n/**\n * Use `record` instead.\n *\n * @category combinators\n * @since 1.0.0\n * @deprecated\n */\nexport var dictionary = record;\n/**\n * @since 1.0.0\n * @deprecated\n */\nvar StrictType = /** @class */ (function (_super) {\n    __extends(StrictType, _super);\n    function StrictType(name, \n    // tslint:disable-next-line: deprecation\n    is, \n    // tslint:disable-next-line: deprecation\n    validate, \n    // tslint:disable-next-line: deprecation\n    encode, props) {\n        var _this = _super.call(this, name, is, validate, encode) || this;\n        _this.props = props;\n        /**\n         * @since 1.0.0\n         */\n        _this._tag = 'StrictType';\n        return _this;\n    }\n    return StrictType;\n}(Type));\nexport { StrictType };\n/**\n * Drops the codec \"kind\".\n *\n * @category combinators\n * @since 1.1.0\n * @deprecated\n */\nexport function clean(codec) {\n    return codec;\n}\nexport function alias(codec) {\n    return function () { return codec; };\n}\n","/* global window, exports, define */\n\n!function() {\n    'use strict'\n\n    var re = {\n        not_string: /[^s]/,\n        not_bool: /[^t]/,\n        not_type: /[^T]/,\n        not_primitive: /[^v]/,\n        number: /[diefg]/,\n        numeric_arg: /[bcdiefguxX]/,\n        json: /[j]/,\n        not_json: /[^j]/,\n        text: /^[^\\x25]+/,\n        modulo: /^\\x25{2}/,\n        placeholder: /^\\x25(?:([1-9]\\d*)\\$|\\(([^)]+)\\))?(\\+)?(0|'[^$])?(-)?(\\d+)?(?:\\.(\\d+))?([b-gijostTuvxX])/,\n        key: /^([a-z_][a-z_\\d]*)/i,\n        key_access: /^\\.([a-z_][a-z_\\d]*)/i,\n        index_access: /^\\[(\\d+)\\]/,\n        sign: /^[+-]/\n    }\n\n    function sprintf(key) {\n        // `arguments` is not an array, but should be fine for this call\n        return sprintf_format(sprintf_parse(key), arguments)\n    }\n\n    function vsprintf(fmt, argv) {\n        return sprintf.apply(null, [fmt].concat(argv || []))\n    }\n\n    function sprintf_format(parse_tree, argv) {\n        var cursor = 1, tree_length = parse_tree.length, arg, output = '', i, k, ph, pad, pad_character, pad_length, is_positive, sign\n        for (i = 0; i < tree_length; i++) {\n            if (typeof parse_tree[i] === 'string') {\n                output += parse_tree[i]\n            }\n            else if (typeof parse_tree[i] === 'object') {\n                ph = parse_tree[i] // convenience purposes only\n                if (ph.keys) { // keyword argument\n                    arg = argv[cursor]\n                    for (k = 0; k < ph.keys.length; k++) {\n                        if (arg == undefined) {\n                            throw new Error(sprintf('[sprintf] Cannot access property \"%s\" of undefined value \"%s\"', ph.keys[k], ph.keys[k-1]))\n                        }\n                        arg = arg[ph.keys[k]]\n                    }\n                }\n                else if (ph.param_no) { // positional argument (explicit)\n                    arg = argv[ph.param_no]\n                }\n                else { // positional argument (implicit)\n                    arg = argv[cursor++]\n                }\n\n                if (re.not_type.test(ph.type) && re.not_primitive.test(ph.type) && arg instanceof Function) {\n                    arg = arg()\n                }\n\n                if (re.numeric_arg.test(ph.type) && (typeof arg !== 'number' && isNaN(arg))) {\n                    throw new TypeError(sprintf('[sprintf] expecting number but found %T', arg))\n                }\n\n                if (re.number.test(ph.type)) {\n                    is_positive = arg >= 0\n                }\n\n                switch (ph.type) {\n                    case 'b':\n                        arg = parseInt(arg, 10).toString(2)\n                        break\n                    case 'c':\n                        arg = String.fromCharCode(parseInt(arg, 10))\n                        break\n                    case 'd':\n                    case 'i':\n                        arg = parseInt(arg, 10)\n                        break\n                    case 'j':\n                        arg = JSON.stringify(arg, null, ph.width ? parseInt(ph.width) : 0)\n                        break\n                    case 'e':\n                        arg = ph.precision ? parseFloat(arg).toExponential(ph.precision) : parseFloat(arg).toExponential()\n                        break\n                    case 'f':\n                        arg = ph.precision ? parseFloat(arg).toFixed(ph.precision) : parseFloat(arg)\n                        break\n                    case 'g':\n                        arg = ph.precision ? String(Number(arg.toPrecision(ph.precision))) : parseFloat(arg)\n                        break\n                    case 'o':\n                        arg = (parseInt(arg, 10) >>> 0).toString(8)\n                        break\n                    case 's':\n                        arg = String(arg)\n                        arg = (ph.precision ? arg.substring(0, ph.precision) : arg)\n                        break\n                    case 't':\n                        arg = String(!!arg)\n                        arg = (ph.precision ? arg.substring(0, ph.precision) : arg)\n                        break\n                    case 'T':\n                        arg = Object.prototype.toString.call(arg).slice(8, -1).toLowerCase()\n                        arg = (ph.precision ? arg.substring(0, ph.precision) : arg)\n                        break\n                    case 'u':\n                        arg = parseInt(arg, 10) >>> 0\n                        break\n                    case 'v':\n                        arg = arg.valueOf()\n                        arg = (ph.precision ? arg.substring(0, ph.precision) : arg)\n                        break\n                    case 'x':\n                        arg = (parseInt(arg, 10) >>> 0).toString(16)\n                        break\n                    case 'X':\n                        arg = (parseInt(arg, 10) >>> 0).toString(16).toUpperCase()\n                        break\n                }\n                if (re.json.test(ph.type)) {\n                    output += arg\n                }\n                else {\n                    if (re.number.test(ph.type) && (!is_positive || ph.sign)) {\n                        sign = is_positive ? '+' : '-'\n                        arg = arg.toString().replace(re.sign, '')\n                    }\n                    else {\n                        sign = ''\n                    }\n                    pad_character = ph.pad_char ? ph.pad_char === '0' ? '0' : ph.pad_char.charAt(1) : ' '\n                    pad_length = ph.width - (sign + arg).length\n                    pad = ph.width ? (pad_length > 0 ? pad_character.repeat(pad_length) : '') : ''\n                    output += ph.align ? sign + arg + pad : (pad_character === '0' ? sign + pad + arg : pad + sign + arg)\n                }\n            }\n        }\n        return output\n    }\n\n    var sprintf_cache = Object.create(null)\n\n    function sprintf_parse(fmt) {\n        if (sprintf_cache[fmt]) {\n            return sprintf_cache[fmt]\n        }\n\n        var _fmt = fmt, match, parse_tree = [], arg_names = 0\n        while (_fmt) {\n            if ((match = re.text.exec(_fmt)) !== null) {\n                parse_tree.push(match[0])\n            }\n            else if ((match = re.modulo.exec(_fmt)) !== null) {\n                parse_tree.push('%')\n            }\n            else if ((match = re.placeholder.exec(_fmt)) !== null) {\n                if (match[2]) {\n                    arg_names |= 1\n                    var field_list = [], replacement_field = match[2], field_match = []\n                    if ((field_match = re.key.exec(replacement_field)) !== null) {\n                        field_list.push(field_match[1])\n                        while ((replacement_field = replacement_field.substring(field_match[0].length)) !== '') {\n                            if ((field_match = re.key_access.exec(replacement_field)) !== null) {\n                                field_list.push(field_match[1])\n                            }\n                            else if ((field_match = re.index_access.exec(replacement_field)) !== null) {\n                                field_list.push(field_match[1])\n                            }\n                            else {\n                                throw new SyntaxError('[sprintf] failed to parse named argument key')\n                            }\n                        }\n                    }\n                    else {\n                        throw new SyntaxError('[sprintf] failed to parse named argument key')\n                    }\n                    match[2] = field_list\n                }\n                else {\n                    arg_names |= 2\n                }\n                if (arg_names === 3) {\n                    throw new Error('[sprintf] mixing positional and named placeholders is not (yet) supported')\n                }\n\n                parse_tree.push(\n                    {\n                        placeholder: match[0],\n                        param_no:    match[1],\n                        keys:        match[2],\n                        sign:        match[3],\n                        pad_char:    match[4],\n                        align:       match[5],\n                        width:       match[6],\n                        precision:   match[7],\n                        type:        match[8]\n                    }\n                )\n            }\n            else {\n                throw new SyntaxError('[sprintf] unexpected placeholder')\n            }\n            _fmt = _fmt.substring(match[0].length)\n        }\n        return sprintf_cache[fmt] = parse_tree\n    }\n\n    /**\n     * export to either browser or node.js\n     */\n    /* eslint-disable quote-props */\n    if (typeof exports !== 'undefined') {\n        exports['sprintf'] = sprintf\n        exports['vsprintf'] = vsprintf\n    }\n    if (typeof window !== 'undefined') {\n        window['sprintf'] = sprintf\n        window['vsprintf'] = vsprintf\n\n        if (typeof define === 'function' && define['amd']) {\n            define(function() {\n                return {\n                    'sprintf': sprintf,\n                    'vsprintf': vsprintf\n                }\n            })\n        }\n    }\n    /* eslint-enable quote-props */\n}(); // eslint-disable-line\n","const hexRegex = /^[-+]?0x[a-fA-F0-9]+$/;\nconst numRegex = /^([\\-\\+])?(0*)([0-9]*(\\.[0-9]*)?)$/;\n// const octRegex = /^0x[a-z0-9]+/;\n// const binRegex = /0x[a-z0-9]+/;\n\n \nconst consider = {\n    hex :  true,\n    // oct: false,\n    leadingZeros: true,\n    decimalPoint: \"\\.\",\n    eNotation: true,\n    //skipLike: /regex/\n};\n\nfunction toNumber(str, options = {}){\n    options = Object.assign({}, consider, options );\n    if(!str || typeof str !== \"string\" ) return str;\n    \n    let trimmedStr  = str.trim();\n    \n    if(options.skipLike !== undefined && options.skipLike.test(trimmedStr)) return str;\n    else if(str===\"0\") return 0;\n    else if (options.hex && hexRegex.test(trimmedStr)) {\n        return parse_int(trimmedStr, 16);\n    // }else if (options.oct && octRegex.test(str)) {\n    //     return Number.parseInt(val, 8);\n    }else if (trimmedStr.search(/[eE]/)!== -1) { //eNotation\n        const notation = trimmedStr.match(/^([-\\+])?(0*)([0-9]*(\\.[0-9]*)?[eE][-\\+]?[0-9]+)$/); \n        // +00.123 => [ , '+', '00', '.123', ..\n        if(notation){\n            // console.log(notation)\n            if(options.leadingZeros){ //accept with leading zeros\n                trimmedStr = (notation[1] || \"\") + notation[3];\n            }else{\n                if(notation[2] === \"0\" && notation[3][0]=== \".\"){ //valid number\n                }else{\n                    return str;\n                }\n            }\n            return options.eNotation ? Number(trimmedStr) : str;\n        }else{\n            return str;\n        }\n    // }else if (options.parseBin && binRegex.test(str)) {\n    //     return Number.parseInt(val, 2);\n    }else{\n        //separate negative sign, leading zeros, and rest number\n        const match = numRegex.exec(trimmedStr);\n        // +00.123 => [ , '+', '00', '.123', ..\n        if(match){\n            const sign = match[1];\n            const leadingZeros = match[2];\n            let numTrimmedByZeros = trimZeros(match[3]); //complete num without leading zeros\n            //trim ending zeros for floating number\n            \n            if(!options.leadingZeros && leadingZeros.length > 0 && sign && trimmedStr[2] !== \".\") return str; //-0123\n            else if(!options.leadingZeros && leadingZeros.length > 0 && !sign && trimmedStr[1] !== \".\") return str; //0123\n            else if(options.leadingZeros && leadingZeros===str) return 0; //00\n            \n            else{//no leading zeros or leading zeros are allowed\n                const num = Number(trimmedStr);\n                const numStr = \"\" + num;\n\n                if(numStr.search(/[eE]/) !== -1){ //given number is long and parsed to eNotation\n                    if(options.eNotation) return num;\n                    else return str;\n                }else if(trimmedStr.indexOf(\".\") !== -1){ //floating number\n                    if(numStr === \"0\" && (numTrimmedByZeros === \"\") ) return num; //0.0\n                    else if(numStr === numTrimmedByZeros) return num; //0.456. 0.79000\n                    else if( sign && numStr === \"-\"+numTrimmedByZeros) return num;\n                    else return str;\n                }\n                \n                if(leadingZeros){\n                    return (numTrimmedByZeros === numStr) || (sign+numTrimmedByZeros === numStr) ? num : str\n                }else  {\n                    return (trimmedStr === numStr) || (trimmedStr === sign+numStr) ? num : str\n                }\n            }\n        }else{ //non-numeric string\n            return str;\n        }\n    }\n}\n\n/**\n * \n * @param {string} numStr without leading zeros\n * @returns \n */\nfunction trimZeros(numStr){\n    if(numStr && numStr.indexOf(\".\") !== -1){//float\n        numStr = numStr.replace(/0+$/, \"\"); //remove ending zeros\n        if(numStr === \".\")  numStr = \"0\";\n        else if(numStr[0] === \".\")  numStr = \"0\"+numStr;\n        else if(numStr[numStr.length-1] === \".\")  numStr = numStr.substr(0,numStr.length-1);\n        return numStr;\n    }\n    return numStr;\n}\n\nfunction parse_int(numStr, base){\n    //polyfill\n    if(parseInt) return parseInt(numStr, base);\n    else if(Number.parseInt) return Number.parseInt(numStr, base);\n    else if(window && window.parseInt) return window.parseInt(numStr, base);\n    else throw new Error(\"parseInt, Number.parseInt, window.parseInt are not supported\")\n}\n\nmodule.exports = toNumber;","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","","// startup\n// Load entry module and return exports\n// This entry module is referenced by other modules so it can't be inlined\nvar __webpack_exports__ = __webpack_require__(\"./build/index.js\");\n",""],"names":[],"sourceRoot":""}